var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/config.js
var require_config = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/config.js"(exports) {
    var dev;
    if (typeof window !== "undefined") {
      dev = window.__DEV__;
    } else if (typeof global !== "undefined") {
      dev = global.__DEV__;
    }
    if (typeof dev === "undefined") {
      dev = true;
    }
    var __DEV__ = dev;
    exports.__DEV__ = __DEV__;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/guid.js
var require_guid = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/guid.js"(exports, module) {
    var idStart = 2311;
    function _default() {
      return idStart++;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/env.js
var require_env = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/env.js"(exports, module) {
    var env = {};
    if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
      env = {
        browser: {},
        os: {},
        node: false,
        wxa: true,
        // Weixin Application
        canvasSupported: true,
        svgSupported: false,
        touchEventsSupported: true,
        domSupported: false
      };
    } else if (typeof document === "undefined" && typeof self !== "undefined") {
      env = {
        browser: {},
        os: {},
        node: false,
        worker: true,
        canvasSupported: true,
        domSupported: false
      };
    } else if (typeof navigator === "undefined") {
      env = {
        browser: {},
        os: {},
        node: true,
        worker: false,
        // Assume canvas is supported
        canvasSupported: true,
        svgSupported: true,
        domSupported: false
      };
    } else {
      env = detect(navigator.userAgent);
    }
    var _default = env;
    function detect(ua) {
      var os = {};
      var browser = {};
      var firefox = ua.match(/Firefox\/([\d.]+)/);
      var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
      var edge = ua.match(/Edge\/([\d.]+)/);
      var weChat = /micromessenger/i.test(ua);
      if (firefox) {
        browser.firefox = true;
        browser.version = firefox[1];
      }
      if (ie) {
        browser.ie = true;
        browser.version = ie[1];
      }
      if (edge) {
        browser.edge = true;
        browser.version = edge[1];
      }
      if (weChat) {
        browser.weChat = true;
      }
      return {
        browser,
        os,
        node: false,
        // 原生canvas支持，改极端点了
        // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
        canvasSupported: !!document.createElement("canvas").getContext,
        svgSupported: typeof SVGRect !== "undefined",
        // works on most browsers
        // IE10/11 does not support touch event, and MS Edge supports them but not by
        // default, so we dont check navigator.maxTouchPoints for them here.
        touchEventsSupported: "ontouchstart" in window && !browser.ie && !browser.edge,
        // <http://caniuse.com/#search=pointer%20event>.
        pointerEventsSupported: (
          // (1) Firefox supports pointer but not by default, only MS browsers are reliable on pointer
          // events currently. So we dont use that on other browsers unless tested sufficiently.
          // For example, in iOS 13 Mobile Chromium 78, if the touching behavior starts page
          // scroll, the `pointermove` event can not be fired any more. That will break some
          // features like "pan horizontally to move something and pan vertically to page scroll".
          // The horizontal pan probably be interrupted by the casually triggered page scroll.
          // (2) Although IE 10 supports pointer event, it use old style and is different from the
          // standard. So we exclude that. (IE 10 is hardly used on touch device)
          "onpointerdown" in window && (browser.edge || browser.ie && browser.version >= 11)
        ),
        // passiveSupported: detectPassiveSupport()
        domSupported: typeof document !== "undefined"
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/util.js
var require_util = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/util.js"(exports) {
    var BUILTIN_OBJECT = {
      "[object Function]": 1,
      "[object RegExp]": 1,
      "[object Date]": 1,
      "[object Error]": 1,
      "[object CanvasGradient]": 1,
      "[object CanvasPattern]": 1,
      // For node-canvas
      "[object Image]": 1,
      "[object Canvas]": 1
    };
    var TYPED_ARRAY = {
      "[object Int8Array]": 1,
      "[object Uint8Array]": 1,
      "[object Uint8ClampedArray]": 1,
      "[object Int16Array]": 1,
      "[object Uint16Array]": 1,
      "[object Int32Array]": 1,
      "[object Uint32Array]": 1,
      "[object Float32Array]": 1,
      "[object Float64Array]": 1
    };
    var objToString = Object.prototype.toString;
    var arrayProto = Array.prototype;
    var nativeForEach = arrayProto.forEach;
    var nativeFilter = arrayProto.filter;
    var nativeSlice = arrayProto.slice;
    var nativeMap = arrayProto.map;
    var nativeReduce = arrayProto.reduce;
    var methods = {};
    function $override(name2, fn) {
      if (name2 === "createCanvas") {
        _ctx = null;
      }
      methods[name2] = fn;
    }
    function clone(source) {
      if (source == null || typeof source !== "object") {
        return source;
      }
      var result = source;
      var typeStr = objToString.call(source);
      if (typeStr === "[object Array]") {
        if (!isPrimitive(source)) {
          result = [];
          for (var i = 0, len = source.length; i < len; i++) {
            result[i] = clone(source[i]);
          }
        }
      } else if (TYPED_ARRAY[typeStr]) {
        if (!isPrimitive(source)) {
          var Ctor = source.constructor;
          if (source.constructor.from) {
            result = Ctor.from(source);
          } else {
            result = new Ctor(source.length);
            for (var i = 0, len = source.length; i < len; i++) {
              result[i] = clone(source[i]);
            }
          }
        }
      } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
        result = {};
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            result[key] = clone(source[key]);
          }
        }
      }
      return result;
    }
    function merge(target, source, overwrite) {
      if (!isObject(source) || !isObject(target)) {
        return overwrite ? clone(source) : target;
      }
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          var targetProp = target[key];
          var sourceProp = source[key];
          if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
            merge(targetProp, sourceProp, overwrite);
          } else if (overwrite || !(key in target)) {
            target[key] = clone(source[key], true);
          }
        }
      }
      return target;
    }
    function mergeAll(targetAndSources, overwrite) {
      var result = targetAndSources[0];
      for (var i = 1, len = targetAndSources.length; i < len; i++) {
        result = merge(result, targetAndSources[i], overwrite);
      }
      return result;
    }
    function extend(target, source) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    function defaults(target, source, overlay) {
      for (var key in source) {
        if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var createCanvas = function() {
      return methods.createCanvas();
    };
    methods.createCanvas = function() {
      return document.createElement("canvas");
    };
    var _ctx;
    function getContext() {
      if (!_ctx) {
        _ctx = createCanvas().getContext("2d");
      }
      return _ctx;
    }
    function indexOf(array, value) {
      if (array) {
        if (array.indexOf) {
          return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i < len; i++) {
          if (array[i] === value) {
            return i;
          }
        }
      }
      return -1;
    }
    function inherits(clazz, baseClazz) {
      var clazzPrototype = clazz.prototype;
      function F() {
      }
      F.prototype = baseClazz.prototype;
      clazz.prototype = new F();
      for (var prop in clazzPrototype) {
        if (clazzPrototype.hasOwnProperty(prop)) {
          clazz.prototype[prop] = clazzPrototype[prop];
        }
      }
      clazz.prototype.constructor = clazz;
      clazz.superClass = baseClazz;
    }
    function mixin(target, source, overlay) {
      target = "prototype" in target ? target.prototype : target;
      source = "prototype" in source ? source.prototype : source;
      defaults(target, source, overlay);
    }
    function isArrayLike(data) {
      if (!data) {
        return;
      }
      if (typeof data === "string") {
        return false;
      }
      return typeof data.length === "number";
    }
    function each(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.forEach && obj.forEach === nativeForEach) {
        obj.forEach(cb, context);
      } else if (obj.length === +obj.length) {
        for (var i = 0, len = obj.length; i < len; i++) {
          cb.call(context, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (obj.hasOwnProperty(key)) {
            cb.call(context, obj[key], key, obj);
          }
        }
      }
    }
    function map(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.map && obj.map === nativeMap) {
        return obj.map(cb, context);
      } else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
          result.push(cb.call(context, obj[i], i, obj));
        }
        return result;
      }
    }
    function reduce(obj, cb, memo, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.reduce && obj.reduce === nativeReduce) {
        return obj.reduce(cb, memo, context);
      } else {
        for (var i = 0, len = obj.length; i < len; i++) {
          memo = cb.call(context, memo, obj[i], i, obj);
        }
        return memo;
      }
    }
    function filter(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      if (obj.filter && obj.filter === nativeFilter) {
        return obj.filter(cb, context);
      } else {
        var result = [];
        for (var i = 0, len = obj.length; i < len; i++) {
          if (cb.call(context, obj[i], i, obj)) {
            result.push(obj[i]);
          }
        }
        return result;
      }
    }
    function find(obj, cb, context) {
      if (!(obj && cb)) {
        return;
      }
      for (var i = 0, len = obj.length; i < len; i++) {
        if (cb.call(context, obj[i], i, obj)) {
          return obj[i];
        }
      }
    }
    function bind(func, context) {
      var args = nativeSlice.call(arguments, 2);
      return function() {
        return func.apply(context, args.concat(nativeSlice.call(arguments)));
      };
    }
    function curry(func) {
      var args = nativeSlice.call(arguments, 1);
      return function() {
        return func.apply(this, args.concat(nativeSlice.call(arguments)));
      };
    }
    function isArray(value) {
      return objToString.call(value) === "[object Array]";
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isString(value) {
      return objToString.call(value) === "[object String]";
    }
    function isObject(value) {
      var type = typeof value;
      return type === "function" || !!value && type === "object";
    }
    function isBuiltInObject(value) {
      return !!BUILTIN_OBJECT[objToString.call(value)];
    }
    function isTypedArray(value) {
      return !!TYPED_ARRAY[objToString.call(value)];
    }
    function isDom(value) {
      return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
    }
    function eqNaN(value) {
      return value !== value;
    }
    function retrieve(values) {
      for (var i = 0, len = arguments.length; i < len; i++) {
        if (arguments[i] != null) {
          return arguments[i];
        }
      }
    }
    function retrieve2(value0, value1) {
      return value0 != null ? value0 : value1;
    }
    function retrieve3(value0, value1, value2) {
      return value0 != null ? value0 : value1 != null ? value1 : value2;
    }
    function slice() {
      return Function.call.apply(nativeSlice, arguments);
    }
    function normalizeCssArray(val) {
      if (typeof val === "number") {
        return [val, val, val, val];
      }
      var len = val.length;
      if (len === 2) {
        return [val[0], val[1], val[0], val[1]];
      } else if (len === 3) {
        return [val[0], val[1], val[2], val[1]];
      }
      return val;
    }
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message);
      }
    }
    function trim(str) {
      if (str == null) {
        return null;
      } else if (typeof str.trim === "function") {
        return str.trim();
      } else {
        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
      }
    }
    var primitiveKey = "__ec_primitive__";
    function setAsPrimitive(obj) {
      obj[primitiveKey] = true;
    }
    function isPrimitive(obj) {
      return obj[primitiveKey];
    }
    function HashMap(obj) {
      var isArr = isArray(obj);
      this.data = {};
      var thisMap = this;
      obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);
      function visit(value, key) {
        isArr ? thisMap.set(value, key) : thisMap.set(key, value);
      }
    }
    HashMap.prototype = {
      constructor: HashMap,
      // Do not provide `has` method to avoid defining what is `has`.
      // (We usually treat `null` and `undefined` as the same, different
      // from ES6 Map).
      get: function(key) {
        return this.data.hasOwnProperty(key) ? this.data[key] : null;
      },
      set: function(key, value) {
        return this.data[key] = value;
      },
      // Although util.each can be performed on this hashMap directly, user
      // should not use the exposed keys, who are prefixed.
      each: function(cb, context) {
        context !== void 0 && (cb = bind(cb, context));
        for (var key in this.data) {
          this.data.hasOwnProperty(key) && cb(this.data[key], key);
        }
      },
      // Do not use this method if performance sensitive.
      removeKey: function(key) {
        delete this.data[key];
      }
    };
    function createHashMap(obj) {
      return new HashMap(obj);
    }
    function concatArray(a, b) {
      var newArray = new a.constructor(a.length + b.length);
      for (var i = 0; i < a.length; i++) {
        newArray[i] = a[i];
      }
      var offset = a.length;
      for (i = 0; i < b.length; i++) {
        newArray[i + offset] = b[i];
      }
      return newArray;
    }
    function noop() {
    }
    exports.$override = $override;
    exports.clone = clone;
    exports.merge = merge;
    exports.mergeAll = mergeAll;
    exports.extend = extend;
    exports.defaults = defaults;
    exports.createCanvas = createCanvas;
    exports.getContext = getContext;
    exports.indexOf = indexOf;
    exports.inherits = inherits;
    exports.mixin = mixin;
    exports.isArrayLike = isArrayLike;
    exports.each = each;
    exports.map = map;
    exports.reduce = reduce;
    exports.filter = filter;
    exports.find = find;
    exports.bind = bind;
    exports.curry = curry;
    exports.isArray = isArray;
    exports.isFunction = isFunction;
    exports.isString = isString;
    exports.isObject = isObject;
    exports.isBuiltInObject = isBuiltInObject;
    exports.isTypedArray = isTypedArray;
    exports.isDom = isDom;
    exports.eqNaN = eqNaN;
    exports.retrieve = retrieve;
    exports.retrieve2 = retrieve2;
    exports.retrieve3 = retrieve3;
    exports.slice = slice;
    exports.normalizeCssArray = normalizeCssArray;
    exports.assert = assert;
    exports.trim = trim;
    exports.setAsPrimitive = setAsPrimitive;
    exports.isPrimitive = isPrimitive;
    exports.createHashMap = createHashMap;
    exports.concatArray = concatArray;
    exports.noop = noop;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/vector.js
var require_vector = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/vector.js"(exports) {
    var ArrayCtor = typeof Float32Array === "undefined" ? Array : Float32Array;
    function create(x, y) {
      var out = new ArrayCtor(2);
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      out[0] = x;
      out[1] = y;
      return out;
    }
    function copy(out, v) {
      out[0] = v[0];
      out[1] = v[1];
      return out;
    }
    function clone(v) {
      var out = new ArrayCtor(2);
      out[0] = v[0];
      out[1] = v[1];
      return out;
    }
    function set(out, a, b) {
      out[0] = a;
      out[1] = b;
      return out;
    }
    function add(out, v1, v2) {
      out[0] = v1[0] + v2[0];
      out[1] = v1[1] + v2[1];
      return out;
    }
    function scaleAndAdd(out, v1, v2, a) {
      out[0] = v1[0] + v2[0] * a;
      out[1] = v1[1] + v2[1] * a;
      return out;
    }
    function sub(out, v1, v2) {
      out[0] = v1[0] - v2[0];
      out[1] = v1[1] - v2[1];
      return out;
    }
    function len(v) {
      return Math.sqrt(lenSquare(v));
    }
    var length = len;
    function lenSquare(v) {
      return v[0] * v[0] + v[1] * v[1];
    }
    var lengthSquare = lenSquare;
    function mul(out, v1, v2) {
      out[0] = v1[0] * v2[0];
      out[1] = v1[1] * v2[1];
      return out;
    }
    function div(out, v1, v2) {
      out[0] = v1[0] / v2[0];
      out[1] = v1[1] / v2[1];
      return out;
    }
    function dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    function scale(out, v, s) {
      out[0] = v[0] * s;
      out[1] = v[1] * s;
      return out;
    }
    function normalize(out, v) {
      var d = len(v);
      if (d === 0) {
        out[0] = 0;
        out[1] = 0;
      } else {
        out[0] = v[0] / d;
        out[1] = v[1] / d;
      }
      return out;
    }
    function distance(v1, v2) {
      return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
    }
    var dist = distance;
    function distanceSquare(v1, v2) {
      return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
    }
    var distSquare = distanceSquare;
    function negate(out, v) {
      out[0] = -v[0];
      out[1] = -v[1];
      return out;
    }
    function lerp(out, v1, v2, t) {
      out[0] = v1[0] + t * (v2[0] - v1[0]);
      out[1] = v1[1] + t * (v2[1] - v1[1]);
      return out;
    }
    function applyTransform(out, v, m) {
      var x = v[0];
      var y = v[1];
      out[0] = m[0] * x + m[2] * y + m[4];
      out[1] = m[1] * x + m[3] * y + m[5];
      return out;
    }
    function min(out, v1, v2) {
      out[0] = Math.min(v1[0], v2[0]);
      out[1] = Math.min(v1[1], v2[1]);
      return out;
    }
    function max(out, v1, v2) {
      out[0] = Math.max(v1[0], v2[0]);
      out[1] = Math.max(v1[1], v2[1]);
      return out;
    }
    exports.create = create;
    exports.copy = copy;
    exports.clone = clone;
    exports.set = set;
    exports.add = add;
    exports.scaleAndAdd = scaleAndAdd;
    exports.sub = sub;
    exports.len = len;
    exports.length = length;
    exports.lenSquare = lenSquare;
    exports.lengthSquare = lengthSquare;
    exports.mul = mul;
    exports.div = div;
    exports.dot = dot;
    exports.scale = scale;
    exports.normalize = normalize;
    exports.distance = distance;
    exports.dist = dist;
    exports.distanceSquare = distanceSquare;
    exports.distSquare = distSquare;
    exports.negate = negate;
    exports.lerp = lerp;
    exports.applyTransform = applyTransform;
    exports.min = min;
    exports.max = max;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Draggable.js
var require_Draggable = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Draggable.js"(exports, module) {
    function Draggable() {
      this.on("mousedown", this._dragStart, this);
      this.on("mousemove", this._drag, this);
      this.on("mouseup", this._dragEnd, this);
    }
    Draggable.prototype = {
      constructor: Draggable,
      _dragStart: function(e) {
        var draggingTarget = e.target;
        while (draggingTarget && !draggingTarget.draggable) {
          draggingTarget = draggingTarget.parent;
        }
        if (draggingTarget) {
          this._draggingTarget = draggingTarget;
          draggingTarget.dragging = true;
          this._x = e.offsetX;
          this._y = e.offsetY;
          this.dispatchToElement(param(draggingTarget, e), "dragstart", e.event);
        }
      },
      _drag: function(e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {
          var x = e.offsetX;
          var y = e.offsetY;
          var dx = x - this._x;
          var dy = y - this._y;
          this._x = x;
          this._y = y;
          draggingTarget.drift(dx, dy, e);
          this.dispatchToElement(param(draggingTarget, e), "drag", e.event);
          var dropTarget = this.findHover(x, y, draggingTarget).target;
          var lastDropTarget = this._dropTarget;
          this._dropTarget = dropTarget;
          if (draggingTarget !== dropTarget) {
            if (lastDropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(lastDropTarget, e), "dragleave", e.event);
            }
            if (dropTarget && dropTarget !== lastDropTarget) {
              this.dispatchToElement(param(dropTarget, e), "dragenter", e.event);
            }
          }
        }
      },
      _dragEnd: function(e) {
        var draggingTarget = this._draggingTarget;
        if (draggingTarget) {
          draggingTarget.dragging = false;
        }
        this.dispatchToElement(param(draggingTarget, e), "dragend", e.event);
        if (this._dropTarget) {
          this.dispatchToElement(param(this._dropTarget, e), "drop", e.event);
        }
        this._draggingTarget = null;
        this._dropTarget = null;
      }
    };
    function param(target, e) {
      return {
        target,
        topTarget: e && e.topTarget
      };
    }
    var _default = Draggable;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Eventful.js
var require_Eventful = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Eventful.js"(exports, module) {
    var arrySlice = Array.prototype.slice;
    var Eventful = function(eventProcessor) {
      this._$handlers = {};
      this._$eventProcessor = eventProcessor;
    };
    Eventful.prototype = {
      constructor: Eventful,
      /**
       * The handler can only be triggered once, then removed.
       *
       * @param {string} event The event name.
       * @param {string|Object} [query] Condition used on event filter.
       * @param {Function} handler The event handler.
       * @param {Object} context
       */
      one: function(event, query, handler, context) {
        return on(this, event, query, handler, context, true);
      },
      /**
       * Bind a handler.
       *
       * @param {string} event The event name.
       * @param {string|Object} [query] Condition used on event filter.
       * @param {Function} handler The event handler.
       * @param {Object} [context]
       */
      on: function(event, query, handler, context) {
        return on(this, event, query, handler, context, false);
      },
      /**
       * Whether any handler has bound.
       *
       * @param  {string}  event
       * @return {boolean}
       */
      isSilent: function(event) {
        var _h = this._$handlers;
        return !_h[event] || !_h[event].length;
      },
      /**
       * Unbind a event.
       *
       * @param {string} [event] The event name.
       *        If no `event` input, "off" all listeners.
       * @param {Function} [handler] The event handler.
       *        If no `handler` input, "off" all listeners of the `event`.
       */
      off: function(event, handler) {
        var _h = this._$handlers;
        if (!event) {
          this._$handlers = {};
          return this;
        }
        if (handler) {
          if (_h[event]) {
            var newList = [];
            for (var i = 0, l = _h[event].length; i < l; i++) {
              if (_h[event][i].h !== handler) {
                newList.push(_h[event][i]);
              }
            }
            _h[event] = newList;
          }
          if (_h[event] && _h[event].length === 0) {
            delete _h[event];
          }
        } else {
          delete _h[event];
        }
        return this;
      },
      /**
       * Dispatch a event.
       *
       * @param {string} type The event name.
       */
      trigger: function(type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;
        if (_h) {
          var args = arguments;
          var argLen = args.length;
          if (argLen > 3) {
            args = arrySlice.call(args, 1);
          }
          var len = _h.length;
          for (var i = 0; i < len; ) {
            var hItem = _h[i];
            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            }
            switch (argLen) {
              case 1:
                hItem.h.call(hItem.ctx);
                break;
              case 2:
                hItem.h.call(hItem.ctx, args[1]);
                break;
              case 3:
                hItem.h.call(hItem.ctx, args[1], args[2]);
                break;
              default:
                hItem.h.apply(hItem.ctx, args);
                break;
            }
            if (hItem.one) {
              _h.splice(i, 1);
              len--;
            } else {
              i++;
            }
          }
        }
        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      },
      /**
       * Dispatch a event with context, which is specified at the last parameter.
       *
       * @param {string} type The event name.
       */
      triggerWithContext: function(type) {
        var _h = this._$handlers[type];
        var eventProcessor = this._$eventProcessor;
        if (_h) {
          var args = arguments;
          var argLen = args.length;
          if (argLen > 4) {
            args = arrySlice.call(args, 1, args.length - 1);
          }
          var ctx = args[args.length - 1];
          var len = _h.length;
          for (var i = 0; i < len; ) {
            var hItem = _h[i];
            if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
              i++;
              continue;
            }
            switch (argLen) {
              case 1:
                hItem.h.call(ctx);
                break;
              case 2:
                hItem.h.call(ctx, args[1]);
                break;
              case 3:
                hItem.h.call(ctx, args[1], args[2]);
                break;
              default:
                hItem.h.apply(ctx, args);
                break;
            }
            if (hItem.one) {
              _h.splice(i, 1);
              len--;
            } else {
              i++;
            }
          }
        }
        eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
        return this;
      }
    };
    function normalizeQuery(host, query) {
      var eventProcessor = host._$eventProcessor;
      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query);
      }
      return query;
    }
    function on(eventful, event, query, handler, context, isOnce) {
      var _h = eventful._$handlers;
      if (typeof query === "function") {
        context = handler;
        handler = query;
        query = null;
      }
      if (!handler || !event) {
        return eventful;
      }
      query = normalizeQuery(eventful, query);
      if (!_h[event]) {
        _h[event] = [];
      }
      for (var i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return eventful;
        }
      }
      var wrap = {
        h: handler,
        one: isOnce,
        query,
        ctx: context || eventful,
        // FIXME
        // Do not publish this feature util it is proved that it makes sense.
        callAtLast: handler.zrEventfulCallAtLast
      };
      var lastIndex = _h[event].length - 1;
      var lastWrap = _h[event][lastIndex];
      lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
      return eventful;
    }
    var _default = Eventful;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/fourPointsTransform.js
var require_fourPointsTransform = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/fourPointsTransform.js"(exports) {
    var LN2 = Math.log(2);
    function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
      var cacheKey = rowMask + "-" + colMask;
      var fullRank = rows.length;
      if (detCache.hasOwnProperty(cacheKey)) {
        return detCache[cacheKey];
      }
      if (rank === 1) {
        var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
        return rows[rowStart][colStart];
      }
      var subRowMask = rowMask | 1 << rowStart;
      var subRowStart = rowStart + 1;
      while (rowMask & 1 << subRowStart) {
        subRowStart++;
      }
      var sum = 0;
      for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
        var colTag = 1 << j;
        if (!(colTag & colMask)) {
          sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
          colLocalIdx++;
        }
      }
      detCache[cacheKey] = sum;
      return sum;
    }
    function buildTransformer(src, dest) {
      var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];
      var detCache = {};
      var det = determinant(mA, 8, 0, 0, 0, detCache);
      if (det === 0) {
        return;
      }
      var vh = [];
      for (var i = 0; i < 8; i++) {
        for (var j = 0; j < 8; j++) {
          vh[j] == null && (vh[j] = 0);
          vh[j] += ((i + j) % 2 ? -1 : 1) * // det(subMatrix(i, j))
          determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
        }
      }
      return function(out, srcPointX, srcPointY) {
        var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
        out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
        out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
      };
    }
    exports.buildTransformer = buildTransformer;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/dom.js
var require_dom = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/dom.js"(exports) {
    var env = require_env();
    var _fourPointsTransform = require_fourPointsTransform();
    var buildTransformer = _fourPointsTransform.buildTransformer;
    var EVENT_SAVED_PROP = "___zrEVENTSAVED";
    var _calcOut = [];
    function transformLocalCoord(out, elFrom, elTarget, inX, inY) {
      return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);
    }
    function transformCoordWithViewport(out, el, inX, inY, inverse) {
      if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {
        var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
        var markers = prepareCoordMarkers(el, saved);
        var transformer = preparePointerTransformer(markers, saved, inverse);
        if (transformer) {
          transformer(out, inX, inY);
          return true;
        }
      }
      return false;
    }
    function prepareCoordMarkers(el, saved) {
      var markers = saved.markers;
      if (markers) {
        return markers;
      }
      markers = saved.markers = [];
      var propLR = ["left", "right"];
      var propTB = ["top", "bottom"];
      for (var i = 0; i < 4; i++) {
        var marker = document.createElement("div");
        var stl = marker.style;
        var idxLR = i % 2;
        var idxTB = (i >> 1) % 2;
        stl.cssText = [
          "position: absolute",
          "visibility: hidden",
          "padding: 0",
          "margin: 0",
          "border-width: 0",
          "user-select: none",
          "width:0",
          "height:0",
          // 'width: 5px',
          // 'height: 5px',
          propLR[idxLR] + ":0",
          propTB[idxTB] + ":0",
          propLR[1 - idxLR] + ":auto",
          propTB[1 - idxTB] + ":auto",
          ""
        ].join("!important;");
        el.appendChild(marker);
        markers.push(marker);
      }
      return markers;
    }
    function preparePointerTransformer(markers, saved, inverse) {
      var transformerName = inverse ? "invTrans" : "trans";
      var transformer = saved[transformerName];
      var oldSrcCoords = saved.srcCoords;
      var oldCoordTheSame = true;
      var srcCoords = [];
      var destCoords = [];
      for (var i = 0; i < 4; i++) {
        var rect = markers[i].getBoundingClientRect();
        var ii = 2 * i;
        var x = rect.left;
        var y = rect.top;
        srcCoords.push(x, y);
        oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
        destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
      }
      return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
    }
    function isCanvasEl(el) {
      return el.nodeName.toUpperCase() === "CANVAS";
    }
    exports.transformLocalCoord = transformLocalCoord;
    exports.transformCoordWithViewport = transformCoordWithViewport;
    exports.isCanvasEl = isCanvasEl;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/event.js
var require_event = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/event.js"(exports) {
    var Eventful = require_Eventful();
    exports.Dispatcher = Eventful;
    var env = require_env();
    var _dom = require_dom();
    var isCanvasEl = _dom.isCanvasEl;
    var transformCoordWithViewport = _dom.transformCoordWithViewport;
    var isDomLevel2 = typeof window !== "undefined" && !!window.addEventListener;
    var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
    var _calcOut = [];
    function clientToLocal(el, e, out, calculate) {
      out = out || {};
      if (calculate || !env.canvasSupported) {
        calculateZrXY(el, e, out);
      } else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
        out.zrX = e.layerX;
        out.zrY = e.layerY;
      } else if (e.offsetX != null) {
        out.zrX = e.offsetX;
        out.zrY = e.offsetY;
      } else {
        calculateZrXY(el, e, out);
      }
      return out;
    }
    function calculateZrXY(el, e, out) {
      if (env.domSupported && el.getBoundingClientRect) {
        var ex = e.clientX;
        var ey = e.clientY;
        if (isCanvasEl(el)) {
          var box = el.getBoundingClientRect();
          out.zrX = ex - box.left;
          out.zrY = ey - box.top;
          return;
        } else {
          if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
            out.zrX = _calcOut[0];
            out.zrY = _calcOut[1];
            return;
          }
        }
      }
      out.zrX = out.zrY = 0;
    }
    function getNativeEvent(e) {
      return e || window.event;
    }
    function normalizeEvent(el, e, calculate) {
      e = getNativeEvent(e);
      if (e.zrX != null) {
        return e;
      }
      var eventType = e.type;
      var isTouch = eventType && eventType.indexOf("touch") >= 0;
      if (!isTouch) {
        clientToLocal(el, e, e, calculate);
        e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
      } else {
        var touch = eventType !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
        touch && clientToLocal(el, touch, e, calculate);
      }
      var button = e.button;
      if (e.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e.type)) {
        e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
      }
      return e;
    }
    function addEventListener(el, name2, handler, opt) {
      if (isDomLevel2) {
        el.addEventListener(name2, handler, opt);
      } else {
        el.attachEvent("on" + name2, handler);
      }
    }
    function removeEventListener(el, name2, handler, opt) {
      if (isDomLevel2) {
        el.removeEventListener(name2, handler, opt);
      } else {
        el.detachEvent("on" + name2, handler);
      }
    }
    var stop = isDomLevel2 ? function(e) {
      e.preventDefault();
      e.stopPropagation();
      e.cancelBubble = true;
    } : function(e) {
      e.returnValue = false;
      e.cancelBubble = true;
    };
    function isMiddleOrRightButtonOnMouseUpDown(e) {
      return e.which === 2 || e.which === 3;
    }
    function notLeftMouse(e) {
      return e.which > 1;
    }
    exports.clientToLocal = clientToLocal;
    exports.getNativeEvent = getNativeEvent;
    exports.normalizeEvent = normalizeEvent;
    exports.addEventListener = addEventListener;
    exports.removeEventListener = removeEventListener;
    exports.stop = stop;
    exports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;
    exports.notLeftMouse = notLeftMouse;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/GestureMgr.js
var require_GestureMgr = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/GestureMgr.js"(exports, module) {
    var eventUtil = require_event();
    var GestureMgr = function() {
      this._track = [];
    };
    GestureMgr.prototype = {
      constructor: GestureMgr,
      recognize: function(event, target, root) {
        this._doTrack(event, target, root);
        return this._recognize(event);
      },
      clear: function() {
        this._track.length = 0;
        return this;
      },
      _doTrack: function(event, target, root) {
        var touches = event.touches;
        if (!touches) {
          return;
        }
        var trackItem = {
          points: [],
          touches: [],
          target,
          event
        };
        for (var i = 0, len = touches.length; i < len; i++) {
          var touch = touches[i];
          var pos = eventUtil.clientToLocal(root, touch, {});
          trackItem.points.push([pos.zrX, pos.zrY]);
          trackItem.touches.push(touch);
        }
        this._track.push(trackItem);
      },
      _recognize: function(event) {
        for (var eventName in recognizers) {
          if (recognizers.hasOwnProperty(eventName)) {
            var gestureInfo = recognizers[eventName](this._track, event);
            if (gestureInfo) {
              return gestureInfo;
            }
          }
        }
      }
    };
    function dist(pointPair) {
      var dx = pointPair[1][0] - pointPair[0][0];
      var dy = pointPair[1][1] - pointPair[0][1];
      return Math.sqrt(dx * dx + dy * dy);
    }
    function center(pointPair) {
      return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
    }
    var recognizers = {
      pinch: function(track, event) {
        var trackLen = track.length;
        if (!trackLen) {
          return;
        }
        var pinchEnd = (track[trackLen - 1] || {}).points;
        var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
        if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
          var pinchScale = dist(pinchEnd) / dist(pinchPre);
          !isFinite(pinchScale) && (pinchScale = 1);
          event.pinchScale = pinchScale;
          var pinchCenter = center(pinchEnd);
          event.pinchX = pinchCenter[0];
          event.pinchY = pinchCenter[1];
          return {
            type: "pinch",
            target: track[0].target,
            event
          };
        }
      }
      // Only pinch currently.
    };
    var _default = GestureMgr;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Handler.js
var require_Handler = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Handler.js"(exports, module) {
    var util = require_util();
    var vec2 = require_vector();
    var Draggable = require_Draggable();
    var Eventful = require_Eventful();
    var eventTool = require_event();
    var GestureMgr = require_GestureMgr();
    var SILENT = "silent";
    function makeEventPacket(eveType, targetInfo, event) {
      return {
        type: eveType,
        event,
        // target can only be an element that is not silent.
        target: targetInfo.target,
        // topTarget can be a silent element.
        topTarget: targetInfo.topTarget,
        cancelBubble: false,
        offsetX: event.zrX,
        offsetY: event.zrY,
        gestureEvent: event.gestureEvent,
        pinchX: event.pinchX,
        pinchY: event.pinchY,
        pinchScale: event.pinchScale,
        wheelDelta: event.zrDelta,
        zrByTouch: event.zrByTouch,
        which: event.which,
        stop: stopEvent
      };
    }
    function stopEvent() {
      eventTool.stop(this.event);
    }
    function EmptyProxy() {
    }
    EmptyProxy.prototype.dispose = function() {
    };
    var handlerNames = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
    var Handler = function(storage, painter, proxy, painterRoot) {
      Eventful.call(this);
      this.storage = storage;
      this.painter = painter;
      this.painterRoot = painterRoot;
      proxy = proxy || new EmptyProxy();
      this.proxy = null;
      this._hovered = {};
      this._lastTouchMoment;
      this._lastX;
      this._lastY;
      this._gestureMgr;
      Draggable.call(this);
      this.setHandlerProxy(proxy);
    };
    Handler.prototype = {
      constructor: Handler,
      setHandlerProxy: function(proxy) {
        if (this.proxy) {
          this.proxy.dispose();
        }
        if (proxy) {
          util.each(handlerNames, function(name2) {
            proxy.on && proxy.on(name2, this[name2], this);
          }, this);
          proxy.handler = this;
        }
        this.proxy = proxy;
      },
      mousemove: function(event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var lastHovered = this._hovered;
        var lastHoveredTarget = lastHovered.target;
        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
          lastHovered = this.findHover(lastHovered.x, lastHovered.y);
          lastHoveredTarget = lastHovered.target;
        }
        var hovered = this._hovered = isOutside ? {
          x,
          y
        } : this.findHover(x, y);
        var hoveredTarget = hovered.target;
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(lastHovered, "mouseout", event);
        }
        this.dispatchToElement(hovered, "mousemove", event);
        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
          this.dispatchToElement(hovered, "mouseover", event);
        }
      },
      mouseout: function(event) {
        var eventControl = event.zrEventControl;
        var zrIsToLocalDOM = event.zrIsToLocalDOM;
        if (eventControl !== "only_globalout") {
          this.dispatchToElement(this._hovered, "mouseout", event);
        }
        if (eventControl !== "no_globalout") {
          !zrIsToLocalDOM && this.trigger("globalout", {
            type: "globalout",
            event
          });
        }
      },
      /**
       * Resize
       */
      resize: function(event) {
        this._hovered = {};
      },
      /**
       * Dispatch event
       * @param {string} eventName
       * @param {event=} eventArgs
       */
      dispatch: function(eventName, eventArgs) {
        var handler = this[eventName];
        handler && handler.call(this, eventArgs);
      },
      /**
       * Dispose
       */
      dispose: function() {
        this.proxy.dispose();
        this.storage = this.proxy = this.painter = null;
      },
      /**
       * 设置默认的cursor style
       * @param {string} [cursorStyle='default'] 例如 crosshair
       */
      setCursorStyle: function(cursorStyle) {
        var proxy = this.proxy;
        proxy.setCursor && proxy.setCursor(cursorStyle);
      },
      /**
       * 事件分发代理
       *
       * @private
       * @param {Object} targetInfo {target, topTarget} 目标图形元素
       * @param {string} eventName 事件名称
       * @param {Object} event 事件对象
       */
      dispatchToElement: function(targetInfo, eventName, event) {
        targetInfo = targetInfo || {};
        var el = targetInfo.target;
        if (el && el.silent) {
          return;
        }
        var eventHandler = "on" + eventName;
        var eventPacket = makeEventPacket(eventName, targetInfo, event);
        while (el) {
          el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
          el.trigger(eventName, eventPacket);
          el = el.parent;
          if (eventPacket.cancelBubble) {
            break;
          }
        }
        if (!eventPacket.cancelBubble) {
          this.trigger(eventName, eventPacket);
          this.painter && this.painter.eachOtherLayer(function(layer) {
            if (typeof layer[eventHandler] === "function") {
              layer[eventHandler].call(layer, eventPacket);
            }
            if (layer.trigger) {
              layer.trigger(eventName, eventPacket);
            }
          });
        }
      },
      /**
       * @private
       * @param {number} x
       * @param {number} y
       * @param {module:zrender/graphic/Displayable} exclude
       * @return {model:zrender/Element}
       * @method
       */
      findHover: function(x, y, exclude) {
        var list = this.storage.getDisplayList();
        var out = {
          x,
          y
        };
        for (var i = list.length - 1; i >= 0; i--) {
          var hoverCheckResult;
          if (list[i] !== exclude && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
            !out.topTarget && (out.topTarget = list[i]);
            if (hoverCheckResult !== SILENT) {
              out.target = list[i];
              break;
            }
          }
        }
        return out;
      },
      processGesture: function(event, stage) {
        if (!this._gestureMgr) {
          this._gestureMgr = new GestureMgr();
        }
        var gestureMgr = this._gestureMgr;
        stage === "start" && gestureMgr.clear();
        var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
        stage === "end" && gestureMgr.clear();
        if (gestureInfo) {
          var type = gestureInfo.type;
          event.gestureEvent = type;
          this.dispatchToElement({
            target: gestureInfo.target
          }, type, gestureInfo.event);
        }
      }
    };
    util.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name2) {
      Handler.prototype[name2] = function(event) {
        var x = event.zrX;
        var y = event.zrY;
        var isOutside = isOutsideBoundary(this, x, y);
        var hovered;
        var hoveredTarget;
        if (name2 !== "mouseup" || !isOutside) {
          hovered = this.findHover(x, y);
          hoveredTarget = hovered.target;
        }
        if (name2 === "mousedown") {
          this._downEl = hoveredTarget;
          this._downPoint = [event.zrX, event.zrY];
          this._upEl = hoveredTarget;
        } else if (name2 === "mouseup") {
          this._upEl = hoveredTarget;
        } else if (name2 === "click") {
          if (this._downEl !== this._upEl || !this._downPoint || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
            return;
          }
          this._downPoint = null;
        }
        this.dispatchToElement(hovered, name2, event);
      };
    });
    function isHover(displayable, x, y) {
      if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
        var el = displayable;
        var isSilent;
        while (el) {
          if (el.clipPath && !el.clipPath.contain(x, y)) {
            return false;
          }
          if (el.silent) {
            isSilent = true;
          }
          el = el.parent;
        }
        return isSilent ? SILENT : true;
      }
      return false;
    }
    function isOutsideBoundary(handlerInstance, x, y) {
      var painter = handlerInstance.painter;
      return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
    }
    util.mixin(Handler, Eventful);
    util.mixin(Handler, Draggable);
    var _default = Handler;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/matrix.js
var require_matrix = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/matrix.js"(exports) {
    var ArrayCtor = typeof Float32Array === "undefined" ? Array : Float32Array;
    function create() {
      var out = new ArrayCtor(6);
      identity(out);
      return out;
    }
    function identity(out) {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      out[4] = 0;
      out[5] = 0;
      return out;
    }
    function copy(out, m) {
      out[0] = m[0];
      out[1] = m[1];
      out[2] = m[2];
      out[3] = m[3];
      out[4] = m[4];
      out[5] = m[5];
      return out;
    }
    function mul(out, m1, m2) {
      var out0 = m1[0] * m2[0] + m1[2] * m2[1];
      var out1 = m1[1] * m2[0] + m1[3] * m2[1];
      var out2 = m1[0] * m2[2] + m1[2] * m2[3];
      var out3 = m1[1] * m2[2] + m1[3] * m2[3];
      var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
      var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
      out[0] = out0;
      out[1] = out1;
      out[2] = out2;
      out[3] = out3;
      out[4] = out4;
      out[5] = out5;
      return out;
    }
    function translate(out, a, v) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[4] = a[4] + v[0];
      out[5] = a[5] + v[1];
      return out;
    }
    function rotate(out, a, rad) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var st = Math.sin(rad);
      var ct = Math.cos(rad);
      out[0] = aa * ct + ab * st;
      out[1] = -aa * st + ab * ct;
      out[2] = ac * ct + ad * st;
      out[3] = -ac * st + ct * ad;
      out[4] = ct * atx + st * aty;
      out[5] = ct * aty - st * atx;
      return out;
    }
    function scale(out, a, v) {
      var vx = v[0];
      var vy = v[1];
      out[0] = a[0] * vx;
      out[1] = a[1] * vy;
      out[2] = a[2] * vx;
      out[3] = a[3] * vy;
      out[4] = a[4] * vx;
      out[5] = a[5] * vy;
      return out;
    }
    function invert(out, a) {
      var aa = a[0];
      var ac = a[2];
      var atx = a[4];
      var ab = a[1];
      var ad = a[3];
      var aty = a[5];
      var det = aa * ad - ab * ac;
      if (!det) {
        return null;
      }
      det = 1 / det;
      out[0] = ad * det;
      out[1] = -ab * det;
      out[2] = -ac * det;
      out[3] = aa * det;
      out[4] = (ac * aty - ad * atx) * det;
      out[5] = (ab * atx - aa * aty) * det;
      return out;
    }
    function clone(a) {
      var b = create();
      copy(b, a);
      return b;
    }
    exports.create = create;
    exports.identity = identity;
    exports.copy = copy;
    exports.mul = mul;
    exports.translate = translate;
    exports.rotate = rotate;
    exports.scale = scale;
    exports.invert = invert;
    exports.clone = clone;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Transformable.js
var require_Transformable = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Transformable.js"(exports, module) {
    var matrix = require_matrix();
    var vector = require_vector();
    var mIdentity = matrix.identity;
    var EPSILON = 5e-5;
    function isNotAroundZero(val) {
      return val > EPSILON || val < -EPSILON;
    }
    var Transformable = function(opts) {
      opts = opts || {};
      if (!opts.position) {
        this.position = [0, 0];
      }
      if (opts.rotation == null) {
        this.rotation = 0;
      }
      if (!opts.scale) {
        this.scale = [1, 1];
      }
      this.origin = this.origin || null;
    };
    var transformableProto = Transformable.prototype;
    transformableProto.transform = null;
    transformableProto.needLocalTransform = function() {
      return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
    };
    var scaleTmp = [];
    transformableProto.updateTransform = function() {
      var parent = this.parent;
      var parentHasTransform = parent && parent.transform;
      var needLocalTransform = this.needLocalTransform();
      var m = this.transform;
      if (!(needLocalTransform || parentHasTransform)) {
        m && mIdentity(m);
        return;
      }
      m = m || matrix.create();
      if (needLocalTransform) {
        this.getLocalTransform(m);
      } else {
        mIdentity(m);
      }
      if (parentHasTransform) {
        if (needLocalTransform) {
          matrix.mul(m, parent.transform, m);
        } else {
          matrix.copy(m, parent.transform);
        }
      }
      this.transform = m;
      var globalScaleRatio = this.globalScaleRatio;
      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp);
        var relX = scaleTmp[0] < 0 ? -1 : 1;
        var relY = scaleTmp[1] < 0 ? -1 : 1;
        var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
        var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
        m[0] *= sx;
        m[1] *= sx;
        m[2] *= sy;
        m[3] *= sy;
      }
      this.invTransform = this.invTransform || matrix.create();
      matrix.invert(this.invTransform, m);
    };
    transformableProto.getLocalTransform = function(m) {
      return Transformable.getLocalTransform(this, m);
    };
    transformableProto.setTransform = function(ctx) {
      var m = this.transform;
      var dpr = ctx.dpr || 1;
      if (m) {
        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
      } else {
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
    };
    transformableProto.restoreTransform = function(ctx) {
      var dpr = ctx.dpr || 1;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    };
    var tmpTransform = [];
    var originTransform = matrix.create();
    transformableProto.setLocalTransform = function(m) {
      if (!m) {
        return;
      }
      var sx = m[0] * m[0] + m[1] * m[1];
      var sy = m[2] * m[2] + m[3] * m[3];
      var position = this.position;
      var scale = this.scale;
      if (isNotAroundZero(sx - 1)) {
        sx = Math.sqrt(sx);
      }
      if (isNotAroundZero(sy - 1)) {
        sy = Math.sqrt(sy);
      }
      if (m[0] < 0) {
        sx = -sx;
      }
      if (m[3] < 0) {
        sy = -sy;
      }
      position[0] = m[4];
      position[1] = m[5];
      scale[0] = sx;
      scale[1] = sy;
      this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
    };
    transformableProto.decomposeTransform = function() {
      if (!this.transform) {
        return;
      }
      var parent = this.parent;
      var m = this.transform;
      if (parent && parent.transform) {
        matrix.mul(tmpTransform, parent.invTransform, m);
        m = tmpTransform;
      }
      var origin = this.origin;
      if (origin && (origin[0] || origin[1])) {
        originTransform[4] = origin[0];
        originTransform[5] = origin[1];
        matrix.mul(tmpTransform, m, originTransform);
        tmpTransform[4] -= origin[0];
        tmpTransform[5] -= origin[1];
        m = tmpTransform;
      }
      this.setLocalTransform(m);
    };
    transformableProto.getGlobalScale = function(out) {
      var m = this.transform;
      out = out || [];
      if (!m) {
        out[0] = 1;
        out[1] = 1;
        return out;
      }
      out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
      out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
      if (m[0] < 0) {
        out[0] = -out[0];
      }
      if (m[3] < 0) {
        out[1] = -out[1];
      }
      return out;
    };
    transformableProto.transformCoordToLocal = function(x, y) {
      var v2 = [x, y];
      var invTransform = this.invTransform;
      if (invTransform) {
        vector.applyTransform(v2, v2, invTransform);
      }
      return v2;
    };
    transformableProto.transformCoordToGlobal = function(x, y) {
      var v2 = [x, y];
      var transform = this.transform;
      if (transform) {
        vector.applyTransform(v2, v2, transform);
      }
      return v2;
    };
    Transformable.getLocalTransform = function(target, m) {
      m = m || [];
      mIdentity(m);
      var origin = target.origin;
      var scale = target.scale || [1, 1];
      var rotation = target.rotation || 0;
      var position = target.position || [0, 0];
      if (origin) {
        m[4] -= origin[0];
        m[5] -= origin[1];
      }
      matrix.scale(m, m, scale);
      if (rotation) {
        matrix.rotate(m, m, rotation);
      }
      if (origin) {
        m[4] += origin[0];
        m[5] += origin[1];
      }
      m[4] += position[0];
      m[5] += position[1];
      return m;
    };
    var _default = Transformable;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/easing.js
var require_easing = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/easing.js"(exports, module) {
    var easing = {
      /**
      * @param {number} k
      * @return {number}
      */
      linear: function(k) {
        return k;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      quadraticIn: function(k) {
        return k * k;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      quadraticOut: function(k) {
        return k * (2 - k);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      quadraticInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
      },
      // 三次方的缓动（t^3）
      /**
      * @param {number} k
      * @return {number}
      */
      cubicIn: function(k) {
        return k * k * k;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      cubicOut: function(k) {
        return --k * k * k + 1;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      cubicInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
      },
      // 四次方的缓动（t^4）
      /**
      * @param {number} k
      * @return {number}
      */
      quarticIn: function(k) {
        return k * k * k * k;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      quarticOut: function(k) {
        return 1 - --k * k * k * k;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      quarticInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
      },
      // 五次方的缓动（t^5）
      /**
      * @param {number} k
      * @return {number}
      */
      quinticIn: function(k) {
        return k * k * k * k * k;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      quinticOut: function(k) {
        return --k * k * k * k * k + 1;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      quinticInOut: function(k) {
        if ((k *= 2) < 1) {
          return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
      },
      // 正弦曲线的缓动（sin(t)）
      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalIn: function(k) {
        return 1 - Math.cos(k * Math.PI / 2);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalOut: function(k) {
        return Math.sin(k * Math.PI / 2);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      sinusoidalInOut: function(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      },
      // 指数曲线的缓动（2^t）
      /**
      * @param {number} k
      * @return {number}
      */
      exponentialIn: function(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      exponentialOut: function(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      exponentialInOut: function(k) {
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if ((k *= 2) < 1) {
          return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
      },
      // 圆形曲线的缓动（sqrt(1-t^2)）
      /**
      * @param {number} k
      * @return {number}
      */
      circularIn: function(k) {
        return 1 - Math.sqrt(1 - k * k);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      circularOut: function(k) {
        return Math.sqrt(1 - --k * k);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      circularInOut: function(k) {
        if ((k *= 2) < 1) {
          return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
      },
      // 创建类似于弹簧在停止前来回振荡的动画
      /**
      * @param {number} k
      * @return {number}
      */
      elasticIn: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
      },
      /**
      * @param {number} k
      * @return {number}
      */
      elasticOut: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      elasticInOut: function(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
          return 0;
        }
        if (k === 1) {
          return 1;
        }
        if (!a || a < 1) {
          a = 1;
          s = p / 4;
        } else {
          s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        if ((k *= 2) < 1) {
          return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
      },
      // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
      /**
      * @param {number} k
      * @return {number}
      */
      backIn: function(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      backOut: function(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
      },
      /**
      * @param {number} k
      * @return {number}
      */
      backInOut: function(k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
          return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
      },
      // 创建弹跳效果
      /**
      * @param {number} k
      * @return {number}
      */
      bounceIn: function(k) {
        return 1 - easing.bounceOut(1 - k);
      },
      /**
      * @param {number} k
      * @return {number}
      */
      bounceOut: function(k) {
        if (k < 1 / 2.75) {
          return 7.5625 * k * k;
        } else if (k < 2 / 2.75) {
          return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
        } else if (k < 2.5 / 2.75) {
          return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
        } else {
          return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
        }
      },
      /**
      * @param {number} k
      * @return {number}
      */
      bounceInOut: function(k) {
        if (k < 0.5) {
          return easing.bounceIn(k * 2) * 0.5;
        }
        return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
      }
    };
    var _default = easing;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/Clip.js
var require_Clip = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/Clip.js"(exports, module) {
    var easingFuncs = require_easing();
    function Clip(options) {
      this._target = options.target;
      this._life = options.life || 1e3;
      this._delay = options.delay || 0;
      this._initialized = false;
      this.loop = options.loop == null ? false : options.loop;
      this.gap = options.gap || 0;
      this.easing = options.easing || "Linear";
      this.onframe = options.onframe;
      this.ondestroy = options.ondestroy;
      this.onrestart = options.onrestart;
      this._pausedTime = 0;
      this._paused = false;
    }
    Clip.prototype = {
      constructor: Clip,
      step: function(globalTime, deltaTime) {
        if (!this._initialized) {
          this._startTime = globalTime + this._delay;
          this._initialized = true;
        }
        if (this._paused) {
          this._pausedTime += deltaTime;
          return;
        }
        var percent = (globalTime - this._startTime - this._pausedTime) / this._life;
        if (percent < 0) {
          return;
        }
        percent = Math.min(percent, 1);
        var easing = this.easing;
        var easingFunc = typeof easing === "string" ? easingFuncs[easing] : easing;
        var schedule = typeof easingFunc === "function" ? easingFunc(percent) : percent;
        this.fire("frame", schedule);
        if (percent === 1) {
          if (this.loop) {
            this.restart(globalTime);
            return "restart";
          }
          this._needsRemove = true;
          return "destroy";
        }
        return null;
      },
      restart: function(globalTime) {
        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
        this._startTime = globalTime - remainder + this.gap;
        this._pausedTime = 0;
        this._needsRemove = false;
      },
      fire: function(eventType, arg) {
        eventType = "on" + eventType;
        if (this[eventType]) {
          this[eventType](this._target, arg);
        }
      },
      pause: function() {
        this._paused = true;
      },
      resume: function() {
        this._paused = false;
      }
    };
    var _default = Clip;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/LRU.js
var require_LRU = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/LRU.js"(exports, module) {
    var LinkedList = function() {
      this.head = null;
      this.tail = null;
      this._len = 0;
    };
    var linkedListProto = LinkedList.prototype;
    linkedListProto.insert = function(val) {
      var entry = new Entry(val);
      this.insertEntry(entry);
      return entry;
    };
    linkedListProto.insertEntry = function(entry) {
      if (!this.head) {
        this.head = this.tail = entry;
      } else {
        this.tail.next = entry;
        entry.prev = this.tail;
        entry.next = null;
        this.tail = entry;
      }
      this._len++;
    };
    linkedListProto.remove = function(entry) {
      var prev = entry.prev;
      var next = entry.next;
      if (prev) {
        prev.next = next;
      } else {
        this.head = next;
      }
      if (next) {
        next.prev = prev;
      } else {
        this.tail = prev;
      }
      entry.next = entry.prev = null;
      this._len--;
    };
    linkedListProto.len = function() {
      return this._len;
    };
    linkedListProto.clear = function() {
      this.head = this.tail = null;
      this._len = 0;
    };
    var Entry = function(val) {
      this.value = val;
      this.next;
      this.prev;
    };
    var LRU = function(maxSize) {
      this._list = new LinkedList();
      this._map = {};
      this._maxSize = maxSize || 10;
      this._lastRemovedEntry = null;
    };
    var LRUProto = LRU.prototype;
    LRUProto.put = function(key, value) {
      var list = this._list;
      var map = this._map;
      var removed = null;
      if (map[key] == null) {
        var len = list.len();
        var entry = this._lastRemovedEntry;
        if (len >= this._maxSize && len > 0) {
          var leastUsedEntry = list.head;
          list.remove(leastUsedEntry);
          delete map[leastUsedEntry.key];
          removed = leastUsedEntry.value;
          this._lastRemovedEntry = leastUsedEntry;
        }
        if (entry) {
          entry.value = value;
        } else {
          entry = new Entry(value);
        }
        entry.key = key;
        list.insertEntry(entry);
        map[key] = entry;
      }
      return removed;
    };
    LRUProto.get = function(key) {
      var entry = this._map[key];
      var list = this._list;
      if (entry != null) {
        if (entry !== list.tail) {
          list.remove(entry);
          list.insertEntry(entry);
        }
        return entry.value;
      }
    };
    LRUProto.clear = function() {
      this._list.clear();
      this._map = {};
    };
    var _default = LRU;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/color.js
var require_color = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/color.js"(exports) {
    var LRU = require_LRU();
    var kCSSColorTable = {
      "transparent": [0, 0, 0, 0],
      "aliceblue": [240, 248, 255, 1],
      "antiquewhite": [250, 235, 215, 1],
      "aqua": [0, 255, 255, 1],
      "aquamarine": [127, 255, 212, 1],
      "azure": [240, 255, 255, 1],
      "beige": [245, 245, 220, 1],
      "bisque": [255, 228, 196, 1],
      "black": [0, 0, 0, 1],
      "blanchedalmond": [255, 235, 205, 1],
      "blue": [0, 0, 255, 1],
      "blueviolet": [138, 43, 226, 1],
      "brown": [165, 42, 42, 1],
      "burlywood": [222, 184, 135, 1],
      "cadetblue": [95, 158, 160, 1],
      "chartreuse": [127, 255, 0, 1],
      "chocolate": [210, 105, 30, 1],
      "coral": [255, 127, 80, 1],
      "cornflowerblue": [100, 149, 237, 1],
      "cornsilk": [255, 248, 220, 1],
      "crimson": [220, 20, 60, 1],
      "cyan": [0, 255, 255, 1],
      "darkblue": [0, 0, 139, 1],
      "darkcyan": [0, 139, 139, 1],
      "darkgoldenrod": [184, 134, 11, 1],
      "darkgray": [169, 169, 169, 1],
      "darkgreen": [0, 100, 0, 1],
      "darkgrey": [169, 169, 169, 1],
      "darkkhaki": [189, 183, 107, 1],
      "darkmagenta": [139, 0, 139, 1],
      "darkolivegreen": [85, 107, 47, 1],
      "darkorange": [255, 140, 0, 1],
      "darkorchid": [153, 50, 204, 1],
      "darkred": [139, 0, 0, 1],
      "darksalmon": [233, 150, 122, 1],
      "darkseagreen": [143, 188, 143, 1],
      "darkslateblue": [72, 61, 139, 1],
      "darkslategray": [47, 79, 79, 1],
      "darkslategrey": [47, 79, 79, 1],
      "darkturquoise": [0, 206, 209, 1],
      "darkviolet": [148, 0, 211, 1],
      "deeppink": [255, 20, 147, 1],
      "deepskyblue": [0, 191, 255, 1],
      "dimgray": [105, 105, 105, 1],
      "dimgrey": [105, 105, 105, 1],
      "dodgerblue": [30, 144, 255, 1],
      "firebrick": [178, 34, 34, 1],
      "floralwhite": [255, 250, 240, 1],
      "forestgreen": [34, 139, 34, 1],
      "fuchsia": [255, 0, 255, 1],
      "gainsboro": [220, 220, 220, 1],
      "ghostwhite": [248, 248, 255, 1],
      "gold": [255, 215, 0, 1],
      "goldenrod": [218, 165, 32, 1],
      "gray": [128, 128, 128, 1],
      "green": [0, 128, 0, 1],
      "greenyellow": [173, 255, 47, 1],
      "grey": [128, 128, 128, 1],
      "honeydew": [240, 255, 240, 1],
      "hotpink": [255, 105, 180, 1],
      "indianred": [205, 92, 92, 1],
      "indigo": [75, 0, 130, 1],
      "ivory": [255, 255, 240, 1],
      "khaki": [240, 230, 140, 1],
      "lavender": [230, 230, 250, 1],
      "lavenderblush": [255, 240, 245, 1],
      "lawngreen": [124, 252, 0, 1],
      "lemonchiffon": [255, 250, 205, 1],
      "lightblue": [173, 216, 230, 1],
      "lightcoral": [240, 128, 128, 1],
      "lightcyan": [224, 255, 255, 1],
      "lightgoldenrodyellow": [250, 250, 210, 1],
      "lightgray": [211, 211, 211, 1],
      "lightgreen": [144, 238, 144, 1],
      "lightgrey": [211, 211, 211, 1],
      "lightpink": [255, 182, 193, 1],
      "lightsalmon": [255, 160, 122, 1],
      "lightseagreen": [32, 178, 170, 1],
      "lightskyblue": [135, 206, 250, 1],
      "lightslategray": [119, 136, 153, 1],
      "lightslategrey": [119, 136, 153, 1],
      "lightsteelblue": [176, 196, 222, 1],
      "lightyellow": [255, 255, 224, 1],
      "lime": [0, 255, 0, 1],
      "limegreen": [50, 205, 50, 1],
      "linen": [250, 240, 230, 1],
      "magenta": [255, 0, 255, 1],
      "maroon": [128, 0, 0, 1],
      "mediumaquamarine": [102, 205, 170, 1],
      "mediumblue": [0, 0, 205, 1],
      "mediumorchid": [186, 85, 211, 1],
      "mediumpurple": [147, 112, 219, 1],
      "mediumseagreen": [60, 179, 113, 1],
      "mediumslateblue": [123, 104, 238, 1],
      "mediumspringgreen": [0, 250, 154, 1],
      "mediumturquoise": [72, 209, 204, 1],
      "mediumvioletred": [199, 21, 133, 1],
      "midnightblue": [25, 25, 112, 1],
      "mintcream": [245, 255, 250, 1],
      "mistyrose": [255, 228, 225, 1],
      "moccasin": [255, 228, 181, 1],
      "navajowhite": [255, 222, 173, 1],
      "navy": [0, 0, 128, 1],
      "oldlace": [253, 245, 230, 1],
      "olive": [128, 128, 0, 1],
      "olivedrab": [107, 142, 35, 1],
      "orange": [255, 165, 0, 1],
      "orangered": [255, 69, 0, 1],
      "orchid": [218, 112, 214, 1],
      "palegoldenrod": [238, 232, 170, 1],
      "palegreen": [152, 251, 152, 1],
      "paleturquoise": [175, 238, 238, 1],
      "palevioletred": [219, 112, 147, 1],
      "papayawhip": [255, 239, 213, 1],
      "peachpuff": [255, 218, 185, 1],
      "peru": [205, 133, 63, 1],
      "pink": [255, 192, 203, 1],
      "plum": [221, 160, 221, 1],
      "powderblue": [176, 224, 230, 1],
      "purple": [128, 0, 128, 1],
      "red": [255, 0, 0, 1],
      "rosybrown": [188, 143, 143, 1],
      "royalblue": [65, 105, 225, 1],
      "saddlebrown": [139, 69, 19, 1],
      "salmon": [250, 128, 114, 1],
      "sandybrown": [244, 164, 96, 1],
      "seagreen": [46, 139, 87, 1],
      "seashell": [255, 245, 238, 1],
      "sienna": [160, 82, 45, 1],
      "silver": [192, 192, 192, 1],
      "skyblue": [135, 206, 235, 1],
      "slateblue": [106, 90, 205, 1],
      "slategray": [112, 128, 144, 1],
      "slategrey": [112, 128, 144, 1],
      "snow": [255, 250, 250, 1],
      "springgreen": [0, 255, 127, 1],
      "steelblue": [70, 130, 180, 1],
      "tan": [210, 180, 140, 1],
      "teal": [0, 128, 128, 1],
      "thistle": [216, 191, 216, 1],
      "tomato": [255, 99, 71, 1],
      "turquoise": [64, 224, 208, 1],
      "violet": [238, 130, 238, 1],
      "wheat": [245, 222, 179, 1],
      "white": [255, 255, 255, 1],
      "whitesmoke": [245, 245, 245, 1],
      "yellow": [255, 255, 0, 1],
      "yellowgreen": [154, 205, 50, 1]
    };
    function clampCssByte(i) {
      i = Math.round(i);
      return i < 0 ? 0 : i > 255 ? 255 : i;
    }
    function clampCssAngle(i) {
      i = Math.round(i);
      return i < 0 ? 0 : i > 360 ? 360 : i;
    }
    function clampCssFloat(f) {
      return f < 0 ? 0 : f > 1 ? 1 : f;
    }
    function parseCssInt(str) {
      if (str.length && str.charAt(str.length - 1) === "%") {
        return clampCssByte(parseFloat(str) / 100 * 255);
      }
      return clampCssByte(parseInt(str, 10));
    }
    function parseCssFloat(str) {
      if (str.length && str.charAt(str.length - 1) === "%") {
        return clampCssFloat(parseFloat(str) / 100);
      }
      return clampCssFloat(parseFloat(str));
    }
    function cssHueToRgb(m1, m2, h) {
      if (h < 0) {
        h += 1;
      } else if (h > 1) {
        h -= 1;
      }
      if (h * 6 < 1) {
        return m1 + (m2 - m1) * h * 6;
      }
      if (h * 2 < 1) {
        return m2;
      }
      if (h * 3 < 2) {
        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
      }
      return m1;
    }
    function lerpNumber(a, b, p) {
      return a + (b - a) * p;
    }
    function setRgba(out, r, g, b, a) {
      out[0] = r;
      out[1] = g;
      out[2] = b;
      out[3] = a;
      return out;
    }
    function copyRgba(out, a) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      return out;
    }
    var colorCache = new LRU(20);
    var lastRemovedArr = null;
    function putToCache(colorStr, rgbaArr) {
      if (lastRemovedArr) {
        copyRgba(lastRemovedArr, rgbaArr);
      }
      lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
    }
    function parse(colorStr, rgbaArr) {
      if (!colorStr) {
        return;
      }
      rgbaArr = rgbaArr || [];
      var cached = colorCache.get(colorStr);
      if (cached) {
        return copyRgba(rgbaArr, cached);
      }
      colorStr = colorStr + "";
      var str = colorStr.replace(/ /g, "").toLowerCase();
      if (str in kCSSColorTable) {
        copyRgba(rgbaArr, kCSSColorTable[str]);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      }
      if (str.charAt(0) === "#") {
        if (str.length === 4) {
          var iv = parseInt(str.substr(1), 16);
          if (!(iv >= 0 && iv <= 4095)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else if (str.length === 7) {
          var iv = parseInt(str.substr(1), 16);
          if (!(iv >= 0 && iv <= 16777215)) {
            setRgba(rgbaArr, 0, 0, 0, 1);
            return;
          }
          setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1);
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        }
        return;
      }
      var op = str.indexOf("(");
      var ep = str.indexOf(")");
      if (op !== -1 && ep + 1 === str.length) {
        var fname = str.substr(0, op);
        var params = str.substr(op + 1, ep - (op + 1)).split(",");
        var alpha = 1;
        switch (fname) {
          case "rgba":
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            alpha = parseCssFloat(params.pop());
          case "rgb":
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          case "hsla":
            if (params.length !== 4) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            params[3] = parseCssFloat(params[3]);
            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          case "hsl":
            if (params.length !== 3) {
              setRgba(rgbaArr, 0, 0, 0, 1);
              return;
            }
            hsla2rgba(params, rgbaArr);
            putToCache(colorStr, rgbaArr);
            return rgbaArr;
          default:
            return;
        }
      }
      setRgba(rgbaArr, 0, 0, 0, 1);
      return;
    }
    function hsla2rgba(hsla, rgba) {
      var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
      var s = parseCssFloat(hsla[1]);
      var l = parseCssFloat(hsla[2]);
      var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
      var m1 = l * 2 - m2;
      rgba = rgba || [];
      setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
      if (hsla.length === 4) {
        rgba[3] = hsla[3];
      }
      return rgba;
    }
    function rgba2hsla(rgba) {
      if (!rgba) {
        return;
      }
      var R = rgba[0] / 255;
      var G = rgba[1] / 255;
      var B = rgba[2] / 255;
      var vMin = Math.min(R, G, B);
      var vMax = Math.max(R, G, B);
      var delta = vMax - vMin;
      var L = (vMax + vMin) / 2;
      var H;
      var S;
      if (delta === 0) {
        H = 0;
        S = 0;
      } else {
        if (L < 0.5) {
          S = delta / (vMax + vMin);
        } else {
          S = delta / (2 - vMax - vMin);
        }
        var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
        var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
        var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
        if (R === vMax) {
          H = deltaB - deltaG;
        } else if (G === vMax) {
          H = 1 / 3 + deltaR - deltaB;
        } else if (B === vMax) {
          H = 2 / 3 + deltaG - deltaR;
        }
        if (H < 0) {
          H += 1;
        }
        if (H > 1) {
          H -= 1;
        }
      }
      var hsla = [H * 360, S, L];
      if (rgba[3] != null) {
        hsla.push(rgba[3]);
      }
      return hsla;
    }
    function lift(color, level) {
      var colorArr = parse(color);
      if (colorArr) {
        for (var i = 0; i < 3; i++) {
          if (level < 0) {
            colorArr[i] = colorArr[i] * (1 - level) | 0;
          } else {
            colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
          }
          if (colorArr[i] > 255) {
            colorArr[i] = 255;
          } else if (color[i] < 0) {
            colorArr[i] = 0;
          }
        }
        return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
      }
    }
    function toHex(color) {
      var colorArr = parse(color);
      if (colorArr) {
        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
      }
    }
    function fastLerp(normalizedValue, colors, out) {
      if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
      }
      out = out || [];
      var value = normalizedValue * (colors.length - 1);
      var leftIndex = Math.floor(value);
      var rightIndex = Math.ceil(value);
      var leftColor = colors[leftIndex];
      var rightColor = colors[rightIndex];
      var dv = value - leftIndex;
      out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
      out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
      out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
      out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
      return out;
    }
    var fastMapToColor = fastLerp;
    function lerp(normalizedValue, colors, fullOutput) {
      if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
        return;
      }
      var value = normalizedValue * (colors.length - 1);
      var leftIndex = Math.floor(value);
      var rightIndex = Math.ceil(value);
      var leftColor = parse(colors[leftIndex]);
      var rightColor = parse(colors[rightIndex]);
      var dv = value - leftIndex;
      var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], "rgba");
      return fullOutput ? {
        color,
        leftIndex,
        rightIndex,
        value
      } : color;
    }
    var mapToColor = lerp;
    function modifyHSL(color, h, s, l) {
      color = parse(color);
      if (color) {
        color = rgba2hsla(color);
        h != null && (color[0] = clampCssAngle(h));
        s != null && (color[1] = parseCssFloat(s));
        l != null && (color[2] = parseCssFloat(l));
        return stringify(hsla2rgba(color), "rgba");
      }
    }
    function modifyAlpha(color, alpha) {
      color = parse(color);
      if (color && alpha != null) {
        color[3] = clampCssFloat(alpha);
        return stringify(color, "rgba");
      }
    }
    function stringify(arrColor, type) {
      if (!arrColor || !arrColor.length) {
        return;
      }
      var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
      if (type === "rgba" || type === "hsva" || type === "hsla") {
        colorStr += "," + arrColor[3];
      }
      return type + "(" + colorStr + ")";
    }
    exports.parse = parse;
    exports.lift = lift;
    exports.toHex = toHex;
    exports.fastLerp = fastLerp;
    exports.fastMapToColor = fastMapToColor;
    exports.lerp = lerp;
    exports.mapToColor = mapToColor;
    exports.modifyHSL = modifyHSL;
    exports.modifyAlpha = modifyAlpha;
    exports.stringify = stringify;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/Animator.js
var require_Animator = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/Animator.js"(exports, module) {
    var Clip = require_Clip();
    var color = require_color();
    var _util = require_util();
    var isArrayLike = _util.isArrayLike;
    var arraySlice = Array.prototype.slice;
    function defaultGetter(target, key) {
      return target[key];
    }
    function defaultSetter(target, key, value) {
      target[key] = value;
    }
    function interpolateNumber(p0, p1, percent) {
      return (p1 - p0) * percent + p0;
    }
    function interpolateString(p0, p1, percent) {
      return percent > 0.5 ? p1 : p0;
    }
    function interpolateArray(p0, p1, percent, out, arrDim) {
      var len = p0.length;
      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = interpolateNumber(p0[i], p1[i], percent);
        }
      } else {
        var len2 = len && p0[0].length;
        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
          }
        }
      }
    }
    function fillArr(arr0, arr1, arrDim) {
      var arr0Len = arr0.length;
      var arr1Len = arr1.length;
      if (arr0Len !== arr1Len) {
        var isPreviousLarger = arr0Len > arr1Len;
        if (isPreviousLarger) {
          arr0.length = arr1Len;
        } else {
          for (var i = arr0Len; i < arr1Len; i++) {
            arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
          }
        }
      }
      var len2 = arr0[0] && arr0[0].length;
      for (var i = 0; i < arr0.length; i++) {
        if (arrDim === 1) {
          if (isNaN(arr0[i])) {
            arr0[i] = arr1[i];
          }
        } else {
          for (var j = 0; j < len2; j++) {
            if (isNaN(arr0[i][j])) {
              arr0[i][j] = arr1[i][j];
            }
          }
        }
      }
    }
    function isArraySame(arr0, arr1, arrDim) {
      if (arr0 === arr1) {
        return true;
      }
      var len = arr0.length;
      if (len !== arr1.length) {
        return false;
      }
      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          if (arr0[i] !== arr1[i]) {
            return false;
          }
        }
      } else {
        var len2 = arr0[0].length;
        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            if (arr0[i][j] !== arr1[i][j]) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
      var len = p0.length;
      if (arrDim === 1) {
        for (var i = 0; i < len; i++) {
          out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
        }
      } else {
        var len2 = p0[0].length;
        for (var i = 0; i < len; i++) {
          for (var j = 0; j < len2; j++) {
            out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
          }
        }
      }
    }
    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function cloneValue(value) {
      if (isArrayLike(value)) {
        var len = value.length;
        if (isArrayLike(value[0])) {
          var ret = [];
          for (var i = 0; i < len; i++) {
            ret.push(arraySlice.call(value[i]));
          }
          return ret;
        }
        return arraySlice.call(value);
      }
      return value;
    }
    function rgba2String(rgba) {
      rgba[0] = Math.floor(rgba[0]);
      rgba[1] = Math.floor(rgba[1]);
      rgba[2] = Math.floor(rgba[2]);
      return "rgba(" + rgba.join(",") + ")";
    }
    function getArrayDim(keyframes) {
      var lastValue = keyframes[keyframes.length - 1].value;
      return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;
    }
    function createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {
      var getter = animator._getter;
      var setter = animator._setter;
      var useSpline = easing === "spline";
      var trackLen = keyframes.length;
      if (!trackLen) {
        return;
      }
      var firstVal = keyframes[0].value;
      var isValueArray = isArrayLike(firstVal);
      var isValueColor = false;
      var isValueString = false;
      var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
      var trackMaxTime;
      keyframes.sort(function(a, b) {
        return a.time - b.time;
      });
      trackMaxTime = keyframes[trackLen - 1].time;
      var kfPercents = [];
      var kfValues = [];
      var prevValue = keyframes[0].value;
      var isAllValueEqual = true;
      for (var i = 0; i < trackLen; i++) {
        kfPercents.push(keyframes[i].time / trackMaxTime);
        var value = keyframes[i].value;
        if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
          isAllValueEqual = false;
        }
        prevValue = value;
        if (typeof value === "string") {
          var colorArray = color.parse(value);
          if (colorArray) {
            value = colorArray;
            isValueColor = true;
          } else {
            isValueString = true;
          }
        }
        kfValues.push(value);
      }
      if (!forceAnimate && isAllValueEqual) {
        return;
      }
      var lastValue = kfValues[trackLen - 1];
      for (var i = 0; i < trackLen - 1; i++) {
        if (isValueArray) {
          fillArr(kfValues[i], lastValue, arrDim);
        } else {
          if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
            kfValues[i] = lastValue;
          }
        }
      }
      isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
      var lastFrame = 0;
      var lastFramePercent = 0;
      var start;
      var w;
      var p0;
      var p1;
      var p2;
      var p3;
      if (isValueColor) {
        var rgba = [0, 0, 0, 0];
      }
      var onframe = function(target, percent) {
        var frame;
        if (percent < 0) {
          frame = 0;
        } else if (percent < lastFramePercent) {
          start = Math.min(lastFrame + 1, trackLen - 1);
          for (frame = start; frame >= 0; frame--) {
            if (kfPercents[frame] <= percent) {
              break;
            }
          }
          frame = Math.min(frame, trackLen - 2);
        } else {
          for (frame = lastFrame; frame < trackLen; frame++) {
            if (kfPercents[frame] > percent) {
              break;
            }
          }
          frame = Math.min(frame - 1, trackLen - 2);
        }
        lastFrame = frame;
        lastFramePercent = percent;
        var range = kfPercents[frame + 1] - kfPercents[frame];
        if (range === 0) {
          return;
        } else {
          w = (percent - kfPercents[frame]) / range;
        }
        if (useSpline) {
          p1 = kfValues[frame];
          p0 = kfValues[frame === 0 ? frame : frame - 1];
          p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
          p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
          if (isValueArray) {
            catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
          } else {
            var value2;
            if (isValueColor) {
              value2 = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
              value2 = rgba2String(rgba);
            } else if (isValueString) {
              return interpolateString(p1, p2, w);
            } else {
              value2 = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
            }
            setter(target, propName, value2);
          }
        } else {
          if (isValueArray) {
            interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
          } else {
            var value2;
            if (isValueColor) {
              interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
              value2 = rgba2String(rgba);
            } else if (isValueString) {
              return interpolateString(kfValues[frame], kfValues[frame + 1], w);
            } else {
              value2 = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
            }
            setter(target, propName, value2);
          }
        }
      };
      var clip = new Clip({
        target: animator._target,
        life: trackMaxTime,
        loop: animator._loop,
        delay: animator._delay,
        onframe,
        ondestroy: oneTrackDone
      });
      if (easing && easing !== "spline") {
        clip.easing = easing;
      }
      return clip;
    }
    var Animator = function(target, loop, getter, setter) {
      this._tracks = {};
      this._target = target;
      this._loop = loop || false;
      this._getter = getter || defaultGetter;
      this._setter = setter || defaultSetter;
      this._clipCount = 0;
      this._delay = 0;
      this._doneList = [];
      this._onframeList = [];
      this._clipList = [];
    };
    Animator.prototype = {
      /**
       * Set Animation keyframe
       * @param  {number} time 关键帧时间，单位是ms
       * @param  {Object} props 关键帧的属性值，key-value表示
       * @return {module:zrender/animation/Animator}
       */
      when: function(time, props) {
        var tracks = this._tracks;
        for (var propName in props) {
          if (!props.hasOwnProperty(propName)) {
            continue;
          }
          if (!tracks[propName]) {
            tracks[propName] = [];
            var value = this._getter(this._target, propName);
            if (value == null) {
              continue;
            }
            if (time !== 0) {
              tracks[propName].push({
                time: 0,
                value: cloneValue(value)
              });
            }
          }
          tracks[propName].push({
            time,
            value: props[propName]
          });
        }
        return this;
      },
      /**
       * 添加动画每一帧的回调函数
       * @param  {Function} callback
       * @return {module:zrender/animation/Animator}
       */
      during: function(callback) {
        this._onframeList.push(callback);
        return this;
      },
      pause: function() {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].pause();
        }
        this._paused = true;
      },
      resume: function() {
        for (var i = 0; i < this._clipList.length; i++) {
          this._clipList[i].resume();
        }
        this._paused = false;
      },
      isPaused: function() {
        return !!this._paused;
      },
      _doneCallback: function() {
        this._tracks = {};
        this._clipList.length = 0;
        var doneList = this._doneList;
        var len = doneList.length;
        for (var i = 0; i < len; i++) {
          doneList[i].call(this);
        }
      },
      /**
       * Start the animation
       * @param  {string|Function} [easing]
       *         动画缓动函数，详见{@link module:zrender/animation/easing}
       * @param  {boolean} forceAnimate
       * @return {module:zrender/animation/Animator}
       */
      start: function(easing, forceAnimate) {
        var self2 = this;
        var clipCount = 0;
        var oneTrackDone = function() {
          clipCount--;
          if (!clipCount) {
            self2._doneCallback();
          }
        };
        var lastClip;
        for (var propName in this._tracks) {
          if (!this._tracks.hasOwnProperty(propName)) {
            continue;
          }
          var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);
          if (clip) {
            this._clipList.push(clip);
            clipCount++;
            if (this.animation) {
              this.animation.addClip(clip);
            }
            lastClip = clip;
          }
        }
        if (lastClip) {
          var oldOnFrame = lastClip.onframe;
          lastClip.onframe = function(target, percent) {
            oldOnFrame(target, percent);
            for (var i = 0; i < self2._onframeList.length; i++) {
              self2._onframeList[i](target, percent);
            }
          };
        }
        if (!clipCount) {
          this._doneCallback();
        }
        return this;
      },
      /**
       * Stop animation
       * @param {boolean} forwardToLast If move to last frame before stop
       */
      stop: function(forwardToLast) {
        var clipList = this._clipList;
        var animation = this.animation;
        for (var i = 0; i < clipList.length; i++) {
          var clip = clipList[i];
          if (forwardToLast) {
            clip.onframe(this._target, 1);
          }
          animation && animation.removeClip(clip);
        }
        clipList.length = 0;
      },
      /**
       * Set when animation delay starts
       * @param  {number} time 单位ms
       * @return {module:zrender/animation/Animator}
       */
      delay: function(time) {
        this._delay = time;
        return this;
      },
      /**
       * Add callback for animation end
       * @param  {Function} cb
       * @return {module:zrender/animation/Animator}
       */
      done: function(cb) {
        if (cb) {
          this._doneList.push(cb);
        }
        return this;
      },
      /**
       * @return {Array.<module:zrender/animation/Clip>}
       */
      getClips: function() {
        return this._clipList;
      }
    };
    var _default = Animator;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/config.js
var require_config2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/config.js"(exports) {
    var dpr = 1;
    if (typeof window !== "undefined") {
      dpr = Math.max(window.devicePixelRatio || 1, 1);
    }
    var debugMode = 0;
    var devicePixelRatio = dpr;
    exports.debugMode = debugMode;
    exports.devicePixelRatio = devicePixelRatio;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/log.js
var require_log = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/log.js"(exports, module) {
    var _config = require_config2();
    var debugMode = _config.debugMode;
    var logError = function() {
    };
    if (debugMode === 1) {
      logError = console.error;
    }
    var _default = logError;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Animatable.js
var require_Animatable = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/mixin/Animatable.js"(exports, module) {
    var Animator = require_Animator();
    var logError = require_log();
    var _util = require_util();
    var isString = _util.isString;
    var isFunction = _util.isFunction;
    var isObject = _util.isObject;
    var isArrayLike = _util.isArrayLike;
    var indexOf = _util.indexOf;
    var Animatable = function() {
      this.animators = [];
    };
    Animatable.prototype = {
      constructor: Animatable,
      /**
       * 动画
       *
       * @param {string} path The path to fetch value from object, like 'a.b.c'.
       * @param {boolean} [loop] Whether to loop animation.
       * @return {module:zrender/animation/Animator}
       * @example:
       *     el.animate('style', false)
       *         .when(1000, {x: 10} )
       *         .done(function(){ // Animation done })
       *         .start()
       */
      animate: function(path, loop) {
        var target;
        var animatingShape = false;
        var el = this;
        var zr = this.__zr;
        if (path) {
          var pathSplitted = path.split(".");
          var prop = el;
          animatingShape = pathSplitted[0] === "shape";
          for (var i = 0, l = pathSplitted.length; i < l; i++) {
            if (!prop) {
              continue;
            }
            prop = prop[pathSplitted[i]];
          }
          if (prop) {
            target = prop;
          }
        } else {
          target = el;
        }
        if (!target) {
          logError('Property "' + path + '" is not existed in element ' + el.id);
          return;
        }
        var animators = el.animators;
        var animator = new Animator(target, loop);
        animator.during(function(target2) {
          el.dirty(animatingShape);
        }).done(function() {
          animators.splice(indexOf(animators, animator), 1);
        });
        animators.push(animator);
        if (zr) {
          zr.animation.addAnimator(animator);
        }
        return animator;
      },
      /**
       * 停止动画
       * @param {boolean} forwardToLast If move to last frame before stop
       */
      stopAnimation: function(forwardToLast) {
        var animators = this.animators;
        var len = animators.length;
        for (var i = 0; i < len; i++) {
          animators[i].stop(forwardToLast);
        }
        animators.length = 0;
        return this;
      },
      /**
       * Caution: this method will stop previous animation.
       * So do not use this method to one element twice before
       * animation starts, unless you know what you are doing.
       * @param {Object} target
       * @param {number} [time=500] Time in ms
       * @param {string} [easing='linear']
       * @param {number} [delay=0]
       * @param {Function} [callback]
       * @param {Function} [forceAnimate] Prevent stop animation and callback
       *        immediently when target values are the same as current values.
       *
       * @example
       *  // Animate position
       *  el.animateTo({
       *      position: [10, 10]
       *  }, function () { // done })
       *
       *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
       *  el.animateTo({
       *      shape: {
       *          width: 500
       *      },
       *      style: {
       *          fill: 'red'
       *      }
       *      position: [10, 10]
       *  }, 100, 100, 'cubicOut', function () { // done })
       */
      // TODO Return animation key
      animateTo: function(target, time, delay, easing, callback, forceAnimate) {
        animateTo(this, target, time, delay, easing, callback, forceAnimate);
      },
      /**
       * Animate from the target state to current state.
       * The params and the return value are the same as `this.animateTo`.
       */
      animateFrom: function(target, time, delay, easing, callback, forceAnimate) {
        animateTo(this, target, time, delay, easing, callback, forceAnimate, true);
      }
    };
    function animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {
      if (isString(delay)) {
        callback = easing;
        easing = delay;
        delay = 0;
      } else if (isFunction(easing)) {
        callback = easing;
        easing = "linear";
        delay = 0;
      } else if (isFunction(delay)) {
        callback = delay;
        delay = 0;
      } else if (isFunction(time)) {
        callback = time;
        time = 500;
      } else if (!time) {
        time = 500;
      }
      animatable.stopAnimation();
      animateToShallow(animatable, "", animatable, target, time, delay, reverse);
      var animators = animatable.animators.slice();
      var count = animators.length;
      function done() {
        count--;
        if (!count) {
          callback && callback();
        }
      }
      if (!count) {
        callback && callback();
      }
      for (var i = 0; i < animators.length; i++) {
        animators[i].done(done).start(easing, forceAnimate);
      }
    }
    function animateToShallow(animatable, path, source, target, time, delay, reverse) {
      var objShallow = {};
      var propertyCount = 0;
      for (var name2 in target) {
        if (!target.hasOwnProperty(name2)) {
          continue;
        }
        if (source[name2] != null) {
          if (isObject(target[name2]) && !isArrayLike(target[name2])) {
            animateToShallow(animatable, path ? path + "." + name2 : name2, source[name2], target[name2], time, delay, reverse);
          } else {
            if (reverse) {
              objShallow[name2] = source[name2];
              setAttrByPath(animatable, path, name2, target[name2]);
            } else {
              objShallow[name2] = target[name2];
            }
            propertyCount++;
          }
        } else if (target[name2] != null && !reverse) {
          setAttrByPath(animatable, path, name2, target[name2]);
        }
      }
      if (propertyCount > 0) {
        animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
      }
    }
    function setAttrByPath(el, path, name2, value) {
      if (!path) {
        el.attr(name2, value);
      } else {
        var props = {};
        props[path] = {};
        props[path][name2] = value;
        el.attr(props);
      }
    }
    var _default = Animatable;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Element.js
var require_Element = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Element.js"(exports, module) {
    var guid = require_guid();
    var Eventful = require_Eventful();
    var Transformable = require_Transformable();
    var Animatable = require_Animatable();
    var zrUtil = require_util();
    var Element = function(opts) {
      Transformable.call(this, opts);
      Eventful.call(this, opts);
      Animatable.call(this, opts);
      this.id = opts.id || guid();
    };
    Element.prototype = {
      /**
       * 元素类型
       * Element type
       * @type {string}
       */
      type: "element",
      /**
       * 元素名字
       * Element name
       * @type {string}
       */
      name: "",
      /**
       * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
       * ZRender instance will be assigned when element is associated with zrender
       * @name module:/zrender/Element#__zr
       * @type {module:zrender/ZRender}
       */
      __zr: null,
      /**
       * 图形是否忽略，为true时忽略图形的绘制以及事件触发
       * If ignore drawing and events of the element object
       * @name module:/zrender/Element#ignore
       * @type {boolean}
       * @default false
       */
      ignore: false,
      /**
       * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
       * 该路径会继承被裁减对象的变换
       * @type {module:zrender/graphic/Path}
       * @see http://www.w3.org/TR/2dcontext/#clipping-region
       * @readOnly
       */
      clipPath: null,
      /**
       * 是否是 Group
       * @type {boolean}
       */
      isGroup: false,
      /**
       * Drift element
       * @param  {number} dx dx on the global space
       * @param  {number} dy dy on the global space
       */
      drift: function(dx, dy) {
        switch (this.draggable) {
          case "horizontal":
            dy = 0;
            break;
          case "vertical":
            dx = 0;
            break;
        }
        var m = this.transform;
        if (!m) {
          m = this.transform = [1, 0, 0, 1, 0, 0];
        }
        m[4] += dx;
        m[5] += dy;
        this.decomposeTransform();
        this.dirty(false);
      },
      /**
       * Hook before update
       */
      beforeUpdate: function() {
      },
      /**
       * Hook after update
       */
      afterUpdate: function() {
      },
      /**
       * Update each frame
       */
      update: function() {
        this.updateTransform();
      },
      /**
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function(cb, context) {
      },
      /**
       * @protected
       */
      attrKV: function(key, value) {
        if (key === "position" || key === "scale" || key === "origin") {
          if (value) {
            var target = this[key];
            if (!target) {
              target = this[key] = [];
            }
            target[0] = value[0];
            target[1] = value[1];
          }
        } else {
          this[key] = value;
        }
      },
      /**
       * Hide the element
       */
      hide: function() {
        this.ignore = true;
        this.__zr && this.__zr.refresh();
      },
      /**
       * Show the element
       */
      show: function() {
        this.ignore = false;
        this.__zr && this.__zr.refresh();
      },
      /**
       * @param {string|Object} key
       * @param {*} value
       */
      attr: function(key, value) {
        if (typeof key === "string") {
          this.attrKV(key, value);
        } else if (zrUtil.isObject(key)) {
          for (var name2 in key) {
            if (key.hasOwnProperty(name2)) {
              this.attrKV(name2, key[name2]);
            }
          }
        }
        this.dirty(false);
        return this;
      },
      /**
       * @param {module:zrender/graphic/Path} clipPath
       */
      setClipPath: function(clipPath) {
        var zr = this.__zr;
        if (zr) {
          clipPath.addSelfToZr(zr);
        }
        if (this.clipPath && this.clipPath !== clipPath) {
          this.removeClipPath();
        }
        this.clipPath = clipPath;
        clipPath.__zr = zr;
        clipPath.__clipTarget = this;
        this.dirty(false);
      },
      /**
       */
      removeClipPath: function() {
        var clipPath = this.clipPath;
        if (clipPath) {
          if (clipPath.__zr) {
            clipPath.removeSelfFromZr(clipPath.__zr);
          }
          clipPath.__zr = null;
          clipPath.__clipTarget = null;
          this.clipPath = null;
          this.dirty(false);
        }
      },
      /**
       * Add self from zrender instance.
       * Not recursively because it will be invoked when element added to storage.
       * @param {module:zrender/ZRender} zr
       */
      addSelfToZr: function(zr) {
        this.__zr = zr;
        var animators = this.animators;
        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.addAnimator(animators[i]);
          }
        }
        if (this.clipPath) {
          this.clipPath.addSelfToZr(zr);
        }
      },
      /**
       * Remove self from zrender instance.
       * Not recursively because it will be invoked when element added to storage.
       * @param {module:zrender/ZRender} zr
       */
      removeSelfFromZr: function(zr) {
        this.__zr = null;
        var animators = this.animators;
        if (animators) {
          for (var i = 0; i < animators.length; i++) {
            zr.animation.removeAnimator(animators[i]);
          }
        }
        if (this.clipPath) {
          this.clipPath.removeSelfFromZr(zr);
        }
      }
    };
    zrUtil.mixin(Element, Animatable);
    zrUtil.mixin(Element, Transformable);
    zrUtil.mixin(Element, Eventful);
    var _default = Element;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/BoundingRect.js
var require_BoundingRect = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/BoundingRect.js"(exports, module) {
    var vec2 = require_vector();
    var matrix = require_matrix();
    var v2ApplyTransform = vec2.applyTransform;
    var mathMin = Math.min;
    var mathMax = Math.max;
    function BoundingRect(x, y, width, height) {
      if (width < 0) {
        x = x + width;
        width = -width;
      }
      if (height < 0) {
        y = y + height;
        height = -height;
      }
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
    }
    BoundingRect.prototype = {
      constructor: BoundingRect,
      /**
       * @param {module:echarts/core/BoundingRect} other
       */
      union: function(other) {
        var x = mathMin(other.x, this.x);
        var y = mathMin(other.y, this.y);
        this.width = mathMax(other.x + other.width, this.x + this.width) - x;
        this.height = mathMax(other.y + other.height, this.y + this.height) - y;
        this.x = x;
        this.y = y;
      },
      /**
       * @param {Array.<number>} m
       * @methods
       */
      applyTransform: /* @__PURE__ */ function() {
        var lt = [];
        var rb = [];
        var lb = [];
        var rt = [];
        return function(m) {
          if (!m) {
            return;
          }
          lt[0] = lb[0] = this.x;
          lt[1] = rt[1] = this.y;
          rb[0] = rt[0] = this.x + this.width;
          rb[1] = lb[1] = this.y + this.height;
          v2ApplyTransform(lt, lt, m);
          v2ApplyTransform(rb, rb, m);
          v2ApplyTransform(lb, lb, m);
          v2ApplyTransform(rt, rt, m);
          this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
          this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
          var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
          var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
          this.width = maxX - this.x;
          this.height = maxY - this.y;
        };
      }(),
      /**
       * Calculate matrix of transforming from self to target rect
       * @param  {module:zrender/core/BoundingRect} b
       * @return {Array.<number>}
       */
      calculateTransform: function(b) {
        var a = this;
        var sx = b.width / a.width;
        var sy = b.height / a.height;
        var m = matrix.create();
        matrix.translate(m, m, [-a.x, -a.y]);
        matrix.scale(m, m, [sx, sy]);
        matrix.translate(m, m, [b.x, b.y]);
        return m;
      },
      /**
       * @param {(module:echarts/core/BoundingRect|Object)} b
       * @return {boolean}
       */
      intersect: function(b) {
        if (!b) {
          return false;
        }
        if (!(b instanceof BoundingRect)) {
          b = BoundingRect.create(b);
        }
        var a = this;
        var ax0 = a.x;
        var ax1 = a.x + a.width;
        var ay0 = a.y;
        var ay1 = a.y + a.height;
        var bx0 = b.x;
        var bx1 = b.x + b.width;
        var by0 = b.y;
        var by1 = b.y + b.height;
        return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
      },
      contain: function(x, y) {
        var rect = this;
        return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
      },
      /**
       * @return {module:echarts/core/BoundingRect}
       */
      clone: function() {
        return new BoundingRect(this.x, this.y, this.width, this.height);
      },
      /**
       * Copy from another rect
       */
      copy: function(other) {
        this.x = other.x;
        this.y = other.y;
        this.width = other.width;
        this.height = other.height;
      },
      plain: function() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height
        };
      }
    };
    BoundingRect.create = function(rect) {
      return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
    };
    var _default = BoundingRect;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/container/Group.js
var require_Group = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/container/Group.js"(exports, module) {
    var zrUtil = require_util();
    var Element = require_Element();
    var BoundingRect = require_BoundingRect();
    var Group = function(opts) {
      opts = opts || {};
      Element.call(this, opts);
      for (var key in opts) {
        if (opts.hasOwnProperty(key)) {
          this[key] = opts[key];
        }
      }
      this._children = [];
      this.__storage = null;
      this.__dirty = true;
    };
    Group.prototype = {
      constructor: Group,
      isGroup: true,
      /**
       * @type {string}
       */
      type: "group",
      /**
       * 所有子孙元素是否响应鼠标事件
       * @name module:/zrender/container/Group#silent
       * @type {boolean}
       * @default false
       */
      silent: false,
      /**
       * @return {Array.<module:zrender/Element>}
       */
      children: function() {
        return this._children.slice();
      },
      /**
       * 获取指定 index 的儿子节点
       * @param  {number} idx
       * @return {module:zrender/Element}
       */
      childAt: function(idx) {
        return this._children[idx];
      },
      /**
       * 获取指定名字的儿子节点
       * @param  {string} name
       * @return {module:zrender/Element}
       */
      childOfName: function(name2) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
          if (children[i].name === name2) {
            return children[i];
          }
        }
      },
      /**
       * @return {number}
       */
      childCount: function() {
        return this._children.length;
      },
      /**
       * 添加子节点到最后
       * @param {module:zrender/Element} child
       */
      add: function(child) {
        if (child && child !== this && child.parent !== this) {
          this._children.push(child);
          this._doAdd(child);
        }
        return this;
      },
      /**
       * 添加子节点在 nextSibling 之前
       * @param {module:zrender/Element} child
       * @param {module:zrender/Element} nextSibling
       */
      addBefore: function(child, nextSibling) {
        if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
          var children = this._children;
          var idx = children.indexOf(nextSibling);
          if (idx >= 0) {
            children.splice(idx, 0, child);
            this._doAdd(child);
          }
        }
        return this;
      },
      _doAdd: function(child) {
        if (child.parent) {
          child.parent.remove(child);
        }
        child.parent = this;
        var storage = this.__storage;
        var zr = this.__zr;
        if (storage && storage !== child.__storage) {
          storage.addToStorage(child);
          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }
        zr && zr.refresh();
      },
      /**
       * 移除子节点
       * @param {module:zrender/Element} child
       */
      remove: function(child) {
        var zr = this.__zr;
        var storage = this.__storage;
        var children = this._children;
        var idx = zrUtil.indexOf(children, child);
        if (idx < 0) {
          return this;
        }
        children.splice(idx, 1);
        child.parent = null;
        if (storage) {
          storage.delFromStorage(child);
          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }
        zr && zr.refresh();
        return this;
      },
      /**
       * 移除所有子节点
       */
      removeAll: function() {
        var children = this._children;
        var storage = this.__storage;
        var child;
        var i;
        for (i = 0; i < children.length; i++) {
          child = children[i];
          if (storage) {
            storage.delFromStorage(child);
            if (child instanceof Group) {
              child.delChildrenFromStorage(storage);
            }
          }
          child.parent = null;
        }
        children.length = 0;
        return this;
      },
      /**
       * 遍历所有子节点
       * @param  {Function} cb
       * @param  {}   context
       */
      eachChild: function(cb, context) {
        var children = this._children;
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          cb.call(context, child, i);
        }
        return this;
      },
      /**
       * 深度优先遍历所有子孙节点
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function(cb, context) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          cb.call(context, child);
          if (child.type === "group") {
            child.traverse(cb, context);
          }
        }
        return this;
      },
      addChildrenToStorage: function(storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.addToStorage(child);
          if (child instanceof Group) {
            child.addChildrenToStorage(storage);
          }
        }
      },
      delChildrenFromStorage: function(storage) {
        for (var i = 0; i < this._children.length; i++) {
          var child = this._children[i];
          storage.delFromStorage(child);
          if (child instanceof Group) {
            child.delChildrenFromStorage(storage);
          }
        }
      },
      dirty: function() {
        this.__dirty = true;
        this.__zr && this.__zr.refresh();
        return this;
      },
      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function(includeChildren) {
        var rect = null;
        var tmpRect = new BoundingRect(0, 0, 0, 0);
        var children = includeChildren || this._children;
        var tmpMat = [];
        for (var i = 0; i < children.length; i++) {
          var child = children[i];
          if (child.ignore || child.invisible) {
            continue;
          }
          var childRect = child.getBoundingRect();
          var transform = child.getLocalTransform(tmpMat);
          if (transform) {
            tmpRect.copy(childRect);
            tmpRect.applyTransform(transform);
            rect = rect || tmpRect.clone();
            rect.union(tmpRect);
          } else {
            rect = rect || childRect.clone();
            rect.union(childRect);
          }
        }
        return rect || tmpRect;
      }
    };
    zrUtil.inherits(Group, Element);
    var _default = Group;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/timsort.js
var require_timsort = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/timsort.js"(exports, module) {
    var DEFAULT_MIN_MERGE = 32;
    var DEFAULT_MIN_GALLOPING = 7;
    var DEFAULT_TMP_STORAGE_LENGTH = 256;
    function minRunLength(n) {
      var r = 0;
      while (n >= DEFAULT_MIN_MERGE) {
        r |= n & 1;
        n >>= 1;
      }
      return n + r;
    }
    function makeAscendingRun(array, lo, hi, compare) {
      var runHi = lo + 1;
      if (runHi === hi) {
        return 1;
      }
      if (compare(array[runHi++], array[lo]) < 0) {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
          runHi++;
        }
        reverseRun(array, lo, runHi);
      } else {
        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
          runHi++;
        }
      }
      return runHi - lo;
    }
    function reverseRun(array, lo, hi) {
      hi--;
      while (lo < hi) {
        var t = array[lo];
        array[lo++] = array[hi];
        array[hi--] = t;
      }
    }
    function binaryInsertionSort(array, lo, hi, start, compare) {
      if (start === lo) {
        start++;
      }
      for (; start < hi; start++) {
        var pivot = array[start];
        var left = lo;
        var right = start;
        var mid;
        while (left < right) {
          mid = left + right >>> 1;
          if (compare(pivot, array[mid]) < 0) {
            right = mid;
          } else {
            left = mid + 1;
          }
        }
        var n = start - left;
        switch (n) {
          case 3:
            array[left + 3] = array[left + 2];
          case 2:
            array[left + 2] = array[left + 1];
          case 1:
            array[left + 1] = array[left];
            break;
          default:
            while (n > 0) {
              array[left + n] = array[left + n - 1];
              n--;
            }
        }
        array[left] = pivot;
      }
    }
    function gallopLeft(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) > 0) {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      } else {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) > 0) {
          lastOffset = m + 1;
        } else {
          offset = m;
        }
      }
      return offset;
    }
    function gallopRight(value, array, start, length, hint, compare) {
      var lastOffset = 0;
      var maxOffset = 0;
      var offset = 1;
      if (compare(value, array[start + hint]) < 0) {
        maxOffset = hint + 1;
        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        var tmp = lastOffset;
        lastOffset = hint - offset;
        offset = hint - tmp;
      } else {
        maxOffset = length - hint;
        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
          lastOffset = offset;
          offset = (offset << 1) + 1;
          if (offset <= 0) {
            offset = maxOffset;
          }
        }
        if (offset > maxOffset) {
          offset = maxOffset;
        }
        lastOffset += hint;
        offset += hint;
      }
      lastOffset++;
      while (lastOffset < offset) {
        var m = lastOffset + (offset - lastOffset >>> 1);
        if (compare(value, array[start + m]) < 0) {
          offset = m;
        } else {
          lastOffset = m + 1;
        }
      }
      return offset;
    }
    function TimSort(array, compare) {
      var minGallop = DEFAULT_MIN_GALLOPING;
      var length = 0;
      var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
      var stackLength = 0;
      var runStart;
      var runLength;
      var stackSize = 0;
      length = array.length;
      if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
        tmpStorageLength = length >>> 1;
      }
      var tmp = [];
      stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
      runStart = [];
      runLength = [];
      function pushRun(_runStart, _runLength) {
        runStart[stackSize] = _runStart;
        runLength[stackSize] = _runLength;
        stackSize += 1;
      }
      function mergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;
          if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
            if (runLength[n - 1] < runLength[n + 1]) {
              n--;
            }
          } else if (runLength[n] > runLength[n + 1]) {
            break;
          }
          mergeAt(n);
        }
      }
      function forceMergeRuns() {
        while (stackSize > 1) {
          var n = stackSize - 2;
          if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
            n--;
          }
          mergeAt(n);
        }
      }
      function mergeAt(i) {
        var start1 = runStart[i];
        var length1 = runLength[i];
        var start2 = runStart[i + 1];
        var length2 = runLength[i + 1];
        runLength[i] = length1 + length2;
        if (i === stackSize - 3) {
          runStart[i + 1] = runStart[i + 2];
          runLength[i + 1] = runLength[i + 2];
        }
        stackSize--;
        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
        start1 += k;
        length1 -= k;
        if (length1 === 0) {
          return;
        }
        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
        if (length2 === 0) {
          return;
        }
        if (length1 <= length2) {
          mergeLow(start1, length1, start2, length2);
        } else {
          mergeHigh(start1, length1, start2, length2);
        }
      }
      function mergeLow(start1, length1, start2, length2) {
        var i = 0;
        for (i = 0; i < length1; i++) {
          tmp[i] = array[start1 + i];
        }
        var cursor1 = 0;
        var cursor2 = start2;
        var dest = start1;
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          return;
        }
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
          return;
        }
        var _minGallop = minGallop;
        var count1;
        var count2;
        var exit;
        while (1) {
          count1 = 0;
          count2 = 0;
          exit = false;
          do {
            if (compare(array[cursor2], tmp[cursor1]) < 0) {
              array[dest++] = array[cursor2++];
              count2++;
              count1 = 0;
              if (--length2 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest++] = tmp[cursor1++];
              count1++;
              count2 = 0;
              if (--length1 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
            if (count1 !== 0) {
              for (i = 0; i < count1; i++) {
                array[dest + i] = tmp[cursor1 + i];
              }
              dest += count1;
              cursor1 += count1;
              length1 -= count1;
              if (length1 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest++] = array[cursor2++];
            if (--length2 === 0) {
              exit = true;
              break;
            }
            count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
            if (count2 !== 0) {
              for (i = 0; i < count2; i++) {
                array[dest + i] = array[cursor2 + i];
              }
              dest += count2;
              cursor2 += count2;
              length2 -= count2;
              if (length2 === 0) {
                exit = true;
                break;
              }
            }
            array[dest++] = tmp[cursor1++];
            if (--length1 === 1) {
              exit = true;
              break;
            }
            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (_minGallop < 0) {
            _minGallop = 0;
          }
          _minGallop += 2;
        }
        minGallop = _minGallop;
        minGallop < 1 && (minGallop = 1);
        if (length1 === 1) {
          for (i = 0; i < length2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          array[dest + length2] = tmp[cursor1];
        } else if (length1 === 0) {
          throw new Error();
        } else {
          for (i = 0; i < length1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
        }
      }
      function mergeHigh(start1, length1, start2, length2) {
        var i = 0;
        for (i = 0; i < length2; i++) {
          tmp[i] = array[start2 + i];
        }
        var cursor1 = start1 + length1 - 1;
        var cursor2 = length2 - 1;
        var dest = start2 + length2 - 1;
        var customCursor = 0;
        var customDest = 0;
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
          return;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          array[dest] = tmp[cursor2];
          return;
        }
        var _minGallop = minGallop;
        while (true) {
          var count1 = 0;
          var count2 = 0;
          var exit = false;
          do {
            if (compare(tmp[cursor2], array[cursor1]) < 0) {
              array[dest--] = array[cursor1--];
              count1++;
              count2 = 0;
              if (--length1 === 0) {
                exit = true;
                break;
              }
            } else {
              array[dest--] = tmp[cursor2--];
              count2++;
              count1 = 0;
              if (--length2 === 1) {
                exit = true;
                break;
              }
            }
          } while ((count1 | count2) < _minGallop);
          if (exit) {
            break;
          }
          do {
            count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
            if (count1 !== 0) {
              dest -= count1;
              cursor1 -= count1;
              length1 -= count1;
              customDest = dest + 1;
              customCursor = cursor1 + 1;
              for (i = count1 - 1; i >= 0; i--) {
                array[customDest + i] = array[customCursor + i];
              }
              if (length1 === 0) {
                exit = true;
                break;
              }
            }
            array[dest--] = tmp[cursor2--];
            if (--length2 === 1) {
              exit = true;
              break;
            }
            count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
            if (count2 !== 0) {
              dest -= count2;
              cursor2 -= count2;
              length2 -= count2;
              customDest = dest + 1;
              customCursor = cursor2 + 1;
              for (i = 0; i < count2; i++) {
                array[customDest + i] = tmp[customCursor + i];
              }
              if (length2 <= 1) {
                exit = true;
                break;
              }
            }
            array[dest--] = array[cursor1--];
            if (--length1 === 0) {
              exit = true;
              break;
            }
            _minGallop--;
          } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
          if (exit) {
            break;
          }
          if (_minGallop < 0) {
            _minGallop = 0;
          }
          _minGallop += 2;
        }
        minGallop = _minGallop;
        if (minGallop < 1) {
          minGallop = 1;
        }
        if (length2 === 1) {
          dest -= length1;
          cursor1 -= length1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = length1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          array[dest] = tmp[cursor2];
        } else if (length2 === 0) {
          throw new Error();
        } else {
          customCursor = dest - (length2 - 1);
          for (i = 0; i < length2; i++) {
            array[customCursor + i] = tmp[i];
          }
        }
      }
      this.mergeRuns = mergeRuns;
      this.forceMergeRuns = forceMergeRuns;
      this.pushRun = pushRun;
    }
    function sort(array, compare, lo, hi) {
      if (!lo) {
        lo = 0;
      }
      if (!hi) {
        hi = array.length;
      }
      var remaining = hi - lo;
      if (remaining < 2) {
        return;
      }
      var runLength = 0;
      if (remaining < DEFAULT_MIN_MERGE) {
        runLength = makeAscendingRun(array, lo, hi, compare);
        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
        return;
      }
      var ts = new TimSort(array, compare);
      var minRun = minRunLength(remaining);
      do {
        runLength = makeAscendingRun(array, lo, hi, compare);
        if (runLength < minRun) {
          var force = remaining;
          if (force > minRun) {
            force = minRun;
          }
          binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
          runLength = force;
        }
        ts.pushRun(lo, runLength);
        ts.mergeRuns();
        remaining -= runLength;
        lo += runLength;
      } while (remaining !== 0);
      ts.forceMergeRuns();
    }
    module.exports = sort;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Storage.js
var require_Storage = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Storage.js"(exports, module) {
    var util = require_util();
    var env = require_env();
    var Group = require_Group();
    var timsort = require_timsort();
    function shapeCompareFunc(a, b) {
      if (a.zlevel === b.zlevel) {
        if (a.z === b.z) {
          return a.z2 - b.z2;
        }
        return a.z - b.z;
      }
      return a.zlevel - b.zlevel;
    }
    var Storage = function() {
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
    };
    Storage.prototype = {
      constructor: Storage,
      /**
       * @param  {Function} cb
       *
       */
      traverse: function(cb, context) {
        for (var i = 0; i < this._roots.length; i++) {
          this._roots[i].traverse(cb, context);
        }
      },
      /**
       * 返回所有图形的绘制队列
       * @param {boolean} [update=false] 是否在返回前更新该数组
       * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
       *
       * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
       * @return {Array.<module:zrender/graphic/Displayable>}
       */
      getDisplayList: function(update, includeIgnore) {
        includeIgnore = includeIgnore || false;
        if (update) {
          this.updateDisplayList(includeIgnore);
        }
        return this._displayList;
      },
      /**
       * 更新图形的绘制队列。
       * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
       * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
       * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
       */
      updateDisplayList: function(includeIgnore) {
        this._displayListLen = 0;
        var roots = this._roots;
        var displayList = this._displayList;
        for (var i = 0, len = roots.length; i < len; i++) {
          this._updateAndAddDisplayable(roots[i], null, includeIgnore);
        }
        displayList.length = this._displayListLen;
        env.canvasSupported && timsort(displayList, shapeCompareFunc);
      },
      _updateAndAddDisplayable: function(el, clipPaths, includeIgnore) {
        if (el.ignore && !includeIgnore) {
          return;
        }
        el.beforeUpdate();
        if (el.__dirty) {
          el.update();
        }
        el.afterUpdate();
        var userSetClipPath = el.clipPath;
        if (userSetClipPath) {
          if (clipPaths) {
            clipPaths = clipPaths.slice();
          } else {
            clipPaths = [];
          }
          var currentClipPath = userSetClipPath;
          var parentClipPath = el;
          while (currentClipPath) {
            currentClipPath.parent = parentClipPath;
            currentClipPath.updateTransform();
            clipPaths.push(currentClipPath);
            parentClipPath = currentClipPath;
            currentClipPath = currentClipPath.clipPath;
          }
        }
        if (el.isGroup) {
          var children = el._children;
          for (var i = 0; i < children.length; i++) {
            var child = children[i];
            if (el.__dirty) {
              child.__dirty = true;
            }
            this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
          }
          el.__dirty = false;
        } else {
          el.__clipPaths = clipPaths;
          this._displayList[this._displayListLen++] = el;
        }
      },
      /**
       * 添加图形(Shape)或者组(Group)到根节点
       * @param {module:zrender/Element} el
       */
      addRoot: function(el) {
        if (el.__storage === this) {
          return;
        }
        if (el instanceof Group) {
          el.addChildrenToStorage(this);
        }
        this.addToStorage(el);
        this._roots.push(el);
      },
      /**
       * 删除指定的图形(Shape)或者组(Group)
       * @param {string|Array.<string>} [el] 如果为空清空整个Storage
       */
      delRoot: function(el) {
        if (el == null) {
          for (var i = 0; i < this._roots.length; i++) {
            var root = this._roots[i];
            if (root instanceof Group) {
              root.delChildrenFromStorage(this);
            }
          }
          this._roots = [];
          this._displayList = [];
          this._displayListLen = 0;
          return;
        }
        if (el instanceof Array) {
          for (var i = 0, l = el.length; i < l; i++) {
            this.delRoot(el[i]);
          }
          return;
        }
        var idx = util.indexOf(this._roots, el);
        if (idx >= 0) {
          this.delFromStorage(el);
          this._roots.splice(idx, 1);
          if (el instanceof Group) {
            el.delChildrenFromStorage(this);
          }
        }
      },
      addToStorage: function(el) {
        if (el) {
          el.__storage = this;
          el.dirty(false);
        }
        return this;
      },
      delFromStorage: function(el) {
        if (el) {
          el.__storage = null;
        }
        return this;
      },
      /**
       * 清空并且释放Storage
       */
      dispose: function() {
        this._renderList = this._roots = null;
      },
      displayableSortFunc: shapeCompareFunc
    };
    var _default = Storage;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/fixShadow.js
var require_fixShadow = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/fixShadow.js"(exports, module) {
    var SHADOW_PROPS = {
      "shadowBlur": 1,
      "shadowOffsetX": 1,
      "shadowOffsetY": 1,
      "textShadowBlur": 1,
      "textShadowOffsetX": 1,
      "textShadowOffsetY": 1,
      "textBoxShadowBlur": 1,
      "textBoxShadowOffsetX": 1,
      "textBoxShadowOffsetY": 1
    };
    function _default(ctx, propName, value) {
      if (SHADOW_PROPS.hasOwnProperty(propName)) {
        return value *= ctx.dpr;
      }
      return value;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/constant.js
var require_constant = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/constant.js"(exports) {
    var ContextCachedBy = {
      NONE: 0,
      STYLE_BIND: 1,
      PLAIN_TEXT: 2
    };
    var WILL_BE_RESTORED = 9;
    exports.ContextCachedBy = ContextCachedBy;
    exports.WILL_BE_RESTORED = WILL_BE_RESTORED;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Style.js
var require_Style = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Style.js"(exports, module) {
    var fixShadow = require_fixShadow();
    var _constant = require_constant();
    var ContextCachedBy = _constant.ContextCachedBy;
    var STYLE_COMMON_PROPS = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]];
    var Style = function(opts) {
      this.extendFrom(opts, false);
    };
    function createLinearGradient(ctx, obj, rect) {
      var x = obj.x == null ? 0 : obj.x;
      var x2 = obj.x2 == null ? 1 : obj.x2;
      var y = obj.y == null ? 0 : obj.y;
      var y2 = obj.y2 == null ? 0 : obj.y2;
      if (!obj.global) {
        x = x * rect.width + rect.x;
        x2 = x2 * rect.width + rect.x;
        y = y * rect.height + rect.y;
        y2 = y2 * rect.height + rect.y;
      }
      x = isNaN(x) ? 0 : x;
      x2 = isNaN(x2) ? 1 : x2;
      y = isNaN(y) ? 0 : y;
      y2 = isNaN(y2) ? 0 : y2;
      var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
      return canvasGradient;
    }
    function createRadialGradient(ctx, obj, rect) {
      var width = rect.width;
      var height = rect.height;
      var min = Math.min(width, height);
      var x = obj.x == null ? 0.5 : obj.x;
      var y = obj.y == null ? 0.5 : obj.y;
      var r = obj.r == null ? 0.5 : obj.r;
      if (!obj.global) {
        x = x * width + rect.x;
        y = y * height + rect.y;
        r = r * min;
      }
      var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
      return canvasGradient;
    }
    Style.prototype = {
      constructor: Style,
      /**
       * @type {string}
       */
      fill: "#000",
      /**
       * @type {string}
       */
      stroke: null,
      /**
       * @type {number}
       */
      opacity: 1,
      /**
       * @type {number}
       */
      fillOpacity: null,
      /**
       * @type {number}
       */
      strokeOpacity: null,
      /**
       * `true` is not supported.
       * `false`/`null`/`undefined` are the same.
       * `false` is used to remove lineDash in some
       * case that `null`/`undefined` can not be set.
       * (e.g., emphasis.lineStyle in echarts)
       * @type {Array.<number>|boolean}
       */
      lineDash: null,
      /**
       * @type {number}
       */
      lineDashOffset: 0,
      /**
       * @type {number}
       */
      shadowBlur: 0,
      /**
       * @type {number}
       */
      shadowOffsetX: 0,
      /**
       * @type {number}
       */
      shadowOffsetY: 0,
      /**
       * @type {number}
       */
      lineWidth: 1,
      /**
       * If stroke ignore scale
       * @type {Boolean}
       */
      strokeNoScale: false,
      // Bounding rect text configuration
      // Not affected by element transform
      /**
       * @type {string}
       */
      text: null,
      /**
       * If `fontSize` or `fontFamily` exists, `font` will be reset by
       * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
       * So do not visit it directly in upper application (like echarts),
       * but use `contain/text#makeFont` instead.
       * @type {string}
       */
      font: null,
      /**
       * The same as font. Use font please.
       * @deprecated
       * @type {string}
       */
      textFont: null,
      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontStyle: null,
      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontWeight: null,
      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * Should be 12 but not '12px'.
       * @type {number}
       */
      fontSize: null,
      /**
       * It helps merging respectively, rather than parsing an entire font string.
       * @type {string}
       */
      fontFamily: null,
      /**
       * Reserved for special functinality, like 'hr'.
       * @type {string}
       */
      textTag: null,
      /**
       * @type {string}
       */
      textFill: "#000",
      /**
       * @type {string}
       */
      textStroke: null,
      /**
       * @type {number}
       */
      textWidth: null,
      /**
       * Only for textBackground.
       * @type {number}
       */
      textHeight: null,
      /**
       * textStroke may be set as some color as a default
       * value in upper applicaion, where the default value
       * of textStrokeWidth should be 0 to make sure that
       * user can choose to do not use text stroke.
       * @type {number}
       */
      textStrokeWidth: 0,
      /**
       * @type {number}
       */
      textLineHeight: null,
      /**
       * 'inside', 'left', 'right', 'top', 'bottom'
       * [x, y]
       * Based on x, y of rect.
       * @type {string|Array.<number>}
       * @default 'inside'
       */
      textPosition: "inside",
      /**
       * If not specified, use the boundingRect of a `displayable`.
       * @type {Object}
       */
      textRect: null,
      /**
       * [x, y]
       * @type {Array.<number>}
       */
      textOffset: null,
      /**
       * @type {string}
       */
      textAlign: null,
      /**
       * @type {string}
       */
      textVerticalAlign: null,
      /**
       * @type {number}
       */
      textDistance: 5,
      /**
       * @type {string}
       */
      textShadowColor: "transparent",
      /**
       * @type {number}
       */
      textShadowBlur: 0,
      /**
       * @type {number}
       */
      textShadowOffsetX: 0,
      /**
       * @type {number}
       */
      textShadowOffsetY: 0,
      /**
       * @type {string}
       */
      textBoxShadowColor: "transparent",
      /**
       * @type {number}
       */
      textBoxShadowBlur: 0,
      /**
       * @type {number}
       */
      textBoxShadowOffsetX: 0,
      /**
       * @type {number}
       */
      textBoxShadowOffsetY: 0,
      /**
       * Whether transform text.
       * Only available in Path and Image element,
       * where the text is called as `RectText`.
       * @type {boolean}
       */
      transformText: false,
      /**
       * Text rotate around position of Path or Image.
       * The origin of the rotation can be specified by `textOrigin`.
       * Only available in Path and Image element,
       * where the text is called as `RectText`.
       */
      textRotation: 0,
      /**
       * Text origin of text rotation.
       * Useful in the case like label rotation of circular symbol.
       * Only available in Path and Image element, where the text is called
       * as `RectText` and the element is called as "host element".
       * The value can be:
       * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`
       * base on the left-top corner of the rect of its host element.
       * + If specified as a string `center`, it is the center of the rect of
       * its host element.
       * + By default, this origin is the `textPosition`.
       * @type {string|Array.<number>}
       */
      textOrigin: null,
      /**
       * @type {string}
       */
      textBackgroundColor: null,
      /**
       * @type {string}
       */
      textBorderColor: null,
      /**
       * @type {number}
       */
      textBorderWidth: 0,
      /**
       * @type {number}
       */
      textBorderRadius: 0,
      /**
       * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
       * @type {number|Array.<number>}
       */
      textPadding: null,
      /**
       * Text styles for rich text.
       * @type {Object}
       */
      rich: null,
      /**
       * {outerWidth, outerHeight, ellipsis, placeholder}
       * @type {Object}
       */
      truncate: null,
      /**
       * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
       * @type {string}
       */
      blend: null,
      /**
       * @param {CanvasRenderingContext2D} ctx
       */
      bind: function(ctx, el, prevEl) {
        var style = this;
        var prevStyle = prevEl && prevEl.style;
        var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy.STYLE_BIND;
        ctx.__attrCachedBy = ContextCachedBy.STYLE_BIND;
        for (var i2 = 0; i2 < STYLE_COMMON_PROPS.length; i2++) {
          var prop2 = STYLE_COMMON_PROPS[i2];
          var styleName = prop2[0];
          if (notCheckCache || style[styleName] !== prevStyle[styleName]) {
            ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop2[1]);
          }
        }
        if (notCheckCache || style.fill !== prevStyle.fill) {
          ctx.fillStyle = style.fill;
        }
        if (notCheckCache || style.stroke !== prevStyle.stroke) {
          ctx.strokeStyle = style.stroke;
        }
        if (notCheckCache || style.opacity !== prevStyle.opacity) {
          ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
        }
        if (notCheckCache || style.blend !== prevStyle.blend) {
          ctx.globalCompositeOperation = style.blend || "source-over";
        }
        if (this.hasStroke()) {
          var lineWidth = style.lineWidth;
          ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
        }
      },
      hasFill: function() {
        var fill = this.fill;
        return fill != null && fill !== "none";
      },
      hasStroke: function() {
        var stroke = this.stroke;
        return stroke != null && stroke !== "none" && this.lineWidth > 0;
      },
      /**
       * Extend from other style
       * @param {zrender/graphic/Style} otherStyle
       * @param {boolean} overwrite true: overwrirte any way.
       *                            false: overwrite only when !target.hasOwnProperty
       *                            others: overwrite when property is not null/undefined.
       */
      extendFrom: function(otherStyle, overwrite) {
        if (otherStyle) {
          for (var name2 in otherStyle) {
            if (otherStyle.hasOwnProperty(name2) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name2) : otherStyle[name2] != null))) {
              this[name2] = otherStyle[name2];
            }
          }
        }
      },
      /**
       * Batch setting style with a given object
       * @param {Object|string} obj
       * @param {*} [obj]
       */
      set: function(obj, value) {
        if (typeof obj === "string") {
          this[obj] = value;
        } else {
          this.extendFrom(obj, true);
        }
      },
      /**
       * Clone
       * @return {zrender/graphic/Style} [description]
       */
      clone: function() {
        var newStyle = new this.constructor();
        newStyle.extendFrom(this, true);
        return newStyle;
      },
      getGradient: function(ctx, obj, rect) {
        var method = obj.type === "radial" ? createRadialGradient : createLinearGradient;
        var canvasGradient = method(ctx, obj, rect);
        var colorStops = obj.colorStops;
        for (var i2 = 0; i2 < colorStops.length; i2++) {
          canvasGradient.addColorStop(colorStops[i2].offset, colorStops[i2].color);
        }
        return canvasGradient;
      }
    };
    var styleProto = Style.prototype;
    for (i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      prop = STYLE_COMMON_PROPS[i];
      if (!(prop[0] in styleProto)) {
        styleProto[prop[0]] = prop[1];
      }
    }
    var prop;
    var i;
    Style.getGradient = styleProto.getGradient;
    var _default = Style;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Pattern.js
var require_Pattern = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Pattern.js"(exports, module) {
    var Pattern = function(image, repeat) {
      this.image = image;
      this.repeat = repeat;
      this.type = "pattern";
    };
    Pattern.prototype.getCanvasPattern = function(ctx) {
      return ctx.createPattern(this.image, this.repeat || "repeat");
    };
    var _default = Pattern;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Layer.js
var require_Layer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Layer.js"(exports, module) {
    var util = require_util();
    var _config = require_config2();
    var devicePixelRatio = _config.devicePixelRatio;
    var Style = require_Style();
    var Pattern = require_Pattern();
    function returnFalse() {
      return false;
    }
    function createDom(id, painter, dpr) {
      var newDom = util.createCanvas();
      var width = painter.getWidth();
      var height = painter.getHeight();
      var newDomStyle = newDom.style;
      if (newDomStyle) {
        newDomStyle.position = "absolute";
        newDomStyle.left = 0;
        newDomStyle.top = 0;
        newDomStyle.width = width + "px";
        newDomStyle.height = height + "px";
        newDom.setAttribute("data-zr-dom-id", id);
      }
      newDom.width = width * dpr;
      newDom.height = height * dpr;
      return newDom;
    }
    var Layer = function(id, painter, dpr) {
      var dom;
      dpr = dpr || devicePixelRatio;
      if (typeof id === "string") {
        dom = createDom(id, painter, dpr);
      } else if (util.isObject(id)) {
        dom = id;
        id = dom.id;
      }
      this.id = id;
      this.dom = dom;
      var domStyle = dom.style;
      if (domStyle) {
        dom.onselectstart = returnFalse;
        domStyle["-webkit-user-select"] = "none";
        domStyle["user-select"] = "none";
        domStyle["-webkit-touch-callout"] = "none";
        domStyle["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)";
        domStyle["padding"] = 0;
        domStyle["margin"] = 0;
        domStyle["border-width"] = 0;
      }
      this.domBack = null;
      this.ctxBack = null;
      this.painter = painter;
      this.config = null;
      this.clearColor = 0;
      this.motionBlur = false;
      this.lastFrameAlpha = 0.7;
      this.dpr = dpr;
    };
    Layer.prototype = {
      constructor: Layer,
      __dirty: true,
      __used: false,
      __drawIndex: 0,
      __startIndex: 0,
      __endIndex: 0,
      incremental: false,
      getElementCount: function() {
        return this.__endIndex - this.__startIndex;
      },
      initContext: function() {
        this.ctx = this.dom.getContext("2d");
        this.ctx.dpr = this.dpr;
      },
      createBackBuffer: function() {
        var dpr = this.dpr;
        this.domBack = createDom("back-" + this.id, this.painter, dpr);
        this.ctxBack = this.domBack.getContext("2d");
        if (dpr !== 1) {
          this.ctxBack.scale(dpr, dpr);
        }
      },
      /**
       * @param  {number} width
       * @param  {number} height
       */
      resize: function(width, height) {
        var dpr = this.dpr;
        var dom = this.dom;
        var domStyle = dom.style;
        var domBack = this.domBack;
        if (domStyle) {
          domStyle.width = width + "px";
          domStyle.height = height + "px";
        }
        dom.width = width * dpr;
        dom.height = height * dpr;
        if (domBack) {
          domBack.width = width * dpr;
          domBack.height = height * dpr;
          if (dpr !== 1) {
            this.ctxBack.scale(dpr, dpr);
          }
        }
      },
      /**
       * 清空该层画布
       * @param {boolean} [clearAll]=false Clear all with out motion blur
       * @param {Color} [clearColor]
       */
      clear: function(clearAll, clearColor) {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;
        var clearColor = clearColor || this.clearColor;
        var haveMotionBLur = this.motionBlur && !clearAll;
        var lastFrameAlpha = this.lastFrameAlpha;
        var dpr = this.dpr;
        if (haveMotionBLur) {
          if (!this.domBack) {
            this.createBackBuffer();
          }
          this.ctxBack.globalCompositeOperation = "copy";
          this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
        }
        ctx.clearRect(0, 0, width, height);
        if (clearColor && clearColor !== "transparent") {
          var clearColorGradientOrPattern;
          if (clearColor.colorStops) {
            clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
              x: 0,
              y: 0,
              width,
              height
            });
            clearColor.__canvasGradient = clearColorGradientOrPattern;
          } else if (clearColor.image) {
            clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
          }
          ctx.save();
          ctx.fillStyle = clearColorGradientOrPattern || clearColor;
          ctx.fillRect(0, 0, width, height);
          ctx.restore();
        }
        if (haveMotionBLur) {
          var domBack = this.domBack;
          ctx.save();
          ctx.globalAlpha = lastFrameAlpha;
          ctx.drawImage(domBack, 0, 0, width, height);
          ctx.restore();
        }
      }
    };
    var _default = Layer;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/requestAnimationFrame.js
var require_requestAnimationFrame = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/requestAnimationFrame.js"(exports, module) {
    var _default = typeof window !== "undefined" && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
    window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
      setTimeout(func, 16);
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/image.js
var require_image = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/image.js"(exports) {
    var LRU = require_LRU();
    var globalImageCache = new LRU(50);
    function findExistImage(newImageOrSrc) {
      if (typeof newImageOrSrc === "string") {
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        return cachedImgObj && cachedImgObj.image;
      } else {
        return newImageOrSrc;
      }
    }
    function createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {
      if (!newImageOrSrc) {
        return image;
      } else if (typeof newImageOrSrc === "string") {
        if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
          return image;
        }
        var cachedImgObj = globalImageCache.get(newImageOrSrc);
        var pendingWrap = {
          hostEl,
          cb,
          cbPayload
        };
        if (cachedImgObj) {
          image = cachedImgObj.image;
          !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
        } else {
          image = new Image();
          image.onload = image.onerror = imageOnLoad;
          globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
            image,
            pending: [pendingWrap]
          });
          image.src = image.__zrImageSrc = newImageOrSrc;
        }
        return image;
      } else {
        return newImageOrSrc;
      }
    }
    function imageOnLoad() {
      var cachedImgObj = this.__cachedImgObj;
      this.onload = this.onerror = this.__cachedImgObj = null;
      for (var i = 0; i < cachedImgObj.pending.length; i++) {
        var pendingWrap = cachedImgObj.pending[i];
        var cb = pendingWrap.cb;
        cb && cb(this, pendingWrap.cbPayload);
        pendingWrap.hostEl.dirty();
      }
      cachedImgObj.pending.length = 0;
    }
    function isImageReady(image) {
      return image && image.width && image.height;
    }
    exports.findExistImage = findExistImage;
    exports.createOrUpdateImage = createOrUpdateImage;
    exports.isImageReady = isImageReady;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/text.js
var require_text = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/text.js"(exports) {
    var BoundingRect = require_BoundingRect();
    var imageHelper = require_image();
    var _util = require_util();
    var getContext = _util.getContext;
    var extend = _util.extend;
    var retrieve2 = _util.retrieve2;
    var retrieve3 = _util.retrieve3;
    var trim = _util.trim;
    var textWidthCache = {};
    var textWidthCacheCounter = 0;
    var TEXT_CACHE_MAX = 5e3;
    var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
    var DEFAULT_FONT = "12px sans-serif";
    var methods = {};
    function $override(name2, fn) {
      methods[name2] = fn;
    }
    function getWidth(text, font) {
      font = font || DEFAULT_FONT;
      var key = text + ":" + font;
      if (textWidthCache[key]) {
        return textWidthCache[key];
      }
      var textLines = (text + "").split("\n");
      var width = 0;
      for (var i = 0, l = textLines.length; i < l; i++) {
        width = Math.max(measureText(textLines[i], font).width, width);
      }
      if (textWidthCacheCounter > TEXT_CACHE_MAX) {
        textWidthCacheCounter = 0;
        textWidthCache = {};
      }
      textWidthCacheCounter++;
      textWidthCache[key] = width;
      return width;
    }
    function getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
      return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);
    }
    function getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {
      var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);
      var outerWidth = getWidth(text, font);
      if (textPadding) {
        outerWidth += textPadding[1] + textPadding[3];
      }
      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      var rect = new BoundingRect(x, y, outerWidth, outerHeight);
      rect.lineHeight = contentBlock.lineHeight;
      return rect;
    }
    function getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
      var contentBlock = parseRichText(text, {
        rich,
        truncate,
        font,
        textAlign,
        textPadding,
        textLineHeight
      });
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var x = adjustTextX(0, outerWidth, textAlign);
      var y = adjustTextY(0, outerHeight, textVerticalAlign);
      return new BoundingRect(x, y, outerWidth, outerHeight);
    }
    function adjustTextX(x, width, textAlign) {
      if (textAlign === "right") {
        x -= width;
      } else if (textAlign === "center") {
        x -= width / 2;
      }
      return x;
    }
    function adjustTextY(y, height, textVerticalAlign) {
      if (textVerticalAlign === "middle") {
        y -= height / 2;
      } else if (textVerticalAlign === "bottom") {
        y -= height;
      }
      return y;
    }
    function calculateTextPosition(out, style, rect) {
      var textPosition = style.textPosition;
      var distance = style.textDistance;
      var x = rect.x;
      var y = rect.y;
      distance = distance || 0;
      var height = rect.height;
      var width = rect.width;
      var halfHeight = height / 2;
      var textAlign = "left";
      var textVerticalAlign = "top";
      switch (textPosition) {
        case "left":
          x -= distance;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "right":
          x += distance + width;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "top":
          x += width / 2;
          y -= distance;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "bottom":
          x += width / 2;
          y += height + distance;
          textAlign = "center";
          break;
        case "inside":
          x += width / 2;
          y += halfHeight;
          textAlign = "center";
          textVerticalAlign = "middle";
          break;
        case "insideLeft":
          x += distance;
          y += halfHeight;
          textVerticalAlign = "middle";
          break;
        case "insideRight":
          x += width - distance;
          y += halfHeight;
          textAlign = "right";
          textVerticalAlign = "middle";
          break;
        case "insideTop":
          x += width / 2;
          y += distance;
          textAlign = "center";
          break;
        case "insideBottom":
          x += width / 2;
          y += height - distance;
          textAlign = "center";
          textVerticalAlign = "bottom";
          break;
        case "insideTopLeft":
          x += distance;
          y += distance;
          break;
        case "insideTopRight":
          x += width - distance;
          y += distance;
          textAlign = "right";
          break;
        case "insideBottomLeft":
          x += distance;
          y += height - distance;
          textVerticalAlign = "bottom";
          break;
        case "insideBottomRight":
          x += width - distance;
          y += height - distance;
          textAlign = "right";
          textVerticalAlign = "bottom";
          break;
      }
      out = out || {};
      out.x = x;
      out.y = y;
      out.textAlign = textAlign;
      out.textVerticalAlign = textVerticalAlign;
      return out;
    }
    function adjustTextPositionOnRect(textPosition, rect, distance) {
      var dummyStyle = {
        textPosition,
        textDistance: distance
      };
      return calculateTextPosition({}, dummyStyle, rect);
    }
    function truncateText(text, containerWidth, font, ellipsis, options) {
      if (!containerWidth) {
        return "";
      }
      var textLines = (text + "").split("\n");
      options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
      for (var i = 0, len = textLines.length; i < len; i++) {
        textLines[i] = truncateSingleLine(textLines[i], options);
      }
      return textLines.join("\n");
    }
    function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
      options = extend({}, options);
      options.font = font;
      var ellipsis = retrieve2(ellipsis, "...");
      options.maxIterations = retrieve2(options.maxIterations, 2);
      var minChar = options.minChar = retrieve2(options.minChar, 0);
      options.cnCharWidth = getWidth("国", font);
      var ascCharWidth = options.ascCharWidth = getWidth("a", font);
      options.placeholder = retrieve2(options.placeholder, "");
      var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
      for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
        contentWidth -= ascCharWidth;
      }
      var ellipsisWidth = getWidth(ellipsis, font);
      if (ellipsisWidth > contentWidth) {
        ellipsis = "";
        ellipsisWidth = 0;
      }
      contentWidth = containerWidth - ellipsisWidth;
      options.ellipsis = ellipsis;
      options.ellipsisWidth = ellipsisWidth;
      options.contentWidth = contentWidth;
      options.containerWidth = containerWidth;
      return options;
    }
    function truncateSingleLine(textLine, options) {
      var containerWidth = options.containerWidth;
      var font = options.font;
      var contentWidth = options.contentWidth;
      if (!containerWidth) {
        return "";
      }
      var lineWidth = getWidth(textLine, font);
      if (lineWidth <= containerWidth) {
        return textLine;
      }
      for (var j = 0; ; j++) {
        if (lineWidth <= contentWidth || j >= options.maxIterations) {
          textLine += options.ellipsis;
          break;
        }
        var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
        textLine = textLine.substr(0, subLength);
        lineWidth = getWidth(textLine, font);
      }
      if (textLine === "") {
        textLine = options.placeholder;
      }
      return textLine;
    }
    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
      var width = 0;
      var i = 0;
      for (var len = text.length; i < len && width < contentWidth; i++) {
        var charCode = text.charCodeAt(i);
        width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
      }
      return i;
    }
    function getLineHeight(font) {
      return getWidth("国", font);
    }
    function measureText(text, font) {
      return methods.measureText(text, font);
    }
    methods.measureText = function(text, font) {
      var ctx = getContext();
      ctx.font = font || DEFAULT_FONT;
      return ctx.measureText(text);
    };
    function parsePlainText(text, font, padding, textLineHeight, truncate) {
      text != null && (text += "");
      var lineHeight = retrieve2(textLineHeight, getLineHeight(font));
      var lines = text ? text.split("\n") : [];
      var height = lines.length * lineHeight;
      var outerHeight = height;
      var canCacheByTextString = true;
      if (padding) {
        outerHeight += padding[0] + padding[2];
      }
      if (text && truncate) {
        canCacheByTextString = false;
        var truncOuterHeight = truncate.outerHeight;
        var truncOuterWidth = truncate.outerWidth;
        if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
          text = "";
          lines = [];
        } else if (truncOuterWidth != null) {
          var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
            minChar: truncate.minChar,
            placeholder: truncate.placeholder
          });
          for (var i = 0, len = lines.length; i < len; i++) {
            lines[i] = truncateSingleLine(lines[i], options);
          }
        }
      }
      return {
        lines,
        height,
        outerHeight,
        lineHeight,
        canCacheByTextString
      };
    }
    function parseRichText(text, style) {
      var contentBlock = {
        lines: [],
        width: 0,
        height: 0
      };
      text != null && (text += "");
      if (!text) {
        return contentBlock;
      }
      var lastIndex = STYLE_REG.lastIndex = 0;
      var result;
      while ((result = STYLE_REG.exec(text)) != null) {
        var matchedIndex = result.index;
        if (matchedIndex > lastIndex) {
          pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));
        }
        pushTokens(contentBlock, result[2], result[1]);
        lastIndex = STYLE_REG.lastIndex;
      }
      if (lastIndex < text.length) {
        pushTokens(contentBlock, text.substring(lastIndex, text.length));
      }
      var lines = contentBlock.lines;
      var contentHeight = 0;
      var contentWidth = 0;
      var pendingList = [];
      var stlPadding = style.textPadding;
      var truncate = style.truncate;
      var truncateWidth = truncate && truncate.outerWidth;
      var truncateHeight = truncate && truncate.outerHeight;
      if (stlPadding) {
        truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
        truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
      }
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        var lineHeight = 0;
        var lineWidth = 0;
        for (var j = 0; j < line.tokens.length; j++) {
          var token = line.tokens[j];
          var tokenStyle = token.styleName && style.rich[token.styleName] || {};
          var textPadding = token.textPadding = tokenStyle.textPadding;
          var font = token.font = tokenStyle.font || style.font;
          var tokenHeight = token.textHeight = retrieve2(
            // textHeight should not be inherited, consider it can be specified
            // as box height of the block.
            tokenStyle.textHeight,
            getLineHeight(font)
          );
          textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
          token.height = tokenHeight;
          token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
          token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
          token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || "middle";
          if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
            return {
              lines: [],
              width: 0,
              height: 0
            };
          }
          token.textWidth = getWidth(token.text, font);
          var tokenWidth = tokenStyle.textWidth;
          var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === "auto";
          if (typeof tokenWidth === "string" && tokenWidth.charAt(tokenWidth.length - 1) === "%") {
            token.percentWidth = tokenWidth;
            pendingList.push(token);
            tokenWidth = 0;
          } else {
            if (tokenWidthNotSpecified) {
              tokenWidth = token.textWidth;
              var textBackgroundColor = tokenStyle.textBackgroundColor;
              var bgImg = textBackgroundColor && textBackgroundColor.image;
              if (bgImg) {
                bgImg = imageHelper.findExistImage(bgImg);
                if (imageHelper.isImageReady(bgImg)) {
                  tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
                }
              }
            }
            var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
            tokenWidth += paddingW;
            var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
            if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
              if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
                token.text = "";
                token.textWidth = tokenWidth = 0;
              } else {
                token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
                  minChar: truncate.minChar
                });
                token.textWidth = getWidth(token.text, font);
                tokenWidth = token.textWidth + paddingW;
              }
            }
          }
          lineWidth += token.width = tokenWidth;
          tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
        }
        line.width = lineWidth;
        line.lineHeight = lineHeight;
        contentHeight += lineHeight;
        contentWidth = Math.max(contentWidth, lineWidth);
      }
      contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);
      contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);
      if (stlPadding) {
        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
      }
      for (var i = 0; i < pendingList.length; i++) {
        var token = pendingList[i];
        var percentWidth = token.percentWidth;
        token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
      }
      return contentBlock;
    }
    function pushTokens(block, str, styleName) {
      var isEmptyStr = str === "";
      var strs = str.split("\n");
      var lines = block.lines;
      for (var i = 0; i < strs.length; i++) {
        var text = strs[i];
        var token = {
          styleName,
          text,
          isLineHolder: !text && !isEmptyStr
        };
        if (!i) {
          var tokens = (lines[lines.length - 1] || (lines[0] = {
            tokens: []
          })).tokens;
          var tokensLen = tokens.length;
          tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (
            // Consider text is '', only insert when it is the "lineHolder" or
            // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
            (text || !tokensLen || isEmptyStr) && tokens.push(token)
          );
        } else {
          lines.push({
            tokens: [token]
          });
        }
      }
    }
    function makeFont(style) {
      var font = (style.fontSize || style.fontFamily) && [
        style.fontStyle,
        style.fontWeight,
        (style.fontSize || 12) + "px",
        // If font properties are defined, `fontFamily` should not be ignored.
        style.fontFamily || "sans-serif"
      ].join(" ");
      return font && trim(font) || style.textFont || style.font;
    }
    exports.DEFAULT_FONT = DEFAULT_FONT;
    exports.$override = $override;
    exports.getWidth = getWidth;
    exports.getBoundingRect = getBoundingRect;
    exports.adjustTextX = adjustTextX;
    exports.adjustTextY = adjustTextY;
    exports.calculateTextPosition = calculateTextPosition;
    exports.adjustTextPositionOnRect = adjustTextPositionOnRect;
    exports.truncateText = truncateText;
    exports.getLineHeight = getLineHeight;
    exports.measureText = measureText;
    exports.parsePlainText = parsePlainText;
    exports.parseRichText = parseRichText;
    exports.makeFont = makeFont;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/roundRect.js
var require_roundRect = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/roundRect.js"(exports) {
    function buildPath(ctx, shape) {
      var x = shape.x;
      var y = shape.y;
      var width = shape.width;
      var height = shape.height;
      var r = shape.r;
      var r1;
      var r2;
      var r3;
      var r4;
      if (width < 0) {
        x = x + width;
        width = -width;
      }
      if (height < 0) {
        y = y + height;
        height = -height;
      }
      if (typeof r === "number") {
        r1 = r2 = r3 = r4 = r;
      } else if (r instanceof Array) {
        if (r.length === 1) {
          r1 = r2 = r3 = r4 = r[0];
        } else if (r.length === 2) {
          r1 = r3 = r[0];
          r2 = r4 = r[1];
        } else if (r.length === 3) {
          r1 = r[0];
          r2 = r4 = r[1];
          r3 = r[2];
        } else {
          r1 = r[0];
          r2 = r[1];
          r3 = r[2];
          r4 = r[3];
        }
      } else {
        r1 = r2 = r3 = r4 = 0;
      }
      var total;
      if (r1 + r2 > width) {
        total = r1 + r2;
        r1 *= width / total;
        r2 *= width / total;
      }
      if (r3 + r4 > width) {
        total = r3 + r4;
        r3 *= width / total;
        r4 *= width / total;
      }
      if (r2 + r3 > height) {
        total = r2 + r3;
        r2 *= height / total;
        r3 *= height / total;
      }
      if (r1 + r4 > height) {
        total = r1 + r4;
        r1 *= height / total;
        r4 *= height / total;
      }
      ctx.moveTo(x + r1, y);
      ctx.lineTo(x + width - r2, y);
      r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
      ctx.lineTo(x + width, y + height - r3);
      r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
      ctx.lineTo(x + r4, y + height);
      r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
      ctx.lineTo(x, y + r1);
      r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
    }
    exports.buildPath = buildPath;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/text.js
var require_text2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/text.js"(exports) {
    var _util = require_util();
    var retrieve2 = _util.retrieve2;
    var retrieve3 = _util.retrieve3;
    var each = _util.each;
    var normalizeCssArray = _util.normalizeCssArray;
    var isString = _util.isString;
    var isObject = _util.isObject;
    var textContain = require_text();
    var roundRectHelper = require_roundRect();
    var imageHelper = require_image();
    var fixShadow = require_fixShadow();
    var _constant = require_constant();
    var ContextCachedBy = _constant.ContextCachedBy;
    var WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;
    var DEFAULT_FONT = textContain.DEFAULT_FONT;
    var VALID_TEXT_ALIGN = {
      left: 1,
      right: 1,
      center: 1
    };
    var VALID_TEXT_VERTICAL_ALIGN = {
      top: 1,
      bottom: 1,
      middle: 1
    };
    var SHADOW_STYLE_COMMON_PROPS = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]];
    var _tmpTextPositionResult = {};
    var _tmpBoxPositionResult = {};
    function normalizeTextStyle(style) {
      normalizeStyle(style);
      each(style.rich, normalizeStyle);
      return style;
    }
    function normalizeStyle(style) {
      if (style) {
        style.font = textContain.makeFont(style);
        var textAlign = style.textAlign;
        textAlign === "middle" && (textAlign = "center");
        style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
        var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
        textVerticalAlign === "center" && (textVerticalAlign = "middle");
        style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : "top";
        var textPadding = style.textPadding;
        if (textPadding) {
          style.textPadding = normalizeCssArray(style.textPadding);
        }
      }
    }
    function renderText(hostEl, ctx, text, style, rect, prevEl) {
      style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);
    }
    function renderPlainText(hostEl, ctx, text, style, rect, prevEl) {
      "use strict";
      var needDrawBg = needDrawBackground(style);
      var prevStyle;
      var checkCache = false;
      var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT;
      if (prevEl !== WILL_BE_RESTORED) {
        if (prevEl) {
          prevStyle = prevEl.style;
          checkCache = !needDrawBg && cachedByMe && prevStyle;
        }
        ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;
      } else if (cachedByMe) {
        ctx.__attrCachedBy = ContextCachedBy.NONE;
      }
      var styleFont = style.font || DEFAULT_FONT;
      if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {
        ctx.font = styleFont;
      }
      var computedFont = hostEl.__computedFont;
      if (hostEl.__styleFont !== styleFont) {
        hostEl.__styleFont = styleFont;
        computedFont = hostEl.__computedFont = ctx.font;
      }
      var textPadding = style.textPadding;
      var textLineHeight = style.textLineHeight;
      var contentBlock = hostEl.__textCotentBlock;
      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
      }
      var outerHeight = contentBlock.outerHeight;
      var textLines = contentBlock.lines;
      var lineHeight = contentBlock.lineHeight;
      var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign || "left";
      var textVerticalAlign = boxPos.textVerticalAlign;
      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var textX = baseX;
      var textY = boxY;
      if (needDrawBg || textPadding) {
        var textWidth = textContain.getWidth(text, computedFont);
        var outerWidth = textWidth;
        textPadding && (outerWidth += textPadding[1] + textPadding[3]);
        var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
        needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
        if (textPadding) {
          textX = getTextXForPadding(baseX, textAlign, textPadding);
          textY += textPadding[0];
        }
      }
      ctx.textAlign = textAlign;
      ctx.textBaseline = "middle";
      ctx.globalAlpha = style.opacity || 1;
      for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
        var propItem = SHADOW_STYLE_COMMON_PROPS[i];
        var styleProp = propItem[0];
        var ctxProp = propItem[1];
        var val = style[styleProp];
        if (!checkCache || val !== prevStyle[styleProp]) {
          ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);
        }
      }
      textY += lineHeight / 2;
      var textStrokeWidth = style.textStrokeWidth;
      var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;
      var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;
      var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;
      var textStroke = getStroke(style.textStroke, textStrokeWidth);
      var textFill = getFill(style.textFill);
      if (textStroke) {
        if (strokeWidthChanged) {
          ctx.lineWidth = textStrokeWidth;
        }
        if (strokeChanged) {
          ctx.strokeStyle = textStroke;
        }
      }
      if (textFill) {
        if (!checkCache || style.textFill !== prevStyle.textFill) {
          ctx.fillStyle = textFill;
        }
      }
      if (textLines.length === 1) {
        textStroke && ctx.strokeText(textLines[0], textX, textY);
        textFill && ctx.fillText(textLines[0], textX, textY);
      } else {
        for (var i = 0; i < textLines.length; i++) {
          textStroke && ctx.strokeText(textLines[i], textX, textY);
          textFill && ctx.fillText(textLines[i], textX, textY);
          textY += lineHeight;
        }
      }
    }
    function renderRichText(hostEl, ctx, text, style, rect, prevEl) {
      if (prevEl !== WILL_BE_RESTORED) {
        ctx.__attrCachedBy = ContextCachedBy.NONE;
      }
      var contentBlock = hostEl.__textCotentBlock;
      if (!contentBlock || hostEl.__dirtyText) {
        contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);
      }
      drawRichText(hostEl, ctx, contentBlock, style, rect);
    }
    function drawRichText(hostEl, ctx, contentBlock, style, rect) {
      var contentWidth = contentBlock.width;
      var outerWidth = contentBlock.outerWidth;
      var outerHeight = contentBlock.outerHeight;
      var textPadding = style.textPadding;
      var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
      var baseX = boxPos.baseX;
      var baseY = boxPos.baseY;
      var textAlign = boxPos.textAlign;
      var textVerticalAlign = boxPos.textVerticalAlign;
      applyTextRotation(ctx, style, rect, baseX, baseY);
      var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);
      var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var xLeft = boxX;
      var lineTop = boxY;
      if (textPadding) {
        xLeft += textPadding[3];
        lineTop += textPadding[0];
      }
      var xRight = xLeft + contentWidth;
      needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
      for (var i = 0; i < contentBlock.lines.length; i++) {
        var line = contentBlock.lines[i];
        var tokens = line.tokens;
        var tokenCount = tokens.length;
        var lineHeight = line.lineHeight;
        var usedWidth = line.width;
        var leftIndex = 0;
        var lineXLeft = xLeft;
        var lineXRight = xRight;
        var rightIndex = tokenCount - 1;
        var token;
        while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === "left")) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, "left");
          usedWidth -= token.width;
          lineXLeft += token.width;
          leftIndex++;
        }
        while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === "right")) {
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, "right");
          usedWidth -= token.width;
          lineXRight -= token.width;
          rightIndex--;
        }
        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
        while (leftIndex <= rightIndex) {
          token = tokens[leftIndex];
          placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center");
          lineXLeft += token.width;
          leftIndex++;
        }
        lineTop += lineHeight;
      }
    }
    function applyTextRotation(ctx, style, rect, x, y) {
      if (rect && style.textRotation) {
        var origin = style.textOrigin;
        if (origin === "center") {
          x = rect.width / 2 + rect.x;
          y = rect.height / 2 + rect.y;
        } else if (origin) {
          x = origin[0] + rect.x;
          y = origin[1] + rect.y;
        }
        ctx.translate(x, y);
        ctx.rotate(-style.textRotation);
        ctx.translate(-x, -y);
      }
    }
    function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
      var tokenStyle = style.rich[token.styleName] || {};
      tokenStyle.text = token.text;
      var textVerticalAlign = token.textVerticalAlign;
      var y = lineTop + lineHeight / 2;
      if (textVerticalAlign === "top") {
        y = lineTop + token.height / 2;
      } else if (textVerticalAlign === "bottom") {
        y = lineTop + lineHeight - token.height / 2;
      }
      !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
      var textPadding = token.textPadding;
      if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding);
        y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
      }
      setCtx(ctx, "shadowBlur", retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
      setCtx(ctx, "shadowColor", tokenStyle.textShadowColor || style.textShadowColor || "transparent");
      setCtx(ctx, "shadowOffsetX", retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
      setCtx(ctx, "shadowOffsetY", retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
      setCtx(ctx, "textAlign", textAlign);
      setCtx(ctx, "textBaseline", "middle");
      setCtx(ctx, "font", token.font || DEFAULT_FONT);
      var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
      var textFill = getFill(tokenStyle.textFill || style.textFill);
      var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);
      if (textStroke) {
        setCtx(ctx, "lineWidth", textStrokeWidth);
        setCtx(ctx, "strokeStyle", textStroke);
        ctx.strokeText(token.text, x, y);
      }
      if (textFill) {
        setCtx(ctx, "fillStyle", textFill);
        ctx.fillText(token.text, x, y);
      }
    }
    function needDrawBackground(style) {
      return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);
    }
    function drawBackground(hostEl, ctx, style, x, y, width, height) {
      var textBackgroundColor = style.textBackgroundColor;
      var textBorderWidth = style.textBorderWidth;
      var textBorderColor = style.textBorderColor;
      var isPlainBg = isString(textBackgroundColor);
      setCtx(ctx, "shadowBlur", style.textBoxShadowBlur || 0);
      setCtx(ctx, "shadowColor", style.textBoxShadowColor || "transparent");
      setCtx(ctx, "shadowOffsetX", style.textBoxShadowOffsetX || 0);
      setCtx(ctx, "shadowOffsetY", style.textBoxShadowOffsetY || 0);
      if (isPlainBg || textBorderWidth && textBorderColor) {
        ctx.beginPath();
        var textBorderRadius = style.textBorderRadius;
        if (!textBorderRadius) {
          ctx.rect(x, y, width, height);
        } else {
          roundRectHelper.buildPath(ctx, {
            x,
            y,
            width,
            height,
            r: textBorderRadius
          });
        }
        ctx.closePath();
      }
      if (isPlainBg) {
        setCtx(ctx, "fillStyle", textBackgroundColor);
        if (style.fillOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.fillOpacity * style.opacity;
          ctx.fill();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.fill();
        }
      } else if (isObject(textBackgroundColor)) {
        var image = textBackgroundColor.image;
        image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);
        if (image && imageHelper.isImageReady(image)) {
          ctx.drawImage(image, x, y, width, height);
        }
      }
      if (textBorderWidth && textBorderColor) {
        setCtx(ctx, "lineWidth", textBorderWidth);
        setCtx(ctx, "strokeStyle", textBorderColor);
        if (style.strokeOpacity != null) {
          var originalGlobalAlpha = ctx.globalAlpha;
          ctx.globalAlpha = style.strokeOpacity * style.opacity;
          ctx.stroke();
          ctx.globalAlpha = originalGlobalAlpha;
        } else {
          ctx.stroke();
        }
      }
    }
    function onBgImageLoaded(image, textBackgroundColor) {
      textBackgroundColor.image = image;
    }
    function getBoxPosition(out, hostEl, style, rect) {
      var baseX = style.x || 0;
      var baseY = style.y || 0;
      var textAlign = style.textAlign;
      var textVerticalAlign = style.textVerticalAlign;
      if (rect) {
        var textPosition = style.textPosition;
        if (textPosition instanceof Array) {
          baseX = rect.x + parsePercent(textPosition[0], rect.width);
          baseY = rect.y + parsePercent(textPosition[1], rect.height);
        } else {
          var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);
          baseX = res.x;
          baseY = res.y;
          textAlign = textAlign || res.textAlign;
          textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
        }
        var textOffset = style.textOffset;
        if (textOffset) {
          baseX += textOffset[0];
          baseY += textOffset[1];
        }
      }
      out = out || {};
      out.baseX = baseX;
      out.baseY = baseY;
      out.textAlign = textAlign;
      out.textVerticalAlign = textVerticalAlign;
      return out;
    }
    function setCtx(ctx, prop, value) {
      ctx[prop] = fixShadow(ctx, prop, value);
      return ctx[prop];
    }
    function getStroke(stroke, lineWidth) {
      return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
    }
    function getFill(fill) {
      return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
    }
    function parsePercent(value, maxValue) {
      if (typeof value === "string") {
        if (value.lastIndexOf("%") >= 0) {
          return parseFloat(value) / 100 * maxValue;
        }
        return parseFloat(value);
      }
      return value;
    }
    function getTextXForPadding(x, textAlign, textPadding) {
      return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
    }
    function needDrawText(text, style) {
      return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
    }
    exports.normalizeTextStyle = normalizeTextStyle;
    exports.renderText = renderText;
    exports.getBoxPosition = getBoxPosition;
    exports.getStroke = getStroke;
    exports.getFill = getFill;
    exports.parsePercent = parsePercent;
    exports.needDrawText = needDrawText;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/mixin/RectText.js
var require_RectText = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/mixin/RectText.js"(exports, module) {
    var textHelper = require_text2();
    var BoundingRect = require_BoundingRect();
    var _constant = require_constant();
    var WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;
    var tmpRect = new BoundingRect();
    var RectText = function() {
    };
    RectText.prototype = {
      constructor: RectText,
      /**
       * Draw text in a rect with specified position.
       * @param  {CanvasRenderingContext2D} ctx
       * @param  {Object} rect Displayable rect
       */
      drawRectText: function(ctx, rect) {
        var style = this.style;
        rect = style.textRect || rect;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        var text = style.text;
        text != null && (text += "");
        if (!textHelper.needDrawText(text, style)) {
          return;
        }
        ctx.save();
        var transform = this.transform;
        if (!style.transformText) {
          if (transform) {
            tmpRect.copy(rect);
            tmpRect.applyTransform(transform);
            rect = tmpRect;
          }
        } else {
          this.setTransform(ctx);
        }
        textHelper.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED);
        ctx.restore();
      }
    };
    var _default = RectText;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Displayable.js
var require_Displayable = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Displayable.js"(exports, module) {
    var zrUtil = require_util();
    var Style = require_Style();
    var Element = require_Element();
    var RectText = require_RectText();
    function Displayable(opts) {
      opts = opts || {};
      Element.call(this, opts);
      for (var name2 in opts) {
        if (opts.hasOwnProperty(name2) && name2 !== "style") {
          this[name2] = opts[name2];
        }
      }
      this.style = new Style(opts.style, this);
      this._rect = null;
      this.__clipPaths = null;
    }
    Displayable.prototype = {
      constructor: Displayable,
      type: "displayable",
      /**
       * Dirty flag. From which painter will determine if this displayable object needs brush.
       * @name module:zrender/graphic/Displayable#__dirty
       * @type {boolean}
       */
      __dirty: true,
      /**
       * Whether the displayable object is visible. when it is true, the displayable object
       * is not drawn, but the mouse event can still trigger the object.
       * @name module:/zrender/graphic/Displayable#invisible
       * @type {boolean}
       * @default false
       */
      invisible: false,
      /**
       * @name module:/zrender/graphic/Displayable#z
       * @type {number}
       * @default 0
       */
      z: 0,
      /**
       * @name module:/zrender/graphic/Displayable#z
       * @type {number}
       * @default 0
       */
      z2: 0,
      /**
       * The z level determines the displayable object can be drawn in which layer canvas.
       * @name module:/zrender/graphic/Displayable#zlevel
       * @type {number}
       * @default 0
       */
      zlevel: 0,
      /**
       * Whether it can be dragged.
       * @name module:/zrender/graphic/Displayable#draggable
       * @type {boolean}
       * @default false
       */
      draggable: false,
      /**
       * Whether is it dragging.
       * @name module:/zrender/graphic/Displayable#draggable
       * @type {boolean}
       * @default false
       */
      dragging: false,
      /**
       * Whether to respond to mouse events.
       * @name module:/zrender/graphic/Displayable#silent
       * @type {boolean}
       * @default false
       */
      silent: false,
      /**
       * If enable culling
       * @type {boolean}
       * @default false
       */
      culling: false,
      /**
       * Mouse cursor when hovered
       * @name module:/zrender/graphic/Displayable#cursor
       * @type {string}
       */
      cursor: "pointer",
      /**
       * If hover area is bounding rect
       * @name module:/zrender/graphic/Displayable#rectHover
       * @type {string}
       */
      rectHover: false,
      /**
       * Render the element progressively when the value >= 0,
       * usefull for large data.
       * @type {boolean}
       */
      progressive: false,
      /**
       * @type {boolean}
       */
      incremental: false,
      /**
       * Scale ratio for global scale.
       * @type {boolean}
       */
      globalScaleRatio: 1,
      beforeBrush: function(ctx) {
      },
      afterBrush: function(ctx) {
      },
      /**
       * Graphic drawing method.
       * @param {CanvasRenderingContext2D} ctx
       */
      // Interface
      brush: function(ctx, prevEl) {
      },
      /**
       * Get the minimum bounding box.
       * @return {module:zrender/core/BoundingRect}
       */
      // Interface
      getBoundingRect: function() {
      },
      /**
       * If displayable element contain coord x, y
       * @param  {number} x
       * @param  {number} y
       * @return {boolean}
       */
      contain: function(x, y) {
        return this.rectContain(x, y);
      },
      /**
       * @param  {Function} cb
       * @param  {}   context
       */
      traverse: function(cb, context) {
        cb.call(context, this);
      },
      /**
       * If bounding rect of element contain coord x, y
       * @param  {number} x
       * @param  {number} y
       * @return {boolean}
       */
      rectContain: function(x, y) {
        var coord = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        return rect.contain(coord[0], coord[1]);
      },
      /**
       * Mark displayable element dirty and refresh next frame
       */
      dirty: function() {
        this.__dirty = this.__dirtyText = true;
        this._rect = null;
        this.__zr && this.__zr.refresh();
      },
      /**
       * If displayable object binded any event
       * @return {boolean}
       */
      // TODO, events bound by bind
      // isSilent: function () {
      //     return !(
      //         this.hoverable || this.draggable
      //         || this.onmousemove || this.onmouseover || this.onmouseout
      //         || this.onmousedown || this.onmouseup || this.onclick
      //         || this.ondragenter || this.ondragover || this.ondragleave
      //         || this.ondrop
      //     );
      // },
      /**
       * Alias for animate('style')
       * @param {boolean} loop
       */
      animateStyle: function(loop) {
        return this.animate("style", loop);
      },
      attrKV: function(key, value) {
        if (key !== "style") {
          Element.prototype.attrKV.call(this, key, value);
        } else {
          this.style.set(value);
        }
      },
      /**
       * @param {Object|string} key
       * @param {*} value
       */
      setStyle: function(key, value) {
        this.style.set(key, value);
        this.dirty(false);
        return this;
      },
      /**
       * Use given style object
       * @param  {Object} obj
       */
      useStyle: function(obj) {
        this.style = new Style(obj, this);
        this.dirty(false);
        return this;
      },
      /**
       * The string value of `textPosition` needs to be calculated to a real postion.
       * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
       * by default. See `contain/text.js#calculateTextPosition` for more details.
       * But some coutom shapes like "pin", "flag" have center that is not exactly
       * `[width/2, height/2]`. So we provide this hook to customize the calculation
       * for those shapes. It will be called if the `style.textPosition` is a string.
       * @param {Obejct} [out] Prepared out object. If not provided, this method should
       *        be responsible for creating one.
       * @param {module:zrender/graphic/Style} style
       * @param {Object} rect {x, y, width, height}
       * @return {Obejct} out The same as the input out.
       *         {
       *             x: number. mandatory.
       *             y: number. mandatory.
       *             textAlign: string. optional. use style.textAlign by default.
       *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.
       *         }
       */
      calculateTextPosition: null
    };
    zrUtil.inherits(Displayable, Element);
    zrUtil.mixin(Displayable, RectText);
    var _default = Displayable;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Image.js
var require_Image = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Image.js"(exports, module) {
    var Displayable = require_Displayable();
    var BoundingRect = require_BoundingRect();
    var zrUtil = require_util();
    var imageHelper = require_image();
    function ZImage(opts) {
      Displayable.call(this, opts);
    }
    ZImage.prototype = {
      constructor: ZImage,
      type: "image",
      brush: function(ctx, prevEl) {
        var style = this.style;
        var src = style.image;
        style.bind(ctx, this, prevEl);
        var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
        if (!image || !imageHelper.isImageReady(image)) {
          return;
        }
        var x = style.x || 0;
        var y = style.y || 0;
        var width = style.width;
        var height = style.height;
        var aspect = image.width / image.height;
        if (width == null && height != null) {
          width = height * aspect;
        } else if (height == null && width != null) {
          height = width / aspect;
        } else if (width == null && height == null) {
          width = image.width;
          height = image.height;
        }
        this.setTransform(ctx);
        if (style.sWidth && style.sHeight) {
          var sx = style.sx || 0;
          var sy = style.sy || 0;
          ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
        } else if (style.sx && style.sy) {
          var sx = style.sx;
          var sy = style.sy;
          var sWidth = width - sx;
          var sHeight = height - sy;
          ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
        } else {
          ctx.drawImage(image, x, y, width, height);
        }
        if (style.text != null) {
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      getBoundingRect: function() {
        var style = this.style;
        if (!this._rect) {
          this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
        }
        return this._rect;
      }
    };
    zrUtil.inherits(ZImage, Displayable);
    var _default = ZImage;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Painter.js
var require_Painter = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/Painter.js"(exports, module) {
    var _config = require_config2();
    var devicePixelRatio = _config.devicePixelRatio;
    var util = require_util();
    var logError = require_log();
    var BoundingRect = require_BoundingRect();
    var timsort = require_timsort();
    var Layer = require_Layer();
    var requestAnimationFrame = require_requestAnimationFrame();
    var Image2 = require_Image();
    var env = require_env();
    var HOVER_LAYER_ZLEVEL = 1e5;
    var CANVAS_ZLEVEL = 314159;
    var EL_AFTER_INCREMENTAL_INC = 0.01;
    var INCREMENTAL_INC = 1e-3;
    function parseInt10(val) {
      return parseInt(val, 10);
    }
    function isLayerValid(layer) {
      if (!layer) {
        return false;
      }
      if (layer.__builtin__) {
        return true;
      }
      if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
        return false;
      }
      return true;
    }
    var tmpRect = new BoundingRect(0, 0, 0, 0);
    var viewRect = new BoundingRect(0, 0, 0, 0);
    function isDisplayableCulled(el, width, height) {
      tmpRect.copy(el.getBoundingRect());
      if (el.transform) {
        tmpRect.applyTransform(el.transform);
      }
      viewRect.width = width;
      viewRect.height = height;
      return !tmpRect.intersect(viewRect);
    }
    function isClipPathChanged(clipPaths, prevClipPaths) {
      if (clipPaths === prevClipPaths) {
        return false;
      }
      if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
        return true;
      }
      for (var i = 0; i < clipPaths.length; i++) {
        if (clipPaths[i] !== prevClipPaths[i]) {
          return true;
        }
      }
      return false;
    }
    function doClip(clipPaths, ctx) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        clipPath.setTransform(ctx);
        ctx.beginPath();
        clipPath.buildPath(ctx, clipPath.shape);
        ctx.clip();
        clipPath.restoreTransform(ctx);
      }
    }
    function createRoot(width, height) {
      var domRoot = document.createElement("div");
      domRoot.style.cssText = [
        "position:relative",
        // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent
        // dom does not act as expected) when some of the parent dom has
        // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and
        // the canvas is not at the top part of the page.
        // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove
        // this `overflow:hidden` to avoid the bug.
        // 'overflow:hidden',
        "width:" + width + "px",
        "height:" + height + "px",
        "padding:0",
        "margin:0",
        "border-width:0"
      ].join(";") + ";";
      return domRoot;
    }
    var Painter = function(root, storage, opts) {
      this.type = "canvas";
      var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
      this._opts = opts = util.extend({}, opts || {});
      this.dpr = opts.devicePixelRatio || devicePixelRatio;
      this._singleCanvas = singleCanvas;
      this.root = root;
      var rootStyle = root.style;
      if (rootStyle) {
        rootStyle["-webkit-tap-highlight-color"] = "transparent";
        rootStyle["-webkit-user-select"] = rootStyle["user-select"] = rootStyle["-webkit-touch-callout"] = "none";
        root.innerHTML = "";
      }
      this.storage = storage;
      var zlevelList = this._zlevelList = [];
      var layers = this._layers = {};
      this._layerConfig = {};
      this._needsManuallyCompositing = false;
      if (!singleCanvas) {
        this._width = this._getSize(0);
        this._height = this._getSize(1);
        var domRoot = this._domRoot = createRoot(this._width, this._height);
        root.appendChild(domRoot);
      } else {
        var width = root.width;
        var height = root.height;
        if (opts.width != null) {
          width = opts.width;
        }
        if (opts.height != null) {
          height = opts.height;
        }
        this.dpr = opts.devicePixelRatio || 1;
        root.width = width * this.dpr;
        root.height = height * this.dpr;
        this._width = width;
        this._height = height;
        var mainLayer = new Layer(root, this, this.dpr);
        mainLayer.__builtin__ = true;
        mainLayer.initContext();
        layers[CANVAS_ZLEVEL] = mainLayer;
        mainLayer.zlevel = CANVAS_ZLEVEL;
        zlevelList.push(CANVAS_ZLEVEL);
        this._domRoot = root;
      }
      this._hoverlayer = null;
      this._hoverElements = [];
    };
    Painter.prototype = {
      constructor: Painter,
      getType: function() {
        return "canvas";
      },
      /**
       * If painter use a single canvas
       * @return {boolean}
       */
      isSingleCanvas: function() {
        return this._singleCanvas;
      },
      /**
       * @return {HTMLDivElement}
       */
      getViewportRoot: function() {
        return this._domRoot;
      },
      getViewportRootOffset: function() {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },
      /**
       * 刷新
       * @param {boolean} [paintAll=false] 强制绘制所有displayable
       */
      refresh: function(paintAll) {
        var list = this.storage.getDisplayList(true);
        var zlevelList = this._zlevelList;
        this._redrawId = Math.random();
        this._paintList(list, paintAll, this._redrawId);
        for (var i = 0; i < zlevelList.length; i++) {
          var z = zlevelList[i];
          var layer = this._layers[z];
          if (!layer.__builtin__ && layer.refresh) {
            var clearColor = i === 0 ? this._backgroundColor : null;
            layer.refresh(clearColor);
          }
        }
        this.refreshHover();
        return this;
      },
      addHover: function(el, hoverStyle) {
        if (el.__hoverMir) {
          return;
        }
        var elMirror = new el.constructor({
          style: el.style,
          shape: el.shape,
          z: el.z,
          z2: el.z2,
          silent: el.silent
        });
        elMirror.__from = el;
        el.__hoverMir = elMirror;
        hoverStyle && elMirror.setStyle(hoverStyle);
        this._hoverElements.push(elMirror);
        return elMirror;
      },
      removeHover: function(el) {
        var elMirror = el.__hoverMir;
        var hoverElements = this._hoverElements;
        var idx = util.indexOf(hoverElements, elMirror);
        if (idx >= 0) {
          hoverElements.splice(idx, 1);
        }
        el.__hoverMir = null;
      },
      clearHover: function(el) {
        var hoverElements = this._hoverElements;
        for (var i = 0; i < hoverElements.length; i++) {
          var from = hoverElements[i].__from;
          if (from) {
            from.__hoverMir = null;
          }
        }
        hoverElements.length = 0;
      },
      refreshHover: function() {
        var hoverElements = this._hoverElements;
        var len = hoverElements.length;
        var hoverLayer = this._hoverlayer;
        hoverLayer && hoverLayer.clear();
        if (!len) {
          return;
        }
        timsort(hoverElements, this.storage.displayableSortFunc);
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        var scope = {};
        hoverLayer.ctx.save();
        for (var i = 0; i < len; ) {
          var el = hoverElements[i];
          var originalEl = el.__from;
          if (!(originalEl && originalEl.__zr)) {
            hoverElements.splice(i, 1);
            originalEl.__hoverMir = null;
            len--;
            continue;
          }
          i++;
          if (!originalEl.invisible) {
            el.transform = originalEl.transform;
            el.invTransform = originalEl.invTransform;
            el.__clipPaths = originalEl.__clipPaths;
            this._doPaintEl(el, hoverLayer, true, scope);
          }
        }
        hoverLayer.ctx.restore();
      },
      getHoverLayer: function() {
        return this.getLayer(HOVER_LAYER_ZLEVEL);
      },
      _paintList: function(list, paintAll, redrawId) {
        if (this._redrawId !== redrawId) {
          return;
        }
        paintAll = paintAll || false;
        this._updateLayerStatus(list);
        var finished = this._doPaintList(list, paintAll);
        if (this._needsManuallyCompositing) {
          this._compositeManually();
        }
        if (!finished) {
          var self2 = this;
          requestAnimationFrame(function() {
            self2._paintList(list, paintAll, redrawId);
          });
        }
      },
      _compositeManually: function() {
        var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
        var width = this._domRoot.width;
        var height = this._domRoot.height;
        ctx.clearRect(0, 0, width, height);
        this.eachBuiltinLayer(function(layer) {
          if (layer.virtual) {
            ctx.drawImage(layer.dom, 0, 0, width, height);
          }
        });
      },
      _doPaintList: function(list, paintAll) {
        var layerList = [];
        for (var zi = 0; zi < this._zlevelList.length; zi++) {
          var zlevel = this._zlevelList[zi];
          var layer = this._layers[zlevel];
          if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
            layerList.push(layer);
          }
        }
        var finished = true;
        for (var k = 0; k < layerList.length; k++) {
          var layer = layerList[k];
          var ctx = layer.ctx;
          var scope = {};
          ctx.save();
          var start = paintAll ? layer.__startIndex : layer.__drawIndex;
          var useTimer = !paintAll && layer.incremental && Date.now;
          var startTime = useTimer && Date.now();
          var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
          if (layer.__startIndex === layer.__endIndex) {
            layer.clear(false, clearColor);
          } else if (start === layer.__startIndex) {
            var firstEl = list[start];
            if (!firstEl.incremental || !firstEl.notClear || paintAll) {
              layer.clear(false, clearColor);
            }
          }
          if (start === -1) {
            console.error("For some unknown reason. drawIndex is -1");
            start = layer.__startIndex;
          }
          for (var i = start; i < layer.__endIndex; i++) {
            var el = list[i];
            this._doPaintEl(el, layer, paintAll, scope);
            el.__dirty = el.__dirtyText = false;
            if (useTimer) {
              var dTime = Date.now() - startTime;
              if (dTime > 15) {
                break;
              }
            }
          }
          layer.__drawIndex = i;
          if (layer.__drawIndex < layer.__endIndex) {
            finished = false;
          }
          if (scope.prevElClipPaths) {
            ctx.restore();
          }
          ctx.restore();
        }
        if (env.wxa) {
          util.each(this._layers, function(layer2) {
            if (layer2 && layer2.ctx && layer2.ctx.draw) {
              layer2.ctx.draw();
            }
          });
        }
        return finished;
      },
      _doPaintEl: function(el, currentLayer, forcePaint, scope) {
        var ctx = currentLayer.ctx;
        var m = el.transform;
        if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
        !el.invisible && el.style.opacity !== 0 && !(m && !m[0] && !m[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
          var clipPaths = el.__clipPaths;
          var prevElClipPaths = scope.prevElClipPaths;
          if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
            if (prevElClipPaths) {
              ctx.restore();
              scope.prevElClipPaths = null;
              scope.prevEl = null;
            }
            if (clipPaths) {
              ctx.save();
              doClip(clipPaths, ctx);
              scope.prevElClipPaths = clipPaths;
            }
          }
          el.beforeBrush && el.beforeBrush(ctx);
          el.brush(ctx, scope.prevEl || null);
          scope.prevEl = el;
          el.afterBrush && el.afterBrush(ctx);
        }
      },
      /**
       * 获取 zlevel 所在层，如果不存在则会创建一个新的层
       * @param {number} zlevel
       * @param {boolean} virtual Virtual layer will not be inserted into dom.
       * @return {module:zrender/Layer}
       */
      getLayer: function(zlevel, virtual) {
        if (this._singleCanvas && !this._needsManuallyCompositing) {
          zlevel = CANVAS_ZLEVEL;
        }
        var layer = this._layers[zlevel];
        if (!layer) {
          layer = new Layer("zr_" + zlevel, this, this.dpr);
          layer.zlevel = zlevel;
          layer.__builtin__ = true;
          if (this._layerConfig[zlevel]) {
            util.merge(layer, this._layerConfig[zlevel], true);
          } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
            util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
          }
          if (virtual) {
            layer.virtual = virtual;
          }
          this.insertLayer(zlevel, layer);
          layer.initContext();
        }
        return layer;
      },
      insertLayer: function(zlevel, layer) {
        var layersMap = this._layers;
        var zlevelList = this._zlevelList;
        var len = zlevelList.length;
        var prevLayer = null;
        var i = -1;
        var domRoot = this._domRoot;
        if (layersMap[zlevel]) {
          logError("ZLevel " + zlevel + " has been used already");
          return;
        }
        if (!isLayerValid(layer)) {
          logError("Layer of zlevel " + zlevel + " is not valid");
          return;
        }
        if (len > 0 && zlevel > zlevelList[0]) {
          for (i = 0; i < len - 1; i++) {
            if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
              break;
            }
          }
          prevLayer = layersMap[zlevelList[i]];
        }
        zlevelList.splice(i + 1, 0, zlevel);
        layersMap[zlevel] = layer;
        if (!layer.virtual) {
          if (prevLayer) {
            var prevDom = prevLayer.dom;
            if (prevDom.nextSibling) {
              domRoot.insertBefore(layer.dom, prevDom.nextSibling);
            } else {
              domRoot.appendChild(layer.dom);
            }
          } else {
            if (domRoot.firstChild) {
              domRoot.insertBefore(layer.dom, domRoot.firstChild);
            } else {
              domRoot.appendChild(layer.dom);
            }
          }
        }
      },
      // Iterate each layer
      eachLayer: function(cb, context) {
        var zlevelList = this._zlevelList;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          cb.call(context, this._layers[z], z);
        }
      },
      // Iterate each buildin layer
      eachBuiltinLayer: function(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];
          if (layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },
      // Iterate each other layer except buildin layer
      eachOtherLayer: function(cb, context) {
        var zlevelList = this._zlevelList;
        var layer;
        var z;
        var i;
        for (i = 0; i < zlevelList.length; i++) {
          z = zlevelList[i];
          layer = this._layers[z];
          if (!layer.__builtin__) {
            cb.call(context, layer, z);
          }
        }
      },
      /**
       * 获取所有已创建的层
       * @param {Array.<module:zrender/Layer>} [prevLayer]
       */
      getLayers: function() {
        return this._layers;
      },
      _updateLayerStatus: function(list) {
        this.eachBuiltinLayer(function(layer2, z) {
          layer2.__dirty = layer2.__used = false;
        });
        function updatePrevLayer(idx) {
          if (prevLayer) {
            if (prevLayer.__endIndex !== idx) {
              prevLayer.__dirty = true;
            }
            prevLayer.__endIndex = idx;
          }
        }
        if (this._singleCanvas) {
          for (var i = 1; i < list.length; i++) {
            var el = list[i];
            if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
              this._needsManuallyCompositing = true;
              break;
            }
          }
        }
        var prevLayer = null;
        var incrementalLayerCount = 0;
        var prevZlevel;
        for (var i = 0; i < list.length; i++) {
          var el = list[i];
          var zlevel = el.zlevel;
          var layer;
          if (prevZlevel !== zlevel) {
            prevZlevel = zlevel;
            incrementalLayerCount = 0;
          }
          if (el.incremental) {
            layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
            layer.incremental = true;
            incrementalLayerCount = 1;
          } else {
            layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
          }
          if (!layer.__builtin__) {
            logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
          }
          if (layer !== prevLayer) {
            layer.__used = true;
            if (layer.__startIndex !== i) {
              layer.__dirty = true;
            }
            layer.__startIndex = i;
            if (!layer.incremental) {
              layer.__drawIndex = i;
            } else {
              layer.__drawIndex = -1;
            }
            updatePrevLayer(i);
            prevLayer = layer;
          }
          if (el.__dirty) {
            layer.__dirty = true;
            if (layer.incremental && layer.__drawIndex < 0) {
              layer.__drawIndex = i;
            }
          }
        }
        updatePrevLayer(i);
        this.eachBuiltinLayer(function(layer2, z) {
          if (!layer2.__used && layer2.getElementCount() > 0) {
            layer2.__dirty = true;
            layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
          }
          if (layer2.__dirty && layer2.__drawIndex < 0) {
            layer2.__drawIndex = layer2.__startIndex;
          }
        });
      },
      /**
       * 清除hover层外所有内容
       */
      clear: function() {
        this.eachBuiltinLayer(this._clearLayer);
        return this;
      },
      _clearLayer: function(layer) {
        layer.clear();
      },
      setBackgroundColor: function(backgroundColor) {
        this._backgroundColor = backgroundColor;
      },
      /**
       * 修改指定zlevel的绘制参数
       *
       * @param {string} zlevel
       * @param {Object} config 配置对象
       * @param {string} [config.clearColor=0] 每次清空画布的颜色
       * @param {string} [config.motionBlur=false] 是否开启动态模糊
       * @param {number} [config.lastFrameAlpha=0.7]
       *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
       */
      configLayer: function(zlevel, config) {
        if (config) {
          var layerConfig = this._layerConfig;
          if (!layerConfig[zlevel]) {
            layerConfig[zlevel] = config;
          } else {
            util.merge(layerConfig[zlevel], config, true);
          }
          for (var i = 0; i < this._zlevelList.length; i++) {
            var _zlevel = this._zlevelList[i];
            if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
              var layer = this._layers[_zlevel];
              util.merge(layer, layerConfig[zlevel], true);
            }
          }
        }
      },
      /**
       * 删除指定层
       * @param {number} zlevel 层所在的zlevel
       */
      delLayer: function(zlevel) {
        var layers = this._layers;
        var zlevelList = this._zlevelList;
        var layer = layers[zlevel];
        if (!layer) {
          return;
        }
        layer.dom.parentNode.removeChild(layer.dom);
        delete layers[zlevel];
        zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
      },
      /**
       * 区域大小变化后重绘
       */
      resize: function(width, height) {
        if (!this._domRoot.style) {
          if (width == null || height == null) {
            return;
          }
          this._width = width;
          this._height = height;
          this.getLayer(CANVAS_ZLEVEL).resize(width, height);
        } else {
          var domRoot = this._domRoot;
          domRoot.style.display = "none";
          var opts = this._opts;
          width != null && (opts.width = width);
          height != null && (opts.height = height);
          width = this._getSize(0);
          height = this._getSize(1);
          domRoot.style.display = "";
          if (this._width !== width || height !== this._height) {
            domRoot.style.width = width + "px";
            domRoot.style.height = height + "px";
            for (var id in this._layers) {
              if (this._layers.hasOwnProperty(id)) {
                this._layers[id].resize(width, height);
              }
            }
            util.each(this._progressiveLayers, function(layer) {
              layer.resize(width, height);
            });
            this.refresh(true);
          }
          this._width = width;
          this._height = height;
        }
        return this;
      },
      /**
       * 清除单独的一个层
       * @param {number} zlevel
       */
      clearLayer: function(zlevel) {
        var layer = this._layers[zlevel];
        if (layer) {
          layer.clear();
        }
      },
      /**
       * 释放
       */
      dispose: function() {
        this.root.innerHTML = "";
        this.root = this.storage = this._domRoot = this._layers = null;
      },
      /**
       * Get canvas which has all thing rendered
       * @param {Object} opts
       * @param {string} [opts.backgroundColor]
       * @param {number} [opts.pixelRatio]
       */
      getRenderedCanvas: function(opts) {
        opts = opts || {};
        if (this._singleCanvas && !this._compositeManually) {
          return this._layers[CANVAS_ZLEVEL].dom;
        }
        var imageLayer = new Layer("image", this, opts.pixelRatio || this.dpr);
        imageLayer.initContext();
        imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
        if (opts.pixelRatio <= this.dpr) {
          this.refresh();
          var width = imageLayer.dom.width;
          var height = imageLayer.dom.height;
          var ctx = imageLayer.ctx;
          this.eachLayer(function(layer) {
            if (layer.__builtin__) {
              ctx.drawImage(layer.dom, 0, 0, width, height);
            } else if (layer.renderToCanvas) {
              imageLayer.ctx.save();
              layer.renderToCanvas(imageLayer.ctx);
              imageLayer.ctx.restore();
            }
          });
        } else {
          var scope = {};
          var displayList = this.storage.getDisplayList(true);
          for (var i = 0; i < displayList.length; i++) {
            var el = displayList[i];
            this._doPaintEl(el, imageLayer, true, scope);
          }
        }
        return imageLayer.dom;
      },
      /**
       * 获取绘图区域宽度
       */
      getWidth: function() {
        return this._width;
      },
      /**
       * 获取绘图区域高度
       */
      getHeight: function() {
        return this._height;
      },
      _getSize: function(whIdx) {
        var opts = this._opts;
        var wh = ["width", "height"][whIdx];
        var cwh = ["clientWidth", "clientHeight"][whIdx];
        var plt = ["paddingLeft", "paddingTop"][whIdx];
        var prb = ["paddingRight", "paddingBottom"][whIdx];
        if (opts[wh] != null && opts[wh] !== "auto") {
          return parseFloat(opts[wh]);
        }
        var root = this.root;
        var stl = document.defaultView.getComputedStyle(root);
        return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
      },
      pathToImage: function(path, dpr) {
        dpr = dpr || this.dpr;
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        var rect = path.getBoundingRect();
        var style = path.style;
        var shadowBlurSize = style.shadowBlur * dpr;
        var shadowOffsetX = style.shadowOffsetX * dpr;
        var shadowOffsetY = style.shadowOffsetY * dpr;
        var lineWidth = style.hasStroke() ? style.lineWidth : 0;
        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
        var width = rect.width + leftMargin + rightMargin;
        var height = rect.height + topMargin + bottomMargin;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);
        ctx.dpr = dpr;
        var pathTransform = {
          position: path.position,
          rotation: path.rotation,
          scale: path.scale
        };
        path.position = [leftMargin - rect.x, topMargin - rect.y];
        path.rotation = 0;
        path.scale = [1, 1];
        path.updateTransform();
        if (path) {
          path.brush(ctx);
        }
        var ImageShape = Image2;
        var imgShape = new ImageShape({
          style: {
            x: 0,
            y: 0,
            image: canvas
          }
        });
        if (pathTransform.position != null) {
          imgShape.position = path.position = pathTransform.position;
        }
        if (pathTransform.rotation != null) {
          imgShape.rotation = path.rotation = pathTransform.rotation;
        }
        if (pathTransform.scale != null) {
          imgShape.scale = path.scale = pathTransform.scale;
        }
        return imgShape;
      }
    };
    var _default = Painter;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/Animation.js
var require_Animation = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/animation/Animation.js"(exports, module) {
    var util = require_util();
    var _event = require_event();
    var Dispatcher = _event.Dispatcher;
    var requestAnimationFrame = require_requestAnimationFrame();
    var Animator = require_Animator();
    var Animation = function(options) {
      options = options || {};
      this.stage = options.stage || {};
      this.onframe = options.onframe || function() {
      };
      this._clips = [];
      this._running = false;
      this._time;
      this._pausedTime;
      this._pauseStart;
      this._paused = false;
      Dispatcher.call(this);
    };
    Animation.prototype = {
      constructor: Animation,
      /**
       * Add clip
       * @param {module:zrender/animation/Clip} clip
       */
      addClip: function(clip) {
        this._clips.push(clip);
      },
      /**
       * Add animator
       * @param {module:zrender/animation/Animator} animator
       */
      addAnimator: function(animator) {
        animator.animation = this;
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
          this.addClip(clips[i]);
        }
      },
      /**
       * Delete animation clip
       * @param {module:zrender/animation/Clip} clip
       */
      removeClip: function(clip) {
        var idx = util.indexOf(this._clips, clip);
        if (idx >= 0) {
          this._clips.splice(idx, 1);
        }
      },
      /**
       * Delete animation clip
       * @param {module:zrender/animation/Animator} animator
       */
      removeAnimator: function(animator) {
        var clips = animator.getClips();
        for (var i = 0; i < clips.length; i++) {
          this.removeClip(clips[i]);
        }
        animator.animation = null;
      },
      _update: function() {
        var time = (/* @__PURE__ */ new Date()).getTime() - this._pausedTime;
        var delta = time - this._time;
        var clips = this._clips;
        var len = clips.length;
        var deferredEvents = [];
        var deferredClips = [];
        for (var i = 0; i < len; i++) {
          var clip = clips[i];
          var e = clip.step(time, delta);
          if (e) {
            deferredEvents.push(e);
            deferredClips.push(clip);
          }
        }
        for (var i = 0; i < len; ) {
          if (clips[i]._needsRemove) {
            clips[i] = clips[len - 1];
            clips.pop();
            len--;
          } else {
            i++;
          }
        }
        len = deferredEvents.length;
        for (var i = 0; i < len; i++) {
          deferredClips[i].fire(deferredEvents[i]);
        }
        this._time = time;
        this.onframe(delta);
        this.trigger("frame", delta);
        if (this.stage.update) {
          this.stage.update();
        }
      },
      _startLoop: function() {
        var self2 = this;
        this._running = true;
        function step() {
          if (self2._running) {
            requestAnimationFrame(step);
            !self2._paused && self2._update();
          }
        }
        requestAnimationFrame(step);
      },
      /**
       * Start animation.
       */
      start: function() {
        this._time = (/* @__PURE__ */ new Date()).getTime();
        this._pausedTime = 0;
        this._startLoop();
      },
      /**
       * Stop animation.
       */
      stop: function() {
        this._running = false;
      },
      /**
       * Pause animation.
       */
      pause: function() {
        if (!this._paused) {
          this._pauseStart = (/* @__PURE__ */ new Date()).getTime();
          this._paused = true;
        }
      },
      /**
       * Resume animation.
       */
      resume: function() {
        if (this._paused) {
          this._pausedTime += (/* @__PURE__ */ new Date()).getTime() - this._pauseStart;
          this._paused = false;
        }
      },
      /**
       * Clear animation.
       */
      clear: function() {
        this._clips = [];
      },
      /**
       * Whether animation finished.
       */
      isFinished: function() {
        return !this._clips.length;
      },
      /**
       * Creat animator for a target, whose props can be animated.
       *
       * @param  {Object} target
       * @param  {Object} options
       * @param  {boolean} [options.loop=false] Whether loop animation.
       * @param  {Function} [options.getter=null] Get value from target.
       * @param  {Function} [options.setter=null] Set value to target.
       * @return {module:zrender/animation/Animation~Animator}
       */
      // TODO Gap
      animate: function(target, options) {
        options = options || {};
        var animator = new Animator(target, options.loop, options.getter, options.setter);
        this.addAnimator(animator);
        return animator;
      }
    };
    util.mixin(Animation, Dispatcher);
    var _default = Animation;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/dom/HandlerProxy.js
var require_HandlerProxy = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/dom/HandlerProxy.js"(exports, module) {
    var _event = require_event();
    var addEventListener = _event.addEventListener;
    var removeEventListener = _event.removeEventListener;
    var normalizeEvent = _event.normalizeEvent;
    var getNativeEvent = _event.getNativeEvent;
    var zrUtil = require_util();
    var Eventful = require_Eventful();
    var env = require_env();
    var TOUCH_CLICK_DELAY = 300;
    var globalEventSupported = env.domSupported;
    var localNativeListenerNames = function() {
      var mouseHandlerNames = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
      var touchHandlerNames = ["touchstart", "touchend", "touchmove"];
      var pointerEventNameMap = {
        pointerdown: 1,
        pointerup: 1,
        pointermove: 1,
        pointerout: 1
      };
      var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function(name2) {
        var nm = name2.replace("mouse", "pointer");
        return pointerEventNameMap.hasOwnProperty(nm) ? nm : name2;
      });
      return {
        mouse: mouseHandlerNames,
        touch: touchHandlerNames,
        pointer: pointerHandlerNames
      };
    }();
    var globalNativeListenerNames = {
      mouse: ["mousemove", "mouseup"],
      pointer: ["pointermove", "pointerup"]
    };
    function eventNameFix(name2) {
      return name2 === "mousewheel" && env.browser.firefox ? "DOMMouseScroll" : name2;
    }
    function isPointerFromTouch(event) {
      var pointerType = event.pointerType;
      return pointerType === "pen" || pointerType === "touch";
    }
    function setTouchTimer(scope) {
      scope.touching = true;
      if (scope.touchTimer != null) {
        clearTimeout(scope.touchTimer);
        scope.touchTimer = null;
      }
      scope.touchTimer = setTimeout(function() {
        scope.touching = false;
        scope.touchTimer = null;
      }, 700);
    }
    function markTouch(event) {
      event && (event.zrByTouch = true);
    }
    function normalizeGlobalEvent(instance, event) {
      return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
    }
    function isLocalEl(instance, el) {
      var elTmp = el;
      var isLocal = false;
      while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
        elTmp = elTmp.parentNode;
      }
      return isLocal;
    }
    function FakeGlobalEvent(instance, event) {
      this.type = event.type;
      this.target = this.currentTarget = instance.dom;
      this.pointerType = event.pointerType;
      this.clientX = event.clientX;
      this.clientY = event.clientY;
    }
    var fakeGlobalEventProto = FakeGlobalEvent.prototype;
    fakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;
    var localDOMHandlers = {
      mousedown: function(event) {
        event = normalizeEvent(this.dom, event);
        this._mayPointerCapture = [event.zrX, event.zrY];
        this.trigger("mousedown", event);
      },
      mousemove: function(event) {
        event = normalizeEvent(this.dom, event);
        var downPoint = this._mayPointerCapture;
        if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
          togglePointerCapture(this, true);
        }
        this.trigger("mousemove", event);
      },
      mouseup: function(event) {
        event = normalizeEvent(this.dom, event);
        togglePointerCapture(this, false);
        this.trigger("mouseup", event);
      },
      mouseout: function(event) {
        event = normalizeEvent(this.dom, event);
        if (this._pointerCapturing) {
          event.zrEventControl = "no_globalout";
        }
        var element = event.toElement || event.relatedTarget;
        event.zrIsToLocalDOM = isLocalEl(this, element);
        this.trigger("mouseout", event);
      },
      touchstart: function(event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this._lastTouchMoment = /* @__PURE__ */ new Date();
        this.handler.processGesture(event, "start");
        localDOMHandlers.mousemove.call(this, event);
        localDOMHandlers.mousedown.call(this, event);
      },
      touchmove: function(event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, "change");
        localDOMHandlers.mousemove.call(this, event);
      },
      touchend: function(event) {
        event = normalizeEvent(this.dom, event);
        markTouch(event);
        this.handler.processGesture(event, "end");
        localDOMHandlers.mouseup.call(this, event);
        if (+/* @__PURE__ */ new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
          localDOMHandlers.click.call(this, event);
        }
      },
      pointerdown: function(event) {
        localDOMHandlers.mousedown.call(this, event);
      },
      pointermove: function(event) {
        if (!isPointerFromTouch(event)) {
          localDOMHandlers.mousemove.call(this, event);
        }
      },
      pointerup: function(event) {
        localDOMHandlers.mouseup.call(this, event);
      },
      pointerout: function(event) {
        if (!isPointerFromTouch(event)) {
          localDOMHandlers.mouseout.call(this, event);
        }
      }
    };
    zrUtil.each(["click", "mousewheel", "dblclick", "contextmenu"], function(name2) {
      localDOMHandlers[name2] = function(event) {
        event = normalizeEvent(this.dom, event);
        this.trigger(name2, event);
      };
    });
    var globalDOMHandlers = {
      pointermove: function(event) {
        if (!isPointerFromTouch(event)) {
          globalDOMHandlers.mousemove.call(this, event);
        }
      },
      pointerup: function(event) {
        globalDOMHandlers.mouseup.call(this, event);
      },
      mousemove: function(event) {
        this.trigger("mousemove", event);
      },
      mouseup: function(event) {
        var pointerCaptureReleasing = this._pointerCapturing;
        togglePointerCapture(this, false);
        this.trigger("mouseup", event);
        if (pointerCaptureReleasing) {
          event.zrEventControl = "only_globalout";
          this.trigger("mouseout", event);
        }
      }
    };
    function mountLocalDOMEventListeners(instance, scope) {
      var domHandlers = scope.domHandlers;
      if (env.pointerEventsSupported) {
        zrUtil.each(localNativeListenerNames.pointer, function(nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function(event) {
            domHandlers[nativeEventName].call(instance, event);
          });
        });
      } else {
        if (env.touchEventsSupported) {
          zrUtil.each(localNativeListenerNames.touch, function(nativeEventName) {
            mountSingleDOMEventListener(scope, nativeEventName, function(event) {
              domHandlers[nativeEventName].call(instance, event);
              setTouchTimer(scope);
            });
          });
        }
        zrUtil.each(localNativeListenerNames.mouse, function(nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function(event) {
            event = getNativeEvent(event);
            if (!scope.touching) {
              domHandlers[nativeEventName].call(instance, event);
            }
          });
        });
      }
    }
    function mountGlobalDOMEventListeners(instance, scope) {
      if (env.pointerEventsSupported) {
        zrUtil.each(globalNativeListenerNames.pointer, mount);
      } else if (!env.touchEventsSupported) {
        zrUtil.each(globalNativeListenerNames.mouse, mount);
      }
      function mount(nativeEventName) {
        function nativeEventListener(event) {
          event = getNativeEvent(event);
          if (!isLocalEl(instance, event.target)) {
            event = normalizeGlobalEvent(instance, event);
            scope.domHandlers[nativeEventName].call(instance, event);
          }
        }
        mountSingleDOMEventListener(
          scope,
          nativeEventName,
          nativeEventListener,
          {
            capture: true
          }
          // See [Drag Outside] in `Handler.js`
        );
      }
    }
    function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
      scope.mounted[nativeEventName] = listener;
      scope.listenerOpts[nativeEventName] = opt;
      addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);
    }
    function unmountDOMEventListeners(scope) {
      var mounted = scope.mounted;
      for (var nativeEventName in mounted) {
        if (mounted.hasOwnProperty(nativeEventName)) {
          removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
        }
      }
      scope.mounted = {};
    }
    function togglePointerCapture(instance, isPointerCapturing) {
      instance._mayPointerCapture = null;
      if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {
        instance._pointerCapturing = isPointerCapturing;
        var globalHandlerScope = instance._globalHandlerScope;
        isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
      }
    }
    function DOMHandlerScope(domTarget, domHandlers) {
      this.domTarget = domTarget;
      this.domHandlers = domHandlers;
      this.mounted = {};
      this.listenerOpts = {};
      this.touchTimer = null;
      this.touching = false;
    }
    function HandlerDomProxy(dom, painterRoot) {
      Eventful.call(this);
      this.dom = dom;
      this.painterRoot = painterRoot;
      this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
      if (globalEventSupported) {
        this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
      }
      this._pointerCapturing = false;
      this._mayPointerCapture = null;
      mountLocalDOMEventListeners(this, this._localHandlerScope);
    }
    var handlerDomProxyProto = HandlerDomProxy.prototype;
    handlerDomProxyProto.dispose = function() {
      unmountDOMEventListeners(this._localHandlerScope);
      if (globalEventSupported) {
        unmountDOMEventListeners(this._globalHandlerScope);
      }
    };
    handlerDomProxyProto.setCursor = function(cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
    };
    zrUtil.mixin(HandlerDomProxy, Eventful);
    var _default = HandlerDomProxy;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/zrender.js
var require_zrender = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/zrender.js"(exports) {
    var guid = require_guid();
    var env = require_env();
    var zrUtil = require_util();
    var Handler = require_Handler();
    var Storage = require_Storage();
    var Painter = require_Painter();
    var Animation = require_Animation();
    var HandlerProxy = require_HandlerProxy();
    var useVML = !env.canvasSupported;
    var painterCtors = {
      canvas: Painter
    };
    var instances = {};
    var version = "4.3.2";
    function init(dom, opts) {
      var zr = new ZRender(guid(), dom, opts);
      instances[zr.id] = zr;
      return zr;
    }
    function dispose(zr) {
      if (zr) {
        zr.dispose();
      } else {
        for (var key in instances) {
          if (instances.hasOwnProperty(key)) {
            instances[key].dispose();
          }
        }
        instances = {};
      }
      return this;
    }
    function getInstance(id) {
      return instances[id];
    }
    function registerPainter(name2, Ctor) {
      painterCtors[name2] = Ctor;
    }
    function delInstance(id) {
      delete instances[id];
    }
    var ZRender = function(id, dom, opts) {
      opts = opts || {};
      this.dom = dom;
      this.id = id;
      var self2 = this;
      var storage = new Storage();
      var rendererType = opts.renderer;
      if (useVML) {
        if (!painterCtors.vml) {
          throw new Error("You need to require 'zrender/vml/vml' to support IE8");
        }
        rendererType = "vml";
      } else if (!rendererType || !painterCtors[rendererType]) {
        rendererType = "canvas";
      }
      var painter = new painterCtors[rendererType](dom, storage, opts, id);
      this.storage = storage;
      this.painter = painter;
      var handerProxy = !env.node && !env.worker ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
      this.handler = new Handler(storage, painter, handerProxy, painter.root);
      this.animation = new Animation({
        stage: {
          update: zrUtil.bind(this.flush, this)
        }
      });
      this.animation.start();
      this._needsRefresh;
      var oldDelFromStorage = storage.delFromStorage;
      var oldAddToStorage = storage.addToStorage;
      storage.delFromStorage = function(el) {
        oldDelFromStorage.call(storage, el);
        el && el.removeSelfFromZr(self2);
      };
      storage.addToStorage = function(el) {
        oldAddToStorage.call(storage, el);
        el.addSelfToZr(self2);
      };
    };
    ZRender.prototype = {
      constructor: ZRender,
      /**
       * 获取实例唯一标识
       * @return {string}
       */
      getId: function() {
        return this.id;
      },
      /**
       * 添加元素
       * @param  {module:zrender/Element} el
       */
      add: function(el) {
        this.storage.addRoot(el);
        this._needsRefresh = true;
      },
      /**
       * 删除元素
       * @param  {module:zrender/Element} el
       */
      remove: function(el) {
        this.storage.delRoot(el);
        this._needsRefresh = true;
      },
      /**
       * Change configuration of layer
       * @param {string} zLevel
       * @param {Object} config
       * @param {string} [config.clearColor=0] Clear color
       * @param {string} [config.motionBlur=false] If enable motion blur
       * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
      */
      configLayer: function(zLevel, config) {
        if (this.painter.configLayer) {
          this.painter.configLayer(zLevel, config);
        }
        this._needsRefresh = true;
      },
      /**
       * Set background color
       * @param {string} backgroundColor
       */
      setBackgroundColor: function(backgroundColor) {
        if (this.painter.setBackgroundColor) {
          this.painter.setBackgroundColor(backgroundColor);
        }
        this._needsRefresh = true;
      },
      /**
       * Repaint the canvas immediately
       */
      refreshImmediately: function() {
        this._needsRefresh = this._needsRefreshHover = false;
        this.painter.refresh();
        this._needsRefresh = this._needsRefreshHover = false;
      },
      /**
       * Mark and repaint the canvas in the next frame of browser
       */
      refresh: function() {
        this._needsRefresh = true;
      },
      /**
       * Perform all refresh
       */
      flush: function() {
        var triggerRendered;
        if (this._needsRefresh) {
          triggerRendered = true;
          this.refreshImmediately();
        }
        if (this._needsRefreshHover) {
          triggerRendered = true;
          this.refreshHoverImmediately();
        }
        triggerRendered && this.trigger("rendered");
      },
      /**
       * Add element to hover layer
       * @param  {module:zrender/Element} el
       * @param {Object} style
       */
      addHover: function(el, style) {
        if (this.painter.addHover) {
          var elMirror = this.painter.addHover(el, style);
          this.refreshHover();
          return elMirror;
        }
      },
      /**
       * Add element from hover layer
       * @param  {module:zrender/Element} el
       */
      removeHover: function(el) {
        if (this.painter.removeHover) {
          this.painter.removeHover(el);
          this.refreshHover();
        }
      },
      /**
       * Clear all hover elements in hover layer
       * @param  {module:zrender/Element} el
       */
      clearHover: function() {
        if (this.painter.clearHover) {
          this.painter.clearHover();
          this.refreshHover();
        }
      },
      /**
       * Refresh hover in next frame
       */
      refreshHover: function() {
        this._needsRefreshHover = true;
      },
      /**
       * Refresh hover immediately
       */
      refreshHoverImmediately: function() {
        this._needsRefreshHover = false;
        this.painter.refreshHover && this.painter.refreshHover();
      },
      /**
       * Resize the canvas.
       * Should be invoked when container size is changed
       * @param {Object} [opts]
       * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
       * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
       */
      resize: function(opts) {
        opts = opts || {};
        this.painter.resize(opts.width, opts.height);
        this.handler.resize();
      },
      /**
       * Stop and clear all animation immediately
       */
      clearAnimation: function() {
        this.animation.clear();
      },
      /**
       * Get container width
       */
      getWidth: function() {
        return this.painter.getWidth();
      },
      /**
       * Get container height
       */
      getHeight: function() {
        return this.painter.getHeight();
      },
      /**
       * Export the canvas as Base64 URL
       * @param {string} type
       * @param {string} [backgroundColor='#fff']
       * @return {string} Base64 URL
       */
      // toDataURL: function(type, backgroundColor) {
      //     return this.painter.getRenderedCanvas({
      //         backgroundColor: backgroundColor
      //     }).toDataURL(type);
      // },
      /**
       * Converting a path to image.
       * It has much better performance of drawing image rather than drawing a vector path.
       * @param {module:zrender/graphic/Path} e
       * @param {number} width
       * @param {number} height
       */
      pathToImage: function(e, dpr) {
        return this.painter.pathToImage(e, dpr);
      },
      /**
       * Set default cursor
       * @param {string} [cursorStyle='default'] 例如 crosshair
       */
      setCursorStyle: function(cursorStyle) {
        this.handler.setCursorStyle(cursorStyle);
      },
      /**
       * Find hovered element
       * @param {number} x
       * @param {number} y
       * @return {Object} {target, topTarget}
       */
      findHover: function(x, y) {
        return this.handler.findHover(x, y);
      },
      /**
       * Bind event
       *
       * @param {string} eventName Event name
       * @param {Function} eventHandler Handler function
       * @param {Object} [context] Context object
       */
      on: function(eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
      },
      /**
       * Unbind event
       * @param {string} eventName Event name
       * @param {Function} [eventHandler] Handler function
       */
      off: function(eventName, eventHandler) {
        this.handler.off(eventName, eventHandler);
      },
      /**
       * Trigger event manually
       *
       * @param {string} eventName Event name
       * @param {event=} event Event object
       */
      trigger: function(eventName, event) {
        this.handler.trigger(eventName, event);
      },
      /**
       * Clear all objects and the canvas.
       */
      clear: function() {
        this.storage.delRoot();
        this.painter.clear();
      },
      /**
       * Dispose self.
       */
      dispose: function() {
        this.animation.stop();
        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();
        this.animation = this.storage = this.painter = this.handler = null;
        delInstance(this.id);
      }
    };
    exports.version = version;
    exports.init = init;
    exports.dispose = dispose;
    exports.getInstance = getInstance;
    exports.registerPainter = registerPainter;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/model.js
var require_model = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/model.js"(exports) {
    var zrUtil = require_util();
    var env = require_env();
    var each = zrUtil.each;
    var isObject = zrUtil.isObject;
    var isArray = zrUtil.isArray;
    var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
    function normalizeToArray(value) {
      return value instanceof Array ? value : value == null ? [] : [value];
    }
    function defaultEmphasis(opt, key, subOpts) {
      if (opt) {
        opt[key] = opt[key] || {};
        opt.emphasis = opt.emphasis || {};
        opt.emphasis[key] = opt.emphasis[key] || {};
        for (var i = 0, len = subOpts.length; i < len; i++) {
          var subOptName = subOpts[i];
          if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
            opt.emphasis[key][subOptName] = opt[key][subOptName];
          }
        }
      }
    }
    var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
    function getDataItemValue(dataItem) {
      return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
    }
    function isDataItemOption(dataItem) {
      return isObject(dataItem) && !(dataItem instanceof Array);
    }
    function mappingToExists(exists, newCptOptions) {
      newCptOptions = (newCptOptions || []).slice();
      var result = zrUtil.map(exists || [], function(obj, index) {
        return {
          exist: obj
        };
      });
      each(newCptOptions, function(cptOption, index) {
        if (!isObject(cptOption)) {
          return;
        }
        for (var i = 0; i < result.length; i++) {
          if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + "") {
            result[i].option = cptOption;
            newCptOptions[index] = null;
            return;
          }
        }
        for (var i = 0; i < result.length; i++) {
          var exist = result[i].exist;
          if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + "") {
            result[i].option = cptOption;
            newCptOptions[index] = null;
            return;
          }
        }
      });
      each(newCptOptions, function(cptOption, index) {
        if (!isObject(cptOption)) {
          return;
        }
        var i = 0;
        for (; i < result.length; i++) {
          var exist = result[i].exist;
          if (!result[i].option && !isIdInner(exist) && cptOption.id == null) {
            result[i].option = cptOption;
            break;
          }
        }
        if (i >= result.length) {
          result.push({
            option: cptOption
          });
        }
      });
      return result;
    }
    function makeIdAndName(mapResult) {
      var idMap = zrUtil.createHashMap();
      each(mapResult, function(item, index) {
        var existCpt = item.exist;
        existCpt && idMap.set(existCpt.id, item);
      });
      each(mapResult, function(item, index) {
        var opt = item.option;
        zrUtil.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
        opt && opt.id != null && idMap.set(opt.id, item);
        !item.keyInfo && (item.keyInfo = {});
      });
      each(mapResult, function(item, index) {
        var existCpt = item.exist;
        var opt = item.option;
        var keyInfo = item.keyInfo;
        if (!isObject(opt)) {
          return;
        }
        keyInfo.name = opt.name != null ? opt.name + "" : existCpt ? existCpt.name : DUMMY_COMPONENT_NAME_PREFIX + index;
        if (existCpt) {
          keyInfo.id = existCpt.id;
        } else if (opt.id != null) {
          keyInfo.id = opt.id + "";
        } else {
          var idNum = 0;
          do {
            keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
          } while (idMap.get(keyInfo.id));
        }
        idMap.set(keyInfo.id, item);
      });
    }
    function isNameSpecified(componentModel) {
      var name2 = componentModel.name;
      return !!(name2 && name2.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
    }
    function isIdInner(cptOption) {
      return isObject(cptOption) && cptOption.id && (cptOption.id + "").indexOf("\0_ec_\0") === 0;
    }
    function compressBatches(batchA, batchB) {
      var mapA = {};
      var mapB = {};
      makeMap(batchA || [], mapA);
      makeMap(batchB || [], mapB, mapA);
      return [mapToArray(mapA), mapToArray(mapB)];
      function makeMap(sourceBatch, map, otherMap) {
        for (var i = 0, len = sourceBatch.length; i < len; i++) {
          var seriesId = sourceBatch[i].seriesId;
          var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
          var otherDataIndices = otherMap && otherMap[seriesId];
          for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
            var dataIndex = dataIndices[j];
            if (otherDataIndices && otherDataIndices[dataIndex]) {
              otherDataIndices[dataIndex] = null;
            } else {
              (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
            }
          }
        }
      }
      function mapToArray(map, isData) {
        var result = [];
        for (var i in map) {
          if (map.hasOwnProperty(i) && map[i] != null) {
            if (isData) {
              result.push(+i);
            } else {
              var dataIndices = mapToArray(map[i], true);
              dataIndices.length && result.push({
                seriesId: i,
                dataIndex: dataIndices
              });
            }
          }
        }
        return result;
      }
    }
    function queryDataIndex(data, payload) {
      if (payload.dataIndexInside != null) {
        return payload.dataIndexInside;
      } else if (payload.dataIndex != null) {
        return zrUtil.isArray(payload.dataIndex) ? zrUtil.map(payload.dataIndex, function(value) {
          return data.indexOfRawIndex(value);
        }) : data.indexOfRawIndex(payload.dataIndex);
      } else if (payload.name != null) {
        return zrUtil.isArray(payload.name) ? zrUtil.map(payload.name, function(value) {
          return data.indexOfName(value);
        }) : data.indexOfName(payload.name);
      }
    }
    function makeInner() {
      var key = "__\0ec_inner_" + innerUniqueIndex++ + "_" + Math.random().toFixed(5);
      return function(hostObj) {
        return hostObj[key] || (hostObj[key] = {});
      };
    }
    var innerUniqueIndex = 0;
    function parseFinder(ecModel, finder, opt) {
      if (zrUtil.isString(finder)) {
        var obj = {};
        obj[finder + "Index"] = 0;
        finder = obj;
      }
      var defaultMainType = opt && opt.defaultMainType;
      if (defaultMainType && !has(finder, defaultMainType + "Index") && !has(finder, defaultMainType + "Id") && !has(finder, defaultMainType + "Name")) {
        finder[defaultMainType + "Index"] = 0;
      }
      var result = {};
      each(finder, function(value, key) {
        var value = finder[key];
        if (key === "dataIndex" || key === "dataIndexInside") {
          result[key] = value;
          return;
        }
        var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
        var mainType = parsedKey[1];
        var queryType = (parsedKey[2] || "").toLowerCase();
        if (!mainType || !queryType || value == null || queryType === "index" && value === "none" || opt && opt.includeMainTypes && zrUtil.indexOf(opt.includeMainTypes, mainType) < 0) {
          return;
        }
        var queryParam = {
          mainType
        };
        if (queryType !== "index" || value !== "all") {
          queryParam[queryType] = value;
        }
        var models = ecModel.queryComponents(queryParam);
        result[mainType + "Models"] = models;
        result[mainType + "Model"] = models[0];
      });
      return result;
    }
    function has(obj, prop) {
      return obj && obj.hasOwnProperty(prop);
    }
    function setAttribute(dom, key, value) {
      dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
    }
    function getAttribute(dom, key) {
      return dom.getAttribute ? dom.getAttribute(key) : dom[key];
    }
    function getTooltipRenderMode(renderModeOption) {
      if (renderModeOption === "auto") {
        return env.domSupported ? "html" : "richText";
      } else {
        return renderModeOption || "html";
      }
    }
    function groupData(array, getKey) {
      var buckets = zrUtil.createHashMap();
      var keys = [];
      zrUtil.each(array, function(item) {
        var key = getKey(item);
        (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);
      });
      return {
        keys,
        buckets
      };
    }
    exports.normalizeToArray = normalizeToArray;
    exports.defaultEmphasis = defaultEmphasis;
    exports.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;
    exports.getDataItemValue = getDataItemValue;
    exports.isDataItemOption = isDataItemOption;
    exports.mappingToExists = mappingToExists;
    exports.makeIdAndName = makeIdAndName;
    exports.isNameSpecified = isNameSpecified;
    exports.isIdInner = isIdInner;
    exports.compressBatches = compressBatches;
    exports.queryDataIndex = queryDataIndex;
    exports.makeInner = makeInner;
    exports.parseFinder = parseFinder;
    exports.setAttribute = setAttribute;
    exports.getAttribute = getAttribute;
    exports.getTooltipRenderMode = getTooltipRenderMode;
    exports.groupData = groupData;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/clazz.js
var require_clazz = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/clazz.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var TYPE_DELIMITER = ".";
    var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
    function parseClassType(componentType) {
      var ret = {
        main: "",
        sub: ""
      };
      if (componentType) {
        componentType = componentType.split(TYPE_DELIMITER);
        ret.main = componentType[0] || "";
        ret.sub = componentType[1] || "";
      }
      return ret;
    }
    function checkClassType(componentType) {
      zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
    }
    function enableClassExtend(RootClass, mandatoryMethods) {
      RootClass.$constructor = RootClass;
      RootClass.extend = function(proto) {
        var superClass = this;
        var ExtendedClass = function() {
          if (!proto.$constructor) {
            superClass.apply(this, arguments);
          } else {
            proto.$constructor.apply(this, arguments);
          }
        };
        zrUtil.extend(ExtendedClass.prototype, proto);
        ExtendedClass.extend = this.extend;
        ExtendedClass.superCall = superCall;
        ExtendedClass.superApply = superApply;
        zrUtil.inherits(ExtendedClass, this);
        ExtendedClass.superClass = superClass;
        return ExtendedClass;
      };
    }
    var classBase = 0;
    function enableClassCheck(Clz) {
      var classAttr = ["__\0is_clz", classBase++, Math.random().toFixed(3)].join("_");
      Clz.prototype[classAttr] = true;
      Clz.isInstance = function(obj) {
        return !!(obj && obj[classAttr]);
      };
    }
    function superCall(context, methodName) {
      var args = zrUtil.slice(arguments, 2);
      return this.superClass.prototype[methodName].apply(context, args);
    }
    function superApply(context, methodName, args) {
      return this.superClass.prototype[methodName].apply(context, args);
    }
    function enableClassManagement(entity, options) {
      options = options || {};
      var storage = {};
      entity.registerClass = function(Clazz, componentType) {
        if (componentType) {
          checkClassType(componentType);
          componentType = parseClassType(componentType);
          if (!componentType.sub) {
            storage[componentType.main] = Clazz;
          } else if (componentType.sub !== IS_CONTAINER) {
            var container = makeContainer(componentType);
            container[componentType.sub] = Clazz;
          }
        }
        return Clazz;
      };
      entity.getClass = function(componentMainType, subType, throwWhenNotFound) {
        var Clazz = storage[componentMainType];
        if (Clazz && Clazz[IS_CONTAINER]) {
          Clazz = subType ? Clazz[subType] : null;
        }
        if (throwWhenNotFound && !Clazz) {
          throw new Error(!subType ? componentMainType + ".type should be specified." : "Component " + componentMainType + "." + (subType || "") + " not exists. Load it first.");
        }
        return Clazz;
      };
      entity.getClassesByMainType = function(componentType) {
        componentType = parseClassType(componentType);
        var result = [];
        var obj = storage[componentType.main];
        if (obj && obj[IS_CONTAINER]) {
          zrUtil.each(obj, function(o, type) {
            type !== IS_CONTAINER && result.push(o);
          });
        } else {
          result.push(obj);
        }
        return result;
      };
      entity.hasClass = function(componentType) {
        componentType = parseClassType(componentType);
        return !!storage[componentType.main];
      };
      entity.getAllClassMainTypes = function() {
        var types = [];
        zrUtil.each(storage, function(obj, type) {
          types.push(type);
        });
        return types;
      };
      entity.hasSubTypes = function(componentType) {
        componentType = parseClassType(componentType);
        var obj = storage[componentType.main];
        return obj && obj[IS_CONTAINER];
      };
      entity.parseClassType = parseClassType;
      function makeContainer(componentType) {
        var container = storage[componentType.main];
        if (!container || !container[IS_CONTAINER]) {
          container = storage[componentType.main] = {};
          container[IS_CONTAINER] = true;
        }
        return container;
      }
      if (options.registerWhenExtend) {
        var originalExtend = entity.extend;
        if (originalExtend) {
          entity.extend = function(proto) {
            var ExtendedClass = originalExtend.call(this, proto);
            return entity.registerClass(ExtendedClass, proto.type);
          };
        }
      }
      return entity;
    }
    function setReadOnly(obj, properties) {
    }
    exports.parseClassType = parseClassType;
    exports.enableClassExtend = enableClassExtend;
    exports.enableClassCheck = enableClassCheck;
    exports.enableClassManagement = enableClassManagement;
    exports.setReadOnly = setReadOnly;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/makeStyleMapper.js
var require_makeStyleMapper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/makeStyleMapper.js"(exports, module) {
    var zrUtil = require_util();
    function _default(properties) {
      for (var i = 0; i < properties.length; i++) {
        if (!properties[i][1]) {
          properties[i][1] = properties[i][0];
        }
      }
      return function(model, excludes, includes) {
        var style = {};
        for (var i2 = 0; i2 < properties.length; i2++) {
          var propName = properties[i2][1];
          if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {
            continue;
          }
          var val = model.getShallow(propName);
          if (val != null) {
            style[properties[i2][0]] = val;
          }
        }
        return style;
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/lineStyle.js
var require_lineStyle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/lineStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getLineStyle = makeStyleMapper([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
    var _default = {
      getLineStyle: function(excludes) {
        var style = getLineStyle(this, excludes);
        style.lineDash = this.getLineDash(style.lineWidth);
        return style;
      },
      getLineDash: function(lineWidth) {
        if (lineWidth == null) {
          lineWidth = 1;
        }
        var lineType = this.get("type");
        var dotSize = Math.max(lineWidth, 2);
        var dashSize = lineWidth * 4;
        return lineType === "solid" || lineType == null ? (
          // Use `false` but not `null` for the solid line here, because `null` might be
          // ignored when assigning to `el.style`. e.g., when setting `lineStyle.type` as
          // `'dashed'` and `emphasis.lineStyle.type` as `'solid'` in graph series, the
          // `lineDash` gotten form the latter one is not able to erase that from the former
          // one if using `null` here according to the emhpsis strategy in `util/graphic.js`.
          false
        ) : lineType === "dashed" ? [dashSize, dashSize] : [dotSize, dotSize];
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/areaStyle.js
var require_areaStyle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/areaStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getAreaStyle = makeStyleMapper([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]);
    var _default = {
      getAreaStyle: function(excludes, includes) {
        return getAreaStyle(this, excludes, includes);
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/curve.js
var require_curve = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/curve.js"(exports) {
    var _vector = require_vector();
    var v2Create = _vector.create;
    var v2DistSquare = _vector.distSquare;
    var mathPow = Math.pow;
    var mathSqrt = Math.sqrt;
    var EPSILON = 1e-8;
    var EPSILON_NUMERIC = 1e-4;
    var THREE_SQRT = mathSqrt(3);
    var ONE_THIRD = 1 / 3;
    var _v0 = v2Create();
    var _v1 = v2Create();
    var _v2 = v2Create();
    function isAroundZero(val) {
      return val > -EPSILON && val < EPSILON;
    }
    function isNotAroundZero(val) {
      return val > EPSILON || val < -EPSILON;
    }
    function cubicAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
    }
    function cubicDerivativeAt(p0, p1, p2, p3, t) {
      var onet = 1 - t;
      return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
    }
    function cubicRootAt(p0, p1, p2, p3, val, roots) {
      var a = p3 + 3 * (p1 - p2) - p0;
      var b = 3 * (p2 - p1 * 2 + p0);
      var c = 3 * (p1 - p0);
      var d = p0 - val;
      var A = b * b - 3 * a * c;
      var B = b * c - 9 * a * d;
      var C = c * c - 3 * b * d;
      var n = 0;
      if (isAroundZero(A) && isAroundZero(B)) {
        if (isAroundZero(b)) {
          roots[0] = 0;
        } else {
          var t1 = -c / b;
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = B * B - 4 * A * C;
        if (isAroundZero(disc)) {
          var K = B / A;
          var t1 = -b / a + K;
          var t2 = -K / 2;
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var Y1 = A * b + 1.5 * a * (-B + discSqrt);
          var Y2 = A * b + 1.5 * a * (-B - discSqrt);
          if (Y1 < 0) {
            Y1 = -mathPow(-Y1, ONE_THIRD);
          } else {
            Y1 = mathPow(Y1, ONE_THIRD);
          }
          if (Y2 < 0) {
            Y2 = -mathPow(-Y2, ONE_THIRD);
          } else {
            Y2 = mathPow(Y2, ONE_THIRD);
          }
          var t1 = (-b - (Y1 + Y2)) / (3 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else {
          var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
          var theta = Math.acos(T) / 3;
          var ASqrt = mathSqrt(A);
          var tmp = Math.cos(theta);
          var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
          var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
          var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
          if (t3 >= 0 && t3 <= 1) {
            roots[n++] = t3;
          }
        }
      }
      return n;
    }
    function cubicExtrema(p0, p1, p2, p3, extrema) {
      var b = 6 * p2 - 12 * p1 + 6 * p0;
      var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
      var c = 3 * p1 - 3 * p0;
      var n = 0;
      if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
          var t1 = -c / b;
          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
          extrema[0] = -b / (2 * a);
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);
          if (t1 >= 0 && t1 <= 1) {
            extrema[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            extrema[n++] = t2;
          }
        }
      }
      return n;
    }
    function cubicSubdivide(p0, p1, p2, p3, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p23 = (p3 - p2) * t + p2;
      var p012 = (p12 - p01) * t + p01;
      var p123 = (p23 - p12) * t + p12;
      var p0123 = (p123 - p012) * t + p012;
      out[0] = p0;
      out[1] = p01;
      out[2] = p012;
      out[3] = p0123;
      out[4] = p0123;
      out[5] = p123;
      out[6] = p23;
      out[7] = p3;
    }
    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
      var t;
      var interval = 5e-3;
      var d = Infinity;
      var prev;
      var next;
      var d1;
      var d2;
      _v0[0] = x;
      _v0[1] = y;
      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
        d1 = v2DistSquare(_v0, _v1);
        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }
      d = Infinity;
      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }
        prev = t - interval;
        next = t + interval;
        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
        _v1[1] = cubicAt(y0, y1, y2, y3, prev);
        d1 = v2DistSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          _v2[0] = cubicAt(x0, x1, x2, x3, next);
          _v2[1] = cubicAt(y0, y1, y2, y3, next);
          d2 = v2DistSquare(_v2, _v0);
          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      }
      if (out) {
        out[0] = cubicAt(x0, x1, x2, x3, t);
        out[1] = cubicAt(y0, y1, y2, y3, t);
      }
      return mathSqrt(d);
    }
    function quadraticAt(p0, p1, p2, t) {
      var onet = 1 - t;
      return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }
    function quadraticDerivativeAt(p0, p1, p2, t) {
      return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }
    function quadraticRootAt(p0, p1, p2, val, roots) {
      var a = p0 - 2 * p1 + p2;
      var b = 2 * (p1 - p0);
      var c = p0 - val;
      var n = 0;
      if (isAroundZero(a)) {
        if (isNotAroundZero(b)) {
          var t1 = -c / b;
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        }
      } else {
        var disc = b * b - 4 * a * c;
        if (isAroundZero(disc)) {
          var t1 = -b / (2 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
        } else if (disc > 0) {
          var discSqrt = mathSqrt(disc);
          var t1 = (-b + discSqrt) / (2 * a);
          var t2 = (-b - discSqrt) / (2 * a);
          if (t1 >= 0 && t1 <= 1) {
            roots[n++] = t1;
          }
          if (t2 >= 0 && t2 <= 1) {
            roots[n++] = t2;
          }
        }
      }
      return n;
    }
    function quadraticExtremum(p0, p1, p2) {
      var divider = p0 + p2 - 2 * p1;
      if (divider === 0) {
        return 0.5;
      } else {
        return (p0 - p1) / divider;
      }
    }
    function quadraticSubdivide(p0, p1, p2, t, out) {
      var p01 = (p1 - p0) * t + p0;
      var p12 = (p2 - p1) * t + p1;
      var p012 = (p12 - p01) * t + p01;
      out[0] = p0;
      out[1] = p01;
      out[2] = p012;
      out[3] = p012;
      out[4] = p12;
      out[5] = p2;
    }
    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
      var t;
      var interval = 5e-3;
      var d = Infinity;
      _v0[0] = x;
      _v0[1] = y;
      for (var _t = 0; _t < 1; _t += 0.05) {
        _v1[0] = quadraticAt(x0, x1, x2, _t);
        _v1[1] = quadraticAt(y0, y1, y2, _t);
        var d1 = v2DistSquare(_v0, _v1);
        if (d1 < d) {
          t = _t;
          d = d1;
        }
      }
      d = Infinity;
      for (var i = 0; i < 32; i++) {
        if (interval < EPSILON_NUMERIC) {
          break;
        }
        var prev = t - interval;
        var next = t + interval;
        _v1[0] = quadraticAt(x0, x1, x2, prev);
        _v1[1] = quadraticAt(y0, y1, y2, prev);
        var d1 = v2DistSquare(_v1, _v0);
        if (prev >= 0 && d1 < d) {
          t = prev;
          d = d1;
        } else {
          _v2[0] = quadraticAt(x0, x1, x2, next);
          _v2[1] = quadraticAt(y0, y1, y2, next);
          var d2 = v2DistSquare(_v2, _v0);
          if (next <= 1 && d2 < d) {
            t = next;
            d = d2;
          } else {
            interval *= 0.5;
          }
        }
      }
      if (out) {
        out[0] = quadraticAt(x0, x1, x2, t);
        out[1] = quadraticAt(y0, y1, y2, t);
      }
      return mathSqrt(d);
    }
    exports.cubicAt = cubicAt;
    exports.cubicDerivativeAt = cubicDerivativeAt;
    exports.cubicRootAt = cubicRootAt;
    exports.cubicExtrema = cubicExtrema;
    exports.cubicSubdivide = cubicSubdivide;
    exports.cubicProjectPoint = cubicProjectPoint;
    exports.quadraticAt = quadraticAt;
    exports.quadraticDerivativeAt = quadraticDerivativeAt;
    exports.quadraticRootAt = quadraticRootAt;
    exports.quadraticExtremum = quadraticExtremum;
    exports.quadraticSubdivide = quadraticSubdivide;
    exports.quadraticProjectPoint = quadraticProjectPoint;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/bbox.js
var require_bbox = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/bbox.js"(exports) {
    var vec2 = require_vector();
    var curve = require_curve();
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI2 = Math.PI * 2;
    var start = vec2.create();
    var end = vec2.create();
    var extremity = vec2.create();
    function fromPoints(points, min, max) {
      if (points.length === 0) {
        return;
      }
      var p = points[0];
      var left = p[0];
      var right = p[0];
      var top = p[1];
      var bottom = p[1];
      var i;
      for (i = 1; i < points.length; i++) {
        p = points[i];
        left = mathMin(left, p[0]);
        right = mathMax(right, p[0]);
        top = mathMin(top, p[1]);
        bottom = mathMax(bottom, p[1]);
      }
      min[0] = left;
      min[1] = top;
      max[0] = right;
      max[1] = bottom;
    }
    function fromLine(x0, y0, x1, y1, min, max) {
      min[0] = mathMin(x0, x1);
      min[1] = mathMin(y0, y1);
      max[0] = mathMax(x0, x1);
      max[1] = mathMax(y0, y1);
    }
    var xDim = [];
    var yDim = [];
    function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
      var cubicExtrema = curve.cubicExtrema;
      var cubicAt = curve.cubicAt;
      var i;
      var n = cubicExtrema(x0, x1, x2, x3, xDim);
      min[0] = Infinity;
      min[1] = Infinity;
      max[0] = -Infinity;
      max[1] = -Infinity;
      for (i = 0; i < n; i++) {
        var x = cubicAt(x0, x1, x2, x3, xDim[i]);
        min[0] = mathMin(x, min[0]);
        max[0] = mathMax(x, max[0]);
      }
      n = cubicExtrema(y0, y1, y2, y3, yDim);
      for (i = 0; i < n; i++) {
        var y = cubicAt(y0, y1, y2, y3, yDim[i]);
        min[1] = mathMin(y, min[1]);
        max[1] = mathMax(y, max[1]);
      }
      min[0] = mathMin(x0, min[0]);
      max[0] = mathMax(x0, max[0]);
      min[0] = mathMin(x3, min[0]);
      max[0] = mathMax(x3, max[0]);
      min[1] = mathMin(y0, min[1]);
      max[1] = mathMax(y0, max[1]);
      min[1] = mathMin(y3, min[1]);
      max[1] = mathMax(y3, max[1]);
    }
    function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
      var quadraticExtremum = curve.quadraticExtremum;
      var quadraticAt = curve.quadraticAt;
      var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
      var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
      var x = quadraticAt(x0, x1, x2, tx);
      var y = quadraticAt(y0, y1, y2, ty);
      min[0] = mathMin(x0, x2, x);
      min[1] = mathMin(y0, y2, y);
      max[0] = mathMax(x0, x2, x);
      max[1] = mathMax(y0, y2, y);
    }
    function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
      var vec2Min = vec2.min;
      var vec2Max = vec2.max;
      var diff = Math.abs(startAngle - endAngle);
      if (diff % PI2 < 1e-4 && diff > 1e-4) {
        min[0] = x - rx;
        min[1] = y - ry;
        max[0] = x + rx;
        max[1] = y + ry;
        return;
      }
      start[0] = mathCos(startAngle) * rx + x;
      start[1] = mathSin(startAngle) * ry + y;
      end[0] = mathCos(endAngle) * rx + x;
      end[1] = mathSin(endAngle) * ry + y;
      vec2Min(min, start, end);
      vec2Max(max, start, end);
      startAngle = startAngle % PI2;
      if (startAngle < 0) {
        startAngle = startAngle + PI2;
      }
      endAngle = endAngle % PI2;
      if (endAngle < 0) {
        endAngle = endAngle + PI2;
      }
      if (startAngle > endAngle && !anticlockwise) {
        endAngle += PI2;
      } else if (startAngle < endAngle && anticlockwise) {
        startAngle += PI2;
      }
      if (anticlockwise) {
        var tmp = endAngle;
        endAngle = startAngle;
        startAngle = tmp;
      }
      for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
        if (angle > startAngle) {
          extremity[0] = mathCos(angle) * rx + x;
          extremity[1] = mathSin(angle) * ry + y;
          vec2Min(min, extremity, min);
          vec2Max(max, extremity, max);
        }
      }
    }
    exports.fromPoints = fromPoints;
    exports.fromLine = fromLine;
    exports.fromCubic = fromCubic;
    exports.fromQuadratic = fromQuadratic;
    exports.fromArc = fromArc;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/PathProxy.js
var require_PathProxy = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/PathProxy.js"(exports, module) {
    var curve = require_curve();
    var vec2 = require_vector();
    var bbox = require_bbox();
    var BoundingRect = require_BoundingRect();
    var _config = require_config2();
    var dpr = _config.devicePixelRatio;
    var CMD = {
      M: 1,
      L: 2,
      C: 3,
      Q: 4,
      A: 5,
      Z: 6,
      // Rect
      R: 7
    };
    var min = [];
    var max = [];
    var min2 = [];
    var max2 = [];
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathCos = Math.cos;
    var mathSin = Math.sin;
    var mathSqrt = Math.sqrt;
    var mathAbs = Math.abs;
    var hasTypedArray = typeof Float32Array !== "undefined";
    var PathProxy = function(notSaveData) {
      this._saveData = !(notSaveData || false);
      if (this._saveData) {
        this.data = [];
      }
      this._ctx = null;
    };
    PathProxy.prototype = {
      constructor: PathProxy,
      _xi: 0,
      _yi: 0,
      _x0: 0,
      _y0: 0,
      // Unit x, Unit y. Provide for avoiding drawing that too short line segment
      _ux: 0,
      _uy: 0,
      _len: 0,
      _lineDash: null,
      _dashOffset: 0,
      _dashIdx: 0,
      _dashSum: 0,
      /**
       * @readOnly
       */
      setScale: function(sx, sy, segmentIgnoreThreshold) {
        segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
        this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;
        this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;
      },
      getContext: function() {
        return this._ctx;
      },
      /**
       * @param  {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      beginPath: function(ctx) {
        this._ctx = ctx;
        ctx && ctx.beginPath();
        ctx && (this.dpr = ctx.dpr);
        if (this._saveData) {
          this._len = 0;
        }
        if (this._lineDash) {
          this._lineDash = null;
          this._dashOffset = 0;
        }
        return this;
      },
      /**
       * @param  {number} x
       * @param  {number} y
       * @return {module:zrender/core/PathProxy}
       */
      moveTo: function(x, y) {
        this.addData(CMD.M, x, y);
        this._ctx && this._ctx.moveTo(x, y);
        this._x0 = x;
        this._y0 = y;
        this._xi = x;
        this._yi = y;
        return this;
      },
      /**
       * @param  {number} x
       * @param  {number} y
       * @return {module:zrender/core/PathProxy}
       */
      lineTo: function(x, y) {
        var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;
        this.addData(CMD.L, x, y);
        if (this._ctx && exceedUnit) {
          this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
        }
        if (exceedUnit) {
          this._xi = x;
          this._yi = y;
        }
        return this;
      },
      /**
       * @param  {number} x1
       * @param  {number} y1
       * @param  {number} x2
       * @param  {number} y2
       * @param  {number} x3
       * @param  {number} y3
       * @return {module:zrender/core/PathProxy}
       */
      bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
        if (this._ctx) {
          this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        this._xi = x3;
        this._yi = y3;
        return this;
      },
      /**
       * @param  {number} x1
       * @param  {number} y1
       * @param  {number} x2
       * @param  {number} y2
       * @return {module:zrender/core/PathProxy}
       */
      quadraticCurveTo: function(x1, y1, x2, y2) {
        this.addData(CMD.Q, x1, y1, x2, y2);
        if (this._ctx) {
          this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        this._xi = x2;
        this._yi = y2;
        return this;
      },
      /**
       * @param  {number} cx
       * @param  {number} cy
       * @param  {number} r
       * @param  {number} startAngle
       * @param  {number} endAngle
       * @param  {boolean} anticlockwise
       * @return {module:zrender/core/PathProxy}
       */
      arc: function(cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        this._xi = mathCos(endAngle) * r + cx;
        this._yi = mathSin(endAngle) * r + cy;
        return this;
      },
      // TODO
      arcTo: function(x1, y1, x2, y2, radius) {
        if (this._ctx) {
          this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
      },
      // TODO
      rect: function(x, y, w, h) {
        this._ctx && this._ctx.rect(x, y, w, h);
        this.addData(CMD.R, x, y, w, h);
        return this;
      },
      /**
       * @return {module:zrender/core/PathProxy}
       */
      closePath: function() {
        this.addData(CMD.Z);
        var ctx = this._ctx;
        var x0 = this._x0;
        var y0 = this._y0;
        if (ctx) {
          this._needsDash() && this._dashedLineTo(x0, y0);
          ctx.closePath();
        }
        this._xi = x0;
        this._yi = y0;
        return this;
      },
      /**
       * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
       * stroke 同样
       * @param {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      fill: function(ctx) {
        ctx && ctx.fill();
        this.toStatic();
      },
      /**
       * @param {CanvasRenderingContext2D} ctx
       * @return {module:zrender/core/PathProxy}
       */
      stroke: function(ctx) {
        ctx && ctx.stroke();
        this.toStatic();
      },
      /**
       * 必须在其它绘制命令前调用
       * Must be invoked before all other path drawing methods
       * @return {module:zrender/core/PathProxy}
       */
      setLineDash: function(lineDash) {
        if (lineDash instanceof Array) {
          this._lineDash = lineDash;
          this._dashIdx = 0;
          var lineDashSum = 0;
          for (var i = 0; i < lineDash.length; i++) {
            lineDashSum += lineDash[i];
          }
          this._dashSum = lineDashSum;
        }
        return this;
      },
      /**
       * 必须在其它绘制命令前调用
       * Must be invoked before all other path drawing methods
       * @return {module:zrender/core/PathProxy}
       */
      setLineDashOffset: function(offset) {
        this._dashOffset = offset;
        return this;
      },
      /**
       *
       * @return {boolean}
       */
      len: function() {
        return this._len;
      },
      /**
       * 直接设置 Path 数据
       */
      setData: function(data) {
        var len = data.length;
        if (!(this.data && this.data.length === len) && hasTypedArray) {
          this.data = new Float32Array(len);
        }
        for (var i = 0; i < len; i++) {
          this.data[i] = data[i];
        }
        this._len = len;
      },
      /**
       * 添加子路径
       * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
       */
      appendPath: function(path) {
        if (!(path instanceof Array)) {
          path = [path];
        }
        var len = path.length;
        var appendSize = 0;
        var offset = this._len;
        for (var i = 0; i < len; i++) {
          appendSize += path[i].len();
        }
        if (hasTypedArray && this.data instanceof Float32Array) {
          this.data = new Float32Array(offset + appendSize);
        }
        for (var i = 0; i < len; i++) {
          var appendPathData = path[i].data;
          for (var k = 0; k < appendPathData.length; k++) {
            this.data[offset++] = appendPathData[k];
          }
        }
        this._len = offset;
      },
      /**
       * 填充 Path 数据。
       * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
       */
      addData: function(cmd) {
        if (!this._saveData) {
          return;
        }
        var data = this.data;
        if (this._len + arguments.length > data.length) {
          this._expandData();
          data = this.data;
        }
        for (var i = 0; i < arguments.length; i++) {
          data[this._len++] = arguments[i];
        }
        this._prevCmd = cmd;
      },
      _expandData: function() {
        if (!(this.data instanceof Array)) {
          var newData = [];
          for (var i = 0; i < this._len; i++) {
            newData[i] = this.data[i];
          }
          this.data = newData;
        }
      },
      /**
       * If needs js implemented dashed line
       * @return {boolean}
       * @private
       */
      _needsDash: function() {
        return this._lineDash;
      },
      _dashedLineTo: function(x1, y1) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var dx = x1 - x0;
        var dy = y1 - y0;
        var dist = mathSqrt(dx * dx + dy * dy);
        var x = x0;
        var y = y0;
        var dash;
        var nDash = lineDash.length;
        var idx;
        dx /= dist;
        dy /= dist;
        if (offset < 0) {
          offset = dashSum + offset;
        }
        offset %= dashSum;
        x -= offset * dx;
        y -= offset * dy;
        while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
          idx = this._dashIdx;
          dash = lineDash[idx];
          x += dx * dash;
          y += dy * dash;
          this._dashIdx = (idx + 1) % nDash;
          if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
            continue;
          }
          ctx[idx % 2 ? "moveTo" : "lineTo"](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
        }
        dx = x - x1;
        dy = y - y1;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
      },
      // Not accurate dashed line to
      _dashedBezierTo: function(x1, y1, x2, y2, x3, y3) {
        var dashSum = this._dashSum;
        var offset = this._dashOffset;
        var lineDash = this._lineDash;
        var ctx = this._ctx;
        var x0 = this._xi;
        var y0 = this._yi;
        var t;
        var dx;
        var dy;
        var cubicAt = curve.cubicAt;
        var bezierLen = 0;
        var idx = this._dashIdx;
        var nDash = lineDash.length;
        var x;
        var y;
        var tmpLen = 0;
        if (offset < 0) {
          offset = dashSum + offset;
        }
        offset %= dashSum;
        for (t = 0; t < 1; t += 0.1) {
          dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
          dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
          bezierLen += mathSqrt(dx * dx + dy * dy);
        }
        for (; idx < nDash; idx++) {
          tmpLen += lineDash[idx];
          if (tmpLen > offset) {
            break;
          }
        }
        t = (tmpLen - offset) / bezierLen;
        while (t <= 1) {
          x = cubicAt(x0, x1, x2, x3, t);
          y = cubicAt(y0, y1, y2, y3, t);
          idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
          t += lineDash[idx] / bezierLen;
          idx = (idx + 1) % nDash;
        }
        idx % 2 !== 0 && ctx.lineTo(x3, y3);
        dx = x3 - x;
        dy = y3 - y;
        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
      },
      _dashedQuadraticTo: function(x1, y1, x2, y2) {
        var x3 = x2;
        var y3 = y2;
        x2 = (x2 + 2 * x1) / 3;
        y2 = (y2 + 2 * y1) / 3;
        x1 = (this._xi + 2 * x1) / 3;
        y1 = (this._yi + 2 * y1) / 3;
        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
      },
      /**
       * 转成静态的 Float32Array 减少堆内存占用
       * Convert dynamic array to static Float32Array
       */
      toStatic: function() {
        var data = this.data;
        if (data instanceof Array) {
          data.length = this._len;
          if (hasTypedArray) {
            this.data = new Float32Array(data);
          }
        }
      },
      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function() {
        min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
        max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
        var data = this.data;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;
        for (var i = 0; i < data.length; ) {
          var cmd = data[i++];
          if (i === 1) {
            xi = data[i];
            yi = data[i + 1];
            x0 = xi;
            y0 = yi;
          }
          switch (cmd) {
            case CMD.M:
              x0 = data[i++];
              y0 = data[i++];
              xi = x0;
              yi = y0;
              min2[0] = x0;
              min2[1] = y0;
              max2[0] = x0;
              max2[1] = y0;
              break;
            case CMD.L:
              bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;
            case CMD.C:
              bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;
            case CMD.Q:
              bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
              xi = data[i++];
              yi = data[i++];
              break;
            case CMD.A:
              var cx = data[i++];
              var cy = data[i++];
              var rx = data[i++];
              var ry = data[i++];
              var startAngle = data[i++];
              var endAngle = data[i++] + startAngle;
              i += 1;
              var anticlockwise = 1 - data[i++];
              if (i === 1) {
                x0 = mathCos(startAngle) * rx + cx;
                y0 = mathSin(startAngle) * ry + cy;
              }
              bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
              xi = mathCos(endAngle) * rx + cx;
              yi = mathSin(endAngle) * ry + cy;
              break;
            case CMD.R:
              x0 = xi = data[i++];
              y0 = yi = data[i++];
              var width = data[i++];
              var height = data[i++];
              bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
              break;
            case CMD.Z:
              xi = x0;
              yi = y0;
              break;
          }
          vec2.min(min, min, min2);
          vec2.max(max, max, max2);
        }
        if (i === 0) {
          min[0] = min[1] = max[0] = max[1] = 0;
        }
        return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      /**
       * Rebuild path from current data
       * Rebuild path will not consider javascript implemented line dash.
       * @param {CanvasRenderingContext2D} ctx
       */
      rebuildPath: function(ctx) {
        var d = this.data;
        var x0;
        var y0;
        var xi;
        var yi;
        var x;
        var y;
        var ux = this._ux;
        var uy = this._uy;
        var len = this._len;
        for (var i = 0; i < len; ) {
          var cmd = d[i++];
          if (i === 1) {
            xi = d[i];
            yi = d[i + 1];
            x0 = xi;
            y0 = yi;
          }
          switch (cmd) {
            case CMD.M:
              x0 = xi = d[i++];
              y0 = yi = d[i++];
              ctx.moveTo(xi, yi);
              break;
            case CMD.L:
              x = d[i++];
              y = d[i++];
              if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
                ctx.lineTo(x, y);
                xi = x;
                yi = y;
              }
              break;
            case CMD.C:
              ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;
            case CMD.Q:
              ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
              xi = d[i - 2];
              yi = d[i - 1];
              break;
            case CMD.A:
              var cx = d[i++];
              var cy = d[i++];
              var rx = d[i++];
              var ry = d[i++];
              var theta = d[i++];
              var dTheta = d[i++];
              var psi = d[i++];
              var fs = d[i++];
              var r = rx > ry ? rx : ry;
              var scaleX = rx > ry ? 1 : rx / ry;
              var scaleY = rx > ry ? ry / rx : 1;
              var isEllipse = Math.abs(rx - ry) > 1e-3;
              var endAngle = theta + dTheta;
              if (isEllipse) {
                ctx.translate(cx, cy);
                ctx.rotate(psi);
                ctx.scale(scaleX, scaleY);
                ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
                ctx.scale(1 / scaleX, 1 / scaleY);
                ctx.rotate(-psi);
                ctx.translate(-cx, -cy);
              } else {
                ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
              }
              if (i === 1) {
                x0 = mathCos(theta) * rx + cx;
                y0 = mathSin(theta) * ry + cy;
              }
              xi = mathCos(endAngle) * rx + cx;
              yi = mathSin(endAngle) * ry + cy;
              break;
            case CMD.R:
              x0 = xi = d[i];
              y0 = yi = d[i + 1];
              ctx.rect(d[i++], d[i++], d[i++], d[i++]);
              break;
            case CMD.Z:
              ctx.closePath();
              xi = x0;
              yi = y0;
          }
        }
      }
    };
    PathProxy.CMD = CMD;
    var _default = PathProxy;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/line.js
var require_line = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/line.js"(exports) {
    function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      var _a = 0;
      var _b = x0;
      if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
        return false;
      }
      if (x0 !== x1) {
        _a = (y0 - y1) / (x0 - x1);
        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
      } else {
        return Math.abs(x - x0) <= _l / 2;
      }
      var tmp = _a * x - y + _b;
      var _s = tmp * tmp / (_a * _a + 1);
      return _s <= _l / 2 * _l / 2;
    }
    exports.containStroke = containStroke;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/cubic.js
var require_cubic = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/cubic.js"(exports) {
    var curve = require_curve();
    function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
        return false;
      }
      var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
      return d <= _l / 2;
    }
    exports.containStroke = containStroke;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/quadratic.js
var require_quadratic = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/quadratic.js"(exports) {
    var _curve = require_curve();
    var quadraticProjectPoint = _curve.quadraticProjectPoint;
    function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
        return false;
      }
      var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
      return d <= _l / 2;
    }
    exports.containStroke = containStroke;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/util.js
var require_util2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/util.js"(exports) {
    var PI2 = Math.PI * 2;
    function normalizeRadian(angle) {
      angle %= PI2;
      if (angle < 0) {
        angle += PI2;
      }
      return angle;
    }
    exports.normalizeRadian = normalizeRadian;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/arc.js
var require_arc = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/arc.js"(exports) {
    var _util = require_util2();
    var normalizeRadian = _util.normalizeRadian;
    var PI2 = Math.PI * 2;
    function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
      if (lineWidth === 0) {
        return false;
      }
      var _l = lineWidth;
      x -= cx;
      y -= cy;
      var d = Math.sqrt(x * x + y * y);
      if (d - _l > r || d + _l < r) {
        return false;
      }
      if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
        return true;
      }
      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
      } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
      }
      if (startAngle > endAngle) {
        endAngle += PI2;
      }
      var angle = Math.atan2(y, x);
      if (angle < 0) {
        angle += PI2;
      }
      return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
    }
    exports.containStroke = containStroke;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/windingLine.js
var require_windingLine = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/windingLine.js"(exports, module) {
    function windingLine(x0, y0, x1, y1, x, y) {
      if (y > y0 && y > y1 || y < y0 && y < y1) {
        return 0;
      }
      if (y1 === y0) {
        return 0;
      }
      var dir = y1 < y0 ? 1 : -1;
      var t = (y - y0) / (y1 - y0);
      if (t === 1 || t === 0) {
        dir = y1 < y0 ? 0.5 : -0.5;
      }
      var x_ = t * (x1 - x0) + x0;
      return x_ === x ? Infinity : x_ > x ? dir : 0;
    }
    module.exports = windingLine;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/path.js
var require_path = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/path.js"(exports) {
    var PathProxy = require_PathProxy();
    var line = require_line();
    var cubic = require_cubic();
    var quadratic = require_quadratic();
    var arc = require_arc();
    var _util = require_util2();
    var normalizeRadian = _util.normalizeRadian;
    var curve = require_curve();
    var windingLine = require_windingLine();
    var CMD = PathProxy.CMD;
    var PI2 = Math.PI * 2;
    var EPSILON = 1e-4;
    function isAroundEqual(a, b) {
      return Math.abs(a - b) < EPSILON;
    }
    var roots = [-1, -1, -1];
    var extrema = [-1, -1];
    function swapExtrema() {
      var tmp = extrema[0];
      extrema[0] = extrema[1];
      extrema[1] = tmp;
    }
    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
      if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
        return 0;
      }
      var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
      if (nRoots === 0) {
        return 0;
      } else {
        var w = 0;
        var nExtrema = -1;
        var y0_;
        var y1_;
        for (var i = 0; i < nRoots; i++) {
          var t = roots[i];
          var unit = t === 0 || t === 1 ? 0.5 : 1;
          var x_ = curve.cubicAt(x0, x1, x2, x3, t);
          if (x_ < x) {
            continue;
          }
          if (nExtrema < 0) {
            nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
            if (extrema[1] < extrema[0] && nExtrema > 1) {
              swapExtrema();
            }
            y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
            if (nExtrema > 1) {
              y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
            }
          }
          if (nExtrema === 2) {
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else if (t < extrema[1]) {
              w += y1_ < y0_ ? unit : -unit;
            } else {
              w += y3 < y1_ ? unit : -unit;
            }
          } else {
            if (t < extrema[0]) {
              w += y0_ < y0 ? unit : -unit;
            } else {
              w += y3 < y0_ ? unit : -unit;
            }
          }
        }
        return w;
      }
    }
    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
      if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
        return 0;
      }
      var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
      if (nRoots === 0) {
        return 0;
      } else {
        var t = curve.quadraticExtremum(y0, y1, y2);
        if (t >= 0 && t <= 1) {
          var w = 0;
          var y_ = curve.quadraticAt(y0, y1, y2, t);
          for (var i = 0; i < nRoots; i++) {
            var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
            var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
            if (x_ < x) {
              continue;
            }
            if (roots[i] < t) {
              w += y_ < y0 ? unit : -unit;
            } else {
              w += y2 < y_ ? unit : -unit;
            }
          }
          return w;
        } else {
          var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
          var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
          if (x_ < x) {
            return 0;
          }
          return y2 < y0 ? unit : -unit;
        }
      }
    }
    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
      y -= cy;
      if (y > r || y < -r) {
        return 0;
      }
      var tmp = Math.sqrt(r * r - y * y);
      roots[0] = -tmp;
      roots[1] = tmp;
      var diff = Math.abs(startAngle - endAngle);
      if (diff < 1e-4) {
        return 0;
      }
      if (diff % PI2 < 1e-4) {
        startAngle = 0;
        endAngle = PI2;
        var dir = anticlockwise ? 1 : -1;
        if (x >= roots[0] + cx && x <= roots[1] + cx) {
          return dir;
        } else {
          return 0;
        }
      }
      if (anticlockwise) {
        var tmp = startAngle;
        startAngle = normalizeRadian(endAngle);
        endAngle = normalizeRadian(tmp);
      } else {
        startAngle = normalizeRadian(startAngle);
        endAngle = normalizeRadian(endAngle);
      }
      if (startAngle > endAngle) {
        endAngle += PI2;
      }
      var w = 0;
      for (var i = 0; i < 2; i++) {
        var x_ = roots[i];
        if (x_ + cx > x) {
          var angle = Math.atan2(y, x_);
          var dir = anticlockwise ? 1 : -1;
          if (angle < 0) {
            angle = PI2 + angle;
          }
          if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
            if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
              dir = -dir;
            }
            w += dir;
          }
        }
      }
      return w;
    }
    function containPath(data, lineWidth, isStroke, x, y) {
      var w = 0;
      var xi = 0;
      var yi = 0;
      var x0 = 0;
      var y0 = 0;
      for (var i = 0; i < data.length; ) {
        var cmd = data[i++];
        if (cmd === CMD.M && i > 1) {
          if (!isStroke) {
            w += windingLine(xi, yi, x0, y0, x, y);
          }
        }
        if (i === 1) {
          xi = data[i];
          yi = data[i + 1];
          x0 = xi;
          y0 = yi;
        }
        switch (cmd) {
          case CMD.M:
            x0 = data[i++];
            y0 = data[i++];
            xi = x0;
            yi = y0;
            break;
          case CMD.L:
            if (isStroke) {
              if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
            }
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.C:
            if (isStroke) {
              if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.Q:
            if (isStroke) {
              if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
            }
            xi = data[i++];
            yi = data[i++];
            break;
          case CMD.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var theta = data[i++];
            var dTheta = data[i++];
            i += 1;
            var anticlockwise = 1 - data[i++];
            var x1 = Math.cos(theta) * rx + cx;
            var y1 = Math.sin(theta) * ry + cy;
            if (i > 1) {
              w += windingLine(xi, yi, x1, y1, x, y);
            } else {
              x0 = x1;
              y0 = y1;
            }
            var _x = (x - cx) * ry / rx + cx;
            if (isStroke) {
              if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                return true;
              }
            } else {
              w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
            }
            xi = Math.cos(theta + dTheta) * rx + cx;
            yi = Math.sin(theta + dTheta) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = data[i++];
            y0 = yi = data[i++];
            var width = data[i++];
            var height = data[i++];
            var x1 = x0 + width;
            var y1 = y0 + height;
            if (isStroke) {
              if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingLine(x1, y0, x1, y1, x, y);
              w += windingLine(x0, y1, x0, y0, x, y);
            }
            break;
          case CMD.Z:
            if (isStroke) {
              if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                return true;
              }
            } else {
              w += windingLine(xi, yi, x0, y0, x, y);
            }
            xi = x0;
            yi = y0;
            break;
        }
      }
      if (!isStroke && !isAroundEqual(yi, y0)) {
        w += windingLine(xi, yi, x0, y0, x, y) || 0;
      }
      return w !== 0;
    }
    function contain(pathData, x, y) {
      return containPath(pathData, 0, false, x, y);
    }
    function containStroke(pathData, lineWidth, x, y) {
      return containPath(pathData, lineWidth, true, x, y);
    }
    exports.contain = contain;
    exports.containStroke = containStroke;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Path.js
var require_Path = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Path.js"(exports, module) {
    var Displayable = require_Displayable();
    var zrUtil = require_util();
    var PathProxy = require_PathProxy();
    var pathContain = require_path();
    var Pattern = require_Pattern();
    var getCanvasPattern = Pattern.prototype.getCanvasPattern;
    var abs = Math.abs;
    var pathProxyForDraw = new PathProxy(true);
    function Path(opts) {
      Displayable.call(this, opts);
      this.path = null;
    }
    Path.prototype = {
      constructor: Path,
      type: "path",
      __dirtyPath: true,
      strokeContainThreshold: 5,
      // This item default to be false. But in map series in echarts,
      // in order to improve performance, it should be set to true,
      // so the shorty segment won't draw.
      segmentIgnoreThreshold: 0,
      /**
       * See `module:zrender/src/graphic/helper/subPixelOptimize`.
       * @type {boolean}
       */
      subPixelOptimize: false,
      brush: function(ctx, prevEl) {
        var style = this.style;
        var path = this.path || pathProxyForDraw;
        var hasStroke = style.hasStroke();
        var hasFill = style.hasFill();
        var fill = style.fill;
        var stroke = style.stroke;
        var hasFillGradient = hasFill && !!fill.colorStops;
        var hasStrokeGradient = hasStroke && !!stroke.colorStops;
        var hasFillPattern = hasFill && !!fill.image;
        var hasStrokePattern = hasStroke && !!stroke.image;
        style.bind(ctx, this, prevEl);
        this.setTransform(ctx);
        if (this.__dirty) {
          var rect;
          if (hasFillGradient) {
            rect = rect || this.getBoundingRect();
            this._fillGradient = style.getGradient(ctx, fill, rect);
          }
          if (hasStrokeGradient) {
            rect = rect || this.getBoundingRect();
            this._strokeGradient = style.getGradient(ctx, stroke, rect);
          }
        }
        if (hasFillGradient) {
          ctx.fillStyle = this._fillGradient;
        } else if (hasFillPattern) {
          ctx.fillStyle = getCanvasPattern.call(fill, ctx);
        }
        if (hasStrokeGradient) {
          ctx.strokeStyle = this._strokeGradient;
        } else if (hasStrokePattern) {
          ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
        }
        var lineDash = style.lineDash;
        var lineDashOffset = style.lineDashOffset;
        var ctxLineDash = !!ctx.setLineDash;
        var scale = this.getGlobalScale();
        path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold);
        if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
          path.beginPath(ctx);
          if (lineDash && !ctxLineDash) {
            path.setLineDash(lineDash);
            path.setLineDashOffset(lineDashOffset);
          }
          this.buildPath(path, this.shape, false);
          if (this.path) {
            this.__dirtyPath = false;
          }
        } else {
          ctx.beginPath();
          this.path.rebuildPath(ctx);
        }
        if (hasFill) {
          if (style.fillOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.fillOpacity * style.opacity;
            path.fill(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.fill(ctx);
          }
        }
        if (lineDash && ctxLineDash) {
          ctx.setLineDash(lineDash);
          ctx.lineDashOffset = lineDashOffset;
        }
        if (hasStroke) {
          if (style.strokeOpacity != null) {
            var originalGlobalAlpha = ctx.globalAlpha;
            ctx.globalAlpha = style.strokeOpacity * style.opacity;
            path.stroke(ctx);
            ctx.globalAlpha = originalGlobalAlpha;
          } else {
            path.stroke(ctx);
          }
        }
        if (lineDash && ctxLineDash) {
          ctx.setLineDash([]);
        }
        if (style.text != null) {
          this.restoreTransform(ctx);
          this.drawRectText(ctx, this.getBoundingRect());
        }
      },
      // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
      // Like in circle
      buildPath: function(ctx, shapeCfg, inBundle) {
      },
      createPathProxy: function() {
        this.path = new PathProxy();
      },
      getBoundingRect: function() {
        var rect = this._rect;
        var style = this.style;
        var needsUpdateRect = !rect;
        if (needsUpdateRect) {
          var path = this.path;
          if (!path) {
            path = this.path = new PathProxy();
          }
          if (this.__dirtyPath) {
            path.beginPath();
            this.buildPath(path, this.shape, false);
          }
          rect = path.getBoundingRect();
        }
        this._rect = rect;
        if (style.hasStroke()) {
          var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
          if (this.__dirty || needsUpdateRect) {
            rectWithStroke.copy(rect);
            var w = style.lineWidth;
            var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
            if (!style.hasFill()) {
              w = Math.max(w, this.strokeContainThreshold || 4);
            }
            if (lineScale > 1e-10) {
              rectWithStroke.width += w / lineScale;
              rectWithStroke.height += w / lineScale;
              rectWithStroke.x -= w / lineScale / 2;
              rectWithStroke.y -= w / lineScale / 2;
            }
          }
          return rectWithStroke;
        }
        return rect;
      },
      contain: function(x, y) {
        var localPos = this.transformCoordToLocal(x, y);
        var rect = this.getBoundingRect();
        var style = this.style;
        x = localPos[0];
        y = localPos[1];
        if (rect.contain(x, y)) {
          var pathData = this.path.data;
          if (style.hasStroke()) {
            var lineWidth = style.lineWidth;
            var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
            if (lineScale > 1e-10) {
              if (!style.hasFill()) {
                lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
              }
              if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
                return true;
              }
            }
          }
          if (style.hasFill()) {
            return pathContain.contain(pathData, x, y);
          }
        }
        return false;
      },
      /**
       * @param  {boolean} dirtyPath
       */
      dirty: function(dirtyPath) {
        if (dirtyPath == null) {
          dirtyPath = true;
        }
        if (dirtyPath) {
          this.__dirtyPath = dirtyPath;
          this._rect = null;
        }
        this.__dirty = this.__dirtyText = true;
        this.__zr && this.__zr.refresh();
        if (this.__clipTarget) {
          this.__clipTarget.dirty();
        }
      },
      /**
       * Alias for animate('shape')
       * @param {boolean} loop
       */
      animateShape: function(loop) {
        return this.animate("shape", loop);
      },
      // Overwrite attrKV
      attrKV: function(key, value) {
        if (key === "shape") {
          this.setShape(value);
          this.__dirtyPath = true;
          this._rect = null;
        } else {
          Displayable.prototype.attrKV.call(this, key, value);
        }
      },
      /**
       * @param {Object|string} key
       * @param {*} value
       */
      setShape: function(key, value) {
        var shape = this.shape;
        if (shape) {
          if (zrUtil.isObject(key)) {
            for (var name2 in key) {
              if (key.hasOwnProperty(name2)) {
                shape[name2] = key[name2];
              }
            }
          } else {
            shape[key] = value;
          }
          this.dirty(true);
        }
        return this;
      },
      getLineScale: function() {
        var m = this.transform;
        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
      }
    };
    Path.extend = function(defaults) {
      var Sub = function(opts) {
        Path.call(this, opts);
        if (defaults.style) {
          this.style.extendFrom(defaults.style, false);
        }
        var defaultShape = defaults.shape;
        if (defaultShape) {
          this.shape = this.shape || {};
          var thisShape = this.shape;
          for (var name3 in defaultShape) {
            if (!thisShape.hasOwnProperty(name3) && defaultShape.hasOwnProperty(name3)) {
              thisShape[name3] = defaultShape[name3];
            }
          }
        }
        defaults.init && defaults.init.call(this, opts);
      };
      zrUtil.inherits(Sub, Path);
      for (var name2 in defaults) {
        if (name2 !== "style" && name2 !== "shape") {
          Sub.prototype[name2] = defaults[name2];
        }
      }
      return Sub;
    };
    zrUtil.inherits(Path, Displayable);
    var _default = Path;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/transformPath.js
var require_transformPath = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/transformPath.js"(exports, module) {
    var PathProxy = require_PathProxy();
    var _vector = require_vector();
    var v2ApplyTransform = _vector.applyTransform;
    var CMD = PathProxy.CMD;
    var points = [[], [], []];
    var mathSqrt = Math.sqrt;
    var mathAtan2 = Math.atan2;
    function _default(path, m) {
      var data = path.data;
      var cmd;
      var nPoint;
      var i;
      var j;
      var k;
      var p;
      var M = CMD.M;
      var C = CMD.C;
      var L = CMD.L;
      var R = CMD.R;
      var A = CMD.A;
      var Q = CMD.Q;
      for (i = 0, j = 0; i < data.length; ) {
        cmd = data[i++];
        j = i;
        nPoint = 0;
        switch (cmd) {
          case M:
            nPoint = 1;
            break;
          case L:
            nPoint = 1;
            break;
          case C:
            nPoint = 3;
            break;
          case Q:
            nPoint = 2;
            break;
          case A:
            var x = m[4];
            var y = m[5];
            var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
            var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
            var angle = mathAtan2(-m[1] / sy, m[0] / sx);
            data[i] *= sx;
            data[i++] += x;
            data[i] *= sy;
            data[i++] += y;
            data[i++] *= sx;
            data[i++] *= sy;
            data[i++] += angle;
            data[i++] += angle;
            i += 2;
            j = i;
            break;
          case R:
            p[0] = data[i++];
            p[1] = data[i++];
            v2ApplyTransform(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1];
            p[0] += data[i++];
            p[1] += data[i++];
            v2ApplyTransform(p, p, m);
            data[j++] = p[0];
            data[j++] = p[1];
        }
        for (k = 0; k < nPoint; k++) {
          var p = points[k];
          p[0] = data[i++];
          p[1] = data[i++];
          v2ApplyTransform(p, p, m);
          data[j++] = p[0];
          data[j++] = p[1];
        }
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/path.js
var require_path2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/path.js"(exports) {
    var Path = require_Path();
    var PathProxy = require_PathProxy();
    var transformPath = require_transformPath();
    var mathSqrt = Math.sqrt;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI = Math.PI;
    var vMag = function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    var vRatio = function(u, v) {
      return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };
    var vAngle = function(u, v) {
      return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };
    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
      var psi = psiDeg * (PI / 180);
      var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;
      var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;
      var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
      if (lambda > 1) {
        rx *= mathSqrt(lambda);
        ry *= mathSqrt(lambda);
      }
      var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
      var cxp = f * rx * yp / ry;
      var cyp = f * -ry * xp / rx;
      var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;
      var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;
      var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
      var u = [(xp - cxp) / rx, (yp - cyp) / ry];
      var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
      var dTheta = vAngle(u, v);
      if (vRatio(u, v) <= -1) {
        dTheta = PI;
      }
      if (vRatio(u, v) >= 1) {
        dTheta = 0;
      }
      if (fs === 0 && dTheta > 0) {
        dTheta = dTheta - 2 * PI;
      }
      if (fs === 1 && dTheta < 0) {
        dTheta = dTheta + 2 * PI;
      }
      path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
    }
    var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
    var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
    function createPathProxyFromString(data) {
      if (!data) {
        return new PathProxy();
      }
      var cpx = 0;
      var cpy = 0;
      var subpathX = cpx;
      var subpathY = cpy;
      var prevCmd;
      var path = new PathProxy();
      var CMD = PathProxy.CMD;
      var cmdList = data.match(commandReg);
      for (var l = 0; l < cmdList.length; l++) {
        var cmdText = cmdList[l];
        var cmdStr = cmdText.charAt(0);
        var cmd;
        var p = cmdText.match(numberReg) || [];
        var pLen = p.length;
        for (var i = 0; i < pLen; i++) {
          p[i] = parseFloat(p[i]);
        }
        var off = 0;
        while (off < pLen) {
          var ctlPtx;
          var ctlPty;
          var rx;
          var ry;
          var psi;
          var fa;
          var fs;
          var x1 = cpx;
          var y1 = cpy;
          switch (cmdStr) {
            case "l":
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "L":
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "m":
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = "l";
              break;
            case "M":
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.M;
              path.addData(cmd, cpx, cpy);
              subpathX = cpx;
              subpathY = cpy;
              cmdStr = "L";
              break;
            case "h":
              cpx += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "H":
              cpx = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "v":
              cpy += p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "V":
              cpy = p[off++];
              cmd = CMD.L;
              path.addData(cmd, cpx, cpy);
              break;
            case "C":
              cmd = CMD.C;
              path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
              cpx = p[off - 2];
              cpy = p[off - 1];
              break;
            case "c":
              cmd = CMD.C;
              path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
              cpx += p[off - 2];
              cpy += p[off - 1];
              break;
            case "S":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cmd = CMD.C;
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;
            case "s":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.C) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cmd = CMD.C;
              x1 = cpx + p[off++];
              y1 = cpy + p[off++];
              cpx += p[off++];
              cpy += p[off++];
              path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
              break;
            case "Q":
              x1 = p[off++];
              y1 = p[off++];
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;
            case "q":
              x1 = p[off++] + cpx;
              y1 = p[off++] + cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, x1, y1, cpx, cpy);
              break;
            case "T":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;
            case "t":
              ctlPtx = cpx;
              ctlPty = cpy;
              var len = path.len();
              var pathData = path.data;
              if (prevCmd === CMD.Q) {
                ctlPtx += cpx - pathData[len - 4];
                ctlPty += cpy - pathData[len - 3];
              }
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.Q;
              path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
              break;
            case "A":
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx = p[off++];
              cpy = p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;
            case "a":
              rx = p[off++];
              ry = p[off++];
              psi = p[off++];
              fa = p[off++];
              fs = p[off++];
              x1 = cpx, y1 = cpy;
              cpx += p[off++];
              cpy += p[off++];
              cmd = CMD.A;
              processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
              break;
          }
        }
        if (cmdStr === "z" || cmdStr === "Z") {
          cmd = CMD.Z;
          path.addData(cmd);
          cpx = subpathX;
          cpy = subpathY;
        }
        prevCmd = cmd;
      }
      path.toStatic();
      return path;
    }
    function createPathOptions(str, opts) {
      var pathProxy = createPathProxyFromString(str);
      opts = opts || {};
      opts.buildPath = function(path) {
        if (path.setData) {
          path.setData(pathProxy.data);
          var ctx = path.getContext();
          if (ctx) {
            path.rebuildPath(ctx);
          }
        } else {
          var ctx = path;
          pathProxy.rebuildPath(ctx);
        }
      };
      opts.applyTransform = function(m) {
        transformPath(pathProxy, m);
        this.dirty(true);
      };
      return opts;
    }
    function createFromString(str, opts) {
      return new Path(createPathOptions(str, opts));
    }
    function extendFromString(str, opts) {
      return Path.extend(createPathOptions(str, opts));
    }
    function mergePath(pathEls, opts) {
      var pathList = [];
      var len = pathEls.length;
      for (var i = 0; i < len; i++) {
        var pathEl = pathEls[i];
        if (!pathEl.path) {
          pathEl.createPathProxy();
        }
        if (pathEl.__dirtyPath) {
          pathEl.buildPath(pathEl.path, pathEl.shape, true);
        }
        pathList.push(pathEl.path);
      }
      var pathBundle = new Path(opts);
      pathBundle.createPathProxy();
      pathBundle.buildPath = function(path) {
        path.appendPath(pathList);
        var ctx = path.getContext();
        if (ctx) {
          path.rebuildPath(ctx);
        }
      };
      return pathBundle;
    }
    exports.createFromString = createFromString;
    exports.extendFromString = extendFromString;
    exports.mergePath = mergePath;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Text.js
var require_Text = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Text.js"(exports, module) {
    var Displayable = require_Displayable();
    var zrUtil = require_util();
    var textContain = require_text();
    var textHelper = require_text2();
    var _constant = require_constant();
    var ContextCachedBy = _constant.ContextCachedBy;
    var Text = function(opts) {
      Displayable.call(this, opts);
    };
    Text.prototype = {
      constructor: Text,
      type: "text",
      brush: function(ctx, prevEl) {
        var style = this.style;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
        var text = style.text;
        text != null && (text += "");
        if (!textHelper.needDrawText(text, style)) {
          ctx.__attrCachedBy = ContextCachedBy.NONE;
          return;
        }
        this.setTransform(ctx);
        textHelper.renderText(this, ctx, text, style, null, prevEl);
        this.restoreTransform(ctx);
      },
      getBoundingRect: function() {
        var style = this.style;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        if (!this._rect) {
          var text = style.text;
          text != null ? text += "" : text = "";
          var rect = textContain.getBoundingRect(style.text + "", style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
          rect.x += style.x || 0;
          rect.y += style.y || 0;
          if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
            var w = style.textStrokeWidth;
            rect.x -= w / 2;
            rect.y -= w / 2;
            rect.width += w;
            rect.height += w;
          }
          this._rect = rect;
        }
        return this._rect;
      }
    };
    zrUtil.inherits(Text, Displayable);
    var _default = Text;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Circle.js
var require_Circle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Circle.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "circle",
      shape: {
        cx: 0,
        cy: 0,
        r: 0
      },
      buildPath: function(ctx, shape, inBundle) {
        if (inBundle) {
          ctx.moveTo(shape.cx + shape.r, shape.cy);
        }
        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js
var require_fixClipWithShadow = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js"(exports, module) {
    var env = require_env();
    var shadowTemp = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]];
    function _default(orignalBrush) {
      return env.browser.ie && env.browser.version >= 11 ? function() {
        var clipPaths = this.__clipPaths;
        var style = this.style;
        var modified;
        if (clipPaths) {
          for (var i = 0; i < clipPaths.length; i++) {
            var clipPath = clipPaths[i];
            var shape = clipPath && clipPath.shape;
            var type = clipPath && clipPath.type;
            if (shape && (type === "sector" && shape.startAngle === shape.endAngle || type === "rect" && (!shape.width || !shape.height))) {
              for (var j = 0; j < shadowTemp.length; j++) {
                shadowTemp[j][2] = style[shadowTemp[j][0]];
                style[shadowTemp[j][0]] = shadowTemp[j][1];
              }
              modified = true;
              break;
            }
          }
        }
        orignalBrush.apply(this, arguments);
        if (modified) {
          for (var j = 0; j < shadowTemp.length; j++) {
            style[shadowTemp[j][0]] = shadowTemp[j][2];
          }
        }
      } : orignalBrush;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Sector.js
var require_Sector = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Sector.js"(exports, module) {
    var Path = require_Path();
    var fixClipWithShadow = require_fixClipWithShadow();
    var _default = Path.extend({
      type: "sector",
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
        ctx.lineTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
        ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
        if (r0 !== 0) {
          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        }
        ctx.closePath();
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Ring.js
var require_Ring = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Ring.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "ring",
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        r0: 0
      },
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var PI2 = Math.PI * 2;
        ctx.moveTo(x + shape.r, y);
        ctx.arc(x, y, shape.r, 0, PI2, false);
        ctx.moveTo(x + shape.r0, y);
        ctx.arc(x, y, shape.r0, 0, PI2, true);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/smoothSpline.js
var require_smoothSpline = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/smoothSpline.js"(exports, module) {
    var _vector = require_vector();
    var v2Distance = _vector.distance;
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function _default(points, isLoop) {
      var len = points.length;
      var ret = [];
      var distance = 0;
      for (var i = 1; i < len; i++) {
        distance += v2Distance(points[i - 1], points[i]);
      }
      var segs = distance / 2;
      segs = segs < len ? len : segs;
      for (var i = 0; i < segs; i++) {
        var pos = i / (segs - 1) * (isLoop ? len : len - 1);
        var idx = Math.floor(pos);
        var w = pos - idx;
        var p0;
        var p1 = points[idx % len];
        var p2;
        var p3;
        if (!isLoop) {
          p0 = points[idx === 0 ? idx : idx - 1];
          p2 = points[idx > len - 2 ? len - 1 : idx + 1];
          p3 = points[idx > len - 3 ? len - 1 : idx + 2];
        } else {
          p0 = points[(idx - 1 + len) % len];
          p2 = points[(idx + 1) % len];
          p3 = points[(idx + 2) % len];
        }
        var w2 = w * w;
        var w3 = w * w2;
        ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
      }
      return ret;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/smoothBezier.js
var require_smoothBezier = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/smoothBezier.js"(exports, module) {
    var _vector = require_vector();
    var v2Min = _vector.min;
    var v2Max = _vector.max;
    var v2Scale = _vector.scale;
    var v2Distance = _vector.distance;
    var v2Add = _vector.add;
    var v2Clone = _vector.clone;
    var v2Sub = _vector.sub;
    function _default(points, smooth, isLoop, constraint) {
      var cps = [];
      var v = [];
      var v1 = [];
      var v2 = [];
      var prevPoint;
      var nextPoint;
      var min;
      var max;
      if (constraint) {
        min = [Infinity, Infinity];
        max = [-Infinity, -Infinity];
        for (var i = 0, len = points.length; i < len; i++) {
          v2Min(min, min, points[i]);
          v2Max(max, max, points[i]);
        }
        v2Min(min, min, constraint[0]);
        v2Max(max, max, constraint[1]);
      }
      for (var i = 0, len = points.length; i < len; i++) {
        var point = points[i];
        if (isLoop) {
          prevPoint = points[i ? i - 1 : len - 1];
          nextPoint = points[(i + 1) % len];
        } else {
          if (i === 0 || i === len - 1) {
            cps.push(v2Clone(points[i]));
            continue;
          } else {
            prevPoint = points[i - 1];
            nextPoint = points[i + 1];
          }
        }
        v2Sub(v, nextPoint, prevPoint);
        v2Scale(v, v, smooth);
        var d0 = v2Distance(point, prevPoint);
        var d1 = v2Distance(point, nextPoint);
        var sum = d0 + d1;
        if (sum !== 0) {
          d0 /= sum;
          d1 /= sum;
        }
        v2Scale(v1, v, -d0);
        v2Scale(v2, v, d1);
        var cp0 = v2Add([], point, v1);
        var cp1 = v2Add([], point, v2);
        if (constraint) {
          v2Max(cp0, cp0, min);
          v2Min(cp0, cp0, max);
          v2Max(cp1, cp1, min);
          v2Min(cp1, cp1, max);
        }
        cps.push(cp0);
        cps.push(cp1);
      }
      if (isLoop) {
        cps.push(cps.shift());
      }
      return cps;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/poly.js
var require_poly = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/poly.js"(exports) {
    var smoothSpline = require_smoothSpline();
    var smoothBezier = require_smoothBezier();
    function buildPath(ctx, shape, closePath) {
      var points = shape.points;
      var smooth = shape.smooth;
      if (points && points.length >= 2) {
        if (smooth && smooth !== "spline") {
          var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
          ctx.moveTo(points[0][0], points[0][1]);
          var len = points.length;
          for (var i = 0; i < (closePath ? len : len - 1); i++) {
            var cp1 = controlPoints[i * 2];
            var cp2 = controlPoints[i * 2 + 1];
            var p = points[(i + 1) % len];
            ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
          }
        } else {
          if (smooth === "spline") {
            points = smoothSpline(points, closePath);
          }
          ctx.moveTo(points[0][0], points[0][1]);
          for (var i = 1, l = points.length; i < l; i++) {
            ctx.lineTo(points[i][0], points[i][1]);
          }
        }
        closePath && ctx.closePath();
      }
    }
    exports.buildPath = buildPath;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Polygon.js
var require_Polygon = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Polygon.js"(exports, module) {
    var Path = require_Path();
    var polyHelper = require_poly();
    var _default = Path.extend({
      type: "polygon",
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      buildPath: function(ctx, shape) {
        polyHelper.buildPath(ctx, shape, true);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Polyline.js
var require_Polyline = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Polyline.js"(exports, module) {
    var Path = require_Path();
    var polyHelper = require_poly();
    var _default = Path.extend({
      type: "polyline",
      shape: {
        points: null,
        smooth: false,
        smoothConstraint: null
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        polyHelper.buildPath(ctx, shape, false);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/subPixelOptimize.js
var require_subPixelOptimize = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/helper/subPixelOptimize.js"(exports) {
    var round = Math.round;
    function subPixelOptimizeLine(outputShape, inputShape, style) {
      if (!inputShape) {
        return;
      }
      var x1 = inputShape.x1;
      var x2 = inputShape.x2;
      var y1 = inputShape.y1;
      var y2 = inputShape.y2;
      outputShape.x1 = x1;
      outputShape.x2 = x2;
      outputShape.y1 = y1;
      outputShape.y2 = y2;
      var lineWidth = style && style.lineWidth;
      if (!lineWidth) {
        return;
      }
      if (round(x1 * 2) === round(x2 * 2)) {
        outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
      }
      if (round(y1 * 2) === round(y2 * 2)) {
        outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
      }
    }
    function subPixelOptimizeRect(outputShape, inputShape, style) {
      if (!inputShape) {
        return;
      }
      var originX = inputShape.x;
      var originY = inputShape.y;
      var originWidth = inputShape.width;
      var originHeight = inputShape.height;
      outputShape.x = originX;
      outputShape.y = originY;
      outputShape.width = originWidth;
      outputShape.height = originHeight;
      var lineWidth = style && style.lineWidth;
      if (!lineWidth) {
        return;
      }
      outputShape.x = subPixelOptimize(originX, lineWidth, true);
      outputShape.y = subPixelOptimize(originY, lineWidth, true);
      outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
      outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
    }
    function subPixelOptimize(position, lineWidth, positiveOrNegative) {
      if (!lineWidth) {
        return position;
      }
      var doubledPosition = round(position * 2);
      return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
    }
    exports.subPixelOptimizeLine = subPixelOptimizeLine;
    exports.subPixelOptimizeRect = subPixelOptimizeRect;
    exports.subPixelOptimize = subPixelOptimize;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Rect.js
var require_Rect = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Rect.js"(exports, module) {
    var Path = require_Path();
    var roundRectHelper = require_roundRect();
    var _subPixelOptimize = require_subPixelOptimize();
    var subPixelOptimizeRect = _subPixelOptimize.subPixelOptimizeRect;
    var subPixelOptimizeOutputShape = {};
    var _default = Path.extend({
      type: "rect",
      shape: {
        // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
        // r缩写为1         相当于 [1, 1, 1, 1]
        // r缩写为[1]       相当于 [1, 1, 1, 1]
        // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
        // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
        r: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function(ctx, shape) {
        var x;
        var y;
        var width;
        var height;
        if (this.subPixelOptimize) {
          subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
          x = subPixelOptimizeOutputShape.x;
          y = subPixelOptimizeOutputShape.y;
          width = subPixelOptimizeOutputShape.width;
          height = subPixelOptimizeOutputShape.height;
          subPixelOptimizeOutputShape.r = shape.r;
          shape = subPixelOptimizeOutputShape;
        } else {
          x = shape.x;
          y = shape.y;
          width = shape.width;
          height = shape.height;
        }
        if (!shape.r) {
          ctx.rect(x, y, width, height);
        } else {
          roundRectHelper.buildPath(ctx, shape);
        }
        ctx.closePath();
        return;
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Line.js
var require_Line = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Line.js"(exports, module) {
    var Path = require_Path();
    var _subPixelOptimize = require_subPixelOptimize();
    var subPixelOptimizeLine = _subPixelOptimize.subPixelOptimizeLine;
    var subPixelOptimizeOutputShape = {};
    var _default = Path.extend({
      type: "line",
      shape: {
        // Start point
        x1: 0,
        y1: 0,
        // End point
        x2: 0,
        y2: 0,
        percent: 1
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var x1;
        var y1;
        var x2;
        var y2;
        if (this.subPixelOptimize) {
          subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style);
          x1 = subPixelOptimizeOutputShape.x1;
          y1 = subPixelOptimizeOutputShape.y1;
          x2 = subPixelOptimizeOutputShape.x2;
          y2 = subPixelOptimizeOutputShape.y2;
        } else {
          x1 = shape.x1;
          y1 = shape.y1;
          x2 = shape.x2;
          y2 = shape.y2;
        }
        var percent = shape.percent;
        if (percent === 0) {
          return;
        }
        ctx.moveTo(x1, y1);
        if (percent < 1) {
          x2 = x1 * (1 - percent) + x2 * percent;
          y2 = y1 * (1 - percent) + y2 * percent;
        }
        ctx.lineTo(x2, y2);
      },
      /**
       * Get point at percent
       * @param  {number} percent
       * @return {Array.<number>}
       */
      pointAt: function(p) {
        var shape = this.shape;
        return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/BezierCurve.js
var require_BezierCurve = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/BezierCurve.js"(exports, module) {
    var Path = require_Path();
    var vec2 = require_vector();
    var _curve = require_curve();
    var quadraticSubdivide = _curve.quadraticSubdivide;
    var cubicSubdivide = _curve.cubicSubdivide;
    var quadraticAt = _curve.quadraticAt;
    var cubicAt = _curve.cubicAt;
    var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
    var cubicDerivativeAt = _curve.cubicDerivativeAt;
    var out = [];
    function someVectorAt(shape, t, isTangent) {
      var cpx2 = shape.cpx2;
      var cpy2 = shape.cpy2;
      if (cpx2 === null || cpy2 === null) {
        return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];
      } else {
        return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];
      }
    }
    var _default = Path.extend({
      type: "bezier-curve",
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cpx1: 0,
        cpy1: 0,
        // cpx2: 0,
        // cpy2: 0
        // Curve show percent, for animating
        percent: 1
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var x1 = shape.x1;
        var y1 = shape.y1;
        var x2 = shape.x2;
        var y2 = shape.y2;
        var cpx1 = shape.cpx1;
        var cpy1 = shape.cpy1;
        var cpx2 = shape.cpx2;
        var cpy2 = shape.cpy2;
        var percent = shape.percent;
        if (percent === 0) {
          return;
        }
        ctx.moveTo(x1, y1);
        if (cpx2 == null || cpy2 == null) {
          if (percent < 1) {
            quadraticSubdivide(x1, cpx1, x2, percent, out);
            cpx1 = out[1];
            x2 = out[2];
            quadraticSubdivide(y1, cpy1, y2, percent, out);
            cpy1 = out[1];
            y2 = out[2];
          }
          ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
        } else {
          if (percent < 1) {
            cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
            cpx1 = out[1];
            cpx2 = out[2];
            x2 = out[3];
            cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
            cpy1 = out[1];
            cpy2 = out[2];
            y2 = out[3];
          }
          ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
        }
      },
      /**
       * Get point at percent
       * @param  {number} t
       * @return {Array.<number>}
       */
      pointAt: function(t) {
        return someVectorAt(this.shape, t, false);
      },
      /**
       * Get tangent at percent
       * @param  {number} t
       * @return {Array.<number>}
       */
      tangentAt: function(t) {
        var p = someVectorAt(this.shape, t, true);
        return vec2.normalize(p, p);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Arc.js
var require_Arc = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Arc.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "arc",
      shape: {
        cx: 0,
        cy: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r = Math.max(shape.r, 0);
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitX = Math.cos(startAngle);
        var unitY = Math.sin(startAngle);
        ctx.moveTo(unitX * r + x, unitY * r + y);
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/CompoundPath.js
var require_CompoundPath = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/CompoundPath.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "compound",
      shape: {
        paths: null
      },
      _updatePathDirty: function() {
        var dirtyPath = this.__dirtyPath;
        var paths = this.shape.paths;
        for (var i = 0; i < paths.length; i++) {
          dirtyPath = dirtyPath || paths[i].__dirtyPath;
        }
        this.__dirtyPath = dirtyPath;
        this.__dirty = this.__dirty || dirtyPath;
      },
      beforeBrush: function() {
        this._updatePathDirty();
        var paths = this.shape.paths || [];
        var scale = this.getGlobalScale();
        for (var i = 0; i < paths.length; i++) {
          if (!paths[i].path) {
            paths[i].createPathProxy();
          }
          paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
        }
      },
      buildPath: function(ctx, shape) {
        var paths = shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
          paths[i].buildPath(ctx, paths[i].shape, true);
        }
      },
      afterBrush: function() {
        var paths = this.shape.paths || [];
        for (var i = 0; i < paths.length; i++) {
          paths[i].__dirtyPath = false;
        }
      },
      getBoundingRect: function() {
        this._updatePathDirty();
        return Path.prototype.getBoundingRect.call(this);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Gradient.js
var require_Gradient = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/Gradient.js"(exports, module) {
    var Gradient = function(colorStops) {
      this.colorStops = colorStops || [];
    };
    Gradient.prototype = {
      constructor: Gradient,
      addColorStop: function(offset, color) {
        this.colorStops.push({
          offset,
          color
        });
      }
    };
    var _default = Gradient;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/LinearGradient.js
var require_LinearGradient = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/LinearGradient.js"(exports, module) {
    var zrUtil = require_util();
    var Gradient = require_Gradient();
    var LinearGradient = function(x, y, x2, y2, colorStops, globalCoord) {
      this.x = x == null ? 0 : x;
      this.y = y == null ? 0 : y;
      this.x2 = x2 == null ? 1 : x2;
      this.y2 = y2 == null ? 0 : y2;
      this.type = "linear";
      this.global = globalCoord || false;
      Gradient.call(this, colorStops);
    };
    LinearGradient.prototype = {
      constructor: LinearGradient
    };
    zrUtil.inherits(LinearGradient, Gradient);
    var _default = LinearGradient;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/RadialGradient.js
var require_RadialGradient = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/RadialGradient.js"(exports, module) {
    var zrUtil = require_util();
    var Gradient = require_Gradient();
    var RadialGradient = function(x, y, r, colorStops, globalCoord) {
      this.x = x == null ? 0.5 : x;
      this.y = y == null ? 0.5 : y;
      this.r = r == null ? 0.5 : r;
      this.type = "radial";
      this.global = globalCoord || false;
      Gradient.call(this, colorStops);
    };
    RadialGradient.prototype = {
      constructor: RadialGradient
    };
    zrUtil.inherits(RadialGradient, Gradient);
    var _default = RadialGradient;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/IncrementalDisplayable.js
var require_IncrementalDisplayable = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/IncrementalDisplayable.js"(exports, module) {
    var _util = require_util();
    var inherits = _util.inherits;
    var Displayble = require_Displayable();
    var BoundingRect = require_BoundingRect();
    function IncrementalDisplayble(opts) {
      Displayble.call(this, opts);
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.notClear = true;
    }
    IncrementalDisplayble.prototype.incremental = true;
    IncrementalDisplayble.prototype.clearDisplaybles = function() {
      this._displayables = [];
      this._temporaryDisplayables = [];
      this._cursor = 0;
      this.dirty();
      this.notClear = false;
    };
    IncrementalDisplayble.prototype.addDisplayable = function(displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable);
      } else {
        this._displayables.push(displayable);
      }
      this.dirty();
    };
    IncrementalDisplayble.prototype.addDisplayables = function(displayables, notPersistent) {
      notPersistent = notPersistent || false;
      for (var i = 0; i < displayables.length; i++) {
        this.addDisplayable(displayables[i], notPersistent);
      }
    };
    IncrementalDisplayble.prototype.eachPendingDisplayable = function(cb) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        cb && cb(this._displayables[i]);
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        cb && cb(this._temporaryDisplayables[i]);
      }
    };
    IncrementalDisplayble.prototype.update = function() {
      this.updateTransform();
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.parent = this;
        displayable.update();
        displayable.parent = null;
      }
    };
    IncrementalDisplayble.prototype.brush = function(ctx, prevEl) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }
      this._cursor = i;
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i];
        displayable.beforeBrush && displayable.beforeBrush(ctx);
        displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
        displayable.afterBrush && displayable.afterBrush(ctx);
      }
      this._temporaryDisplayables = [];
      this.notClear = true;
    };
    var m = [];
    IncrementalDisplayble.prototype.getBoundingRect = function() {
      if (!this._rect) {
        var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          var childRect = displayable.getBoundingRect().clone();
          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m));
          }
          rect.union(childRect);
        }
        this._rect = rect;
      }
      return this._rect;
    };
    IncrementalDisplayble.prototype.contain = function(x, y) {
      var localPos = this.transformCoordToLocal(x, y);
      var rect = this.getBoundingRect();
      if (rect.contain(localPos[0], localPos[1])) {
        for (var i = 0; i < this._displayables.length; i++) {
          var displayable = this._displayables[i];
          if (displayable.contain(x, y)) {
            return true;
          }
        }
      }
      return false;
    };
    inherits(IncrementalDisplayble, Displayble);
    var _default = IncrementalDisplayble;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/graphic.js
var require_graphic = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/graphic.js"(exports) {
    var zrUtil = require_util();
    var pathTool = require_path2();
    var colorTool = require_color();
    var matrix = require_matrix();
    var vector = require_vector();
    var Path = require_Path();
    var Transformable = require_Transformable();
    var ZImage = require_Image();
    exports.Image = ZImage;
    var Group = require_Group();
    exports.Group = Group;
    var Text = require_Text();
    exports.Text = Text;
    var Circle = require_Circle();
    exports.Circle = Circle;
    var Sector = require_Sector();
    exports.Sector = Sector;
    var Ring = require_Ring();
    exports.Ring = Ring;
    var Polygon = require_Polygon();
    exports.Polygon = Polygon;
    var Polyline = require_Polyline();
    exports.Polyline = Polyline;
    var Rect = require_Rect();
    exports.Rect = Rect;
    var Line = require_Line();
    exports.Line = Line;
    var BezierCurve = require_BezierCurve();
    exports.BezierCurve = BezierCurve;
    var Arc = require_Arc();
    exports.Arc = Arc;
    var CompoundPath = require_CompoundPath();
    exports.CompoundPath = CompoundPath;
    var LinearGradient = require_LinearGradient();
    exports.LinearGradient = LinearGradient;
    var RadialGradient = require_RadialGradient();
    exports.RadialGradient = RadialGradient;
    var BoundingRect = require_BoundingRect();
    exports.BoundingRect = BoundingRect;
    var IncrementalDisplayable = require_IncrementalDisplayable();
    exports.IncrementalDisplayable = IncrementalDisplayable;
    var subPixelOptimizeUtil = require_subPixelOptimize();
    var mathMax = Math.max;
    var mathMin = Math.min;
    var EMPTY_OBJ = {};
    var Z2_EMPHASIS_LIFT = 1;
    var CACHED_LABEL_STYLE_PROPERTIES = {
      color: "textFill",
      textBorderColor: "textStroke",
      textBorderWidth: "textStrokeWidth"
    };
    var EMPHASIS = "emphasis";
    var NORMAL = "normal";
    var _highlightNextDigit = 1;
    var _highlightKeyMap = {};
    var _customShapeMap = {};
    function extendShape(opts) {
      return Path.extend(opts);
    }
    function extendPath(pathData, opts) {
      return pathTool.extendFromString(pathData, opts);
    }
    function registerShape(name2, ShapeClass) {
      _customShapeMap[name2] = ShapeClass;
    }
    function getShapeClass(name2) {
      if (_customShapeMap.hasOwnProperty(name2)) {
        return _customShapeMap[name2];
      }
    }
    function makePath(pathData, opts, rect, layout) {
      var path = pathTool.createFromString(pathData, opts);
      if (rect) {
        if (layout === "center") {
          rect = centerGraphic(rect, path.getBoundingRect());
        }
        resizePath(path, rect);
      }
      return path;
    }
    function makeImage(imageUrl, rect, layout) {
      var path = new ZImage({
        style: {
          image: imageUrl,
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        },
        onload: function(img) {
          if (layout === "center") {
            var boundingRect = {
              width: img.width,
              height: img.height
            };
            path.setStyle(centerGraphic(rect, boundingRect));
          }
        }
      });
      return path;
    }
    function centerGraphic(rect, boundingRect) {
      var aspect = boundingRect.width / boundingRect.height;
      var width = rect.height * aspect;
      var height;
      if (width <= rect.width) {
        height = rect.height;
      } else {
        width = rect.width;
        height = width / aspect;
      }
      var cx = rect.x + rect.width / 2;
      var cy = rect.y + rect.height / 2;
      return {
        x: cx - width / 2,
        y: cy - height / 2,
        width,
        height
      };
    }
    var mergePath = pathTool.mergePath;
    function resizePath(path, rect) {
      if (!path.applyTransform) {
        return;
      }
      var pathRect = path.getBoundingRect();
      var m = pathRect.calculateTransform(rect);
      path.applyTransform(m);
    }
    function subPixelOptimizeLine(param) {
      subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);
      return param;
    }
    function subPixelOptimizeRect(param) {
      subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);
      return param;
    }
    var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;
    function hasFillOrStroke(fillOrStroke) {
      return fillOrStroke != null && fillOrStroke !== "none";
    }
    var liftedColorMap = zrUtil.createHashMap();
    var liftedColorCount = 0;
    function liftColor(color) {
      if (typeof color !== "string") {
        return color;
      }
      var liftedColor = liftedColorMap.get(color);
      if (!liftedColor) {
        liftedColor = colorTool.lift(color, -0.1);
        if (liftedColorCount < 1e4) {
          liftedColorMap.set(color, liftedColor);
          liftedColorCount++;
        }
      }
      return liftedColor;
    }
    function cacheElementStl(el) {
      if (!el.__hoverStlDirty) {
        return;
      }
      el.__hoverStlDirty = false;
      var hoverStyle = el.__hoverStl;
      if (!hoverStyle) {
        el.__cachedNormalStl = el.__cachedNormalZ2 = null;
        return;
      }
      var normalStyle = el.__cachedNormalStl = {};
      el.__cachedNormalZ2 = el.z2;
      var elStyle = el.style;
      for (var name2 in hoverStyle) {
        if (hoverStyle[name2] != null) {
          normalStyle[name2] = elStyle[name2];
        }
      }
      normalStyle.fill = elStyle.fill;
      normalStyle.stroke = elStyle.stroke;
    }
    function singleEnterEmphasis(el) {
      var hoverStl = el.__hoverStl;
      if (!hoverStl || el.__highlighted) {
        return;
      }
      var zr = el.__zr;
      var useHoverLayer = el.useHoverLayer && zr && zr.painter.type === "canvas";
      el.__highlighted = useHoverLayer ? "layer" : "plain";
      if (el.isGroup || !zr && el.useHoverLayer) {
        return;
      }
      var elTarget = el;
      var targetStyle = el.style;
      if (useHoverLayer) {
        elTarget = zr.addHover(el);
        targetStyle = elTarget.style;
      }
      rollbackDefaultTextStyle(targetStyle);
      if (!useHoverLayer) {
        cacheElementStl(elTarget);
      }
      targetStyle.extendFrom(hoverStl);
      setDefaultHoverFillStroke(targetStyle, hoverStl, "fill");
      setDefaultHoverFillStroke(targetStyle, hoverStl, "stroke");
      applyDefaultTextStyle(targetStyle);
      if (!useHoverLayer) {
        el.dirty(false);
        el.z2 += Z2_EMPHASIS_LIFT;
      }
    }
    function setDefaultHoverFillStroke(targetStyle, hoverStyle, prop) {
      if (!hasFillOrStroke(hoverStyle[prop]) && hasFillOrStroke(targetStyle[prop])) {
        targetStyle[prop] = liftColor(targetStyle[prop]);
      }
    }
    function singleEnterNormal(el) {
      var highlighted = el.__highlighted;
      if (!highlighted) {
        return;
      }
      el.__highlighted = false;
      if (el.isGroup) {
        return;
      }
      if (highlighted === "layer") {
        el.__zr && el.__zr.removeHover(el);
      } else {
        var style = el.style;
        var normalStl = el.__cachedNormalStl;
        if (normalStl) {
          rollbackDefaultTextStyle(style);
          el.setStyle(normalStl);
          applyDefaultTextStyle(style);
        }
        var normalZ2 = el.__cachedNormalZ2;
        if (normalZ2 != null && el.z2 - normalZ2 === Z2_EMPHASIS_LIFT) {
          el.z2 = normalZ2;
        }
      }
    }
    function traverseUpdate(el, updater, commonParam) {
      var fromState = NORMAL;
      var toState = NORMAL;
      var trigger;
      el.__highlighted && (fromState = EMPHASIS, trigger = true);
      updater(el, commonParam);
      el.__highlighted && (toState = EMPHASIS, trigger = true);
      el.isGroup && el.traverse(function(child) {
        !child.isGroup && updater(child, commonParam);
      });
      trigger && el.__highDownOnUpdate && el.__highDownOnUpdate(fromState, toState);
    }
    function setElementHoverStyle(el, hoverStl) {
      hoverStl = el.__hoverStl = hoverStl !== false && (el.hoverStyle || hoverStl || {});
      el.__hoverStlDirty = true;
      if (el.__highlighted) {
        el.__cachedNormalStl = null;
        singleEnterNormal(el);
        singleEnterEmphasis(el);
      }
    }
    function onElementMouseOver(e) {
      !shouldSilent(this, e) && !this.__highByOuter && traverseUpdate(this, singleEnterEmphasis);
    }
    function onElementMouseOut(e) {
      !shouldSilent(this, e) && !this.__highByOuter && traverseUpdate(this, singleEnterNormal);
    }
    function onElementEmphasisEvent(highlightDigit) {
      this.__highByOuter |= 1 << (highlightDigit || 0);
      traverseUpdate(this, singleEnterEmphasis);
    }
    function onElementNormalEvent(highlightDigit) {
      !(this.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdate(this, singleEnterNormal);
    }
    function shouldSilent(el, e) {
      return el.__highDownSilentOnTouch && e.zrByTouch;
    }
    function setHoverStyle(el, hoverStyle) {
      setAsHighDownDispatcher(el, true);
      traverseUpdate(el, setElementHoverStyle, hoverStyle);
    }
    function setAsHighDownDispatcher(el, asDispatcher) {
      var disable = asDispatcher === false;
      el.__highDownSilentOnTouch = el.highDownSilentOnTouch;
      el.__highDownOnUpdate = el.highDownOnUpdate;
      if (!disable || el.__highDownDispatcher) {
        var method = disable ? "off" : "on";
        el[method]("mouseover", onElementMouseOver)[method]("mouseout", onElementMouseOut);
        el[method]("emphasis", onElementEmphasisEvent)[method]("normal", onElementNormalEvent);
        el.__highByOuter = el.__highByOuter || 0;
        el.__highDownDispatcher = !disable;
      }
    }
    function isHighDownDispatcher(el) {
      return !!(el && el.__highDownDispatcher);
    }
    function getHighlightDigit(highlightKey) {
      var highlightDigit = _highlightKeyMap[highlightKey];
      if (highlightDigit == null && _highlightNextDigit <= 32) {
        highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
      }
      return highlightDigit;
    }
    function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
      opt = opt || EMPTY_OBJ;
      var labelFetcher = opt.labelFetcher;
      var labelDataIndex = opt.labelDataIndex;
      var labelDimIndex = opt.labelDimIndex;
      var labelProp = opt.labelProp;
      var showNormal = normalModel.getShallow("show");
      var showEmphasis = emphasisModel.getShallow("show");
      var baseText;
      if (showNormal || showEmphasis) {
        if (labelFetcher) {
          baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, labelProp);
        }
        if (baseText == null) {
          baseText = zrUtil.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt) : opt.defaultText;
        }
      }
      var normalStyleText = showNormal ? baseText : null;
      var emphasisStyleText = showEmphasis ? zrUtil.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, "emphasis", null, labelDimIndex, labelProp) : null, baseText) : null;
      if (normalStyleText != null || emphasisStyleText != null) {
        setTextStyle(normalStyle, normalModel, normalSpecified, opt);
        setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
      }
      normalStyle.text = normalStyleText;
      emphasisStyle.text = emphasisStyleText;
    }
    function modifyLabelStyle(el, normalStyleProps, emphasisStyleProps) {
      var elStyle = el.style;
      if (normalStyleProps) {
        rollbackDefaultTextStyle(elStyle);
        el.setStyle(normalStyleProps);
        applyDefaultTextStyle(elStyle);
      }
      elStyle = el.__hoverStl;
      if (emphasisStyleProps && elStyle) {
        rollbackDefaultTextStyle(elStyle);
        zrUtil.extend(elStyle, emphasisStyleProps);
        applyDefaultTextStyle(elStyle);
      }
    }
    function setTextStyle(textStyle, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
      setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis);
      specifiedTextStyle && zrUtil.extend(textStyle, specifiedTextStyle);
      return textStyle;
    }
    function setText(textStyle, labelModel, defaultColor) {
      var opt = {
        isRectText: true
      };
      var isEmphasis;
      if (defaultColor === false) {
        isEmphasis = true;
      } else {
        opt.autoColor = defaultColor;
      }
      setTextStyleCommon(textStyle, labelModel, opt, isEmphasis);
    }
    function setTextStyleCommon(textStyle, textStyleModel, opt, isEmphasis) {
      opt = opt || EMPTY_OBJ;
      if (opt.isRectText) {
        var textPosition;
        if (opt.getTextPosition) {
          textPosition = opt.getTextPosition(textStyleModel, isEmphasis);
        } else {
          textPosition = textStyleModel.getShallow("position") || (isEmphasis ? null : "inside");
          textPosition === "outside" && (textPosition = "top");
        }
        textStyle.textPosition = textPosition;
        textStyle.textOffset = textStyleModel.getShallow("offset");
        var labelRotate = textStyleModel.getShallow("rotate");
        labelRotate != null && (labelRotate *= Math.PI / 180);
        textStyle.textRotation = labelRotate;
        textStyle.textDistance = zrUtil.retrieve2(textStyleModel.getShallow("distance"), isEmphasis ? null : 5);
      }
      var ecModel = textStyleModel.ecModel;
      var globalTextStyle = ecModel && ecModel.option.textStyle;
      var richItemNames = getRichItemNames(textStyleModel);
      var richResult;
      if (richItemNames) {
        richResult = {};
        for (var name2 in richItemNames) {
          if (richItemNames.hasOwnProperty(name2)) {
            var richTextStyle = textStyleModel.getModel(["rich", name2]);
            setTokenTextStyle(richResult[name2] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
          }
        }
      }
      textStyle.rich = richResult;
      setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, true);
      if (opt.forceRich && !opt.textStyle) {
        opt.textStyle = {};
      }
      return textStyle;
    }
    function getRichItemNames(textStyleModel) {
      var richItemNameMap;
      while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
        var rich = (textStyleModel.option || EMPTY_OBJ).rich;
        if (rich) {
          richItemNameMap = richItemNameMap || {};
          for (var name2 in rich) {
            if (rich.hasOwnProperty(name2)) {
              richItemNameMap[name2] = 1;
            }
          }
        }
        textStyleModel = textStyleModel.parentModel;
      }
      return richItemNameMap;
    }
    function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
      globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
      textStyle.textFill = getAutoColor(textStyleModel.getShallow("color"), opt) || globalTextStyle.color;
      textStyle.textStroke = getAutoColor(textStyleModel.getShallow("textBorderColor"), opt) || globalTextStyle.textBorderColor;
      textStyle.textStrokeWidth = zrUtil.retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
      if (!isEmphasis) {
        if (isBlock) {
          textStyle.insideRollbackOpt = opt;
          applyDefaultTextStyle(textStyle);
        }
        if (textStyle.textFill == null) {
          textStyle.textFill = opt.autoColor;
        }
      }
      textStyle.fontStyle = textStyleModel.getShallow("fontStyle") || globalTextStyle.fontStyle;
      textStyle.fontWeight = textStyleModel.getShallow("fontWeight") || globalTextStyle.fontWeight;
      textStyle.fontSize = textStyleModel.getShallow("fontSize") || globalTextStyle.fontSize;
      textStyle.fontFamily = textStyleModel.getShallow("fontFamily") || globalTextStyle.fontFamily;
      textStyle.textAlign = textStyleModel.getShallow("align");
      textStyle.textVerticalAlign = textStyleModel.getShallow("verticalAlign") || textStyleModel.getShallow("baseline");
      textStyle.textLineHeight = textStyleModel.getShallow("lineHeight");
      textStyle.textWidth = textStyleModel.getShallow("width");
      textStyle.textHeight = textStyleModel.getShallow("height");
      textStyle.textTag = textStyleModel.getShallow("tag");
      if (!isBlock || !opt.disableBox) {
        textStyle.textBackgroundColor = getAutoColor(textStyleModel.getShallow("backgroundColor"), opt);
        textStyle.textPadding = textStyleModel.getShallow("padding");
        textStyle.textBorderColor = getAutoColor(textStyleModel.getShallow("borderColor"), opt);
        textStyle.textBorderWidth = textStyleModel.getShallow("borderWidth");
        textStyle.textBorderRadius = textStyleModel.getShallow("borderRadius");
        textStyle.textBoxShadowColor = textStyleModel.getShallow("shadowColor");
        textStyle.textBoxShadowBlur = textStyleModel.getShallow("shadowBlur");
        textStyle.textBoxShadowOffsetX = textStyleModel.getShallow("shadowOffsetX");
        textStyle.textBoxShadowOffsetY = textStyleModel.getShallow("shadowOffsetY");
      }
      textStyle.textShadowColor = textStyleModel.getShallow("textShadowColor") || globalTextStyle.textShadowColor;
      textStyle.textShadowBlur = textStyleModel.getShallow("textShadowBlur") || globalTextStyle.textShadowBlur;
      textStyle.textShadowOffsetX = textStyleModel.getShallow("textShadowOffsetX") || globalTextStyle.textShadowOffsetX;
      textStyle.textShadowOffsetY = textStyleModel.getShallow("textShadowOffsetY") || globalTextStyle.textShadowOffsetY;
    }
    function getAutoColor(color, opt) {
      return color !== "auto" ? color : opt && opt.autoColor ? opt.autoColor : null;
    }
    function applyDefaultTextStyle(textStyle) {
      var textPosition = textStyle.textPosition;
      var opt = textStyle.insideRollbackOpt;
      var insideRollback;
      if (opt && textStyle.textFill == null) {
        var autoColor = opt.autoColor;
        var isRectText = opt.isRectText;
        var useInsideStyle = opt.useInsideStyle;
        var useInsideStyleCache = useInsideStyle !== false && (useInsideStyle === true || isRectText && textPosition && typeof textPosition === "string" && textPosition.indexOf("inside") >= 0);
        var useAutoColorCache = !useInsideStyleCache && autoColor != null;
        if (useInsideStyleCache || useAutoColorCache) {
          insideRollback = {
            textFill: textStyle.textFill,
            textStroke: textStyle.textStroke,
            textStrokeWidth: textStyle.textStrokeWidth
          };
        }
        if (useInsideStyleCache) {
          textStyle.textFill = "#fff";
          if (textStyle.textStroke == null) {
            textStyle.textStroke = autoColor;
            textStyle.textStrokeWidth == null && (textStyle.textStrokeWidth = 2);
          }
        }
        if (useAutoColorCache) {
          textStyle.textFill = autoColor;
        }
      }
      textStyle.insideRollback = insideRollback;
    }
    function rollbackDefaultTextStyle(style) {
      var insideRollback = style.insideRollback;
      if (insideRollback) {
        style.textFill = insideRollback.textFill;
        style.textStroke = insideRollback.textStroke;
        style.textStrokeWidth = insideRollback.textStrokeWidth;
        style.insideRollback = null;
      }
    }
    function getFont(opt, ecModel) {
      var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
      return zrUtil.trim([
        // FIXME in node-canvas fontWeight is before fontStyle
        opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
        opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
        (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
        opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
      ].join(" "));
    }
    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
      if (typeof dataIndex === "function") {
        cb = dataIndex;
        dataIndex = null;
      }
      var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
      if (animationEnabled) {
        var postfix = isUpdate ? "Update" : "";
        var duration = animatableModel.getShallow("animationDuration" + postfix);
        var animationEasing = animatableModel.getShallow("animationEasing" + postfix);
        var animationDelay = animatableModel.getShallow("animationDelay" + postfix);
        if (typeof animationDelay === "function") {
          animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
        }
        if (typeof duration === "function") {
          duration = duration(dataIndex);
        }
        duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
      } else {
        el.stopAnimation();
        el.attr(props);
        cb && cb();
      }
    }
    function updateProps(el, props, animatableModel, dataIndex, cb) {
      animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
    }
    function initProps(el, props, animatableModel, dataIndex, cb) {
      animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
    }
    function getTransform(target, ancestor) {
      var mat = matrix.identity([]);
      while (target && target !== ancestor) {
        matrix.mul(mat, target.getLocalTransform(), mat);
        target = target.parent;
      }
      return mat;
    }
    function applyTransform(target, transform, invert) {
      if (transform && !zrUtil.isArrayLike(transform)) {
        transform = Transformable.getLocalTransform(transform);
      }
      if (invert) {
        transform = matrix.invert([], transform);
      }
      return vector.applyTransform([], target, transform);
    }
    function transformDirection(direction, transform, invert) {
      var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
      var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
      var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
      vertex = applyTransform(vertex, transform, invert);
      return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
    }
    function groupTransition(g1, g2, animatableModel, cb) {
      if (!g1 || !g2) {
        return;
      }
      function getElMap(g) {
        var elMap = {};
        g.traverse(function(el) {
          if (!el.isGroup && el.anid) {
            elMap[el.anid] = el;
          }
        });
        return elMap;
      }
      function getAnimatableProps(el) {
        var obj = {
          position: vector.clone(el.position),
          rotation: el.rotation
        };
        if (el.shape) {
          obj.shape = zrUtil.extend({}, el.shape);
        }
        return obj;
      }
      var elMap1 = getElMap(g1);
      g2.traverse(function(el) {
        if (!el.isGroup && el.anid) {
          var oldEl = elMap1[el.anid];
          if (oldEl) {
            var newProp = getAnimatableProps(el);
            el.attr(getAnimatableProps(oldEl));
            updateProps(el, newProp, animatableModel, el.dataIndex);
          }
        }
      });
    }
    function clipPointsByRect(points, rect) {
      return zrUtil.map(points, function(point) {
        var x = point[0];
        x = mathMax(x, rect.x);
        x = mathMin(x, rect.x + rect.width);
        var y = point[1];
        y = mathMax(y, rect.y);
        y = mathMin(y, rect.y + rect.height);
        return [x, y];
      });
    }
    function clipRectByRect(targetRect, rect) {
      var x = mathMax(targetRect.x, rect.x);
      var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
      var y = mathMax(targetRect.y, rect.y);
      var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);
      if (x2 >= x && y2 >= y) {
        return {
          x,
          y,
          width: x2 - x,
          height: y2 - y
        };
      }
    }
    function createIcon(iconStr, opt, rect) {
      opt = zrUtil.extend({
        rectHover: true
      }, opt);
      var style = opt.style = {
        strokeNoScale: true
      };
      rect = rect || {
        x: -1,
        y: -1,
        width: 2,
        height: 2
      };
      if (iconStr) {
        return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), zrUtil.defaults(style, rect), new ZImage(opt)) : makePath(iconStr.replace("path://", ""), opt, rect, "center");
      }
    }
    function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {
      for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
        var p = points[i];
        if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
          return true;
        }
        p2 = p;
      }
    }
    function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
      var mx = a2x - a1x;
      var my = a2y - a1y;
      var nx = b2x - b1x;
      var ny = b2y - b1y;
      var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
      if (nearZero(nmCrossProduct)) {
        return false;
      }
      var b1a1x = a1x - b1x;
      var b1a1y = a1y - b1y;
      var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
      if (q < 0 || q > 1) {
        return false;
      }
      var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
      if (p < 0 || p > 1) {
        return false;
      }
      return true;
    }
    function crossProduct2d(x1, y1, x2, y2) {
      return x1 * y2 - x2 * y1;
    }
    function nearZero(val) {
      return val <= 1e-6 && val >= -1e-6;
    }
    registerShape("circle", Circle);
    registerShape("sector", Sector);
    registerShape("ring", Ring);
    registerShape("polygon", Polygon);
    registerShape("polyline", Polyline);
    registerShape("rect", Rect);
    registerShape("line", Line);
    registerShape("bezierCurve", BezierCurve);
    registerShape("arc", Arc);
    exports.Z2_EMPHASIS_LIFT = Z2_EMPHASIS_LIFT;
    exports.CACHED_LABEL_STYLE_PROPERTIES = CACHED_LABEL_STYLE_PROPERTIES;
    exports.extendShape = extendShape;
    exports.extendPath = extendPath;
    exports.registerShape = registerShape;
    exports.getShapeClass = getShapeClass;
    exports.makePath = makePath;
    exports.makeImage = makeImage;
    exports.mergePath = mergePath;
    exports.resizePath = resizePath;
    exports.subPixelOptimizeLine = subPixelOptimizeLine;
    exports.subPixelOptimizeRect = subPixelOptimizeRect;
    exports.subPixelOptimize = subPixelOptimize;
    exports.setElementHoverStyle = setElementHoverStyle;
    exports.setHoverStyle = setHoverStyle;
    exports.setAsHighDownDispatcher = setAsHighDownDispatcher;
    exports.isHighDownDispatcher = isHighDownDispatcher;
    exports.getHighlightDigit = getHighlightDigit;
    exports.setLabelStyle = setLabelStyle;
    exports.modifyLabelStyle = modifyLabelStyle;
    exports.setTextStyle = setTextStyle;
    exports.setText = setText;
    exports.getFont = getFont;
    exports.updateProps = updateProps;
    exports.initProps = initProps;
    exports.getTransform = getTransform;
    exports.applyTransform = applyTransform;
    exports.transformDirection = transformDirection;
    exports.groupTransition = groupTransition;
    exports.clipPointsByRect = clipPointsByRect;
    exports.clipRectByRect = clipRectByRect;
    exports.createIcon = createIcon;
    exports.linePolygonIntersect = linePolygonIntersect;
    exports.lineLineIntersect = lineLineIntersect;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/textStyle.js
var require_textStyle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/textStyle.js"(exports, module) {
    var textContain = require_text();
    var graphicUtil = require_graphic();
    var PATH_COLOR = ["textStyle", "color"];
    var _default = {
      /**
       * Get color property or get color from option.textStyle.color
       * @param {boolean} [isEmphasis]
       * @return {string}
       */
      getTextColor: function(isEmphasis) {
        var ecModel = this.ecModel;
        return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
      },
      /**
       * Create font string from fontStyle, fontWeight, fontSize, fontFamily
       * @return {string}
       */
      getFont: function() {
        return graphicUtil.getFont({
          fontStyle: this.getShallow("fontStyle"),
          fontWeight: this.getShallow("fontWeight"),
          fontSize: this.getShallow("fontSize"),
          fontFamily: this.getShallow("fontFamily")
        }, this.ecModel);
      },
      getTextRect: function(text) {
        return textContain.getBoundingRect(text, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText"));
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/itemStyle.js
var require_itemStyle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/itemStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getItemStyle = makeStyleMapper([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]);
    var _default = {
      getItemStyle: function(excludes, includes) {
        var style = getItemStyle(this, excludes, includes);
        var lineDash = this.getBorderLineDash();
        lineDash && (style.lineDash = lineDash);
        return style;
      },
      getBorderLineDash: function() {
        var lineType = this.get("borderType");
        return lineType === "solid" || lineType == null ? null : lineType === "dashed" ? [5, 5] : [1, 1];
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Model.js
var require_Model = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Model.js"(exports, module) {
    var zrUtil = require_util();
    var env = require_env();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var _clazz = require_clazz();
    var enableClassExtend = _clazz.enableClassExtend;
    var enableClassCheck = _clazz.enableClassCheck;
    var lineStyleMixin = require_lineStyle();
    var areaStyleMixin = require_areaStyle();
    var textStyleMixin = require_textStyle();
    var itemStyleMixin = require_itemStyle();
    var mixin = zrUtil.mixin;
    var inner = makeInner();
    function Model(option, parentModel, ecModel) {
      this.parentModel = parentModel;
      this.ecModel = ecModel;
      this.option = option;
    }
    Model.prototype = {
      constructor: Model,
      /**
       * Model 的初始化函数
       * @param {Object} option
       */
      init: null,
      /**
       * 从新的 Option merge
       */
      mergeOption: function(option) {
        zrUtil.merge(this.option, option, true);
      },
      /**
       * @param {string|Array.<string>} path
       * @param {boolean} [ignoreParent=false]
       * @return {*}
       */
      get: function(path, ignoreParent) {
        if (path == null) {
          return this.option;
        }
        return doGet(this.option, this.parsePath(path), !ignoreParent && getParent(this, path));
      },
      /**
       * @param {string} key
       * @param {boolean} [ignoreParent=false]
       * @return {*}
       */
      getShallow: function(key, ignoreParent) {
        var option = this.option;
        var val = option == null ? option : option[key];
        var parentModel = !ignoreParent && getParent(this, key);
        if (val == null && parentModel) {
          val = parentModel.getShallow(key);
        }
        return val;
      },
      /**
       * @param {string|Array.<string>} [path]
       * @param {module:echarts/model/Model} [parentModel]
       * @return {module:echarts/model/Model}
       */
      getModel: function(path, parentModel) {
        var obj = path == null ? this.option : doGet(this.option, path = this.parsePath(path));
        var thisParentModel;
        parentModel = parentModel || (thisParentModel = getParent(this, path)) && thisParentModel.getModel(path);
        return new Model(obj, parentModel, this.ecModel);
      },
      /**
       * If model has option
       */
      isEmpty: function() {
        return this.option == null;
      },
      restoreData: function() {
      },
      // Pending
      clone: function() {
        var Ctor = this.constructor;
        return new Ctor(zrUtil.clone(this.option));
      },
      setReadOnly: function(properties) {
      },
      // If path is null/undefined, return null/undefined.
      parsePath: function(path) {
        if (typeof path === "string") {
          path = path.split(".");
        }
        return path;
      },
      /**
       * @param {Function} getParentMethod
       *        param {Array.<string>|string} path
       *        return {module:echarts/model/Model}
       */
      customizeGetParent: function(getParentMethod) {
        inner(this).getParent = getParentMethod;
      },
      isAnimationEnabled: function() {
        if (!env.node) {
          if (this.option.animation != null) {
            return !!this.option.animation;
          } else if (this.parentModel) {
            return this.parentModel.isAnimationEnabled();
          }
        }
      }
    };
    function doGet(obj, pathArr, parentModel) {
      for (var i = 0; i < pathArr.length; i++) {
        if (!pathArr[i]) {
          continue;
        }
        obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
        if (obj == null) {
          break;
        }
      }
      if (obj == null && parentModel) {
        obj = parentModel.get(pathArr);
      }
      return obj;
    }
    function getParent(model, path) {
      var getParentMethod = inner(model).getParent;
      return getParentMethod ? getParentMethod.call(model, path) : model.parentModel;
    }
    enableClassExtend(Model);
    enableClassCheck(Model);
    mixin(Model, lineStyleMixin);
    mixin(Model, areaStyleMixin);
    mixin(Model, textStyleMixin);
    mixin(Model, itemStyleMixin);
    var _default = Model;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/component.js
var require_component = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/component.js"(exports) {
    var zrUtil = require_util();
    var _clazz = require_clazz();
    var parseClassType = _clazz.parseClassType;
    var base = 0;
    function getUID(type) {
      return [type || "", base++, Math.random().toFixed(5)].join("_");
    }
    function enableSubTypeDefaulter(entity) {
      var subTypeDefaulters = {};
      entity.registerSubTypeDefaulter = function(componentType, defaulter) {
        componentType = parseClassType(componentType);
        subTypeDefaulters[componentType.main] = defaulter;
      };
      entity.determineSubType = function(componentType, option) {
        var type = option.type;
        if (!type) {
          var componentTypeMain = parseClassType(componentType).main;
          if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
            type = subTypeDefaulters[componentTypeMain](option);
          }
        }
        return type;
      };
      return entity;
    }
    function enableTopologicalTravel(entity, dependencyGetter) {
      entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
        if (!targetNameList.length) {
          return;
        }
        var result = makeDepndencyGraph(fullNameList);
        var graph = result.graph;
        var stack = result.noEntryList;
        var targetNameSet = {};
        zrUtil.each(targetNameList, function(name2) {
          targetNameSet[name2] = true;
        });
        while (stack.length) {
          var currComponentType = stack.pop();
          var currVertex = graph[currComponentType];
          var isInTargetNameSet = !!targetNameSet[currComponentType];
          if (isInTargetNameSet) {
            callback.call(context, currComponentType, currVertex.originalDeps.slice());
            delete targetNameSet[currComponentType];
          }
          zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
        }
        zrUtil.each(targetNameSet, function() {
          throw new Error("Circle dependency may exists");
        });
        function removeEdge(succComponentType) {
          graph[succComponentType].entryCount--;
          if (graph[succComponentType].entryCount === 0) {
            stack.push(succComponentType);
          }
        }
        function removeEdgeAndAdd(succComponentType) {
          targetNameSet[succComponentType] = true;
          removeEdge(succComponentType);
        }
      };
      function makeDepndencyGraph(fullNameList) {
        var graph = {};
        var noEntryList = [];
        zrUtil.each(fullNameList, function(name2) {
          var thisItem = createDependencyGraphItem(graph, name2);
          var originalDeps = thisItem.originalDeps = dependencyGetter(name2);
          var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
          thisItem.entryCount = availableDeps.length;
          if (thisItem.entryCount === 0) {
            noEntryList.push(name2);
          }
          zrUtil.each(availableDeps, function(dependentName) {
            if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
              thisItem.predecessor.push(dependentName);
            }
            var thatItem = createDependencyGraphItem(graph, dependentName);
            if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
              thatItem.successor.push(name2);
            }
          });
        });
        return {
          graph,
          noEntryList
        };
      }
      function createDependencyGraphItem(graph, name2) {
        if (!graph[name2]) {
          graph[name2] = {
            predecessor: [],
            successor: []
          };
        }
        return graph[name2];
      }
      function getAvailableDependencies(originalDeps, fullNameList) {
        var availableDeps = [];
        zrUtil.each(originalDeps, function(dep) {
          zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
        });
        return availableDeps;
      }
    }
    exports.getUID = getUID;
    exports.enableSubTypeDefaulter = enableSubTypeDefaulter;
    exports.enableTopologicalTravel = enableTopologicalTravel;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/number.js
var require_number = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/number.js"(exports) {
    var zrUtil = require_util();
    var RADIAN_EPSILON = 1e-4;
    function _trim(str) {
      return str.replace(/^\s+|\s+$/g, "");
    }
    function linearMap(val, domain, range, clamp) {
      var subDomain = domain[1] - domain[0];
      var subRange = range[1] - range[0];
      if (subDomain === 0) {
        return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
      }
      if (clamp) {
        if (subDomain > 0) {
          if (val <= domain[0]) {
            return range[0];
          } else if (val >= domain[1]) {
            return range[1];
          }
        } else {
          if (val >= domain[0]) {
            return range[0];
          } else if (val <= domain[1]) {
            return range[1];
          }
        }
      } else {
        if (val === domain[0]) {
          return range[0];
        }
        if (val === domain[1]) {
          return range[1];
        }
      }
      return (val - domain[0]) / subDomain * subRange + range[0];
    }
    function parsePercent(percent, all) {
      switch (percent) {
        case "center":
        case "middle":
          percent = "50%";
          break;
        case "left":
        case "top":
          percent = "0%";
          break;
        case "right":
        case "bottom":
          percent = "100%";
          break;
      }
      if (typeof percent === "string") {
        if (_trim(percent).match(/%$/)) {
          return parseFloat(percent) / 100 * all;
        }
        return parseFloat(percent);
      }
      return percent == null ? NaN : +percent;
    }
    function round(x, precision, returnStr) {
      if (precision == null) {
        precision = 10;
      }
      precision = Math.min(Math.max(0, precision), 20);
      x = (+x).toFixed(precision);
      return returnStr ? x : +x;
    }
    function asc(arr) {
      arr.sort(function(a, b) {
        return a - b;
      });
      return arr;
    }
    function getPrecision(val) {
      val = +val;
      if (isNaN(val)) {
        return 0;
      }
      var e = 1;
      var count = 0;
      while (Math.round(val * e) / e !== val) {
        e *= 10;
        count++;
      }
      return count;
    }
    function getPrecisionSafe(val) {
      var str = val.toString();
      var eIndex = str.indexOf("e");
      if (eIndex > 0) {
        var precision = +str.slice(eIndex + 1);
        return precision < 0 ? -precision : 0;
      } else {
        var dotIndex = str.indexOf(".");
        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
      }
    }
    function getPixelPrecision(dataExtent, pixelExtent) {
      var log = Math.log;
      var LN10 = Math.LN10;
      var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
      var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
      var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
      return !isFinite(precision) ? 20 : precision;
    }
    function getPercentWithPrecision(valueList, idx, precision) {
      if (!valueList[idx]) {
        return 0;
      }
      var sum = zrUtil.reduce(valueList, function(acc, val) {
        return acc + (isNaN(val) ? 0 : val);
      }, 0);
      if (sum === 0) {
        return 0;
      }
      var digits = Math.pow(10, precision);
      var votesPerQuota = zrUtil.map(valueList, function(val) {
        return (isNaN(val) ? 0 : val) / sum * digits * 100;
      });
      var targetSeats = digits * 100;
      var seats = zrUtil.map(votesPerQuota, function(votes) {
        return Math.floor(votes);
      });
      var currentSum = zrUtil.reduce(seats, function(acc, val) {
        return acc + val;
      }, 0);
      var remainder = zrUtil.map(votesPerQuota, function(votes, idx2) {
        return votes - seats[idx2];
      });
      while (currentSum < targetSeats) {
        var max = Number.NEGATIVE_INFINITY;
        var maxId = null;
        for (var i = 0, len = remainder.length; i < len; ++i) {
          if (remainder[i] > max) {
            max = remainder[i];
            maxId = i;
          }
        }
        ++seats[maxId];
        remainder[maxId] = 0;
        ++currentSum;
      }
      return seats[idx] / digits;
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    function remRadian(radian) {
      var pi2 = Math.PI * 2;
      return (radian % pi2 + pi2) % pi2;
    }
    function isRadianAroundZero(val) {
      return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
    }
    var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
    function parseDate(value) {
      if (value instanceof Date) {
        return value;
      } else if (typeof value === "string") {
        var match = TIME_REG.exec(value);
        if (!match) {
          return /* @__PURE__ */ new Date(NaN);
        }
        if (!match[8]) {
          return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
        } else {
          var hour = +match[4] || 0;
          if (match[8].toUpperCase() !== "Z") {
            hour -= match[8].slice(0, 3);
          }
          return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
        }
      } else if (value == null) {
        return /* @__PURE__ */ new Date(NaN);
      }
      return new Date(Math.round(value));
    }
    function quantity(val) {
      return Math.pow(10, quantityExponent(val));
    }
    function quantityExponent(val) {
      if (val === 0) {
        return 0;
      }
      var exp = Math.floor(Math.log(val) / Math.LN10);
      if (val / Math.pow(10, exp) >= 10) {
        exp++;
      }
      return exp;
    }
    function nice(val, round2) {
      var exponent = quantityExponent(val);
      var exp10 = Math.pow(10, exponent);
      var f = val / exp10;
      var nf;
      if (round2) {
        if (f < 1.5) {
          nf = 1;
        } else if (f < 2.5) {
          nf = 2;
        } else if (f < 4) {
          nf = 3;
        } else if (f < 7) {
          nf = 5;
        } else {
          nf = 10;
        }
      } else {
        if (f < 1) {
          nf = 1;
        } else if (f < 2) {
          nf = 2;
        } else if (f < 3) {
          nf = 3;
        } else if (f < 5) {
          nf = 5;
        } else {
          nf = 10;
        }
      }
      val = nf * exp10;
      return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
    }
    function quantile(ascArr, p) {
      var H = (ascArr.length - 1) * p + 1;
      var h = Math.floor(H);
      var v = +ascArr[h - 1];
      var e = H - h;
      return e ? v + e * (ascArr[h] - v) : v;
    }
    function reformIntervals(list) {
      list.sort(function(a, b) {
        return littleThan(a, b, 0) ? -1 : 1;
      });
      var curr = -Infinity;
      var currClose = 1;
      for (var i = 0; i < list.length; ) {
        var interval = list[i].interval;
        var close = list[i].close;
        for (var lg = 0; lg < 2; lg++) {
          if (interval[lg] <= curr) {
            interval[lg] = curr;
            close[lg] = !lg ? 1 - currClose : 1;
          }
          curr = interval[lg];
          currClose = close[lg];
        }
        if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
          list.splice(i, 1);
        } else {
          i++;
        }
      }
      return list;
      function littleThan(a, b, lg2) {
        return a.interval[lg2] < b.interval[lg2] || a.interval[lg2] === b.interval[lg2] && (a.close[lg2] - b.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan(a, b, 1));
      }
    }
    function isNumeric(v) {
      return v - parseFloat(v) >= 0;
    }
    exports.linearMap = linearMap;
    exports.parsePercent = parsePercent;
    exports.round = round;
    exports.asc = asc;
    exports.getPrecision = getPrecision;
    exports.getPrecisionSafe = getPrecisionSafe;
    exports.getPixelPrecision = getPixelPrecision;
    exports.getPercentWithPrecision = getPercentWithPrecision;
    exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    exports.remRadian = remRadian;
    exports.isRadianAroundZero = isRadianAroundZero;
    exports.parseDate = parseDate;
    exports.quantity = quantity;
    exports.quantityExponent = quantityExponent;
    exports.nice = nice;
    exports.quantile = quantile;
    exports.reformIntervals = reformIntervals;
    exports.isNumeric = isNumeric;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/format.js
var require_format = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/format.js"(exports) {
    var zrUtil = require_util();
    var textContain = require_text();
    var numberUtil = require_number();
    function addCommas(x) {
      if (isNaN(x)) {
        return "-";
      }
      x = (x + "").split(".");
      return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (x.length > 1 ? "." + x[1] : "");
    }
    function toCamelCase(str, upperCaseFirst) {
      str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
        return group1.toUpperCase();
      });
      if (upperCaseFirst && str) {
        str = str.charAt(0).toUpperCase() + str.slice(1);
      }
      return str;
    }
    var normalizeCssArray = zrUtil.normalizeCssArray;
    var replaceReg = /([&<>"'])/g;
    var replaceMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    function encodeHTML(source) {
      return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
        return replaceMap[c];
      });
    }
    var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
    var wrapVar = function(varName, seriesIdx) {
      return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
    };
    function formatTpl(tpl, paramsList, encode) {
      if (!zrUtil.isArray(paramsList)) {
        paramsList = [paramsList];
      }
      var seriesLen = paramsList.length;
      if (!seriesLen) {
        return "";
      }
      var $vars = paramsList[0].$vars || [];
      for (var i = 0; i < $vars.length; i++) {
        var alias = TPL_VAR_ALIAS[i];
        tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
      }
      for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
        for (var k = 0; k < $vars.length; k++) {
          var val = paramsList[seriesIdx][$vars[k]];
          tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
        }
      }
      return tpl;
    }
    function formatTplSimple(tpl, param, encode) {
      zrUtil.each(param, function(value, key) {
        tpl = tpl.replace("{" + key + "}", encode ? encodeHTML(value) : value);
      });
      return tpl;
    }
    function getTooltipMarker(opt, extraCssText) {
      opt = zrUtil.isString(opt) ? {
        color: opt,
        extraCssText
      } : opt || {};
      var color = opt.color;
      var type = opt.type;
      var extraCssText = opt.extraCssText;
      var renderMode = opt.renderMode || "html";
      var markerId = opt.markerId || "X";
      if (!color) {
        return "";
      }
      if (renderMode === "html") {
        return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ";" + (extraCssText || "") + '"></span>';
      } else {
        return {
          renderMode,
          content: "{marker" + markerId + "|}  ",
          style: {
            color
          }
        };
      }
    }
    function pad(str, len) {
      str += "";
      return "0000".substr(0, len - str.length) + str;
    }
    function formatTime(tpl, value, isUTC) {
      if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
        tpl = "MM-dd\nyyyy";
      }
      var date = numberUtil.parseDate(value);
      var utc = isUTC ? "UTC" : "";
      var y = date["get" + utc + "FullYear"]();
      var M = date["get" + utc + "Month"]() + 1;
      var d = date["get" + utc + "Date"]();
      var h = date["get" + utc + "Hours"]();
      var m = date["get" + utc + "Minutes"]();
      var s = date["get" + utc + "Seconds"]();
      var S = date["get" + utc + "Milliseconds"]();
      tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", y % 100).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m, 2)).replace("m", m).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
      return tpl;
    }
    function capitalFirst(str) {
      return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
    }
    var truncateText = textContain.truncateText;
    function getTextBoundingRect(opt) {
      return textContain.getBoundingRect(opt.text, opt.font, opt.textAlign, opt.textVerticalAlign, opt.textPadding, opt.textLineHeight, opt.rich, opt.truncate);
    }
    function getTextRect(text, font, textAlign, textVerticalAlign, textPadding, rich, truncate, textLineHeight) {
      return textContain.getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate);
    }
    function windowOpen(link, target) {
      if (target === "_blank" || target === "blank") {
        var blank = window.open();
        blank.opener = null;
        blank.location = link;
      } else {
        window.open(link, target);
      }
    }
    exports.addCommas = addCommas;
    exports.toCamelCase = toCamelCase;
    exports.normalizeCssArray = normalizeCssArray;
    exports.encodeHTML = encodeHTML;
    exports.formatTpl = formatTpl;
    exports.formatTplSimple = formatTplSimple;
    exports.getTooltipMarker = getTooltipMarker;
    exports.formatTime = formatTime;
    exports.capitalFirst = capitalFirst;
    exports.truncateText = truncateText;
    exports.getTextBoundingRect = getTextBoundingRect;
    exports.getTextRect = getTextRect;
    exports.windowOpen = windowOpen;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/layout.js
var require_layout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/layout.js"(exports) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var formatUtil = require_format();
    var each = zrUtil.each;
    var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
    var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
    function boxLayout(orient, group, gap, maxWidth, maxHeight) {
      var x = 0;
      var y = 0;
      if (maxWidth == null) {
        maxWidth = Infinity;
      }
      if (maxHeight == null) {
        maxHeight = Infinity;
      }
      var currentLineMaxSize = 0;
      group.eachChild(function(child, idx) {
        var position = child.position;
        var rect = child.getBoundingRect();
        var nextChild = group.childAt(idx + 1);
        var nextChildRect = nextChild && nextChild.getBoundingRect();
        var nextX;
        var nextY;
        if (orient === "horizontal") {
          var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
          nextX = x + moveX;
          if (nextX > maxWidth || child.newline) {
            x = 0;
            nextX = moveX;
            y += currentLineMaxSize + gap;
            currentLineMaxSize = rect.height;
          } else {
            currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
          }
        } else {
          var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
          nextY = y + moveY;
          if (nextY > maxHeight || child.newline) {
            x += currentLineMaxSize + gap;
            y = 0;
            nextY = moveY;
            currentLineMaxSize = rect.width;
          } else {
            currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
          }
        }
        if (child.newline) {
          return;
        }
        position[0] = x;
        position[1] = y;
        orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
      });
    }
    var box = boxLayout;
    var vbox = zrUtil.curry(boxLayout, "vertical");
    var hbox = zrUtil.curry(boxLayout, "horizontal");
    function getAvailableSize(positionInfo, containerRect, margin) {
      var containerWidth = containerRect.width;
      var containerHeight = containerRect.height;
      var x = parsePercent(positionInfo.x, containerWidth);
      var y = parsePercent(positionInfo.y, containerHeight);
      var x2 = parsePercent(positionInfo.x2, containerWidth);
      var y2 = parsePercent(positionInfo.y2, containerHeight);
      (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
      (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
      (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
      (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
      margin = formatUtil.normalizeCssArray(margin || 0);
      return {
        width: Math.max(x2 - x - margin[1] - margin[3], 0),
        height: Math.max(y2 - y - margin[0] - margin[2], 0)
      };
    }
    function getLayoutRect(positionInfo, containerRect, margin) {
      margin = formatUtil.normalizeCssArray(margin || 0);
      var containerWidth = containerRect.width;
      var containerHeight = containerRect.height;
      var left = parsePercent(positionInfo.left, containerWidth);
      var top = parsePercent(positionInfo.top, containerHeight);
      var right = parsePercent(positionInfo.right, containerWidth);
      var bottom = parsePercent(positionInfo.bottom, containerHeight);
      var width = parsePercent(positionInfo.width, containerWidth);
      var height = parsePercent(positionInfo.height, containerHeight);
      var verticalMargin = margin[2] + margin[0];
      var horizontalMargin = margin[1] + margin[3];
      var aspect = positionInfo.aspect;
      if (isNaN(width)) {
        width = containerWidth - right - horizontalMargin - left;
      }
      if (isNaN(height)) {
        height = containerHeight - bottom - verticalMargin - top;
      }
      if (aspect != null) {
        if (isNaN(width) && isNaN(height)) {
          if (aspect > containerWidth / containerHeight) {
            width = containerWidth * 0.8;
          } else {
            height = containerHeight * 0.8;
          }
        }
        if (isNaN(width)) {
          width = aspect * height;
        }
        if (isNaN(height)) {
          height = width / aspect;
        }
      }
      if (isNaN(left)) {
        left = containerWidth - right - width - horizontalMargin;
      }
      if (isNaN(top)) {
        top = containerHeight - bottom - height - verticalMargin;
      }
      switch (positionInfo.left || positionInfo.right) {
        case "center":
          left = containerWidth / 2 - width / 2 - margin[3];
          break;
        case "right":
          left = containerWidth - width - horizontalMargin;
          break;
      }
      switch (positionInfo.top || positionInfo.bottom) {
        case "middle":
        case "center":
          top = containerHeight / 2 - height / 2 - margin[0];
          break;
        case "bottom":
          top = containerHeight - height - verticalMargin;
          break;
      }
      left = left || 0;
      top = top || 0;
      if (isNaN(width)) {
        width = containerWidth - horizontalMargin - left - (right || 0);
      }
      if (isNaN(height)) {
        height = containerHeight - verticalMargin - top - (bottom || 0);
      }
      var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
      rect.margin = margin;
      return rect;
    }
    function positionElement(el, positionInfo, containerRect, margin, opt) {
      var h = !opt || !opt.hv || opt.hv[0];
      var v = !opt || !opt.hv || opt.hv[1];
      var boundingMode = opt && opt.boundingMode || "all";
      if (!h && !v) {
        return;
      }
      var rect;
      if (boundingMode === "raw") {
        rect = el.type === "group" ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
      } else {
        rect = el.getBoundingRect();
        if (el.needLocalTransform()) {
          var transform = el.getLocalTransform();
          rect = rect.clone();
          rect.applyTransform(transform);
        }
      }
      positionInfo = getLayoutRect(zrUtil.defaults({
        width: rect.width,
        height: rect.height
      }, positionInfo), containerRect, margin);
      var elPos = el.position;
      var dx = h ? positionInfo.x - rect.x : 0;
      var dy = v ? positionInfo.y - rect.y : 0;
      el.attr("position", boundingMode === "raw" ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
    }
    function sizeCalculable(option, hvIdx) {
      return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
    }
    function mergeLayoutParam(targetOption, newOption, opt) {
      !zrUtil.isObject(opt) && (opt = {});
      var ignoreSize = opt.ignoreSize;
      !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
      var hResult = merge(HV_NAMES[0], 0);
      var vResult = merge(HV_NAMES[1], 1);
      copy(HV_NAMES[0], targetOption, hResult);
      copy(HV_NAMES[1], targetOption, vResult);
      function merge(names, hvIdx) {
        var newParams = {};
        var newValueCount = 0;
        var merged = {};
        var mergedValueCount = 0;
        var enoughParamNumber = 2;
        each(names, function(name3) {
          merged[name3] = targetOption[name3];
        });
        each(names, function(name3) {
          hasProp(newOption, name3) && (newParams[name3] = merged[name3] = newOption[name3]);
          hasValue(newParams, name3) && newValueCount++;
          hasValue(merged, name3) && mergedValueCount++;
        });
        if (ignoreSize[hvIdx]) {
          if (hasValue(newOption, names[1])) {
            merged[names[2]] = null;
          } else if (hasValue(newOption, names[2])) {
            merged[names[1]] = null;
          }
          return merged;
        }
        if (mergedValueCount === enoughParamNumber || !newValueCount) {
          return merged;
        } else if (newValueCount >= enoughParamNumber) {
          return newParams;
        } else {
          for (var i = 0; i < names.length; i++) {
            var name2 = names[i];
            if (!hasProp(newParams, name2) && hasProp(targetOption, name2)) {
              newParams[name2] = targetOption[name2];
              break;
            }
          }
          return newParams;
        }
      }
      function hasProp(obj, name2) {
        return obj.hasOwnProperty(name2);
      }
      function hasValue(obj, name2) {
        return obj[name2] != null && obj[name2] !== "auto";
      }
      function copy(names, target, source) {
        each(names, function(name2) {
          target[name2] = source[name2];
        });
      }
    }
    function getLayoutParams(source) {
      return copyLayoutParams({}, source);
    }
    function copyLayoutParams(target, source) {
      source && target && each(LOCATION_PARAMS, function(name2) {
        source.hasOwnProperty(name2) && (target[name2] = source[name2]);
      });
      return target;
    }
    exports.LOCATION_PARAMS = LOCATION_PARAMS;
    exports.HV_NAMES = HV_NAMES;
    exports.box = box;
    exports.vbox = vbox;
    exports.hbox = hbox;
    exports.getAvailableSize = getAvailableSize;
    exports.getLayoutRect = getLayoutRect;
    exports.positionElement = positionElement;
    exports.sizeCalculable = sizeCalculable;
    exports.mergeLayoutParam = mergeLayoutParam;
    exports.getLayoutParams = getLayoutParams;
    exports.copyLayoutParams = copyLayoutParams;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/boxLayout.js
var require_boxLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/boxLayout.js"(exports, module) {
    var _default = {
      getBoxLayoutParams: function() {
        return {
          left: this.get("left"),
          top: this.get("top"),
          right: this.get("right"),
          bottom: this.get("bottom"),
          width: this.get("width"),
          height: this.get("height")
        };
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Component.js
var require_Component = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Component.js"(exports, module) {
    var zrUtil = require_util();
    var Model = require_Model();
    var componentUtil = require_component();
    var _clazz = require_clazz();
    var enableClassManagement = _clazz.enableClassManagement;
    var parseClassType = _clazz.parseClassType;
    var _model = require_model();
    var makeInner = _model.makeInner;
    var layout = require_layout();
    var boxLayoutMixin = require_boxLayout();
    var inner = makeInner();
    var ComponentModel = Model.extend({
      type: "component",
      /**
       * @readOnly
       * @type {string}
       */
      id: "",
      /**
       * Because simplified concept is probably better, series.name (or component.name)
       * has been having too many resposibilities:
       * (1) Generating id (which requires name in option should not be modified).
       * (2) As an index to mapping series when merging option or calling API (a name
       * can refer to more then one components, which is convinient is some case).
       * (3) Display.
       * @readOnly
       */
      name: "",
      /**
       * @readOnly
       * @type {string}
       */
      mainType: "",
      /**
       * @readOnly
       * @type {string}
       */
      subType: "",
      /**
       * @readOnly
       * @type {number}
       */
      componentIndex: 0,
      /**
       * @type {Object}
       * @protected
       */
      defaultOption: null,
      /**
       * @type {module:echarts/model/Global}
       * @readOnly
       */
      ecModel: null,
      /**
       * key: componentType
       * value:  Component model list, can not be null.
       * @type {Object.<string, Array.<module:echarts/model/Model>>}
       * @readOnly
       */
      dependentModels: [],
      /**
       * @type {string}
       * @readOnly
       */
      uid: null,
      /**
       * Support merge layout params.
       * Only support 'box' now (left/right/top/bottom/width/height).
       * @type {string|Object} Object can be {ignoreSize: true}
       * @readOnly
       */
      layoutMode: null,
      $constructor: function(option, parentModel, ecModel, extraOpt) {
        Model.call(this, option, parentModel, ecModel, extraOpt);
        this.uid = componentUtil.getUID("ec_cpt_model");
      },
      init: function(option, parentModel, ecModel, extraOpt) {
        this.mergeDefaultAndTheme(option, ecModel);
      },
      mergeDefaultAndTheme: function(option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
        var themeModel = ecModel.getTheme();
        zrUtil.merge(option, themeModel.get(this.mainType));
        zrUtil.merge(option, this.getDefaultOption());
        if (layoutMode) {
          layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },
      mergeOption: function(option, extraOpt) {
        zrUtil.merge(this.option, option, true);
        var layoutMode = this.layoutMode;
        if (layoutMode) {
          layout.mergeLayoutParam(this.option, option, layoutMode);
        }
      },
      // Hooker after init or mergeOption
      optionUpdated: function(newCptOption, isInit) {
      },
      getDefaultOption: function() {
        var fields = inner(this);
        if (!fields.defaultOption) {
          var optList = [];
          var Class = this.constructor;
          while (Class) {
            var opt = Class.prototype.defaultOption;
            opt && optList.push(opt);
            Class = Class.superClass;
          }
          var defaultOption = {};
          for (var i = optList.length - 1; i >= 0; i--) {
            defaultOption = zrUtil.merge(defaultOption, optList[i], true);
          }
          fields.defaultOption = defaultOption;
        }
        return fields.defaultOption;
      },
      getReferringComponents: function(mainType) {
        return this.ecModel.queryComponents({
          mainType,
          index: this.get(mainType + "Index", true),
          id: this.get(mainType + "Id", true)
        });
      }
    });
    enableClassManagement(ComponentModel, {
      registerWhenExtend: true
    });
    componentUtil.enableSubTypeDefaulter(ComponentModel);
    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);
    function getDependencies(componentType) {
      var deps = [];
      zrUtil.each(ComponentModel.getClassesByMainType(componentType), function(Clazz) {
        deps = deps.concat(Clazz.prototype.dependencies || []);
      });
      deps = zrUtil.map(deps, function(type) {
        return parseClassType(type).main;
      });
      if (componentType !== "dataset" && zrUtil.indexOf(deps, "dataset") <= 0) {
        deps.unshift("dataset");
      }
      return deps;
    }
    zrUtil.mixin(ComponentModel, boxLayoutMixin);
    var _default = ComponentModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/globalDefault.js
var require_globalDefault = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/globalDefault.js"(exports, module) {
    var platform = "";
    if (typeof navigator !== "undefined") {
      platform = navigator.platform || "";
    }
    var _default = {
      // backgroundColor: 'rgba(0,0,0,0)',
      // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
      // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
      // Light colors:
      // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
      // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
      // Dark colors:
      color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
      gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
      // If xAxis and yAxis declared, grid is created by default.
      // grid: {},
      textStyle: {
        // color: '#000',
        // decoration: 'none',
        // PENDING
        fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
        // fontFamily: 'Arial, Verdana, sans-serif',
        fontSize: 12,
        fontStyle: "normal",
        fontWeight: "normal"
      },
      // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
      // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
      // Default is source-over
      blendMode: null,
      animation: "auto",
      animationDuration: 1e3,
      animationDurationUpdate: 300,
      animationEasing: "exponentialOut",
      animationEasingUpdate: "cubicOut",
      animationThreshold: 2e3,
      // Configuration for progressive/incremental rendering
      progressiveThreshold: 3e3,
      progressive: 400,
      // Threshold of if use single hover layer to optimize.
      // It is recommended that `hoverLayerThreshold` is equivalent to or less than
      // `progressiveThreshold`, otherwise hover will cause restart of progressive,
      // which is unexpected.
      // see example <echarts/test/heatmap-large.html>.
      hoverLayerThreshold: 3e3,
      // See: module:echarts/scale/Time
      useUTC: false
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/colorPalette.js
var require_colorPalette = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/colorPalette.js"(exports, module) {
    var _model = require_model();
    var makeInner = _model.makeInner;
    var normalizeToArray = _model.normalizeToArray;
    var inner = makeInner();
    function getNearestColorPalette(colors, requestColorNum) {
      var paletteNum = colors.length;
      for (var i = 0; i < paletteNum; i++) {
        if (colors[i].length > requestColorNum) {
          return colors[i];
        }
      }
      return colors[paletteNum - 1];
    }
    var _default = {
      clearColorPalette: function() {
        inner(this).colorIdx = 0;
        inner(this).colorNameMap = {};
      },
      /**
       * @param {string} name MUST NOT be null/undefined. Otherwise call this function
       *                 twise with the same parameters will get different result.
       * @param {Object} [scope=this]
       * @param {Object} [requestColorNum]
       * @return {string} color string.
       */
      getColorFromPalette: function(name2, scope, requestColorNum) {
        scope = scope || this;
        var scopeFields = inner(scope);
        var colorIdx = scopeFields.colorIdx || 0;
        var colorNameMap = scopeFields.colorNameMap = scopeFields.colorNameMap || {};
        if (colorNameMap.hasOwnProperty(name2)) {
          return colorNameMap[name2];
        }
        var defaultColorPalette = normalizeToArray(this.get("color", true));
        var layeredColorPalette = this.get("colorLayer", true);
        var colorPalette = requestColorNum == null || !layeredColorPalette ? defaultColorPalette : getNearestColorPalette(layeredColorPalette, requestColorNum);
        colorPalette = colorPalette || defaultColorPalette;
        if (!colorPalette || !colorPalette.length) {
          return;
        }
        var color = colorPalette[colorIdx];
        if (name2) {
          colorNameMap[name2] = color;
        }
        scopeFields.colorIdx = (colorIdx + 1) % colorPalette.length;
        return color;
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/sourceType.js
var require_sourceType = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/sourceType.js"(exports) {
    var SOURCE_FORMAT_ORIGINAL = "original";
    var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
    var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
    var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
    var SOURCE_FORMAT_UNKNOWN = "unknown";
    var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
    var SERIES_LAYOUT_BY_COLUMN = "column";
    var SERIES_LAYOUT_BY_ROW = "row";
    exports.SOURCE_FORMAT_ORIGINAL = SOURCE_FORMAT_ORIGINAL;
    exports.SOURCE_FORMAT_ARRAY_ROWS = SOURCE_FORMAT_ARRAY_ROWS;
    exports.SOURCE_FORMAT_OBJECT_ROWS = SOURCE_FORMAT_OBJECT_ROWS;
    exports.SOURCE_FORMAT_KEYED_COLUMNS = SOURCE_FORMAT_KEYED_COLUMNS;
    exports.SOURCE_FORMAT_UNKNOWN = SOURCE_FORMAT_UNKNOWN;
    exports.SOURCE_FORMAT_TYPED_ARRAY = SOURCE_FORMAT_TYPED_ARRAY;
    exports.SERIES_LAYOUT_BY_COLUMN = SERIES_LAYOUT_BY_COLUMN;
    exports.SERIES_LAYOUT_BY_ROW = SERIES_LAYOUT_BY_ROW;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Source.js
var require_Source = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Source.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var isTypedArray = _util.isTypedArray;
    var _clazz = require_clazz();
    var enableClassCheck = _clazz.enableClassCheck;
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var SERIES_LAYOUT_BY_COLUMN = _sourceType.SERIES_LAYOUT_BY_COLUMN;
    var SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;
    var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
    function Source(fields) {
      this.fromDataset = fields.fromDataset;
      this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
      this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
      this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
      this.dimensionsDefine = fields.dimensionsDefine;
      this.encodeDefine = fields.encodeDefine && createHashMap(fields.encodeDefine);
      this.startIndex = fields.startIndex || 0;
      this.dimensionsDetectCount = fields.dimensionsDetectCount;
    }
    Source.seriesDataToSource = function(data) {
      return new Source({
        data,
        sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL,
        fromDataset: false
      });
    };
    enableClassCheck(Source);
    var _default = Source;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/sourceHelper.js
var require_sourceHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/sourceHelper.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _model = require_model();
    var makeInner = _model.makeInner;
    var getDataItemValue = _model.getDataItemValue;
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    var map = _util.map;
    var isArray = _util.isArray;
    var isString = _util.isString;
    var isObject = _util.isObject;
    var isTypedArray = _util.isTypedArray;
    var isArrayLike = _util.isArrayLike;
    var extend = _util.extend;
    var assert = _util.assert;
    var Source = require_Source();
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;
    var SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;
    var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;
    var SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;
    var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;
    var BE_ORDINAL = {
      Must: 1,
      // Encounter string but not '-' and not number-like.
      Might: 2,
      // Encounter string but number-like.
      Not: 3
      // Other cases
    };
    var inner = makeInner();
    function detectSourceFormat(datasetModel) {
      var data = datasetModel.option.source;
      var sourceFormat = SOURCE_FORMAT_UNKNOWN;
      if (isTypedArray(data)) {
        sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
      } else if (isArray(data)) {
        if (data.length === 0) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        }
        for (var i = 0, len = data.length; i < len; i++) {
          var item = data[i];
          if (item == null) {
            continue;
          } else if (isArray(item)) {
            sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
            break;
          } else if (isObject(item)) {
            sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
            break;
          }
        }
      } else if (isObject(data)) {
        for (var key in data) {
          if (data.hasOwnProperty(key) && isArrayLike(data[key])) {
            sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
            break;
          }
        }
      } else if (data != null) {
        throw new Error("Invalid data");
      }
      inner(datasetModel).sourceFormat = sourceFormat;
    }
    function getSource(seriesModel) {
      return inner(seriesModel).source;
    }
    function resetSourceDefaulter(ecModel) {
      inner(ecModel).datasetMap = createHashMap();
    }
    function prepareSource(seriesModel) {
      var seriesOption = seriesModel.option;
      var data = seriesOption.data;
      var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
      var fromDataset = false;
      var seriesLayoutBy = seriesOption.seriesLayoutBy;
      var sourceHeader = seriesOption.sourceHeader;
      var dimensionsDefine = seriesOption.dimensions;
      var datasetModel = getDatasetModel(seriesModel);
      if (datasetModel) {
        var datasetOption = datasetModel.option;
        data = datasetOption.source;
        sourceFormat = inner(datasetModel).sourceFormat;
        fromDataset = true;
        seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;
        sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);
        dimensionsDefine = dimensionsDefine || datasetOption.dimensions;
      }
      var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);
      inner(seriesModel).source = new Source({
        data,
        fromDataset,
        seriesLayoutBy,
        sourceFormat,
        dimensionsDefine: completeResult.dimensionsDefine,
        startIndex: completeResult.startIndex,
        dimensionsDetectCount: completeResult.dimensionsDetectCount,
        // Note: dataset option does not have `encode`.
        encodeDefine: seriesOption.encode
      });
    }
    function completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
      if (!data) {
        return {
          dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)
        };
      }
      var dimensionsDetectCount;
      var startIndex;
      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
        if (sourceHeader === "auto" || sourceHeader == null) {
          arrayRowsTravelFirst(function(val) {
            if (val != null && val !== "-") {
              if (isString(val)) {
                startIndex == null && (startIndex = 1);
              } else {
                startIndex = 0;
              }
            }
          }, seriesLayoutBy, data, 10);
        } else {
          startIndex = sourceHeader ? 1 : 0;
        }
        if (!dimensionsDefine && startIndex === 1) {
          dimensionsDefine = [];
          arrayRowsTravelFirst(function(val, index) {
            dimensionsDefine[index] = val != null ? val : "";
          }, seriesLayoutBy, data);
        }
        dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;
      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
        if (!dimensionsDefine) {
          dimensionsDefine = objectRowsCollectDimensions(data);
        }
      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
        if (!dimensionsDefine) {
          dimensionsDefine = [];
          each(data, function(colArr, key) {
            dimensionsDefine.push(key);
          });
        }
      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        var value0 = getDataItemValue(data[0]);
        dimensionsDetectCount = isArray(value0) && value0.length || 1;
      } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      }
      return {
        startIndex,
        dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),
        dimensionsDetectCount
      };
    }
    function normalizeDimensionsDefine(dimensionsDefine) {
      if (!dimensionsDefine) {
        return;
      }
      var nameMap = createHashMap();
      return map(dimensionsDefine, function(item, index) {
        item = extend({}, isObject(item) ? item : {
          name: item
        });
        if (item.name == null) {
          return item;
        }
        item.name += "";
        if (item.displayName == null) {
          item.displayName = item.name;
        }
        var exist = nameMap.get(item.name);
        if (!exist) {
          nameMap.set(item.name, {
            count: 1
          });
        } else {
          item.name += "-" + exist.count++;
        }
        return item;
      });
    }
    function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
      maxLoop == null && (maxLoop = Infinity);
      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          cb(data[i] ? data[i][0] : null, i);
        }
      } else {
        var value0 = data[0] || [];
        for (var i = 0; i < value0.length && i < maxLoop; i++) {
          cb(value0[i], i);
        }
      }
    }
    function objectRowsCollectDimensions(data) {
      var firstIndex = 0;
      var obj;
      while (firstIndex < data.length && !(obj = data[firstIndex++])) {
      }
      if (obj) {
        var dimensions = [];
        each(obj, function(value, key) {
          dimensions.push(key);
        });
        return dimensions;
      }
    }
    function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
      var encode = {};
      var datasetModel = getDatasetModel(seriesModel);
      if (!datasetModel || !coordDimensions) {
        return encode;
      }
      var encodeItemName = [];
      var encodeSeriesName = [];
      var ecModel = seriesModel.ecModel;
      var datasetMap = inner(ecModel).datasetMap;
      var key = datasetModel.uid + "_" + source.seriesLayoutBy;
      var baseCategoryDimIndex;
      var categoryWayValueDimStart;
      coordDimensions = coordDimensions.slice();
      each(coordDimensions, function(coordDimInfo, coordDimIdx) {
        !isObject(coordDimInfo) && (coordDimensions[coordDimIdx] = {
          name: coordDimInfo
        });
        if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
          baseCategoryDimIndex = coordDimIdx;
          categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);
        }
        encode[coordDimInfo.name] = [];
      });
      var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
        categoryWayDim: categoryWayValueDimStart,
        valueWayDim: 0
      });
      each(coordDimensions, function(coordDimInfo, coordDimIdx) {
        var coordDimName = coordDimInfo.name;
        var count = getDataDimCountOnCoordDim(coordDimInfo);
        if (baseCategoryDimIndex == null) {
          var start = datasetRecord.valueWayDim;
          pushDim(encode[coordDimName], start, count);
          pushDim(encodeSeriesName, start, count);
          datasetRecord.valueWayDim += count;
        } else if (baseCategoryDimIndex === coordDimIdx) {
          pushDim(encode[coordDimName], 0, count);
          pushDim(encodeItemName, 0, count);
        } else {
          var start = datasetRecord.categoryWayDim;
          pushDim(encode[coordDimName], start, count);
          pushDim(encodeSeriesName, start, count);
          datasetRecord.categoryWayDim += count;
        }
      });
      function pushDim(dimIdxArr, idxFrom, idxCount) {
        for (var i = 0; i < idxCount; i++) {
          dimIdxArr.push(idxFrom + i);
        }
      }
      function getDataDimCountOnCoordDim(coordDimInfo) {
        var dimsDef = coordDimInfo.dimsDef;
        return dimsDef ? dimsDef.length : 1;
      }
      encodeItemName.length && (encode.itemName = encodeItemName);
      encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
      return encode;
    }
    function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
      var encode = {};
      var datasetModel = getDatasetModel(seriesModel);
      if (!datasetModel) {
        return encode;
      }
      var sourceFormat = source.sourceFormat;
      var dimensionsDefine = source.dimensionsDefine;
      var potentialNameDimIndex;
      if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
        each(dimensionsDefine, function(dim, idx) {
          if ((isObject(dim) ? dim.name : dim) === "name") {
            potentialNameDimIndex = idx;
          }
        });
      }
      var idxResult = function() {
        var idxRes0 = {};
        var idxRes1 = {};
        var guessRecords = [];
        for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
          var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
          guessRecords.push(guessResult);
          var isPureNumber = guessResult === BE_ORDINAL.Not;
          if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
            idxRes0.v = i;
          }
          if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
            idxRes0.n = i;
          }
          if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
            return idxRes0;
          }
          if (!isPureNumber) {
            if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
              idxRes1.v = i;
            }
            if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
              idxRes1.n = i;
            }
          }
        }
        function fulfilled(idxResult2) {
          return idxResult2.v != null && idxResult2.n != null;
        }
        return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
      }();
      if (idxResult) {
        encode.value = idxResult.v;
        var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
        encode.itemName = [nameDimIndex];
        encode.seriesName = [nameDimIndex];
      }
      return encode;
    }
    function getDatasetModel(seriesModel) {
      var option = seriesModel.option;
      var thisData = option.data;
      if (!thisData) {
        return seriesModel.ecModel.getComponent("dataset", option.datasetIndex || 0);
      }
    }
    function guessOrdinal(source, dimIndex) {
      return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
    }
    function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
      var result;
      var maxLoop = 5;
      if (isTypedArray(data)) {
        return BE_ORDINAL.Not;
      }
      var dimName;
      var dimType;
      if (dimensionsDefine) {
        var dimDefItem = dimensionsDefine[dimIndex];
        if (isObject(dimDefItem)) {
          dimName = dimDefItem.name;
          dimType = dimDefItem.type;
        } else if (isString(dimDefItem)) {
          dimName = dimDefItem;
        }
      }
      if (dimType != null) {
        return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
      }
      if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
        if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
          var sample = data[dimIndex];
          for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
            if ((result = detectValue(sample[startIndex + i])) != null) {
              return result;
            }
          }
        } else {
          for (var i = 0; i < data.length && i < maxLoop; i++) {
            var row = data[startIndex + i];
            if (row && (result = detectValue(row[dimIndex])) != null) {
              return result;
            }
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
        if (!dimName) {
          return BE_ORDINAL.Not;
        }
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var item = data[i];
          if (item && (result = detectValue(item[dimName])) != null) {
            return result;
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
        if (!dimName) {
          return BE_ORDINAL.Not;
        }
        var sample = data[dimName];
        if (!sample || isTypedArray(sample)) {
          return BE_ORDINAL.Not;
        }
        for (var i = 0; i < sample.length && i < maxLoop; i++) {
          if ((result = detectValue(sample[i])) != null) {
            return result;
          }
        }
      } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var item = data[i];
          var val = getDataItemValue(item);
          if (!isArray(val)) {
            return BE_ORDINAL.Not;
          }
          if ((result = detectValue(val[dimIndex])) != null) {
            return result;
          }
        }
      }
      function detectValue(val2) {
        var beStr = isString(val2);
        if (val2 != null && isFinite(val2) && val2 !== "") {
          return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
        } else if (beStr && val2 !== "-") {
          return BE_ORDINAL.Must;
        }
      }
      return BE_ORDINAL.Not;
    }
    exports.BE_ORDINAL = BE_ORDINAL;
    exports.detectSourceFormat = detectSourceFormat;
    exports.getSource = getSource;
    exports.resetSourceDefaulter = resetSourceDefaulter;
    exports.prepareSource = prepareSource;
    exports.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;
    exports.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;
    exports.guessOrdinal = guessOrdinal;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Global.js
var require_Global = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Global.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var each = _util.each;
    var filter = _util.filter;
    var map = _util.map;
    var isArray = _util.isArray;
    var indexOf = _util.indexOf;
    var isObject = _util.isObject;
    var isString = _util.isString;
    var createHashMap = _util.createHashMap;
    var assert = _util.assert;
    var clone = _util.clone;
    var merge = _util.merge;
    var extend = _util.extend;
    var mixin = _util.mixin;
    var modelUtil = require_model();
    var Model = require_Model();
    var ComponentModel = require_Component();
    var globalDefault = require_globalDefault();
    var colorPaletteMixin = require_colorPalette();
    var _sourceHelper = require_sourceHelper();
    var resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;
    var OPTION_INNER_KEY = "\0_ec_inner";
    var GlobalModel = Model.extend({
      init: function(option, parentModel, theme, optionManager) {
        theme = theme || {};
        this.option = null;
        this._theme = new Model(theme);
        this._optionManager = optionManager;
      },
      setOption: function(option, optionPreprocessorFuncs) {
        assert(!(OPTION_INNER_KEY in option), "please use chart.getOption()");
        this._optionManager.setOption(option, optionPreprocessorFuncs);
        this.resetOption(null);
      },
      /**
       * @param {string} type null/undefined: reset all.
       *                      'recreate': force recreate all.
       *                      'timeline': only reset timeline option
       *                      'media': only reset media query option
       * @return {boolean} Whether option changed.
       */
      resetOption: function(type) {
        var optionChanged = false;
        var optionManager = this._optionManager;
        if (!type || type === "recreate") {
          var baseOption = optionManager.mountOption(type === "recreate");
          if (!this.option || type === "recreate") {
            initBase.call(this, baseOption);
          } else {
            this.restoreData();
            this.mergeOption(baseOption);
          }
          optionChanged = true;
        }
        if (type === "timeline" || type === "media") {
          this.restoreData();
        }
        if (!type || type === "recreate" || type === "timeline") {
          var timelineOption = optionManager.getTimelineOption(this);
          timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
        }
        if (!type || type === "recreate" || type === "media") {
          var mediaOptions = optionManager.getMediaOption(this, this._api);
          if (mediaOptions.length) {
            each(mediaOptions, function(mediaOption) {
              this.mergeOption(mediaOption, optionChanged = true);
            }, this);
          }
        }
        return optionChanged;
      },
      /**
       * @protected
       */
      mergeOption: function(newOption) {
        var option = this.option;
        var componentsMap = this._componentsMap;
        var newCptTypes = [];
        resetSourceDefaulter(this);
        each(newOption, function(componentOption, mainType) {
          if (componentOption == null) {
            return;
          }
          if (!ComponentModel.hasClass(mainType)) {
            option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
          } else if (mainType) {
            newCptTypes.push(mainType);
          }
        });
        ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
        function visitComponent(mainType, dependencies) {
          var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
          var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);
          modelUtil.makeIdAndName(mapResult);
          each(mapResult, function(item, index) {
            var opt = item.option;
            if (isObject(opt)) {
              item.keyInfo.mainType = mainType;
              item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
            }
          });
          var dependentModels = getComponentsByTypes(componentsMap, dependencies);
          option[mainType] = [];
          componentsMap.set(mainType, []);
          each(mapResult, function(resultItem, index) {
            var componentModel = resultItem.exist;
            var newCptOption = resultItem.option;
            assert(isObject(newCptOption) || componentModel, "Empty component definition");
            if (!newCptOption) {
              componentModel.mergeOption({}, this);
              componentModel.optionUpdated({}, false);
            } else {
              var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);
              if (componentModel && componentModel.constructor === ComponentModelClass) {
                componentModel.name = resultItem.keyInfo.name;
                componentModel.mergeOption(newCptOption, this);
                componentModel.optionUpdated(newCptOption, false);
              } else {
                var extraOpt = extend({
                  dependentModels,
                  componentIndex: index
                }, resultItem.keyInfo);
                componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
                extend(componentModel, extraOpt);
                componentModel.init(newCptOption, this, this, extraOpt);
                componentModel.optionUpdated(null, true);
              }
            }
            componentsMap.get(mainType)[index] = componentModel;
            option[mainType][index] = componentModel.option;
          }, this);
          if (mainType === "series") {
            createSeriesIndices(this, componentsMap.get("series"));
          }
        }
        this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);
      },
      /**
       * Get option for output (cloned option and inner info removed)
       * @public
       * @return {Object}
       */
      getOption: function() {
        var option = clone(this.option);
        each(option, function(opts, mainType) {
          if (ComponentModel.hasClass(mainType)) {
            var opts = modelUtil.normalizeToArray(opts);
            for (var i = opts.length - 1; i >= 0; i--) {
              if (modelUtil.isIdInner(opts[i])) {
                opts.splice(i, 1);
              }
            }
            option[mainType] = opts;
          }
        });
        delete option[OPTION_INNER_KEY];
        return option;
      },
      /**
       * @return {module:echarts/model/Model}
       */
      getTheme: function() {
        return this._theme;
      },
      /**
       * @param {string} mainType
       * @param {number} [idx=0]
       * @return {module:echarts/model/Component}
       */
      getComponent: function(mainType, idx) {
        var list = this._componentsMap.get(mainType);
        if (list) {
          return list[idx || 0];
        }
      },
      /**
       * If none of index and id and name used, return all components with mainType.
       * @param {Object} condition
       * @param {string} condition.mainType
       * @param {string} [condition.subType] If ignore, only query by mainType
       * @param {number|Array.<number>} [condition.index] Either input index or id or name.
       * @param {string|Array.<string>} [condition.id] Either input index or id or name.
       * @param {string|Array.<string>} [condition.name] Either input index or id or name.
       * @return {Array.<module:echarts/model/Component>}
       */
      queryComponents: function(condition) {
        var mainType = condition.mainType;
        if (!mainType) {
          return [];
        }
        var index = condition.index;
        var id = condition.id;
        var name2 = condition.name;
        var cpts = this._componentsMap.get(mainType);
        if (!cpts || !cpts.length) {
          return [];
        }
        var result;
        if (index != null) {
          if (!isArray(index)) {
            index = [index];
          }
          result = filter(map(index, function(idx) {
            return cpts[idx];
          }), function(val) {
            return !!val;
          });
        } else if (id != null) {
          var isIdArray = isArray(id);
          result = filter(cpts, function(cpt) {
            return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
          });
        } else if (name2 != null) {
          var isNameArray = isArray(name2);
          result = filter(cpts, function(cpt) {
            return isNameArray && indexOf(name2, cpt.name) >= 0 || !isNameArray && cpt.name === name2;
          });
        } else {
          result = cpts.slice();
        }
        return filterBySubType(result, condition);
      },
      /**
       * The interface is different from queryComponents,
       * which is convenient for inner usage.
       *
       * @usage
       * var result = findComponents(
       *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
       * );
       * var result = findComponents(
       *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
       * );
       * var result = findComponents(
       *     {mainType: 'series',
       *     filter: function (model, index) {...}}
       * );
       * // result like [component0, componnet1, ...]
       *
       * @param {Object} condition
       * @param {string} condition.mainType Mandatory.
       * @param {string} [condition.subType] Optional.
       * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
       *        where xxx is mainType.
       *        If query attribute is null/undefined or has no index/id/name,
       *        do not filtering by query conditions, which is convenient for
       *        no-payload situations or when target of action is global.
       * @param {Function} [condition.filter] parameter: component, return boolean.
       * @return {Array.<module:echarts/model/Component>}
       */
      findComponents: function(condition) {
        var query = condition.query;
        var mainType = condition.mainType;
        var queryCond = getQueryCond(query);
        var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
        return doFilter(filterBySubType(result, condition));
        function getQueryCond(q) {
          var indexAttr = mainType + "Index";
          var idAttr = mainType + "Id";
          var nameAttr = mainType + "Name";
          return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
            mainType,
            // subType will be filtered finally.
            index: q[indexAttr],
            id: q[idAttr],
            name: q[nameAttr]
          } : null;
        }
        function doFilter(res) {
          return condition.filter ? filter(res, condition.filter) : res;
        }
      },
      /**
       * @usage
       * eachComponent('legend', function (legendModel, index) {
       *     ...
       * });
       * eachComponent(function (componentType, model, index) {
       *     // componentType does not include subType
       *     // (componentType is 'xxx' but not 'xxx.aa')
       * });
       * eachComponent(
       *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
       *     function (model, index) {...}
       * );
       * eachComponent(
       *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
       *     function (model, index) {...}
       * );
       *
       * @param {string|Object=} mainType When mainType is object, the definition
       *                                  is the same as the method 'findComponents'.
       * @param {Function} cb
       * @param {*} context
       */
      eachComponent: function(mainType, cb, context) {
        var componentsMap = this._componentsMap;
        if (typeof mainType === "function") {
          context = cb;
          cb = mainType;
          componentsMap.each(function(components, componentType) {
            each(components, function(component, index) {
              cb.call(context, componentType, component, index);
            });
          });
        } else if (isString(mainType)) {
          each(componentsMap.get(mainType), cb, context);
        } else if (isObject(mainType)) {
          var queryResult = this.findComponents(mainType);
          each(queryResult, cb, context);
        }
      },
      /**
       * @param {string} name
       * @return {Array.<module:echarts/model/Series>}
       */
      getSeriesByName: function(name2) {
        var series = this._componentsMap.get("series");
        return filter(series, function(oneSeries) {
          return oneSeries.name === name2;
        });
      },
      /**
       * @param {number} seriesIndex
       * @return {module:echarts/model/Series}
       */
      getSeriesByIndex: function(seriesIndex) {
        return this._componentsMap.get("series")[seriesIndex];
      },
      /**
       * Get series list before filtered by type.
       * FIXME: rename to getRawSeriesByType?
       *
       * @param {string} subType
       * @return {Array.<module:echarts/model/Series>}
       */
      getSeriesByType: function(subType) {
        var series = this._componentsMap.get("series");
        return filter(series, function(oneSeries) {
          return oneSeries.subType === subType;
        });
      },
      /**
       * @return {Array.<module:echarts/model/Series>}
       */
      getSeries: function() {
        return this._componentsMap.get("series").slice();
      },
      /**
       * @return {number}
       */
      getSeriesCount: function() {
        return this._componentsMap.get("series").length;
      },
      /**
       * After filtering, series may be different
       * frome raw series.
       *
       * @param {Function} cb
       * @param {*} context
       */
      eachSeries: function(cb, context) {
        assertSeriesInitialized(this);
        each(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          cb.call(context, series, rawSeriesIndex);
        }, this);
      },
      /**
       * Iterate raw series before filtered.
       *
       * @param {Function} cb
       * @param {*} context
       */
      eachRawSeries: function(cb, context) {
        each(this._componentsMap.get("series"), cb, context);
      },
      /**
       * After filtering, series may be different.
       * frome raw series.
       *
       * @param {string} subType.
       * @param {Function} cb
       * @param {*} context
       */
      eachSeriesByType: function(subType, cb, context) {
        assertSeriesInitialized(this);
        each(this._seriesIndices, function(rawSeriesIndex) {
          var series = this._componentsMap.get("series")[rawSeriesIndex];
          if (series.subType === subType) {
            cb.call(context, series, rawSeriesIndex);
          }
        }, this);
      },
      /**
       * Iterate raw series before filtered of given type.
       *
       * @parma {string} subType
       * @param {Function} cb
       * @param {*} context
       */
      eachRawSeriesByType: function(subType, cb, context) {
        return each(this.getSeriesByType(subType), cb, context);
      },
      /**
       * @param {module:echarts/model/Series} seriesModel
       */
      isSeriesFiltered: function(seriesModel) {
        assertSeriesInitialized(this);
        return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
      },
      /**
       * @return {Array.<number>}
       */
      getCurrentSeriesIndices: function() {
        return (this._seriesIndices || []).slice();
      },
      /**
       * @param {Function} cb
       * @param {*} context
       */
      filterSeries: function(cb, context) {
        assertSeriesInitialized(this);
        var filteredSeries = filter(this._componentsMap.get("series"), cb, context);
        createSeriesIndices(this, filteredSeries);
      },
      restoreData: function(payload) {
        var componentsMap = this._componentsMap;
        createSeriesIndices(this, componentsMap.get("series"));
        var componentTypes = [];
        componentsMap.each(function(components, componentType) {
          componentTypes.push(componentType);
        });
        ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function(componentType, dependencies) {
          each(componentsMap.get(componentType), function(component) {
            (componentType !== "series" || !isNotTargetSeries(component, payload)) && component.restoreData();
          });
        });
      }
    });
    function isNotTargetSeries(seriesModel, payload) {
      if (payload) {
        var index = payload.seiresIndex;
        var id = payload.seriesId;
        var name2 = payload.seriesName;
        return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name2 != null && seriesModel.name !== name2;
      }
    }
    function mergeTheme(option, theme) {
      var notMergeColorLayer = option.color && !option.colorLayer;
      each(theme, function(themeItem, name2) {
        if (name2 === "colorLayer" && notMergeColorLayer) {
          return;
        }
        if (!ComponentModel.hasClass(name2)) {
          if (typeof themeItem === "object") {
            option[name2] = !option[name2] ? clone(themeItem) : merge(option[name2], themeItem, false);
          } else {
            if (option[name2] == null) {
              option[name2] = themeItem;
            }
          }
        }
      });
    }
    function initBase(baseOption) {
      baseOption = baseOption;
      this.option = {};
      this.option[OPTION_INNER_KEY] = 1;
      this._componentsMap = createHashMap({
        series: []
      });
      this._seriesIndices;
      this._seriesIndicesMap;
      mergeTheme(baseOption, this._theme.option);
      merge(baseOption, globalDefault, false);
      this.mergeOption(baseOption);
    }
    function getComponentsByTypes(componentsMap, types) {
      if (!isArray(types)) {
        types = types ? [types] : [];
      }
      var ret = {};
      each(types, function(type) {
        ret[type] = (componentsMap.get(type) || []).slice();
      });
      return ret;
    }
    function determineSubType(mainType, newCptOption, existComponent) {
      var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);
      return subType;
    }
    function createSeriesIndices(ecModel, seriesModels) {
      ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function(series) {
        return series.componentIndex;
      }) || []);
    }
    function filterBySubType(components, condition) {
      return condition.hasOwnProperty("subType") ? filter(components, function(cpt) {
        return cpt.subType === condition.subType;
      }) : components;
    }
    function assertSeriesInitialized(ecModel) {
    }
    mixin(GlobalModel, colorPaletteMixin);
    var _default = GlobalModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/ExtensionAPI.js
var require_ExtensionAPI = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/ExtensionAPI.js"(exports, module) {
    var zrUtil = require_util();
    var echartsAPIList = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"];
    function ExtensionAPI(chartInstance) {
      zrUtil.each(echartsAPIList, function(name2) {
        this[name2] = zrUtil.bind(chartInstance[name2], chartInstance);
      }, this);
    }
    var _default = ExtensionAPI;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/CoordinateSystem.js
var require_CoordinateSystem = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/CoordinateSystem.js"(exports, module) {
    var zrUtil = require_util();
    var coordinateSystemCreators = {};
    function CoordinateSystemManager() {
      this._coordinateSystems = [];
    }
    CoordinateSystemManager.prototype = {
      constructor: CoordinateSystemManager,
      create: function(ecModel, api) {
        var coordinateSystems = [];
        zrUtil.each(coordinateSystemCreators, function(creater, type) {
          var list = creater.create(ecModel, api);
          coordinateSystems = coordinateSystems.concat(list || []);
        });
        this._coordinateSystems = coordinateSystems;
      },
      update: function(ecModel, api) {
        zrUtil.each(this._coordinateSystems, function(coordSys) {
          coordSys.update && coordSys.update(ecModel, api);
        });
      },
      getCoordinateSystems: function() {
        return this._coordinateSystems.slice();
      }
    };
    CoordinateSystemManager.register = function(type, coordinateSystemCreator) {
      coordinateSystemCreators[type] = coordinateSystemCreator;
    };
    CoordinateSystemManager.get = function(type) {
      return coordinateSystemCreators[type];
    };
    var _default = CoordinateSystemManager;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/OptionManager.js
var require_OptionManager = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/OptionManager.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    var ComponentModel = require_Component();
    var each = zrUtil.each;
    var clone = zrUtil.clone;
    var map = zrUtil.map;
    var merge = zrUtil.merge;
    var QUERY_REG = /^(min|max)?(.+)$/;
    function OptionManager(api) {
      this._api = api;
      this._timelineOptions = [];
      this._mediaList = [];
      this._mediaDefault;
      this._currentMediaIndices = [];
      this._optionBackup;
      this._newBaseOption;
    }
    OptionManager.prototype = {
      constructor: OptionManager,
      /**
       * @public
       * @param {Object} rawOption Raw option.
       * @param {module:echarts/model/Global} ecModel
       * @param {Array.<Function>} optionPreprocessorFuncs
       * @return {Object} Init option
       */
      setOption: function(rawOption, optionPreprocessorFuncs) {
        if (rawOption) {
          zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function(series) {
            series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);
          });
        }
        rawOption = clone(rawOption);
        var oldOptionBackup = this._optionBackup;
        var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
        this._newBaseOption = newParsedOption.baseOption;
        if (oldOptionBackup) {
          mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);
          if (newParsedOption.timelineOptions.length) {
            oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
          }
          if (newParsedOption.mediaList.length) {
            oldOptionBackup.mediaList = newParsedOption.mediaList;
          }
          if (newParsedOption.mediaDefault) {
            oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
          }
        } else {
          this._optionBackup = newParsedOption;
        }
      },
      /**
       * @param {boolean} isRecreate
       * @return {Object}
       */
      mountOption: function(isRecreate) {
        var optionBackup = this._optionBackup;
        this._timelineOptions = map(optionBackup.timelineOptions, clone);
        this._mediaList = map(optionBackup.mediaList, clone);
        this._mediaDefault = clone(optionBackup.mediaDefault);
        this._currentMediaIndices = [];
        return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
      },
      /**
       * @param {module:echarts/model/Global} ecModel
       * @return {Object}
       */
      getTimelineOption: function(ecModel) {
        var option;
        var timelineOptions = this._timelineOptions;
        if (timelineOptions.length) {
          var timelineModel = ecModel.getComponent("timeline");
          if (timelineModel) {
            option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
          }
        }
        return option;
      },
      /**
       * @param {module:echarts/model/Global} ecModel
       * @return {Array.<Object>}
       */
      getMediaOption: function(ecModel) {
        var ecWidth = this._api.getWidth();
        var ecHeight = this._api.getHeight();
        var mediaList = this._mediaList;
        var mediaDefault = this._mediaDefault;
        var indices = [];
        var result = [];
        if (!mediaList.length && !mediaDefault) {
          return result;
        }
        for (var i = 0, len = mediaList.length; i < len; i++) {
          if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
            indices.push(i);
          }
        }
        if (!indices.length && mediaDefault) {
          indices = [-1];
        }
        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
          result = map(indices, function(index) {
            return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
          });
        }
        this._currentMediaIndices = indices;
        return result;
      }
    };
    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
      var timelineOptions = [];
      var mediaList = [];
      var mediaDefault;
      var baseOption;
      var timelineOpt = rawOption.timeline;
      if (rawOption.baseOption) {
        baseOption = rawOption.baseOption;
      }
      if (timelineOpt || rawOption.options) {
        baseOption = baseOption || {};
        timelineOptions = (rawOption.options || []).slice();
      }
      if (rawOption.media) {
        baseOption = baseOption || {};
        var media = rawOption.media;
        each(media, function(singleMedia) {
          if (singleMedia && singleMedia.option) {
            if (singleMedia.query) {
              mediaList.push(singleMedia);
            } else if (!mediaDefault) {
              mediaDefault = singleMedia;
            }
          }
        });
      }
      if (!baseOption) {
        baseOption = rawOption;
      }
      if (!baseOption.timeline) {
        baseOption.timeline = timelineOpt;
      }
      each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function(media2) {
        return media2.option;
      })), function(option) {
        each(optionPreprocessorFuncs, function(preProcess) {
          preProcess(option, isNew);
        });
      });
      return {
        baseOption,
        timelineOptions,
        mediaDefault,
        mediaList
      };
    }
    function applyMediaQuery(query, ecWidth, ecHeight) {
      var realMap = {
        width: ecWidth,
        height: ecHeight,
        aspectratio: ecWidth / ecHeight
        // lowser case for convenientce.
      };
      var applicatable = true;
      zrUtil.each(query, function(value, attr) {
        var matched = attr.match(QUERY_REG);
        if (!matched || !matched[1] || !matched[2]) {
          return;
        }
        var operator = matched[1];
        var realAttr = matched[2].toLowerCase();
        if (!compare(realMap[realAttr], value, operator)) {
          applicatable = false;
        }
      });
      return applicatable;
    }
    function compare(real, expect, operator) {
      if (operator === "min") {
        return real >= expect;
      } else if (operator === "max") {
        return real <= expect;
      } else {
        return real === expect;
      }
    }
    function indicesEquals(indices1, indices2) {
      return indices1.join(",") === indices2.join(",");
    }
    function mergeOption(oldOption, newOption) {
      newOption = newOption || {};
      each(newOption, function(newCptOpt, mainType) {
        if (newCptOpt == null) {
          return;
        }
        var oldCptOpt = oldOption[mainType];
        if (!ComponentModel.hasClass(mainType)) {
          oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
        } else {
          newCptOpt = modelUtil.normalizeToArray(newCptOpt);
          oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
          var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
          oldOption[mainType] = map(mapResult, function(item) {
            return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;
          });
        }
      });
    }
    var _default = OptionManager;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/preprocessor/helper/compatStyle.js
var require_compatStyle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/preprocessor/helper/compatStyle.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    var each = zrUtil.each;
    var isObject = zrUtil.isObject;
    var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
    function compatEC2ItemStyle(opt) {
      var itemStyleOpt = opt && opt.itemStyle;
      if (!itemStyleOpt) {
        return;
      }
      for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
        var styleName = POSSIBLE_STYLES[i];
        var normalItemStyleOpt = itemStyleOpt.normal;
        var emphasisItemStyleOpt = itemStyleOpt.emphasis;
        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};
          if (!opt[styleName].normal) {
            opt[styleName].normal = normalItemStyleOpt[styleName];
          } else {
            zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
          }
          normalItemStyleOpt[styleName] = null;
        }
        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
          opt[styleName] = opt[styleName] || {};
          if (!opt[styleName].emphasis) {
            opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
          } else {
            zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
          }
          emphasisItemStyleOpt[styleName] = null;
        }
      }
    }
    function convertNormalEmphasis(opt, optType, useExtend) {
      if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
        var normalOpt = opt[optType].normal;
        var emphasisOpt = opt[optType].emphasis;
        if (normalOpt) {
          if (useExtend) {
            opt[optType].normal = opt[optType].emphasis = null;
            zrUtil.defaults(opt[optType], normalOpt);
          } else {
            opt[optType] = normalOpt;
          }
        }
        if (emphasisOpt) {
          opt.emphasis = opt.emphasis || {};
          opt.emphasis[optType] = emphasisOpt;
        }
      }
    }
    function removeEC3NormalStatus(opt) {
      convertNormalEmphasis(opt, "itemStyle");
      convertNormalEmphasis(opt, "lineStyle");
      convertNormalEmphasis(opt, "areaStyle");
      convertNormalEmphasis(opt, "label");
      convertNormalEmphasis(opt, "labelLine");
      convertNormalEmphasis(opt, "upperLabel");
      convertNormalEmphasis(opt, "edgeLabel");
    }
    function compatTextStyle(opt, propName) {
      var labelOptSingle = isObject(opt) && opt[propName];
      var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;
      if (textStyle) {
        for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {
          var propName = modelUtil.TEXT_STYLE_OPTIONS[i];
          if (textStyle.hasOwnProperty(propName)) {
            labelOptSingle[propName] = textStyle[propName];
          }
        }
      }
    }
    function compatEC3CommonStyles(opt) {
      if (opt) {
        removeEC3NormalStatus(opt);
        compatTextStyle(opt, "label");
        opt.emphasis && compatTextStyle(opt.emphasis, "label");
      }
    }
    function processSeries(seriesOpt) {
      if (!isObject(seriesOpt)) {
        return;
      }
      compatEC2ItemStyle(seriesOpt);
      removeEC3NormalStatus(seriesOpt);
      compatTextStyle(seriesOpt, "label");
      compatTextStyle(seriesOpt, "upperLabel");
      compatTextStyle(seriesOpt, "edgeLabel");
      if (seriesOpt.emphasis) {
        compatTextStyle(seriesOpt.emphasis, "label");
        compatTextStyle(seriesOpt.emphasis, "upperLabel");
        compatTextStyle(seriesOpt.emphasis, "edgeLabel");
      }
      var markPoint = seriesOpt.markPoint;
      if (markPoint) {
        compatEC2ItemStyle(markPoint);
        compatEC3CommonStyles(markPoint);
      }
      var markLine = seriesOpt.markLine;
      if (markLine) {
        compatEC2ItemStyle(markLine);
        compatEC3CommonStyles(markLine);
      }
      var markArea = seriesOpt.markArea;
      if (markArea) {
        compatEC3CommonStyles(markArea);
      }
      var data = seriesOpt.data;
      if (seriesOpt.type === "graph") {
        data = data || seriesOpt.nodes;
        var edgeData = seriesOpt.links || seriesOpt.edges;
        if (edgeData && !zrUtil.isTypedArray(edgeData)) {
          for (var i = 0; i < edgeData.length; i++) {
            compatEC3CommonStyles(edgeData[i]);
          }
        }
        zrUtil.each(seriesOpt.categories, function(opt) {
          removeEC3NormalStatus(opt);
        });
      }
      if (data && !zrUtil.isTypedArray(data)) {
        for (var i = 0; i < data.length; i++) {
          compatEC3CommonStyles(data[i]);
        }
      }
      var markPoint = seriesOpt.markPoint;
      if (markPoint && markPoint.data) {
        var mpData = markPoint.data;
        for (var i = 0; i < mpData.length; i++) {
          compatEC3CommonStyles(mpData[i]);
        }
      }
      var markLine = seriesOpt.markLine;
      if (markLine && markLine.data) {
        var mlData = markLine.data;
        for (var i = 0; i < mlData.length; i++) {
          if (zrUtil.isArray(mlData[i])) {
            compatEC3CommonStyles(mlData[i][0]);
            compatEC3CommonStyles(mlData[i][1]);
          } else {
            compatEC3CommonStyles(mlData[i]);
          }
        }
      }
      if (seriesOpt.type === "gauge") {
        compatTextStyle(seriesOpt, "axisLabel");
        compatTextStyle(seriesOpt, "title");
        compatTextStyle(seriesOpt, "detail");
      } else if (seriesOpt.type === "treemap") {
        convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
        zrUtil.each(seriesOpt.levels, function(opt) {
          removeEC3NormalStatus(opt);
        });
      } else if (seriesOpt.type === "tree") {
        removeEC3NormalStatus(seriesOpt.leaves);
      }
    }
    function toArr(o) {
      return zrUtil.isArray(o) ? o : o ? [o] : [];
    }
    function toObj(o) {
      return (zrUtil.isArray(o) ? o[0] : o) || {};
    }
    function _default(option, isTheme) {
      each(toArr(option.series), function(seriesOpt) {
        isObject(seriesOpt) && processSeries(seriesOpt);
      });
      var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
      isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
      each(axes, function(axisName) {
        each(toArr(option[axisName]), function(axisOpt) {
          if (axisOpt) {
            compatTextStyle(axisOpt, "axisLabel");
            compatTextStyle(axisOpt.axisPointer, "label");
          }
        });
      });
      each(toArr(option.parallel), function(parallelOpt) {
        var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
        compatTextStyle(parallelAxisDefault, "axisLabel");
        compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
      });
      each(toArr(option.calendar), function(calendarOpt) {
        convertNormalEmphasis(calendarOpt, "itemStyle");
        compatTextStyle(calendarOpt, "dayLabel");
        compatTextStyle(calendarOpt, "monthLabel");
        compatTextStyle(calendarOpt, "yearLabel");
      });
      each(toArr(option.radar), function(radarOpt) {
        compatTextStyle(radarOpt, "name");
      });
      each(toArr(option.geo), function(geoOpt) {
        if (isObject(geoOpt)) {
          compatEC3CommonStyles(geoOpt);
          each(toArr(geoOpt.regions), function(regionObj) {
            compatEC3CommonStyles(regionObj);
          });
        }
      });
      each(toArr(option.timeline), function(timelineOpt) {
        compatEC3CommonStyles(timelineOpt);
        convertNormalEmphasis(timelineOpt, "label");
        convertNormalEmphasis(timelineOpt, "itemStyle");
        convertNormalEmphasis(timelineOpt, "controlStyle", true);
        var data = timelineOpt.data;
        zrUtil.isArray(data) && zrUtil.each(data, function(item) {
          if (zrUtil.isObject(item)) {
            convertNormalEmphasis(item, "label");
            convertNormalEmphasis(item, "itemStyle");
          }
        });
      });
      each(toArr(option.toolbox), function(toolboxOpt) {
        convertNormalEmphasis(toolboxOpt, "iconStyle");
        each(toolboxOpt.feature, function(featureOpt) {
          convertNormalEmphasis(featureOpt, "iconStyle");
        });
      });
      compatTextStyle(toObj(option.axisPointer), "label");
      compatTextStyle(toObj(option.tooltip).axisPointer, "label");
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/preprocessor/backwardCompat.js
var require_backwardCompat = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/preprocessor/backwardCompat.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var isArray = _util.isArray;
    var isObject = _util.isObject;
    var compatStyle = require_compatStyle();
    var _model = require_model();
    var normalizeToArray = _model.normalizeToArray;
    function get(opt, path) {
      path = path.split(",");
      var obj = opt;
      for (var i = 0; i < path.length; i++) {
        obj = obj && obj[path[i]];
        if (obj == null) {
          break;
        }
      }
      return obj;
    }
    function set(opt, path, val, overwrite) {
      path = path.split(",");
      var obj = opt;
      var key;
      for (var i = 0; i < path.length - 1; i++) {
        key = path[i];
        if (obj[key] == null) {
          obj[key] = {};
        }
        obj = obj[key];
      }
      if (overwrite || obj[path[i]] == null) {
        obj[path[i]] = val;
      }
    }
    function compatLayoutProperties(option) {
      each(LAYOUT_PROPERTIES, function(prop) {
        if (prop[0] in option && !(prop[1] in option)) {
          option[prop[1]] = option[prop[0]];
        }
      });
    }
    var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
    var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
    function _default(option, isTheme) {
      compatStyle(option, isTheme);
      option.series = normalizeToArray(option.series);
      each(option.series, function(seriesOpt) {
        if (!isObject(seriesOpt)) {
          return;
        }
        var seriesType = seriesOpt.type;
        if (seriesType === "line") {
          if (seriesOpt.clipOverflow != null) {
            seriesOpt.clip = seriesOpt.clipOverflow;
          }
        } else if (seriesType === "pie" || seriesType === "gauge") {
          if (seriesOpt.clockWise != null) {
            seriesOpt.clockwise = seriesOpt.clockWise;
          }
        } else if (seriesType === "gauge") {
          var pointerColor = get(seriesOpt, "pointer.color");
          pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
        }
        compatLayoutProperties(seriesOpt);
      });
      if (option.dataRange) {
        option.visualMap = option.dataRange;
      }
      each(COMPATITABLE_COMPONENTS, function(componentName) {
        var options = option[componentName];
        if (options) {
          if (!isArray(options)) {
            options = [options];
          }
          each(options, function(option2) {
            compatLayoutProperties(option2);
          });
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataStack.js
var require_dataStack = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataStack.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    function _default(ecModel) {
      var stackInfoMap = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var stack = seriesModel.get("stack");
        if (stack) {
          var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
          var data = seriesModel.getData();
          var stackInfo = {
            // Used for calculate axis extent automatically.
            stackResultDimension: data.getCalculationInfo("stackResultDimension"),
            stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
            stackedDimension: data.getCalculationInfo("stackedDimension"),
            stackedByDimension: data.getCalculationInfo("stackedByDimension"),
            isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
            data,
            seriesModel
          };
          if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
            return;
          }
          stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
          stackInfoList.push(stackInfo);
        }
      });
      stackInfoMap.each(calculateStack);
    }
    function calculateStack(stackInfoList) {
      each(stackInfoList, function(targetStackInfo, idxInStack) {
        var resultVal = [];
        var resultNaN = [NaN, NaN];
        var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
        var targetData = targetStackInfo.data;
        var isStackedByIndex = targetStackInfo.isStackedByIndex;
        var newData = targetData.map(dims, function(v0, v1, dataIndex) {
          var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
          if (isNaN(sum)) {
            return resultNaN;
          }
          var byValue;
          var stackedDataRawIndex;
          if (isStackedByIndex) {
            stackedDataRawIndex = targetData.getRawIndex(dataIndex);
          } else {
            byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
          }
          var stackedOver = NaN;
          for (var j = idxInStack - 1; j >= 0; j--) {
            var stackInfo = stackInfoList[j];
            if (!isStackedByIndex) {
              stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
            }
            if (stackedDataRawIndex >= 0) {
              var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
              if (sum >= 0 && val > 0 || // Positive stack
              sum <= 0 && val < 0) {
                sum += val;
                stackedOver = val;
                break;
              }
            }
          }
          resultVal[0] = sum;
          resultVal[1] = stackedOver;
          return resultVal;
        });
        targetData.hostModel.setData(newData);
        targetStackInfo.data = newData;
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/dataProvider.js
var require_dataProvider = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/dataProvider.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var isTypedArray = _util.isTypedArray;
    var extend = _util.extend;
    var assert = _util.assert;
    var each = _util.each;
    var isObject = _util.isObject;
    var _model = require_model();
    var getDataItemValue = _model.getDataItemValue;
    var isDataItemOption = _model.isDataItemOption;
    var _number = require_number();
    var parseDate = _number.parseDate;
    var Source = require_Source();
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
    var SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;
    function DefaultDataProvider(source, dimSize) {
      if (!Source.isInstance(source)) {
        source = Source.seriesDataToSource(source);
      }
      this._source = source;
      var data = this._data = source.data;
      var sourceFormat = source.sourceFormat;
      if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
        this._offset = 0;
        this._dimSize = dimSize;
        this._data = data;
      }
      var methods = providerMethods[sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + source.seriesLayoutBy : sourceFormat];
      extend(this, methods);
    }
    var providerProto = DefaultDataProvider.prototype;
    providerProto.pure = false;
    providerProto.persistent = true;
    providerProto.getSource = function() {
      return this._source;
    };
    var providerMethods = {
      "arrayRows_column": {
        pure: true,
        count: function() {
          return Math.max(0, this._data.length - this._source.startIndex);
        },
        getItem: function(idx) {
          return this._data[idx + this._source.startIndex];
        },
        appendData: appendDataSimply
      },
      "arrayRows_row": {
        pure: true,
        count: function() {
          var row = this._data[0];
          return row ? Math.max(0, row.length - this._source.startIndex) : 0;
        },
        getItem: function(idx) {
          idx += this._source.startIndex;
          var item = [];
          var data = this._data;
          for (var i = 0; i < data.length; i++) {
            var row = data[i];
            item.push(row ? row[idx] : null);
          }
          return item;
        },
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      },
      "objectRows": {
        pure: true,
        count: countSimply,
        getItem: getItemSimply,
        appendData: appendDataSimply
      },
      "keyedColumns": {
        pure: true,
        count: function() {
          var dimName = this._source.dimensionsDefine[0].name;
          var col = this._data[dimName];
          return col ? col.length : 0;
        },
        getItem: function(idx) {
          var item = [];
          var dims = this._source.dimensionsDefine;
          for (var i = 0; i < dims.length; i++) {
            var col = this._data[dims[i].name];
            item.push(col ? col[idx] : null);
          }
          return item;
        },
        appendData: function(newData) {
          var data = this._data;
          each(newData, function(newCol, key) {
            var oldCol = data[key] || (data[key] = []);
            for (var i = 0; i < (newCol || []).length; i++) {
              oldCol.push(newCol[i]);
            }
          });
        }
      },
      "original": {
        count: countSimply,
        getItem: getItemSimply,
        appendData: appendDataSimply
      },
      "typedArray": {
        persistent: false,
        pure: true,
        count: function() {
          return this._data ? this._data.length / this._dimSize : 0;
        },
        getItem: function(idx, out) {
          idx = idx - this._offset;
          out = out || [];
          var offset = this._dimSize * idx;
          for (var i = 0; i < this._dimSize; i++) {
            out[i] = this._data[offset + i];
          }
          return out;
        },
        appendData: function(newData) {
          this._data = newData;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count();
          this._data = null;
        }
      }
    };
    function countSimply() {
      return this._data.length;
    }
    function getItemSimply(idx) {
      return this._data[idx];
    }
    function appendDataSimply(newData) {
      for (var i = 0; i < newData.length; i++) {
        this._data.push(newData[i]);
      }
    }
    var rawValueGetters = {
      arrayRows: getRawValueSimply,
      objectRows: function(dataItem, dataIndex, dimIndex, dimName) {
        return dimIndex != null ? dataItem[dimName] : dataItem;
      },
      keyedColumns: getRawValueSimply,
      original: function(dataItem, dataIndex, dimIndex, dimName) {
        var value = getDataItemValue(dataItem);
        return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];
      },
      typedArray: getRawValueSimply
    };
    function getRawValueSimply(dataItem, dataIndex, dimIndex, dimName) {
      return dimIndex != null ? dataItem[dimIndex] : dataItem;
    }
    var defaultDimValueGetters = {
      arrayRows: getDimValueSimply,
      objectRows: function(dataItem, dimName, dataIndex, dimIndex) {
        return converDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
      },
      keyedColumns: getDimValueSimply,
      original: function(dataItem, dimName, dataIndex, dimIndex) {
        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
        if (!this._rawData.pure && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        return converDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);
      },
      typedArray: function(dataItem, dimName, dataIndex, dimIndex) {
        return dataItem[dimIndex];
      }
    };
    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
      return converDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
    }
    function converDataValue(value, dimInfo) {
      var dimType = dimInfo && dimInfo.type;
      if (dimType === "ordinal") {
        var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
        return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
      }
      if (dimType === "time" && typeof value !== "number" && value != null && value !== "-") {
        value = +parseDate(value);
      }
      return value == null || value === "" ? NaN : +value;
    }
    function retrieveRawValue(data, dataIndex, dim) {
      if (!data) {
        return;
      }
      var dataItem = data.getRawDataItem(dataIndex);
      if (dataItem == null) {
        return;
      }
      var sourceFormat = data.getProvider().getSource().sourceFormat;
      var dimName;
      var dimIndex;
      var dimInfo = data.getDimensionInfo(dim);
      if (dimInfo) {
        dimName = dimInfo.name;
        dimIndex = dimInfo.index;
      }
      return rawValueGetters[sourceFormat](dataItem, dataIndex, dimIndex, dimName);
    }
    function retrieveRawAttr(data, dataIndex, attr) {
      if (!data) {
        return;
      }
      var sourceFormat = data.getProvider().getSource().sourceFormat;
      if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
        return;
      }
      var dataItem = data.getRawDataItem(dataIndex);
      if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {
        dataItem = null;
      }
      if (dataItem) {
        return dataItem[attr];
      }
    }
    exports.DefaultDataProvider = DefaultDataProvider;
    exports.defaultDimValueGetters = defaultDimValueGetters;
    exports.retrieveRawValue = retrieveRawValue;
    exports.retrieveRawAttr = retrieveRawAttr;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/dataFormat.js
var require_dataFormat = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/mixin/dataFormat.js"(exports, module) {
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    var _format = require_format();
    var getTooltipMarker = _format.getTooltipMarker;
    var formatTpl = _format.formatTpl;
    var _model = require_model();
    var getTooltipRenderMode = _model.getTooltipRenderMode;
    var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
    var _default = {
      /**
       * Get params for formatter
       * @param {number} dataIndex
       * @param {string} [dataType]
       * @return {Object}
       */
      getDataParams: function(dataIndex, dataType) {
        var data = this.getData(dataType);
        var rawValue = this.getRawValue(dataIndex, dataType);
        var rawDataIndex = data.getRawIndex(dataIndex);
        var name2 = data.getName(dataIndex);
        var itemOpt = data.getRawDataItem(dataIndex);
        var color = data.getItemVisual(dataIndex, "color");
        var borderColor = data.getItemVisual(dataIndex, "borderColor");
        var tooltipModel = this.ecModel.getComponent("tooltip");
        var renderModeOption = tooltipModel && tooltipModel.get("renderMode");
        var renderMode = getTooltipRenderMode(renderModeOption);
        var mainType = this.mainType;
        var isSeries = mainType === "series";
        var userOutput = data.userOutput;
        return {
          componentType: mainType,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: isSeries ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: isSeries ? this.id : null,
          seriesName: isSeries ? this.name : null,
          name: name2,
          dataIndex: rawDataIndex,
          data: itemOpt,
          dataType,
          value: rawValue,
          color,
          borderColor,
          dimensionNames: userOutput ? userOutput.dimensionNames : null,
          encode: userOutput ? userOutput.encode : null,
          marker: getTooltipMarker({
            color,
            renderMode
          }),
          // Param name list for mapping `a`, `b`, `c`, `d`, `e`
          $vars: ["seriesName", "name", "value"]
        };
      },
      /**
       * Format label
       * @param {number} dataIndex
       * @param {string} [status='normal'] 'normal' or 'emphasis'
       * @param {string} [dataType]
       * @param {number} [dimIndex] Only used in some chart that
       *        use formatter in different dimensions, like radar.
       * @param {string} [labelProp='label']
       * @return {string} If not formatter, return null/undefined
       */
      getFormattedLabel: function(dataIndex, status, dataType, dimIndex, labelProp) {
        status = status || "normal";
        var data = this.getData(dataType);
        var itemModel = data.getItemModel(dataIndex);
        var params = this.getDataParams(dataIndex, dataType);
        if (dimIndex != null && params.value instanceof Array) {
          params.value = params.value[dimIndex];
        }
        var formatter = itemModel.get(status === "normal" ? [labelProp || "label", "formatter"] : [status, labelProp || "label", "formatter"]);
        if (typeof formatter === "function") {
          params.status = status;
          params.dimensionIndex = dimIndex;
          return formatter(params);
        } else if (typeof formatter === "string") {
          var str = formatTpl(formatter, params);
          return str.replace(DIMENSION_LABEL_REG, function(origin, dim) {
            var len = dim.length;
            if (dim.charAt(0) === "[" && dim.charAt(len - 1) === "]") {
              dim = +dim.slice(1, len - 1);
            }
            return retrieveRawValue(data, dataIndex, dim);
          });
        }
      },
      /**
       * Get raw value in option
       * @param {number} idx
       * @param {string} [dataType]
       * @return {Array|number|string}
       */
      getRawValue: function(idx, dataType) {
        return retrieveRawValue(this.getData(dataType), idx);
      },
      /**
       * Should be implemented.
       * @param {number} dataIndex
       * @param {boolean} [multipleSeries=false]
       * @param {number} [dataType]
       * @return {string} tooltip string
       */
      formatTooltip: function() {
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/stream/task.js
var require_task = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/stream/task.js"(exports) {
    var _util = require_util();
    var assert = _util.assert;
    var isArray = _util.isArray;
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    function createTask(define) {
      return new Task(define);
    }
    function Task(define) {
      define = define || {};
      this._reset = define.reset;
      this._plan = define.plan;
      this._count = define.count;
      this._onDirty = define.onDirty;
      this._dirty = true;
      this.context;
    }
    var taskProto = Task.prototype;
    taskProto.perform = function(performArgs) {
      var upTask = this._upstream;
      var skip = performArgs && performArgs.skip;
      if (this._dirty && upTask) {
        var context = this.context;
        context.data = context.outputData = upTask.context.outputData;
      }
      if (this.__pipeline) {
        this.__pipeline.currentTask = this;
      }
      var planResult;
      if (this._plan && !skip) {
        planResult = this._plan(this.context);
      }
      var lastModBy = normalizeModBy(this._modBy);
      var lastModDataCount = this._modDataCount || 0;
      var modBy = normalizeModBy(performArgs && performArgs.modBy);
      var modDataCount = performArgs && performArgs.modDataCount || 0;
      if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
        planResult = "reset";
      }
      function normalizeModBy(val) {
        !(val >= 1) && (val = 1);
        return val;
      }
      var forceFirstProgress;
      if (this._dirty || planResult === "reset") {
        this._dirty = false;
        forceFirstProgress = reset(this, skip);
      }
      this._modBy = modBy;
      this._modDataCount = modDataCount;
      var step = performArgs && performArgs.step;
      if (upTask) {
        this._dueEnd = upTask._outputDueEnd;
      } else {
        this._dueEnd = this._count ? this._count(this.context) : Infinity;
      }
      if (this._progress) {
        var start = this._dueIndex;
        var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
        if (!skip && (forceFirstProgress || start < end)) {
          var progress = this._progress;
          if (isArray(progress)) {
            for (var i = 0; i < progress.length; i++) {
              doProgress(this, progress[i], start, end, modBy, modDataCount);
            }
          } else {
            doProgress(this, progress, start, end, modBy, modDataCount);
          }
        }
        this._dueIndex = end;
        var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
        this._outputDueEnd = outputDueEnd;
      } else {
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      }
      return this.unfinished();
    };
    var iterator = /* @__PURE__ */ function() {
      var end;
      var current;
      var modBy;
      var modDataCount;
      var winCount;
      var it = {
        reset: function(s, e, sStep, sCount) {
          current = s;
          end = e;
          modBy = sStep;
          modDataCount = sCount;
          winCount = Math.ceil(modDataCount / modBy);
          it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
        }
      };
      return it;
      function sequentialNext() {
        return current < end ? current++ : null;
      }
      function modNext() {
        var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
        var result = current >= end ? null : dataIndex < modDataCount ? dataIndex : current;
        current++;
        return result;
      }
    }();
    taskProto.dirty = function() {
      this._dirty = true;
      this._onDirty && this._onDirty(this.context);
    };
    function doProgress(taskIns, progress, start, end, modBy, modDataCount) {
      iterator.reset(start, end, modBy, modDataCount);
      taskIns._callingProgress = progress;
      taskIns._callingProgress({
        start,
        end,
        count: end - start,
        next: iterator.next
      }, taskIns.context);
    }
    function reset(taskIns, skip) {
      taskIns._dueIndex = taskIns._outputDueEnd = taskIns._dueEnd = 0;
      taskIns._settedOutputEnd = null;
      var progress;
      var forceFirstProgress;
      if (!skip && taskIns._reset) {
        progress = taskIns._reset(taskIns.context);
        if (progress && progress.progress) {
          forceFirstProgress = progress.forceFirstProgress;
          progress = progress.progress;
        }
        if (isArray(progress) && !progress.length) {
          progress = null;
        }
      }
      taskIns._progress = progress;
      taskIns._modBy = taskIns._modDataCount = null;
      var downstream = taskIns._downstream;
      downstream && downstream.dirty();
      return forceFirstProgress;
    }
    taskProto.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    };
    taskProto.pipe = function(downTask) {
      if (this._downstream !== downTask || this._dirty) {
        this._downstream = downTask;
        downTask._upstream = this;
        downTask.dirty();
      }
    };
    taskProto.dispose = function() {
      if (this._disposed) {
        return;
      }
      this._upstream && (this._upstream._downstream = null);
      this._downstream && (this._downstream._upstream = null);
      this._dirty = false;
      this._disposed = true;
    };
    taskProto.getUpstream = function() {
      return this._upstream;
    };
    taskProto.getDownstream = function() {
      return this._downstream;
    };
    taskProto.setOutputEnd = function(end) {
      this._outputDueEnd = this._settedOutputEnd = end;
    };
    exports.createTask = createTask;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Series.js
var require_Series = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/Series.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var env = require_env();
    var _format = require_format();
    var formatTime = _format.formatTime;
    var encodeHTML = _format.encodeHTML;
    var addCommas = _format.addCommas;
    var getTooltipMarker = _format.getTooltipMarker;
    var modelUtil = require_model();
    var ComponentModel = require_Component();
    var colorPaletteMixin = require_colorPalette();
    var dataFormatMixin = require_dataFormat();
    var _layout = require_layout();
    var getLayoutParams = _layout.getLayoutParams;
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var _task = require_task();
    var createTask = _task.createTask;
    var _sourceHelper = require_sourceHelper();
    var prepareSource = _sourceHelper.prepareSource;
    var getSource = _sourceHelper.getSource;
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    var inner = modelUtil.makeInner();
    var SeriesModel = ComponentModel.extend({
      type: "series.__base__",
      /**
       * @readOnly
       */
      seriesIndex: 0,
      // coodinateSystem will be injected in the echarts/CoordinateSystem
      coordinateSystem: null,
      /**
       * @type {Object}
       * @protected
       */
      defaultOption: null,
      /**
       * legend visual provider to the legend component
       * @type {Object}
       */
      // PENDING
      legendVisualProvider: null,
      /**
       * Access path of color for visual
       */
      visualColorAccessPath: "itemStyle.color",
      /**
       * Access path of borderColor for visual
       */
      visualBorderColorAccessPath: "itemStyle.borderColor",
      /**
       * Support merge layout params.
       * Only support 'box' now (left/right/top/bottom/width/height).
       * @type {string|Object} Object can be {ignoreSize: true}
       * @readOnly
       */
      layoutMode: null,
      init: function(option, parentModel, ecModel, extraOpt) {
        this.seriesIndex = this.componentIndex;
        this.dataTask = createTask({
          count: dataTaskCount,
          reset: dataTaskReset
        });
        this.dataTask.context = {
          model: this
        };
        this.mergeDefaultAndTheme(option, ecModel);
        prepareSource(this);
        var data = this.getInitialData(option, ecModel);
        wrapData(data, this);
        this.dataTask.context.data = data;
        inner(this).dataBeforeProcessed = data;
        autoSeriesName(this);
      },
      /**
       * Util for merge default and theme to option
       * @param  {Object} option
       * @param  {module:echarts/model/Global} ecModel
       */
      mergeDefaultAndTheme: function(option, ecModel) {
        var layoutMode = this.layoutMode;
        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        var themeSubType = this.subType;
        if (ComponentModel.hasClass(themeSubType)) {
          themeSubType += "Series";
        }
        zrUtil.merge(option, ecModel.getTheme().get(this.subType));
        zrUtil.merge(option, this.getDefaultOption());
        modelUtil.defaultEmphasis(option, "label", ["show"]);
        this.fillDataTextStyle(option.data);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      },
      mergeOption: function(newSeriesOption, ecModel) {
        newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
        this.fillDataTextStyle(newSeriesOption.data);
        var layoutMode = this.layoutMode;
        if (layoutMode) {
          mergeLayoutParam(this.option, newSeriesOption, layoutMode);
        }
        prepareSource(this);
        var data = this.getInitialData(newSeriesOption, ecModel);
        wrapData(data, this);
        this.dataTask.dirty();
        this.dataTask.context.data = data;
        inner(this).dataBeforeProcessed = data;
        autoSeriesName(this);
      },
      fillDataTextStyle: function(data) {
        if (data && !zrUtil.isTypedArray(data)) {
          var props = ["show"];
          for (var i = 0; i < data.length; i++) {
            if (data[i] && data[i].label) {
              modelUtil.defaultEmphasis(data[i], "label", props);
            }
          }
        }
      },
      /**
       * Init a data structure from data related option in series
       * Must be overwritten
       */
      getInitialData: function() {
      },
      /**
       * Append data to list
       * @param {Object} params
       * @param {Array|TypedArray} params.data
       */
      appendData: function(params) {
        var data = this.getRawData();
        data.appendData(params.data);
      },
      /**
       * Consider some method like `filter`, `map` need make new data,
       * We should make sure that `seriesModel.getData()` get correct
       * data in the stream procedure. So we fetch data from upstream
       * each time `task.perform` called.
       * @param {string} [dataType]
       * @return {module:echarts/data/List}
       */
      getData: function(dataType) {
        var task = getCurrentTask(this);
        if (task) {
          var data = task.context.data;
          return dataType == null ? data : data.getLinkedData(dataType);
        } else {
          return inner(this).data;
        }
      },
      /**
       * @param {module:echarts/data/List} data
       */
      setData: function(data) {
        var task = getCurrentTask(this);
        if (task) {
          var context = task.context;
          if (context.data !== data && task.modifyOutputEnd) {
            task.setOutputEnd(data.count());
          }
          context.outputData = data;
          if (task !== this.dataTask) {
            context.data = data;
          }
        }
        inner(this).data = data;
      },
      /**
       * @see {module:echarts/data/helper/sourceHelper#getSource}
       * @return {module:echarts/data/Source} source
       */
      getSource: function() {
        return getSource(this);
      },
      /**
       * Get data before processed
       * @return {module:echarts/data/List}
       */
      getRawData: function() {
        return inner(this).dataBeforeProcessed;
      },
      /**
       * Get base axis if has coordinate system and has axis.
       * By default use coordSys.getBaseAxis();
       * Can be overrided for some chart.
       * @return {type} description
       */
      getBaseAxis: function() {
        var coordSys = this.coordinateSystem;
        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
      },
      // FIXME
      /**
       * Default tooltip formatter
       *
       * @param {number} dataIndex
       * @param {boolean} [multipleSeries=false]
       * @param {number} [dataType]
       * @param {string} [renderMode='html'] valid values: 'html' and 'richText'.
       *                                     'html' is used for rendering tooltip in extra DOM form, and the result
       *                                     string is used as DOM HTML content.
       *                                     'richText' is used for rendering tooltip in rich text form, for those where
       *                                     DOM operation is not supported.
       * @return {Object} formatted tooltip with `html` and `markers`
       */
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var series = this;
        renderMode = renderMode || "html";
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        var isRichText = renderMode === "richText";
        var markers = {};
        var markerId = 0;
        function formatArrayValue(value2) {
          var vertially = zrUtil.reduce(value2, function(vertially2, val, idx) {
            var dimItem = data.getDimensionInfo(idx);
            return vertially2 |= dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
          }, 0);
          var result = [];
          tooltipDims.length ? zrUtil.each(tooltipDims, function(dim) {
            setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
          }) : zrUtil.each(value2, setEachItem);
          function setEachItem(val, dim) {
            var dimInfo = data.getDimensionInfo(dim);
            if (!dimInfo || dimInfo.otherDims.tooltip === false) {
              return;
            }
            var dimType = dimInfo.type;
            var markName2 = "sub" + series.seriesIndex + "at" + markerId;
            var dimHead = getTooltipMarker({
              color,
              type: "subItem",
              renderMode,
              markerId: markName2
            });
            var dimHeadStr = typeof dimHead === "string" ? dimHead : dimHead.content;
            var valStr = (vertially ? dimHeadStr + encodeHTML(dimInfo.displayName || "-") + ": " : "") + // FIXME should not format time for raw data?
            encodeHTML(dimType === "ordinal" ? val + "" : dimType === "time" ? multipleSeries ? "" : formatTime("yyyy/MM/dd hh:mm:ss", val) : addCommas(val));
            valStr && result.push(valStr);
            if (isRichText) {
              markers[markName2] = color;
              ++markerId;
            }
          }
          var newLine2 = vertially ? isRichText ? "\n" : "<br/>" : "";
          var content2 = newLine2 + result.join(newLine2 || ", ");
          return {
            renderMode,
            content: content2,
            style: markers
          };
        }
        function formatSingleValue(val) {
          return {
            renderMode,
            content: encodeHTML(addCommas(val)),
            style: markers
          };
        }
        var data = this.getData();
        var tooltipDims = data.mapDimension("defaultedTooltip", true);
        var tooltipDimLen = tooltipDims.length;
        var value = this.getRawValue(dataIndex);
        var isValueArr = zrUtil.isArray(value);
        var color = data.getItemVisual(dataIndex, "color");
        if (zrUtil.isObject(color) && color.colorStops) {
          color = (color.colorStops[0] || {}).color;
        }
        color = color || "transparent";
        var formattedValue = tooltipDimLen > 1 || isValueArr && !tooltipDimLen ? formatArrayValue(value) : tooltipDimLen ? formatSingleValue(retrieveRawValue(data, dataIndex, tooltipDims[0])) : formatSingleValue(isValueArr ? value[0] : value);
        var content = formattedValue.content;
        var markName = series.seriesIndex + "at" + markerId;
        var colorEl = getTooltipMarker({
          color,
          type: "item",
          renderMode,
          markerId: markName
        });
        markers[markName] = color;
        ++markerId;
        var name2 = data.getName(dataIndex);
        var seriesName = this.name;
        if (!modelUtil.isNameSpecified(this)) {
          seriesName = "";
        }
        seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? newLine : ": ") : "";
        var colorStr = typeof colorEl === "string" ? colorEl : colorEl.content;
        var html = !multipleSeries ? seriesName + colorStr + (name2 ? encodeHTML(name2) + ": " + content : content) : colorStr + seriesName + content;
        return {
          html,
          markers
        };
      },
      /**
       * @return {boolean}
       */
      isAnimationEnabled: function() {
        if (env.node) {
          return false;
        }
        var animationEnabled = this.getShallow("animation");
        if (animationEnabled) {
          if (this.getData().count() > this.getShallow("animationThreshold")) {
            animationEnabled = false;
          }
        }
        return animationEnabled;
      },
      restoreData: function() {
        this.dataTask.dirty();
      },
      getColorFromPalette: function(name2, scope, requestColorNum) {
        var ecModel = this.ecModel;
        var color = colorPaletteMixin.getColorFromPalette.call(this, name2, scope, requestColorNum);
        if (!color) {
          color = ecModel.getColorFromPalette(name2, scope, requestColorNum);
        }
        return color;
      },
      /**
       * Use `data.mapDimension(coordDim, true)` instead.
       * @deprecated
       */
      coordDimToDataDim: function(coordDim) {
        return this.getRawData().mapDimension(coordDim, true);
      },
      /**
       * Get progressive rendering count each step
       * @return {number}
       */
      getProgressive: function() {
        return this.get("progressive");
      },
      /**
       * Get progressive rendering count each step
       * @return {number}
       */
      getProgressiveThreshold: function() {
        return this.get("progressiveThreshold");
      },
      /**
       * Get data indices for show tooltip content. See tooltip.
       * @abstract
       * @param {Array.<string>|string} dim
       * @param {Array.<number>} value
       * @param {module:echarts/coord/single/SingleAxis} baseAxis
       * @return {Object} {dataIndices, nestestValue}.
       */
      getAxisTooltipData: null,
      /**
       * See tooltip.
       * @abstract
       * @param {number} dataIndex
       * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
       */
      getTooltipPosition: null,
      /**
       * @see {module:echarts/stream/Scheduler}
       */
      pipeTask: null,
      /**
       * Convinient for override in extended class.
       * @protected
       * @type {Function}
       */
      preventIncremental: null,
      /**
       * @public
       * @readOnly
       * @type {Object}
       */
      pipelineContext: null
    });
    zrUtil.mixin(SeriesModel, dataFormatMixin);
    zrUtil.mixin(SeriesModel, colorPaletteMixin);
    function autoSeriesName(seriesModel) {
      var name2 = seriesModel.name;
      if (!modelUtil.isNameSpecified(seriesModel)) {
        seriesModel.name = getSeriesAutoName(seriesModel) || name2;
      }
    }
    function getSeriesAutoName(seriesModel) {
      var data = seriesModel.getRawData();
      var dataDims = data.mapDimension("seriesName", true);
      var nameArr = [];
      zrUtil.each(dataDims, function(dataDim) {
        var dimInfo = data.getDimensionInfo(dataDim);
        dimInfo.displayName && nameArr.push(dimInfo.displayName);
      });
      return nameArr.join(" ");
    }
    function dataTaskCount(context) {
      return context.model.getRawData().count();
    }
    function dataTaskReset(context) {
      var seriesModel = context.model;
      seriesModel.setData(seriesModel.getRawData().cloneShallow());
      return dataTaskProgress;
    }
    function dataTaskProgress(param, context) {
      if (context.outputData && param.end > context.outputData.count()) {
        context.model.getRawData().cloneShallow(context.outputData);
      }
    }
    function wrapData(data, seriesModel) {
      zrUtil.each(data.CHANGABLE_METHODS, function(methodName) {
        data.wrapMethod(methodName, zrUtil.curry(onDataSelfChange, seriesModel));
      });
    }
    function onDataSelfChange(seriesModel) {
      var task = getCurrentTask(seriesModel);
      if (task) {
        task.setOutputEnd(this.count());
      }
    }
    function getCurrentTask(seriesModel) {
      var scheduler = (seriesModel.ecModel || {}).scheduler;
      var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
      if (pipeline) {
        var task = pipeline.currentTask;
        if (task) {
          var agentStubMap = task.agentStubMap;
          if (agentStubMap) {
            task = agentStubMap.get(seriesModel.uid);
          }
        }
        return task;
      }
    }
    var _default = SeriesModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/view/Component.js
var require_Component2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/view/Component.js"(exports, module) {
    var Group = require_Group();
    var componentUtil = require_component();
    var clazzUtil = require_clazz();
    var Component = function() {
      this.group = new Group();
      this.uid = componentUtil.getUID("viewComponent");
    };
    Component.prototype = {
      constructor: Component,
      init: function(ecModel, api) {
      },
      render: function(componentModel, ecModel, api, payload) {
      },
      dispose: function() {
      },
      /**
       * @param {string} eventType
       * @param {Object} query
       * @param {module:zrender/Element} targetEl
       * @param {Object} packedEvent
       * @return {boolen} Pass only when return `true`.
       */
      filterForExposedEvent: null
    };
    var componentProto = Component.prototype;
    componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function(seriesModel, ecModel, api, payload) {
    };
    clazzUtil.enableClassExtend(Component);
    clazzUtil.enableClassManagement(Component, {
      registerWhenExtend: true
    });
    var _default = Component;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createRenderPlanner.js
var require_createRenderPlanner = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createRenderPlanner.js"(exports, module) {
    var _model = require_model();
    var makeInner = _model.makeInner;
    function _default() {
      var inner = makeInner();
      return function(seriesModel) {
        var fields = inner(seriesModel);
        var pipelineContext = seriesModel.pipelineContext;
        var originalLarge = fields.large;
        var originalProgressive = fields.progressiveRender;
        var large = fields.large = pipelineContext && pipelineContext.large;
        var progressive = fields.progressiveRender = pipelineContext && pipelineContext.progressiveRender;
        return !!(originalLarge ^ large || originalProgressive ^ progressive) && "reset";
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/view/Chart.js
var require_Chart = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/view/Chart.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var Group = require_Group();
    var componentUtil = require_component();
    var clazzUtil = require_clazz();
    var modelUtil = require_model();
    var graphicUtil = require_graphic();
    var _task = require_task();
    var createTask = _task.createTask;
    var createRenderPlanner = require_createRenderPlanner();
    var inner = modelUtil.makeInner();
    var renderPlanner = createRenderPlanner();
    function Chart() {
      this.group = new Group();
      this.uid = componentUtil.getUID("viewChart");
      this.renderTask = createTask({
        plan: renderTaskPlan,
        reset: renderTaskReset
      });
      this.renderTask.context = {
        view: this
      };
    }
    Chart.prototype = {
      type: "chart",
      /**
       * Init the chart.
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      init: function(ecModel, api) {
      },
      /**
       * Render the chart.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      render: function(seriesModel, ecModel, api, payload) {
      },
      /**
       * Highlight series or specified data item.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      highlight: function(seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, "emphasis");
      },
      /**
       * Downplay series or specified data item.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      downplay: function(seriesModel, ecModel, api, payload) {
        toggleHighlight(seriesModel.getData(), payload, "normal");
      },
      /**
       * Remove self.
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      remove: function(ecModel, api) {
        this.group.removeAll();
      },
      /**
       * Dispose self.
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      dispose: function() {
      },
      /**
       * Rendering preparation in progressive mode.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      incrementalPrepareRender: null,
      /**
       * Render in progressive mode.
       * @param  {Object} params See taskParams in `stream/task.js`
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       */
      incrementalRender: null,
      /**
       * Update transform directly.
       * @param  {module:echarts/model/Series} seriesModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @param  {Object} payload
       * @return {Object} {update: true}
       */
      updateTransform: null,
      /**
       * The view contains the given point.
       * @interface
       * @param {Array.<number>} point
       * @return {boolean}
       */
      // containPoint: function () {}
      /**
       * @param {string} eventType
       * @param {Object} query
       * @param {module:zrender/Element} targetEl
       * @param {Object} packedEvent
       * @return {boolen} Pass only when return `true`.
       */
      filterForExposedEvent: null
    };
    var chartProto = Chart.prototype;
    chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function(seriesModel, ecModel, api, payload) {
      this.render(seriesModel, ecModel, api, payload);
    };
    function elSetState(el, state, highlightDigit) {
      if (el) {
        el.trigger(state, highlightDigit);
        if (el.isGroup && !graphicUtil.isHighDownDispatcher(el)) {
          for (var i = 0, len = el.childCount(); i < len; i++) {
            elSetState(el.childAt(i), state, highlightDigit);
          }
        }
      }
    }
    function toggleHighlight(data, payload, state) {
      var dataIndex = modelUtil.queryDataIndex(data, payload);
      var highlightDigit = payload && payload.highlightKey != null ? graphicUtil.getHighlightDigit(payload.highlightKey) : null;
      if (dataIndex != null) {
        each(modelUtil.normalizeToArray(dataIndex), function(dataIdx) {
          elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
        });
      } else {
        data.eachItemGraphicEl(function(el) {
          elSetState(el, state, highlightDigit);
        });
      }
    }
    clazzUtil.enableClassExtend(Chart, ["dispose"]);
    clazzUtil.enableClassManagement(Chart, {
      registerWhenExtend: true
    });
    Chart.markUpdateMethod = function(payload, methodName) {
      inner(payload).updateMethod = methodName;
    };
    function renderTaskPlan(context) {
      return renderPlanner(context.model);
    }
    function renderTaskReset(context) {
      var seriesModel = context.model;
      var ecModel = context.ecModel;
      var api = context.api;
      var payload = context.payload;
      var progressiveRender = seriesModel.pipelineContext.progressiveRender;
      var view = context.view;
      var updateMethod = payload && inner(payload).updateMethod;
      var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
      if (methodName !== "render") {
        view[methodName](seriesModel, ecModel, api, payload);
      }
      return progressMethodMap[methodName];
    }
    var progressMethodMap = {
      incrementalPrepareRender: {
        progress: function(params, context) {
          context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
        }
      },
      render: {
        // Put view.render in `progress` to support appendData. But in this case
        // view.render should not be called in reset, otherwise it will be called
        // twise. Use `forceFirstProgress` to make sure that view.render is called
        // in any cases.
        forceFirstProgress: true,
        progress: function(params, context) {
          context.view.render(context.model, context.ecModel, context.api, context.payload);
        }
      }
    };
    var _default = Chart;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/throttle.js
var require_throttle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/throttle.js"(exports) {
    var ORIGIN_METHOD = "\0__throttleOriginMethod";
    var RATE = "\0__throttleRate";
    var THROTTLE_TYPE = "\0__throttleType";
    function throttle(fn, delay, debounce) {
      var currCall;
      var lastCall = 0;
      var lastExec = 0;
      var timer = null;
      var diff;
      var scope;
      var args;
      var debounceNextCall;
      delay = delay || 0;
      function exec() {
        lastExec = (/* @__PURE__ */ new Date()).getTime();
        timer = null;
        fn.apply(scope, args || []);
      }
      var cb = function() {
        currCall = (/* @__PURE__ */ new Date()).getTime();
        scope = this;
        args = arguments;
        var thisDelay = debounceNextCall || delay;
        var thisDebounce = debounceNextCall || debounce;
        debounceNextCall = null;
        diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
        clearTimeout(timer);
        if (thisDebounce) {
          timer = setTimeout(exec, thisDelay);
        } else {
          if (diff >= 0) {
            exec();
          } else {
            timer = setTimeout(exec, -diff);
          }
        }
        lastCall = currCall;
      };
      cb.clear = function() {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
      };
      cb.debounceNextCall = function(debounceDelay) {
        debounceNextCall = debounceDelay;
      };
      return cb;
    }
    function createOrUpdate(obj, fnAttr, rate, throttleType) {
      var fn = obj[fnAttr];
      if (!fn) {
        return;
      }
      var originFn = fn[ORIGIN_METHOD] || fn;
      var lastThrottleType = fn[THROTTLE_TYPE];
      var lastRate = fn[RATE];
      if (lastRate !== rate || lastThrottleType !== throttleType) {
        if (rate == null || !throttleType) {
          return obj[fnAttr] = originFn;
        }
        fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
        fn[ORIGIN_METHOD] = originFn;
        fn[THROTTLE_TYPE] = throttleType;
        fn[RATE] = rate;
      }
      return fn;
    }
    function clear(obj, fnAttr) {
      var fn = obj[fnAttr];
      if (fn && fn[ORIGIN_METHOD]) {
        obj[fnAttr] = fn[ORIGIN_METHOD];
      }
    }
    exports.throttle = throttle;
    exports.createOrUpdate = createOrUpdate;
    exports.clear = clear;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/seriesColor.js
var require_seriesColor = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/seriesColor.js"(exports, module) {
    var Gradient = require_Gradient();
    var _util = require_util();
    var isFunction = _util.isFunction;
    var _default = {
      createOnAllSeries: true,
      performRawSeries: true,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        var colorAccessPath = (seriesModel.visualColorAccessPath || "itemStyle.color").split(".");
        var color = seriesModel.get(colorAccessPath);
        var colorCallback = isFunction(color) && !(color instanceof Gradient) ? color : null;
        if (!color || colorCallback) {
          color = seriesModel.getColorFromPalette(
            // TODO series count changed.
            seriesModel.name,
            null,
            ecModel.getSeriesCount()
          );
        }
        data.setVisual("color", color);
        var borderColorAccessPath = (seriesModel.visualBorderColorAccessPath || "itemStyle.borderColor").split(".");
        var borderColor = seriesModel.get(borderColorAccessPath);
        data.setVisual("borderColor", borderColor);
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          if (colorCallback) {
            data.each(function(idx) {
              data.setItemVisual(idx, "color", colorCallback(seriesModel.getDataParams(idx)));
            });
          }
          var dataEach = function(data2, idx) {
            var itemModel = data2.getItemModel(idx);
            var color2 = itemModel.get(colorAccessPath, true);
            var borderColor2 = itemModel.get(borderColorAccessPath, true);
            if (color2 != null) {
              data2.setItemVisual(idx, "color", color2);
            }
            if (borderColor2 != null) {
              data2.setItemVisual(idx, "borderColor", borderColor2);
            }
          };
          return {
            dataEach: data.hasItemOption ? dataEach : null
          };
        }
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/lang.js
var require_lang = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/lang.js"(exports, module) {
    var _default = {
      legend: {
        selector: {
          all: "全选",
          inverse: "反选"
        }
      },
      toolbox: {
        brush: {
          title: {
            rect: "矩形选择",
            polygon: "圈选",
            lineX: "横向选择",
            lineY: "纵向选择",
            keep: "保持选择",
            clear: "清除选择"
          }
        },
        dataView: {
          title: "数据视图",
          lang: ["数据视图", "关闭", "刷新"]
        },
        dataZoom: {
          title: {
            zoom: "区域缩放",
            back: "区域缩放还原"
          }
        },
        magicType: {
          title: {
            line: "切换为折线图",
            bar: "切换为柱状图",
            stack: "切换为堆叠",
            tiled: "切换为平铺"
          }
        },
        restore: {
          title: "还原"
        },
        saveAsImage: {
          title: "保存为图片",
          lang: ["右键另存为图片"]
        }
      },
      series: {
        typeNames: {
          pie: "饼图",
          bar: "柱状图",
          line: "折线图",
          scatter: "散点图",
          effectScatter: "涟漪散点图",
          radar: "雷达图",
          tree: "树图",
          treemap: "矩形树图",
          boxplot: "箱型图",
          candlestick: "K线图",
          k: "K线图",
          heatmap: "热力图",
          map: "地图",
          parallel: "平行坐标图",
          lines: "线图",
          graph: "关系图",
          sankey: "桑基图",
          funnel: "漏斗图",
          gauge: "仪表盘图",
          pictorialBar: "象形柱图",
          themeRiver: "主题河流图",
          sunburst: "旭日图"
        }
      },
      aria: {
        general: {
          withTitle: "这是一个关于“{title}”的图表。",
          withoutTitle: "这是一个图表，"
        },
        series: {
          single: {
            prefix: "",
            withName: "图表类型是{seriesType}，表示{seriesName}。",
            withoutName: "图表类型是{seriesType}。"
          },
          multiple: {
            prefix: "它由{seriesCount}个图表系列组成。",
            withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
            withoutName: "第{seriesId}个系列是一个{seriesType}，",
            separator: {
              middle: "；",
              end: "。"
            }
          }
        },
        data: {
          allData: "其数据是——",
          partialData: "其中，前{displayCnt}项是——",
          withName: "{name}的数据是{value}",
          withoutName: "{value}",
          separator: {
            middle: "，",
            end: ""
          }
        }
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/aria.js
var require_aria = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/aria.js"(exports, module) {
    var zrUtil = require_util();
    var lang = require_lang();
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    function _default(dom, ecModel) {
      var ariaModel = ecModel.getModel("aria");
      if (!ariaModel.get("show")) {
        return;
      } else if (ariaModel.get("description")) {
        dom.setAttribute("aria-label", ariaModel.get("description"));
        return;
      }
      var seriesCnt = 0;
      ecModel.eachSeries(function(seriesModel, idx) {
        ++seriesCnt;
      }, this);
      var maxDataCnt = ariaModel.get("data.maxCount") || 10;
      var maxSeriesCnt = ariaModel.get("series.maxCount") || 10;
      var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
      var ariaLabel;
      if (seriesCnt < 1) {
        return;
      } else {
        var title = getTitle();
        if (title) {
          ariaLabel = replace(getConfig("general.withTitle"), {
            title
          });
        } else {
          ariaLabel = getConfig("general.withoutTitle");
        }
        var seriesLabels = [];
        var prefix = seriesCnt > 1 ? "series.multiple.prefix" : "series.single.prefix";
        ariaLabel += replace(getConfig(prefix), {
          seriesCount: seriesCnt
        });
        ecModel.eachSeries(function(seriesModel, idx) {
          if (idx < displaySeriesCnt) {
            var seriesLabel;
            var seriesName = seriesModel.get("name");
            var seriesTpl = "series." + (seriesCnt > 1 ? "multiple" : "single") + ".";
            seriesLabel = getConfig(seriesName ? seriesTpl + "withName" : seriesTpl + "withoutName");
            seriesLabel = replace(seriesLabel, {
              seriesId: seriesModel.seriesIndex,
              seriesName: seriesModel.get("name"),
              seriesType: getSeriesTypeName(seriesModel.subType)
            });
            var data = seriesModel.getData();
            window.data = data;
            if (data.count() > maxDataCnt) {
              seriesLabel += replace(getConfig("data.partialData"), {
                displayCnt: maxDataCnt
              });
            } else {
              seriesLabel += getConfig("data.allData");
            }
            var dataLabels = [];
            for (var i = 0; i < data.count(); i++) {
              if (i < maxDataCnt) {
                var name2 = data.getName(i);
                var value = retrieveRawValue(data, i);
                dataLabels.push(replace(name2 ? getConfig("data.withName") : getConfig("data.withoutName"), {
                  name: name2,
                  value
                }));
              }
            }
            seriesLabel += dataLabels.join(getConfig("data.separator.middle")) + getConfig("data.separator.end");
            seriesLabels.push(seriesLabel);
          }
        });
        ariaLabel += seriesLabels.join(getConfig("series.multiple.separator.middle")) + getConfig("series.multiple.separator.end");
        dom.setAttribute("aria-label", ariaLabel);
      }
      function replace(str, keyValues) {
        if (typeof str !== "string") {
          return str;
        }
        var result = str;
        zrUtil.each(keyValues, function(value, key) {
          result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
        });
        return result;
      }
      function getConfig(path) {
        var userConfig = ariaModel.get(path);
        if (userConfig == null) {
          var pathArr = path.split(".");
          var result = lang.aria;
          for (var i = 0; i < pathArr.length; ++i) {
            result = result[pathArr[i]];
          }
          return result;
        } else {
          return userConfig;
        }
      }
      function getTitle() {
        var title2 = ecModel.getModel("title").option;
        if (title2 && title2.length) {
          title2 = title2[0];
        }
        return title2 && title2.text;
      }
      function getSeriesTypeName(type) {
        return lang.series.typeNames[type] || "自定义图";
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/loading/default.js
var require_default = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/loading/default.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var textContain = require_text();
    var PI = Math.PI;
    function _default(api, opts) {
      opts = opts || {};
      zrUtil.defaults(opts, {
        text: "loading",
        textColor: "#000",
        fontSize: "12px",
        maskColor: "rgba(255, 255, 255, 0.8)",
        showSpinner: true,
        color: "#c23531",
        spinnerRadius: 10,
        lineWidth: 5,
        zlevel: 0
      });
      var group = new graphic.Group();
      var mask = new graphic.Rect({
        style: {
          fill: opts.maskColor
        },
        zlevel: opts.zlevel,
        z: 1e4
      });
      group.add(mask);
      var font = opts.fontSize + " sans-serif";
      var labelRect = new graphic.Rect({
        style: {
          fill: "none",
          text: opts.text,
          font,
          textPosition: "right",
          textDistance: 10,
          textFill: opts.textColor
        },
        zlevel: opts.zlevel,
        z: 10001
      });
      group.add(labelRect);
      if (opts.showSpinner) {
        var arc = new graphic.Arc({
          shape: {
            startAngle: -PI / 2,
            endAngle: -PI / 2 + 0.1,
            r: opts.spinnerRadius
          },
          style: {
            stroke: opts.color,
            lineCap: "round",
            lineWidth: opts.lineWidth
          },
          zlevel: opts.zlevel,
          z: 10001
        });
        arc.animateShape(true).when(1e3, {
          endAngle: PI * 3 / 2
        }).start("circularInOut");
        arc.animateShape(true).when(1e3, {
          startAngle: PI * 3 / 2
        }).delay(300).start("circularInOut");
        group.add(arc);
      }
      group.resize = function() {
        var textWidth = textContain.getWidth(opts.text, font);
        var r = opts.showSpinner ? opts.spinnerRadius : 0;
        var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner ? 0 : textWidth / 2);
        var cy = api.getHeight() / 2;
        opts.showSpinner && arc.setShape({
          cx,
          cy
        });
        labelRect.setShape({
          x: cx - r,
          y: cy - r,
          width: r * 2,
          height: r * 2
        });
        mask.setShape({
          x: 0,
          y: 0,
          width: api.getWidth(),
          height: api.getHeight()
        });
      };
      group.resize();
      return group;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/stream/Scheduler.js
var require_Scheduler = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/stream/Scheduler.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var map = _util.map;
    var isFunction = _util.isFunction;
    var createHashMap = _util.createHashMap;
    var noop = _util.noop;
    var _task = require_task();
    var createTask = _task.createTask;
    var _component = require_component();
    var getUID = _component.getUID;
    var GlobalModel = require_Global();
    var ExtensionAPI = require_ExtensionAPI();
    var _model = require_model();
    var normalizeToArray = _model.normalizeToArray;
    function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
      this.ecInstance = ecInstance;
      this.api = api;
      this.unfinished;
      var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
      var visualHandlers = this._visualHandlers = visualHandlers.slice();
      this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
      this._stageTaskMap = createHashMap();
    }
    var proto = Scheduler.prototype;
    proto.restoreData = function(ecModel, payload) {
      ecModel.restoreData(payload);
      this._stageTaskMap.each(function(taskRecord) {
        var overallTask = taskRecord.overallTask;
        overallTask && overallTask.dirty();
      });
    };
    proto.getPerformArgs = function(task, isBlock) {
      if (!task.__pipeline) {
        return;
      }
      var pipeline = this._pipelineMap.get(task.__pipeline.id);
      var pCtx = pipeline.context;
      var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
      var step = incremental ? pipeline.step : null;
      var modDataCount = pCtx && pCtx.modDataCount;
      var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
      return {
        step,
        modBy,
        modDataCount
      };
    };
    proto.getPipeline = function(pipelineId) {
      return this._pipelineMap.get(pipelineId);
    };
    proto.updateStreamModes = function(seriesModel, view) {
      var pipeline = this._pipelineMap.get(seriesModel.uid);
      var data = seriesModel.getData();
      var dataLen = data.count();
      var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
      var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
      var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
      seriesModel.pipelineContext = pipeline.context = {
        progressiveRender,
        modDataCount,
        large
      };
    };
    proto.restorePipelines = function(ecModel) {
      var scheduler = this;
      var pipelineMap = scheduler._pipelineMap = createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var progressive = seriesModel.getProgressive();
        var pipelineId = seriesModel.uid;
        pipelineMap.set(pipelineId, {
          id: pipelineId,
          head: null,
          tail: null,
          threshold: seriesModel.getProgressiveThreshold(),
          progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
          blockIndex: -1,
          step: Math.round(progressive || 700),
          count: 0
        });
        pipe(scheduler, seriesModel, seriesModel.dataTask);
      });
    };
    proto.prepareStageTasks = function() {
      var stageTaskMap = this._stageTaskMap;
      var ecModel = this.ecInstance.getModel();
      var api = this.api;
      each(this._allHandlers, function(handler) {
        var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);
        handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);
        handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);
      }, this);
    };
    proto.prepareView = function(view, model, ecModel, api) {
      var renderTask = view.renderTask;
      var context = renderTask.context;
      context.model = model;
      context.ecModel = ecModel;
      context.api = api;
      renderTask.__block = !view.incrementalPrepareRender;
      pipe(this, model, renderTask);
    };
    proto.performDataProcessorTasks = function(ecModel, payload) {
      performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {
        block: true
      });
    };
    proto.performVisualTasks = function(ecModel, payload, opt) {
      performStageTasks(this, this._visualHandlers, ecModel, payload, opt);
    };
    function performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {
      opt = opt || {};
      var unfinished;
      each(stageHandlers, function(stageHandler, idx) {
        if (opt.visualType && opt.visualType !== stageHandler.visualType) {
          return;
        }
        var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
        var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
        var overallTask = stageHandlerRecord.overallTask;
        if (overallTask) {
          var overallNeedDirty;
          var agentStubMap = overallTask.agentStubMap;
          agentStubMap.each(function(stub) {
            if (needSetDirty(opt, stub)) {
              stub.dirty();
              overallNeedDirty = true;
            }
          });
          overallNeedDirty && overallTask.dirty();
          updatePayload(overallTask, payload);
          var performArgs = scheduler.getPerformArgs(overallTask, opt.block);
          agentStubMap.each(function(stub) {
            stub.perform(performArgs);
          });
          unfinished |= overallTask.perform(performArgs);
        } else if (seriesTaskMap) {
          seriesTaskMap.each(function(task, pipelineId) {
            if (needSetDirty(opt, task)) {
              task.dirty();
            }
            var performArgs2 = scheduler.getPerformArgs(task, opt.block);
            performArgs2.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
            updatePayload(task, payload);
            unfinished |= task.perform(performArgs2);
          });
        }
      });
      function needSetDirty(opt2, task) {
        return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
      }
      scheduler.unfinished |= unfinished;
    }
    proto.performSeriesTasks = function(ecModel) {
      var unfinished;
      ecModel.eachSeries(function(seriesModel) {
        unfinished |= seriesModel.dataTask.perform();
      });
      this.unfinished |= unfinished;
    };
    proto.plan = function() {
      this._pipelineMap.each(function(pipeline) {
        var task = pipeline.tail;
        do {
          if (task.__block) {
            pipeline.blockIndex = task.__idxInPipeline;
            break;
          }
          task = task.getUpstream();
        } while (task);
      });
    };
    var updatePayload = proto.updatePayload = function(task, payload) {
      payload !== "remain" && (task.context.payload = payload);
    };
    function createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
      var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());
      var seriesType2 = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries;
      if (stageHandler.createOnAllSeries) {
        ecModel.eachRawSeries(create);
      } else if (seriesType2) {
        ecModel.eachRawSeriesByType(seriesType2, create);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(create);
      }
      function create(seriesModel) {
        var pipelineId = seriesModel.uid;
        var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({
          plan: seriesTaskPlan,
          reset: seriesTaskReset,
          count: seriesTaskCount
        }));
        task.context = {
          model: seriesModel,
          ecModel,
          api,
          useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
          plan: stageHandler.plan,
          reset: stageHandler.reset,
          scheduler
        };
        pipe(scheduler, seriesModel, task);
      }
      var pipelineMap = scheduler._pipelineMap;
      seriesTaskMap.each(function(task, pipelineId) {
        if (!pipelineMap.get(pipelineId)) {
          task.dispose();
          seriesTaskMap.removeKey(pipelineId);
        }
      });
    }
    function createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
      var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
        reset: overallTaskReset
      });
      overallTask.context = {
        ecModel,
        api,
        overallReset: stageHandler.overallReset,
        scheduler
      };
      var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();
      var seriesType2 = stageHandler.seriesType;
      var getTargetSeries = stageHandler.getTargetSeries;
      var overallProgress = true;
      var modifyOutputEnd = stageHandler.modifyOutputEnd;
      if (seriesType2) {
        ecModel.eachRawSeriesByType(seriesType2, createStub);
      } else if (getTargetSeries) {
        getTargetSeries(ecModel, api).each(createStub);
      } else {
        overallProgress = false;
        each(ecModel.getSeries(), createStub);
      }
      function createStub(seriesModel) {
        var pipelineId = seriesModel.uid;
        var stub = agentStubMap.get(pipelineId);
        if (!stub) {
          stub = agentStubMap.set(pipelineId, createTask({
            reset: stubReset,
            onDirty: stubOnDirty
          }));
          overallTask.dirty();
        }
        stub.context = {
          model: seriesModel,
          overallProgress,
          modifyOutputEnd
        };
        stub.agent = overallTask;
        stub.__block = overallProgress;
        pipe(scheduler, seriesModel, stub);
      }
      var pipelineMap = scheduler._pipelineMap;
      agentStubMap.each(function(stub, pipelineId) {
        if (!pipelineMap.get(pipelineId)) {
          stub.dispose();
          overallTask.dirty();
          agentStubMap.removeKey(pipelineId);
        }
      });
    }
    function overallTaskReset(context) {
      context.overallReset(context.ecModel, context.api, context.payload);
    }
    function stubReset(context, upstreamContext) {
      return context.overallProgress && stubProgress;
    }
    function stubProgress() {
      this.agent.dirty();
      this.getDownstream().dirty();
    }
    function stubOnDirty() {
      this.agent && this.agent.dirty();
    }
    function seriesTaskPlan(context) {
      return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);
    }
    function seriesTaskReset(context) {
      if (context.useClearVisual) {
        context.data.clearAllVisual();
      }
      var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
      return resetDefines.length > 1 ? map(resetDefines, function(v, idx) {
        return makeSeriesTaskProgress(idx);
      }) : singleSeriesTaskProgress;
    }
    var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
    function makeSeriesTaskProgress(resetDefineIdx) {
      return function(params, context) {
        var data = context.data;
        var resetDefine = context.resetDefines[resetDefineIdx];
        if (resetDefine && resetDefine.dataEach) {
          for (var i = params.start; i < params.end; i++) {
            resetDefine.dataEach(data, i);
          }
        } else if (resetDefine && resetDefine.progress) {
          resetDefine.progress(params, data);
        }
      };
    }
    function seriesTaskCount(context) {
      return context.data.count();
    }
    function pipe(scheduler, seriesModel, task) {
      var pipelineId = seriesModel.uid;
      var pipeline = scheduler._pipelineMap.get(pipelineId);
      !pipeline.head && (pipeline.head = task);
      pipeline.tail && pipeline.tail.pipe(task);
      pipeline.tail = task;
      task.__idxInPipeline = pipeline.count++;
      task.__pipeline = pipeline;
    }
    Scheduler.wrapStageHandler = function(stageHandler, visualType) {
      if (isFunction(stageHandler)) {
        stageHandler = {
          overallReset: stageHandler,
          seriesType: detectSeriseType(stageHandler)
        };
      }
      stageHandler.uid = getUID("stageHandler");
      visualType && (stageHandler.visualType = visualType);
      return stageHandler;
    };
    function detectSeriseType(legacyFunc) {
      seriesType = null;
      try {
        legacyFunc(ecModelMock, apiMock);
      } catch (e) {
      }
      return seriesType;
    }
    var ecModelMock = {};
    var apiMock = {};
    var seriesType;
    mockMethods(ecModelMock, GlobalModel);
    mockMethods(apiMock, ExtensionAPI);
    ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
      seriesType = type;
    };
    ecModelMock.eachComponent = function(cond) {
      if (cond.mainType === "series" && cond.subType) {
        seriesType = cond.subType;
      }
    };
    function mockMethods(target, Clz) {
      for (var name2 in Clz.prototype) {
        target[name2] = noop;
      }
    }
    var _default = Scheduler;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/theme/light.js
var require_light = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/theme/light.js"(exports, module) {
    var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
    var _default = {
      color: colorAll,
      colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/theme/dark.js
var require_dark = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/theme/dark.js"(exports, module) {
    var contrastColor = "#eee";
    var axisCommon = function() {
      return {
        axisLine: {
          lineStyle: {
            color: contrastColor
          }
        },
        axisTick: {
          lineStyle: {
            color: contrastColor
          }
        },
        axisLabel: {
          textStyle: {
            color: contrastColor
          }
        },
        splitLine: {
          lineStyle: {
            type: "dashed",
            color: "#aaa"
          }
        },
        splitArea: {
          areaStyle: {
            color: contrastColor
          }
        }
      };
    };
    var colorPalette = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"];
    var theme = {
      color: colorPalette,
      backgroundColor: "#333",
      tooltip: {
        axisPointer: {
          lineStyle: {
            color: contrastColor
          },
          crossStyle: {
            color: contrastColor
          },
          label: {
            color: "#000"
          }
        }
      },
      legend: {
        textStyle: {
          color: contrastColor
        }
      },
      textStyle: {
        color: contrastColor
      },
      title: {
        textStyle: {
          color: contrastColor
        }
      },
      toolbox: {
        iconStyle: {
          normal: {
            borderColor: contrastColor
          }
        }
      },
      dataZoom: {
        textStyle: {
          color: contrastColor
        }
      },
      visualMap: {
        textStyle: {
          color: contrastColor
        }
      },
      timeline: {
        lineStyle: {
          color: contrastColor
        },
        itemStyle: {
          normal: {
            color: colorPalette[1]
          }
        },
        label: {
          normal: {
            textStyle: {
              color: contrastColor
            }
          }
        },
        controlStyle: {
          normal: {
            color: contrastColor,
            borderColor: contrastColor
          }
        }
      },
      timeAxis: axisCommon(),
      logAxis: axisCommon(),
      valueAxis: axisCommon(),
      categoryAxis: axisCommon(),
      line: {
        symbol: "circle"
      },
      graph: {
        color: colorPalette
      },
      gauge: {
        title: {
          textStyle: {
            color: contrastColor
          }
        }
      },
      candlestick: {
        itemStyle: {
          normal: {
            color: "#FD1050",
            color0: "#0CF49B",
            borderColor: "#FD1050",
            borderColor0: "#0CF49B"
          }
        }
      }
    };
    theme.categoryAxis.splitLine.show = false;
    var _default = theme;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataset.js
var require_dataset = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataset.js"() {
    var ComponentModel = require_Component();
    var ComponentView = require_Component2();
    var _sourceHelper = require_sourceHelper();
    var detectSourceFormat = _sourceHelper.detectSourceFormat;
    var _sourceType = require_sourceType();
    var SERIES_LAYOUT_BY_COLUMN = _sourceType.SERIES_LAYOUT_BY_COLUMN;
    ComponentModel.extend({
      type: "dataset",
      /**
       * @protected
       */
      defaultOption: {
        // 'row', 'column'
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        // null/'auto': auto detect header, see "module:echarts/data/helper/sourceHelper"
        sourceHeader: null,
        dimensions: null,
        source: null
      },
      optionUpdated: function() {
        detectSourceFormat(this);
      }
    });
    ComponentView.extend({
      type: "dataset"
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Ellipse.js
var require_Ellipse = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/graphic/shape/Ellipse.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "ellipse",
      shape: {
        cx: 0,
        cy: 0,
        rx: 0,
        ry: 0
      },
      buildPath: function(ctx, shape) {
        var k = 0.5522848;
        var x = shape.cx;
        var y = shape.cy;
        var a = shape.rx;
        var b = shape.ry;
        var ox = a * k;
        var oy = b * k;
        ctx.moveTo(x - a, y);
        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
        ctx.closePath();
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/parseSVG.js
var require_parseSVG = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/tool/parseSVG.js"(exports) {
    var Group = require_Group();
    var ZImage = require_Image();
    var Text = require_Text();
    var Circle = require_Circle();
    var Rect = require_Rect();
    var Ellipse = require_Ellipse();
    var Line = require_Line();
    var Path = require_Path();
    var Polygon = require_Polygon();
    var Polyline = require_Polyline();
    var LinearGradient = require_LinearGradient();
    var Style = require_Style();
    var matrix = require_matrix();
    var _path = require_path2();
    var createFromString = _path.createFromString;
    var _util = require_util();
    var isString = _util.isString;
    var extend = _util.extend;
    var defaults = _util.defaults;
    var trim = _util.trim;
    var each = _util.each;
    var DILIMITER_REG = /[\s,]+/;
    function parseXML(svg) {
      if (isString(svg)) {
        var parser = new DOMParser();
        svg = parser.parseFromString(svg, "text/xml");
      }
      if (svg.nodeType === 9) {
        svg = svg.firstChild;
      }
      while (svg.nodeName.toLowerCase() !== "svg" || svg.nodeType !== 1) {
        svg = svg.nextSibling;
      }
      return svg;
    }
    function SVGParser() {
      this._defs = {};
      this._root = null;
      this._isDefine = false;
      this._isText = false;
    }
    SVGParser.prototype.parse = function(xml, opt) {
      opt = opt || {};
      var svg = parseXML(xml);
      if (!svg) {
        throw new Error("Illegal svg");
      }
      var root = new Group();
      this._root = root;
      var viewBox = svg.getAttribute("viewBox") || "";
      var width = parseFloat(svg.getAttribute("width") || opt.width);
      var height = parseFloat(svg.getAttribute("height") || opt.height);
      isNaN(width) && (width = null);
      isNaN(height) && (height = null);
      parseAttributes(svg, root, null, true);
      var child = svg.firstChild;
      while (child) {
        this._parseNode(child, root);
        child = child.nextSibling;
      }
      var viewBoxRect;
      var viewBoxTransform;
      if (viewBox) {
        var viewBoxArr = trim(viewBox).split(DILIMITER_REG);
        if (viewBoxArr.length >= 4) {
          viewBoxRect = {
            x: parseFloat(viewBoxArr[0] || 0),
            y: parseFloat(viewBoxArr[1] || 0),
            width: parseFloat(viewBoxArr[2]),
            height: parseFloat(viewBoxArr[3])
          };
        }
      }
      if (viewBoxRect && width != null && height != null) {
        viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);
        if (!opt.ignoreViewBox) {
          var elRoot = root;
          root = new Group();
          root.add(elRoot);
          elRoot.scale = viewBoxTransform.scale.slice();
          elRoot.position = viewBoxTransform.position.slice();
        }
      }
      if (!opt.ignoreRootClip && width != null && height != null) {
        root.setClipPath(new Rect({
          shape: {
            x: 0,
            y: 0,
            width,
            height
          }
        }));
      }
      return {
        root,
        width,
        height,
        viewBoxRect,
        viewBoxTransform
      };
    };
    SVGParser.prototype._parseNode = function(xmlNode, parentGroup) {
      var nodeName = xmlNode.nodeName.toLowerCase();
      if (nodeName === "defs") {
        this._isDefine = true;
      } else if (nodeName === "text") {
        this._isText = true;
      }
      var el;
      if (this._isDefine) {
        var parser = defineParsers[nodeName];
        if (parser) {
          var def = parser.call(this, xmlNode);
          var id = xmlNode.getAttribute("id");
          if (id) {
            this._defs[id] = def;
          }
        }
      } else {
        var parser = nodeParsers[nodeName];
        if (parser) {
          el = parser.call(this, xmlNode, parentGroup);
          parentGroup.add(el);
        }
      }
      var child = xmlNode.firstChild;
      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el);
        }
        if (child.nodeType === 3 && this._isText) {
          this._parseText(child, el);
        }
        child = child.nextSibling;
      }
      if (nodeName === "defs") {
        this._isDefine = false;
      } else if (nodeName === "text") {
        this._isText = false;
      }
    };
    SVGParser.prototype._parseText = function(xmlNode, parentGroup) {
      if (xmlNode.nodeType === 1) {
        var dx = xmlNode.getAttribute("dx") || 0;
        var dy = xmlNode.getAttribute("dy") || 0;
        this._textX += parseFloat(dx);
        this._textY += parseFloat(dy);
      }
      var text = new Text({
        style: {
          text: xmlNode.textContent,
          transformText: true
        },
        position: [this._textX || 0, this._textY || 0]
      });
      inheritStyle(parentGroup, text);
      parseAttributes(xmlNode, text, this._defs);
      var fontSize = text.style.fontSize;
      if (fontSize && fontSize < 9) {
        text.style.fontSize = 9;
        text.scale = text.scale || [1, 1];
        text.scale[0] *= fontSize / 9;
        text.scale[1] *= fontSize / 9;
      }
      var rect = text.getBoundingRect();
      this._textX += rect.width;
      parentGroup.add(text);
      return text;
    };
    var nodeParsers = {
      "g": function(xmlNode, parentGroup) {
        var g = new Group();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        return g;
      },
      "rect": function(xmlNode, parentGroup) {
        var rect = new Rect();
        inheritStyle(parentGroup, rect);
        parseAttributes(xmlNode, rect, this._defs);
        rect.setShape({
          x: parseFloat(xmlNode.getAttribute("x") || 0),
          y: parseFloat(xmlNode.getAttribute("y") || 0),
          width: parseFloat(xmlNode.getAttribute("width") || 0),
          height: parseFloat(xmlNode.getAttribute("height") || 0)
        });
        return rect;
      },
      "circle": function(xmlNode, parentGroup) {
        var circle = new Circle();
        inheritStyle(parentGroup, circle);
        parseAttributes(xmlNode, circle, this._defs);
        circle.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || 0),
          cy: parseFloat(xmlNode.getAttribute("cy") || 0),
          r: parseFloat(xmlNode.getAttribute("r") || 0)
        });
        return circle;
      },
      "line": function(xmlNode, parentGroup) {
        var line = new Line();
        inheritStyle(parentGroup, line);
        parseAttributes(xmlNode, line, this._defs);
        line.setShape({
          x1: parseFloat(xmlNode.getAttribute("x1") || 0),
          y1: parseFloat(xmlNode.getAttribute("y1") || 0),
          x2: parseFloat(xmlNode.getAttribute("x2") || 0),
          y2: parseFloat(xmlNode.getAttribute("y2") || 0)
        });
        return line;
      },
      "ellipse": function(xmlNode, parentGroup) {
        var ellipse = new Ellipse();
        inheritStyle(parentGroup, ellipse);
        parseAttributes(xmlNode, ellipse, this._defs);
        ellipse.setShape({
          cx: parseFloat(xmlNode.getAttribute("cx") || 0),
          cy: parseFloat(xmlNode.getAttribute("cy") || 0),
          rx: parseFloat(xmlNode.getAttribute("rx") || 0),
          ry: parseFloat(xmlNode.getAttribute("ry") || 0)
        });
        return ellipse;
      },
      "polygon": function(xmlNode, parentGroup) {
        var points = xmlNode.getAttribute("points");
        if (points) {
          points = parsePoints(points);
        }
        var polygon = new Polygon({
          shape: {
            points: points || []
          }
        });
        inheritStyle(parentGroup, polygon);
        parseAttributes(xmlNode, polygon, this._defs);
        return polygon;
      },
      "polyline": function(xmlNode, parentGroup) {
        var path = new Path();
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defs);
        var points = xmlNode.getAttribute("points");
        if (points) {
          points = parsePoints(points);
        }
        var polyline = new Polyline({
          shape: {
            points: points || []
          }
        });
        return polyline;
      },
      "image": function(xmlNode, parentGroup) {
        var img = new ZImage();
        inheritStyle(parentGroup, img);
        parseAttributes(xmlNode, img, this._defs);
        img.setStyle({
          image: xmlNode.getAttribute("xlink:href"),
          x: xmlNode.getAttribute("x"),
          y: xmlNode.getAttribute("y"),
          width: xmlNode.getAttribute("width"),
          height: xmlNode.getAttribute("height")
        });
        return img;
      },
      "text": function(xmlNode, parentGroup) {
        var x = xmlNode.getAttribute("x") || 0;
        var y = xmlNode.getAttribute("y") || 0;
        var dx = xmlNode.getAttribute("dx") || 0;
        var dy = xmlNode.getAttribute("dy") || 0;
        this._textX = parseFloat(x) + parseFloat(dx);
        this._textY = parseFloat(y) + parseFloat(dy);
        var g = new Group();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        return g;
      },
      "tspan": function(xmlNode, parentGroup) {
        var x = xmlNode.getAttribute("x");
        var y = xmlNode.getAttribute("y");
        if (x != null) {
          this._textX = parseFloat(x);
        }
        if (y != null) {
          this._textY = parseFloat(y);
        }
        var dx = xmlNode.getAttribute("dx") || 0;
        var dy = xmlNode.getAttribute("dy") || 0;
        var g = new Group();
        inheritStyle(parentGroup, g);
        parseAttributes(xmlNode, g, this._defs);
        this._textX += dx;
        this._textY += dy;
        return g;
      },
      "path": function(xmlNode, parentGroup) {
        var d = xmlNode.getAttribute("d") || "";
        var path = createFromString(d);
        inheritStyle(parentGroup, path);
        parseAttributes(xmlNode, path, this._defs);
        return path;
      }
    };
    var defineParsers = {
      "lineargradient": function(xmlNode) {
        var x1 = parseInt(xmlNode.getAttribute("x1") || 0, 10);
        var y1 = parseInt(xmlNode.getAttribute("y1") || 0, 10);
        var x2 = parseInt(xmlNode.getAttribute("x2") || 10, 10);
        var y2 = parseInt(xmlNode.getAttribute("y2") || 0, 10);
        var gradient = new LinearGradient(x1, y1, x2, y2);
        _parseGradientColorStops(xmlNode, gradient);
        return gradient;
      },
      "radialgradient": function(xmlNode) {
      }
    };
    function _parseGradientColorStops(xmlNode, gradient) {
      var stop = xmlNode.firstChild;
      while (stop) {
        if (stop.nodeType === 1) {
          var offset = stop.getAttribute("offset");
          if (offset.indexOf("%") > 0) {
            offset = parseInt(offset, 10) / 100;
          } else if (offset) {
            offset = parseFloat(offset);
          } else {
            offset = 0;
          }
          var stopColor = stop.getAttribute("stop-color") || "#000000";
          gradient.addColorStop(offset, stopColor);
        }
        stop = stop.nextSibling;
      }
    }
    function inheritStyle(parent, child) {
      if (parent && parent.__inheritedStyle) {
        if (!child.__inheritedStyle) {
          child.__inheritedStyle = {};
        }
        defaults(child.__inheritedStyle, parent.__inheritedStyle);
      }
    }
    function parsePoints(pointsString) {
      var list = trim(pointsString).split(DILIMITER_REG);
      var points = [];
      for (var i = 0; i < list.length; i += 2) {
        var x = parseFloat(list[i]);
        var y = parseFloat(list[i + 1]);
        points.push([x, y]);
      }
      return points;
    }
    var attributesMap = {
      "fill": "fill",
      "stroke": "stroke",
      "stroke-width": "lineWidth",
      "opacity": "opacity",
      "fill-opacity": "fillOpacity",
      "stroke-opacity": "strokeOpacity",
      "stroke-dasharray": "lineDash",
      "stroke-dashoffset": "lineDashOffset",
      "stroke-linecap": "lineCap",
      "stroke-linejoin": "lineJoin",
      "stroke-miterlimit": "miterLimit",
      "font-family": "fontFamily",
      "font-size": "fontSize",
      "font-style": "fontStyle",
      "font-weight": "fontWeight",
      "text-align": "textAlign",
      "alignment-baseline": "textBaseline"
    };
    function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
      var zrStyle = el.__inheritedStyle || {};
      var isTextEl = el.type === "text";
      if (xmlNode.nodeType === 1) {
        parseTransformAttribute(xmlNode, el);
        extend(zrStyle, parseStyleAttribute(xmlNode));
        if (!onlyInlineStyle) {
          for (var svgAttrName in attributesMap) {
            if (attributesMap.hasOwnProperty(svgAttrName)) {
              var attrValue = xmlNode.getAttribute(svgAttrName);
              if (attrValue != null) {
                zrStyle[attributesMap[svgAttrName]] = attrValue;
              }
            }
          }
        }
      }
      var elFillProp = isTextEl ? "textFill" : "fill";
      var elStrokeProp = isTextEl ? "textStroke" : "stroke";
      el.style = el.style || new Style();
      var elStyle = el.style;
      zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));
      zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));
      each(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(propName) {
        var elPropName = propName === "lineWidth" && isTextEl ? "textStrokeWidth" : propName;
        zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));
      });
      if (!zrStyle.textBaseline || zrStyle.textBaseline === "auto") {
        zrStyle.textBaseline = "alphabetic";
      }
      if (zrStyle.textBaseline === "alphabetic") {
        zrStyle.textBaseline = "bottom";
      }
      if (zrStyle.textAlign === "start") {
        zrStyle.textAlign = "left";
      }
      if (zrStyle.textAlign === "end") {
        zrStyle.textAlign = "right";
      }
      each(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function(propName) {
        zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);
      });
      if (zrStyle.lineDash) {
        el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);
      }
      if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== "none") {
        el[elStrokeProp] = true;
      }
      el.__inheritedStyle = zrStyle;
    }
    var urlRegex = /url\(\s*#(.*?)\)/;
    function getPaint(str, defs) {
      var urlMatch = defs && str && str.match(urlRegex);
      if (urlMatch) {
        var url = trim(urlMatch[1]);
        var def = defs[url];
        return def;
      }
      return str;
    }
    var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;
    function parseTransformAttribute(xmlNode, node) {
      var transform = xmlNode.getAttribute("transform");
      if (transform) {
        transform = transform.replace(/,/g, " ");
        var m = null;
        var transformOps = [];
        transform.replace(transformRegex, function(str, type2, value2) {
          transformOps.push(type2, value2);
        });
        for (var i = transformOps.length - 1; i > 0; i -= 2) {
          var value = transformOps[i];
          var type = transformOps[i - 1];
          m = m || matrix.create();
          switch (type) {
            case "translate":
              value = trim(value).split(DILIMITER_REG);
              matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);
              break;
            case "scale":
              value = trim(value).split(DILIMITER_REG);
              matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);
              break;
            case "rotate":
              value = trim(value).split(DILIMITER_REG);
              matrix.rotate(m, m, parseFloat(value[0]));
              break;
            case "skew":
              value = trim(value).split(DILIMITER_REG);
              console.warn("Skew transform is not supported yet");
              break;
            case "matrix":
              var value = trim(value).split(DILIMITER_REG);
              m[0] = parseFloat(value[0]);
              m[1] = parseFloat(value[1]);
              m[2] = parseFloat(value[2]);
              m[3] = parseFloat(value[3]);
              m[4] = parseFloat(value[4]);
              m[5] = parseFloat(value[5]);
              break;
          }
        }
        node.setLocalTransform(m);
      }
    }
    var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
    function parseStyleAttribute(xmlNode) {
      var style = xmlNode.getAttribute("style");
      var result = {};
      if (!style) {
        return result;
      }
      var styleList = {};
      styleRegex.lastIndex = 0;
      var styleRegResult;
      while ((styleRegResult = styleRegex.exec(style)) != null) {
        styleList[styleRegResult[1]] = styleRegResult[2];
      }
      for (var svgAttrName in attributesMap) {
        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
          result[attributesMap[svgAttrName]] = styleList[svgAttrName];
        }
      }
      return result;
    }
    function makeViewBoxTransform(viewBoxRect, width, height) {
      var scaleX = width / viewBoxRect.width;
      var scaleY = height / viewBoxRect.height;
      var scale = Math.min(scaleX, scaleY);
      var viewBoxScale = [scale, scale];
      var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];
      return {
        scale: viewBoxScale,
        position: viewBoxPosition
      };
    }
    function parseSVG(xml, opt) {
      var parser = new SVGParser();
      return parser.parse(xml, opt);
    }
    exports.parseXML = parseXML;
    exports.makeViewBoxTransform = makeViewBoxTransform;
    exports.parseSVG = parseSVG;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/mapDataStorage.js
var require_mapDataStorage = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/mapDataStorage.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var isString = _util.isString;
    var isArray = _util.isArray;
    var each = _util.each;
    var assert = _util.assert;
    var _parseSVG = require_parseSVG();
    var parseXML = _parseSVG.parseXML;
    var storage = createHashMap();
    var _default = {
      // The format of record: see `echarts.registerMap`.
      // Compatible with previous `echarts.registerMap`.
      registerMap: function(mapName, rawGeoJson, rawSpecialAreas) {
        var records;
        if (isArray(rawGeoJson)) {
          records = rawGeoJson;
        } else if (rawGeoJson.svg) {
          records = [{
            type: "svg",
            source: rawGeoJson.svg,
            specialAreas: rawGeoJson.specialAreas
          }];
        } else {
          if (rawGeoJson.geoJson && !rawGeoJson.features) {
            rawSpecialAreas = rawGeoJson.specialAreas;
            rawGeoJson = rawGeoJson.geoJson;
          }
          records = [{
            type: "geoJSON",
            source: rawGeoJson,
            specialAreas: rawSpecialAreas
          }];
        }
        each(records, function(record) {
          var type = record.type;
          type === "geoJson" && (type = record.type = "geoJSON");
          var parse = parsers[type];
          parse(record);
        });
        return storage.set(mapName, records);
      },
      retrieveMap: function(mapName) {
        return storage.get(mapName);
      }
    };
    var parsers = {
      geoJSON: function(record) {
        var source = record.source;
        record.geoJSON = !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
      },
      // Only perform parse to XML object here, which might be time
      // consiming for large SVG.
      // Although convert XML to zrender element is also time consiming,
      // if we do it here, the clone of zrender elements has to be
      // required. So we do it once for each geo instance, util real
      // performance issues call for optimizing it.
      svg: function(record) {
        record.svgXML = parseXML(record.source);
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/DataDiffer.js
var require_DataDiffer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/DataDiffer.js"(exports, module) {
    function defaultKeyGetter(item) {
      return item;
    }
    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
      this._old = oldArr;
      this._new = newArr;
      this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
      this._newKeyGetter = newKeyGetter || defaultKeyGetter;
      this.context = context;
    }
    DataDiffer.prototype = {
      constructor: DataDiffer,
      /**
       * Callback function when add a data
       */
      add: function(func) {
        this._add = func;
        return this;
      },
      /**
       * Callback function when update a data
       */
      update: function(func) {
        this._update = func;
        return this;
      },
      /**
       * Callback function when remove a data
       */
      remove: function(func) {
        this._remove = func;
        return this;
      },
      execute: function() {
        var oldArr = this._old;
        var newArr = this._new;
        var oldDataIndexMap = {};
        var newDataIndexMap = {};
        var oldDataKeyArr = [];
        var newDataKeyArr = [];
        var i;
        initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter", this);
        initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter", this);
        for (i = 0; i < oldArr.length; i++) {
          var key = oldDataKeyArr[i];
          var idx = newDataIndexMap[key];
          if (idx != null) {
            var len = idx.length;
            if (len) {
              len === 1 && (newDataIndexMap[key] = null);
              idx = idx.shift();
            } else {
              newDataIndexMap[key] = null;
            }
            this._update && this._update(idx, i);
          } else {
            this._remove && this._remove(i);
          }
        }
        for (var i = 0; i < newDataKeyArr.length; i++) {
          var key = newDataKeyArr[i];
          if (newDataIndexMap.hasOwnProperty(key)) {
            var idx = newDataIndexMap[key];
            if (idx == null) {
              continue;
            }
            if (!idx.length) {
              this._add && this._add(idx);
            } else {
              for (var j = 0, len = idx.length; j < len; j++) {
                this._add && this._add(idx[j]);
              }
            }
          }
        }
      }
    };
    function initIndexMap(arr, map, keyArr, keyGetterName, dataDiffer) {
      for (var i = 0; i < arr.length; i++) {
        var key = "_ec_" + dataDiffer[keyGetterName](arr[i], i);
        var existence = map[key];
        if (existence == null) {
          keyArr.push(key);
          map[key] = i;
        } else {
          if (!existence.length) {
            map[key] = existence = [existence];
          }
          existence.push(i);
        }
      }
    }
    var _default = DataDiffer;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/dimensionHelper.js
var require_dimensionHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/dimensionHelper.js"(exports) {
    var _util = require_util();
    var each = _util.each;
    var createHashMap = _util.createHashMap;
    var assert = _util.assert;
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var OTHER_DIMENSIONS = createHashMap(["tooltip", "label", "itemName", "itemId", "seriesName"]);
    function summarizeDimensions(data) {
      var summary = {};
      var encode = summary.encode = {};
      var notExtraCoordDimMap = createHashMap();
      var defaultedLabel = [];
      var defaultedTooltip = [];
      var userOutput = summary.userOutput = {
        dimensionNames: data.dimensions.slice(),
        encode: {}
      };
      each(data.dimensions, function(dimName) {
        var dimItem = data.getDimensionInfo(dimName);
        var coordDim = dimItem.coordDim;
        if (coordDim) {
          var coordDimIndex = dimItem.coordDimIndex;
          getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
          if (!dimItem.isExtraCoord) {
            notExtraCoordDimMap.set(coordDim, 1);
            if (mayLabelDimType(dimItem.type)) {
              defaultedLabel[0] = dimName;
            }
            getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index;
          }
          if (dimItem.defaultTooltip) {
            defaultedTooltip.push(dimName);
          }
        }
        OTHER_DIMENSIONS.each(function(v, otherDim) {
          var encodeArr = getOrCreateEncodeArr(encode, otherDim);
          var dimIndex = dimItem.otherDims[otherDim];
          if (dimIndex != null && dimIndex !== false) {
            encodeArr[dimIndex] = dimItem.name;
          }
        });
      });
      var dataDimsOnCoord = [];
      var encodeFirstDimNotExtra = {};
      notExtraCoordDimMap.each(function(v, coordDim) {
        var dimArr = encode[coordDim];
        encodeFirstDimNotExtra[coordDim] = dimArr[0];
        dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
      });
      summary.dataDimsOnCoord = dataDimsOnCoord;
      summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
      var encodeLabel = encode.label;
      if (encodeLabel && encodeLabel.length) {
        defaultedLabel = encodeLabel.slice();
      }
      var encodeTooltip = encode.tooltip;
      if (encodeTooltip && encodeTooltip.length) {
        defaultedTooltip = encodeTooltip.slice();
      } else if (!defaultedTooltip.length) {
        defaultedTooltip = defaultedLabel.slice();
      }
      encode.defaultedLabel = defaultedLabel;
      encode.defaultedTooltip = defaultedTooltip;
      return summary;
    }
    function getOrCreateEncodeArr(encode, dim) {
      if (!encode.hasOwnProperty(dim)) {
        encode[dim] = [];
      }
      return encode[dim];
    }
    function getDimensionTypeByAxis(axisType) {
      return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
    }
    function mayLabelDimType(dimType) {
      return !(dimType === "ordinal" || dimType === "time");
    }
    exports.OTHER_DIMENSIONS = OTHER_DIMENSIONS;
    exports.summarizeDimensions = summarizeDimensions;
    exports.getDimensionTypeByAxis = getDimensionTypeByAxis;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/DataDimensionInfo.js
var require_DataDimensionInfo = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/DataDimensionInfo.js"(exports, module) {
    var zrUtil = require_util();
    function DataDimensionInfo(opt) {
      if (opt != null) {
        zrUtil.extend(this, opt);
      }
      this.otherDims = {};
    }
    var _default = DataDimensionInfo;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/List.js
var require_List = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/List.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var Model = require_Model();
    var DataDiffer = require_DataDiffer();
    var Source = require_Source();
    var _dataProvider = require_dataProvider();
    var defaultDimValueGetters = _dataProvider.defaultDimValueGetters;
    var DefaultDataProvider = _dataProvider.DefaultDataProvider;
    var _dimensionHelper = require_dimensionHelper();
    var summarizeDimensions = _dimensionHelper.summarizeDimensions;
    var DataDimensionInfo = require_DataDimensionInfo();
    var isObject = zrUtil.isObject;
    var UNDEFINED = "undefined";
    var INDEX_NOT_FOUND = -1;
    var ID_PREFIX = "e\0\0";
    var dataCtors = {
      "float": typeof Float64Array === UNDEFINED ? Array : Float64Array,
      "int": typeof Int32Array === UNDEFINED ? Array : Int32Array,
      // Ordinal data type can be string or int
      "ordinal": Array,
      "number": Array,
      "time": Array
    };
    var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
    var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
    var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
    function getIndicesCtor(list) {
      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
    }
    function cloneChunk(originalChunk) {
      var Ctor = originalChunk.constructor;
      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
    }
    var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"];
    var CLONE_PROPERTIES = ["_extent", "_approximateExtent", "_rawExtent"];
    function transferProperties(target, source) {
      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
        if (source.hasOwnProperty(propName)) {
          target[propName] = source[propName];
        }
      });
      target.__wrappedMethods = source.__wrappedMethods;
      zrUtil.each(CLONE_PROPERTIES, function(propName) {
        target[propName] = zrUtil.clone(source[propName]);
      });
      target._calculationInfo = zrUtil.extend(source._calculationInfo);
    }
    var List = function(dimensions, hostModel) {
      dimensions = dimensions || ["x", "y"];
      var dimensionInfos = {};
      var dimensionNames = [];
      var invertedIndicesMap = {};
      for (var i = 0; i < dimensions.length; i++) {
        var dimensionInfo = dimensions[i];
        if (zrUtil.isString(dimensionInfo)) {
          dimensionInfo = new DataDimensionInfo({
            name: dimensionInfo
          });
        } else if (!(dimensionInfo instanceof DataDimensionInfo)) {
          dimensionInfo = new DataDimensionInfo(dimensionInfo);
        }
        var dimensionName = dimensionInfo.name;
        dimensionInfo.type = dimensionInfo.type || "float";
        if (!dimensionInfo.coordDim) {
          dimensionInfo.coordDim = dimensionName;
          dimensionInfo.coordDimIndex = 0;
        }
        dimensionInfo.otherDims = dimensionInfo.otherDims || {};
        dimensionNames.push(dimensionName);
        dimensionInfos[dimensionName] = dimensionInfo;
        dimensionInfo.index = i;
        if (dimensionInfo.createInvertedIndices) {
          invertedIndicesMap[dimensionName] = [];
        }
      }
      this.dimensions = dimensionNames;
      this._dimensionInfos = dimensionInfos;
      this.hostModel = hostModel;
      this.dataType;
      this._indices = null;
      this._count = 0;
      this._rawCount = 0;
      this._storage = {};
      this._nameList = [];
      this._idList = [];
      this._optionModels = [];
      this._visual = {};
      this._layout = {};
      this._itemVisuals = [];
      this.hasItemVisual = {};
      this._itemLayouts = [];
      this._graphicEls = [];
      this._chunkSize = 1e5;
      this._chunkCount = 0;
      this._rawData;
      this._rawExtent = {};
      this._extent = {};
      this._approximateExtent = {};
      this._dimensionsSummary = summarizeDimensions(this);
      this._invertedIndicesMap = invertedIndicesMap;
      this._calculationInfo = {};
      this.userOutput = this._dimensionsSummary.userOutput;
    };
    var listProto = List.prototype;
    listProto.type = "list";
    listProto.hasItemOption = true;
    listProto.getDimension = function(dim) {
      if (typeof dim === "number" || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {
        dim = this.dimensions[dim];
      }
      return dim;
    };
    listProto.getDimensionInfo = function(dim) {
      return this._dimensionInfos[this.getDimension(dim)];
    };
    listProto.getDimensionsOnCoord = function() {
      return this._dimensionsSummary.dataDimsOnCoord.slice();
    };
    listProto.mapDimension = function(coordDim, idx) {
      var dimensionsSummary = this._dimensionsSummary;
      if (idx == null) {
        return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
      }
      var dims = dimensionsSummary.encode[coordDim];
      return idx === true ? (dims || []).slice() : dims && dims[idx];
    };
    listProto.initData = function(data, nameList, dimValueGetter) {
      var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);
      if (notProvider) {
        data = new DefaultDataProvider(data, this.dimensions.length);
      }
      this._rawData = data;
      this._storage = {};
      this._indices = null;
      this._nameList = nameList || [];
      this._idList = [];
      this._nameRepeatCount = {};
      if (!dimValueGetter) {
        this.hasItemOption = false;
      }
      this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat];
      this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;
      this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;
      this._rawExtent = {};
      this._initDataFromProvider(0, data.count());
      if (data.pure) {
        this.hasItemOption = false;
      }
    };
    listProto.getProvider = function() {
      return this._rawData;
    };
    listProto.appendData = function(data) {
      var rawData = this._rawData;
      var start = this.count();
      rawData.appendData(data);
      var end = rawData.count();
      if (!rawData.persistent) {
        end += start;
      }
      this._initDataFromProvider(start, end);
    };
    listProto.appendValues = function(values, names) {
      var chunkSize = this._chunkSize;
      var storage = this._storage;
      var dimensions = this.dimensions;
      var dimLen = dimensions.length;
      var rawExtent = this._rawExtent;
      var start = this.count();
      var end = start + Math.max(values.length, names ? names.length : 0);
      var originalChunkCount = this._chunkCount;
      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];
        if (!rawExtent[dim]) {
          rawExtent[dim] = getInitialExtent();
        }
        if (!storage[dim]) {
          storage[dim] = [];
        }
        prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);
        this._chunkCount = storage[dim].length;
      }
      var emptyDataItem = new Array(dimLen);
      for (var idx = start; idx < end; idx++) {
        var sourceIdx = idx - start;
        var chunkIndex = Math.floor(idx / chunkSize);
        var chunkOffset = idx % chunkSize;
        for (var k = 0; k < dimLen; k++) {
          var dim = dimensions[k];
          var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);
          storage[dim][chunkIndex][chunkOffset] = val;
          var dimRawExtent = rawExtent[dim];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
        if (names) {
          this._nameList[idx] = names[sourceIdx];
        }
      }
      this._rawCount = this._count = end;
      this._extent = {};
      prepareInvertedIndex(this);
    };
    listProto._initDataFromProvider = function(start, end) {
      if (start >= end) {
        return;
      }
      var chunkSize = this._chunkSize;
      var rawData = this._rawData;
      var storage = this._storage;
      var dimensions = this.dimensions;
      var dimLen = dimensions.length;
      var dimensionInfoMap = this._dimensionInfos;
      var nameList = this._nameList;
      var idList = this._idList;
      var rawExtent = this._rawExtent;
      var nameRepeatCount = this._nameRepeatCount = {};
      var nameDimIdx;
      var originalChunkCount = this._chunkCount;
      for (var i = 0; i < dimLen; i++) {
        var dim = dimensions[i];
        if (!rawExtent[dim]) {
          rawExtent[dim] = getInitialExtent();
        }
        var dimInfo = dimensionInfoMap[dim];
        if (dimInfo.otherDims.itemName === 0) {
          nameDimIdx = this._nameDimIdx = i;
        }
        if (dimInfo.otherDims.itemId === 0) {
          this._idDimIdx = i;
        }
        if (!storage[dim]) {
          storage[dim] = [];
        }
        prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);
        this._chunkCount = storage[dim].length;
      }
      var dataItem = new Array(dimLen);
      for (var idx = start; idx < end; idx++) {
        dataItem = rawData.getItem(idx, dataItem);
        var chunkIndex = Math.floor(idx / chunkSize);
        var chunkOffset = idx % chunkSize;
        for (var k = 0; k < dimLen; k++) {
          var dim = dimensions[k];
          var dimStorage = storage[dim][chunkIndex];
          var val = this._dimValueGetter(dataItem, dim, idx, k);
          dimStorage[chunkOffset] = val;
          var dimRawExtent = rawExtent[dim];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
        if (!rawData.pure) {
          var name2 = nameList[idx];
          if (dataItem && name2 == null) {
            if (dataItem.name != null) {
              nameList[idx] = name2 = dataItem.name;
            } else if (nameDimIdx != null) {
              var nameDim = dimensions[nameDimIdx];
              var nameDimChunk = storage[nameDim][chunkIndex];
              if (nameDimChunk) {
                name2 = nameDimChunk[chunkOffset];
                var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;
                if (ordinalMeta && ordinalMeta.categories.length) {
                  name2 = ordinalMeta.categories[name2];
                }
              }
            }
          }
          var id = dataItem == null ? null : dataItem.id;
          if (id == null && name2 != null) {
            nameRepeatCount[name2] = nameRepeatCount[name2] || 0;
            id = name2;
            if (nameRepeatCount[name2] > 0) {
              id += "__ec__" + nameRepeatCount[name2];
            }
            nameRepeatCount[name2]++;
          }
          id != null && (idList[idx] = id);
        }
      }
      if (!rawData.persistent && rawData.clean) {
        rawData.clean();
      }
      this._rawCount = this._count = end;
      this._extent = {};
      prepareInvertedIndex(this);
    };
    function prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {
      var DataCtor = dataCtors[dimInfo.type];
      var lastChunkIndex = chunkCount - 1;
      var dim = dimInfo.name;
      var resizeChunkArray = storage[dim][lastChunkIndex];
      if (resizeChunkArray && resizeChunkArray.length < chunkSize) {
        var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize));
        for (var j = 0; j < resizeChunkArray.length; j++) {
          newStore[j] = resizeChunkArray[j];
        }
        storage[dim][lastChunkIndex] = newStore;
      }
      for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {
        storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));
      }
    }
    function prepareInvertedIndex(list) {
      var invertedIndicesMap = list._invertedIndicesMap;
      zrUtil.each(invertedIndicesMap, function(invertedIndices, dim) {
        var dimInfo = list._dimensionInfos[dim];
        var ordinalMeta = dimInfo.ordinalMeta;
        if (ordinalMeta) {
          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
          for (var i = 0; i < invertedIndices.length; i++) {
            invertedIndices[i] = INDEX_NOT_FOUND;
          }
          for (var i = 0; i < list._count; i++) {
            invertedIndices[list.get(dim, i)] = i;
          }
        }
      });
    }
    function getRawValueFromStore(list, dimIndex, rawIndex) {
      var val;
      if (dimIndex != null) {
        var chunkSize = list._chunkSize;
        var chunkIndex = Math.floor(rawIndex / chunkSize);
        var chunkOffset = rawIndex % chunkSize;
        var dim = list.dimensions[dimIndex];
        var chunk = list._storage[dim][chunkIndex];
        if (chunk) {
          val = chunk[chunkOffset];
          var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;
          if (ordinalMeta && ordinalMeta.categories.length) {
            val = ordinalMeta.categories[val];
          }
        }
      }
      return val;
    }
    listProto.count = function() {
      return this._count;
    };
    listProto.getIndices = function() {
      var newIndices;
      var indices = this._indices;
      if (indices) {
        var Ctor = indices.constructor;
        var thisCount = this._count;
        if (Ctor === Array) {
          newIndices = new Ctor(thisCount);
          for (var i = 0; i < thisCount; i++) {
            newIndices[i] = indices[i];
          }
        } else {
          newIndices = new Ctor(indices.buffer, 0, thisCount);
        }
      } else {
        var Ctor = getIndicesCtor(this);
        var newIndices = new Ctor(this.count());
        for (var i = 0; i < newIndices.length; i++) {
          newIndices[i] = i;
        }
      }
      return newIndices;
    };
    listProto.get = function(dim, idx) {
      if (!(idx >= 0 && idx < this._count)) {
        return NaN;
      }
      var storage = this._storage;
      if (!storage[dim]) {
        return NaN;
      }
      idx = this.getRawIndex(idx);
      var chunkIndex = Math.floor(idx / this._chunkSize);
      var chunkOffset = idx % this._chunkSize;
      var chunkStore = storage[dim][chunkIndex];
      var value = chunkStore[chunkOffset];
      return value;
    };
    listProto.getByRawIndex = function(dim, rawIdx) {
      if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
        return NaN;
      }
      var dimStore = this._storage[dim];
      if (!dimStore) {
        return NaN;
      }
      var chunkIndex = Math.floor(rawIdx / this._chunkSize);
      var chunkOffset = rawIdx % this._chunkSize;
      var chunkStore = dimStore[chunkIndex];
      return chunkStore[chunkOffset];
    };
    listProto._getFast = function(dim, rawIdx) {
      var chunkIndex = Math.floor(rawIdx / this._chunkSize);
      var chunkOffset = rawIdx % this._chunkSize;
      var chunkStore = this._storage[dim][chunkIndex];
      return chunkStore[chunkOffset];
    };
    listProto.getValues = function(dimensions, idx) {
      var values = [];
      if (!zrUtil.isArray(dimensions)) {
        idx = dimensions;
        dimensions = this.dimensions;
      }
      for (var i = 0, len = dimensions.length; i < len; i++) {
        values.push(this.get(
          dimensions[i],
          idx
          /*, stack */
        ));
      }
      return values;
    };
    listProto.hasValue = function(idx) {
      var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;
      for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {
        if (isNaN(this.get(dataDimsOnCoord[i], idx))) {
          return false;
        }
      }
      return true;
    };
    listProto.getDataExtent = function(dim) {
      dim = this.getDimension(dim);
      var dimData = this._storage[dim];
      var initialExtent = getInitialExtent();
      if (!dimData) {
        return initialExtent;
      }
      var currEnd = this.count();
      var useRaw = !this._indices;
      var dimExtent;
      if (useRaw) {
        return this._rawExtent[dim].slice();
      }
      dimExtent = this._extent[dim];
      if (dimExtent) {
        return dimExtent.slice();
      }
      dimExtent = initialExtent;
      var min = dimExtent[0];
      var max = dimExtent[1];
      for (var i = 0; i < currEnd; i++) {
        var value = this._getFast(dim, this.getRawIndex(i));
        value < min && (min = value);
        value > max && (max = value);
      }
      dimExtent = [min, max];
      this._extent[dim] = dimExtent;
      return dimExtent;
    };
    listProto.getApproximateExtent = function(dim) {
      dim = this.getDimension(dim);
      return this._approximateExtent[dim] || this.getDataExtent(
        dim
        /*, stack */
      );
    };
    listProto.setApproximateExtent = function(extent, dim) {
      dim = this.getDimension(dim);
      this._approximateExtent[dim] = extent.slice();
    };
    listProto.getCalculationInfo = function(key) {
      return this._calculationInfo[key];
    };
    listProto.setCalculationInfo = function(key, value) {
      isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
    };
    listProto.getSum = function(dim) {
      var dimData = this._storage[dim];
      var sum = 0;
      if (dimData) {
        for (var i = 0, len = this.count(); i < len; i++) {
          var value = this.get(
            dim,
            i
            /*, stack */
          );
          if (!isNaN(value)) {
            sum += value;
          }
        }
      }
      return sum;
    };
    listProto.getMedian = function(dim) {
      var dimDataArray = [];
      this.each(dim, function(val, idx) {
        if (!isNaN(val)) {
          dimDataArray.push(val);
        }
      });
      var sortedDimDataArray = [].concat(dimDataArray).sort(function(a, b) {
        return a - b;
      });
      var len = this.count();
      return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
    };
    listProto.rawIndexOf = function(dim, value) {
      var invertedIndices = dim && this._invertedIndicesMap[dim];
      var rawIndex = invertedIndices[value];
      if (rawIndex == null || isNaN(rawIndex)) {
        return INDEX_NOT_FOUND;
      }
      return rawIndex;
    };
    listProto.indexOfName = function(name2) {
      for (var i = 0, len = this.count(); i < len; i++) {
        if (this.getName(i) === name2) {
          return i;
        }
      }
      return -1;
    };
    listProto.indexOfRawIndex = function(rawIndex) {
      if (rawIndex >= this._rawCount || rawIndex < 0) {
        return -1;
      }
      if (!this._indices) {
        return rawIndex;
      }
      var indices = this._indices;
      var rawDataIndex = indices[rawIndex];
      if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
        return rawIndex;
      }
      var left = 0;
      var right = this._count - 1;
      while (left <= right) {
        var mid = (left + right) / 2 | 0;
        if (indices[mid] < rawIndex) {
          left = mid + 1;
        } else if (indices[mid] > rawIndex) {
          right = mid - 1;
        } else {
          return mid;
        }
      }
      return -1;
    };
    listProto.indicesOfNearest = function(dim, value, maxDistance) {
      var storage = this._storage;
      var dimData = storage[dim];
      var nearestIndices = [];
      if (!dimData) {
        return nearestIndices;
      }
      if (maxDistance == null) {
        maxDistance = Infinity;
      }
      var minDist = Infinity;
      var minDiff = -1;
      var nearestIndicesLen = 0;
      for (var i = 0, len = this.count(); i < len; i++) {
        var diff = value - this.get(dim, i);
        var dist = Math.abs(diff);
        if (dist <= maxDistance) {
          if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
            minDist = dist;
            minDiff = diff;
            nearestIndicesLen = 0;
          }
          if (diff === minDiff) {
            nearestIndices[nearestIndicesLen++] = i;
          }
        }
      }
      nearestIndices.length = nearestIndicesLen;
      return nearestIndices;
    };
    listProto.getRawIndex = getRawIndexWithoutIndices;
    function getRawIndexWithoutIndices(idx) {
      return idx;
    }
    function getRawIndexWithIndices(idx) {
      if (idx < this._count && idx >= 0) {
        return this._indices[idx];
      }
      return -1;
    }
    listProto.getRawDataItem = function(idx) {
      if (!this._rawData.persistent) {
        var val = [];
        for (var i = 0; i < this.dimensions.length; i++) {
          var dim = this.dimensions[i];
          val.push(this.get(dim, idx));
        }
        return val;
      } else {
        return this._rawData.getItem(this.getRawIndex(idx));
      }
    };
    listProto.getName = function(idx) {
      var rawIndex = this.getRawIndex(idx);
      return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || "";
    };
    listProto.getId = function(idx) {
      return getId(this, this.getRawIndex(idx));
    };
    function getId(list, rawIndex) {
      var id = list._idList[rawIndex];
      if (id == null) {
        id = getRawValueFromStore(list, list._idDimIdx, rawIndex);
      }
      if (id == null) {
        id = ID_PREFIX + rawIndex;
      }
      return id;
    }
    function normalizeDimensions(dimensions) {
      if (!zrUtil.isArray(dimensions)) {
        dimensions = [dimensions];
      }
      return dimensions;
    }
    listProto.each = function(dims, cb, context, contextCompat) {
      "use strict";
      if (!this._count) {
        return;
      }
      if (typeof dims === "function") {
        contextCompat = context;
        context = cb;
        cb = dims;
        dims = [];
      }
      context = context || contextCompat || this;
      dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);
      var dimSize = dims.length;
      for (var i = 0; i < this.count(); i++) {
        switch (dimSize) {
          case 0:
            cb.call(context, i);
            break;
          case 1:
            cb.call(context, this.get(dims[0], i), i);
            break;
          case 2:
            cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);
            break;
          default:
            var k = 0;
            var value = [];
            for (; k < dimSize; k++) {
              value[k] = this.get(dims[k], i);
            }
            value[k] = i;
            cb.apply(context, value);
        }
      }
    };
    listProto.filterSelf = function(dimensions, cb, context, contextCompat) {
      "use strict";
      if (!this._count) {
        return;
      }
      if (typeof dimensions === "function") {
        contextCompat = context;
        context = cb;
        cb = dimensions;
        dimensions = [];
      }
      context = context || contextCompat || this;
      dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
      var count = this.count();
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(count);
      var value = [];
      var dimSize = dimensions.length;
      var offset = 0;
      var dim0 = dimensions[0];
      for (var i = 0; i < count; i++) {
        var keep;
        var rawIdx = this.getRawIndex(i);
        if (dimSize === 0) {
          keep = cb.call(context, i);
        } else if (dimSize === 1) {
          var val = this._getFast(dim0, rawIdx);
          keep = cb.call(context, val, i);
        } else {
          for (var k = 0; k < dimSize; k++) {
            value[k] = this._getFast(dim0, rawIdx);
          }
          value[k] = i;
          keep = cb.apply(context, value);
        }
        if (keep) {
          newIndices[offset++] = rawIdx;
        }
      }
      if (offset < count) {
        this._indices = newIndices;
      }
      this._count = offset;
      this._extent = {};
      this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return this;
    };
    listProto.selectRange = function(range) {
      "use strict";
      if (!this._count) {
        return;
      }
      var dimensions = [];
      for (var dim in range) {
        if (range.hasOwnProperty(dim)) {
          dimensions.push(dim);
        }
      }
      var dimSize = dimensions.length;
      if (!dimSize) {
        return;
      }
      var originalCount = this.count();
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(originalCount);
      var offset = 0;
      var dim0 = dimensions[0];
      var min = range[dim0][0];
      var max = range[dim0][1];
      var quickFinished = false;
      if (!this._indices) {
        var idx = 0;
        if (dimSize === 1) {
          var dimStorage = this._storage[dimensions[0]];
          for (var k = 0; k < this._chunkCount; k++) {
            var chunkStorage = dimStorage[k];
            var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);
            for (var i = 0; i < len; i++) {
              var val = chunkStorage[i];
              if (val >= min && val <= max || isNaN(val)) {
                newIndices[offset++] = idx;
              }
              idx++;
            }
          }
          quickFinished = true;
        } else if (dimSize === 2) {
          var dimStorage = this._storage[dim0];
          var dimStorage2 = this._storage[dimensions[1]];
          var min2 = range[dimensions[1]][0];
          var max2 = range[dimensions[1]][1];
          for (var k = 0; k < this._chunkCount; k++) {
            var chunkStorage = dimStorage[k];
            var chunkStorage2 = dimStorage2[k];
            var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);
            for (var i = 0; i < len; i++) {
              var val = chunkStorage[i];
              var val2 = chunkStorage2[i];
              if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
                newIndices[offset++] = idx;
              }
              idx++;
            }
          }
          quickFinished = true;
        }
      }
      if (!quickFinished) {
        if (dimSize === 1) {
          for (var i = 0; i < originalCount; i++) {
            var rawIndex = this.getRawIndex(i);
            var val = this._getFast(dim0, rawIndex);
            if (val >= min && val <= max || isNaN(val)) {
              newIndices[offset++] = rawIndex;
            }
          }
        } else {
          for (var i = 0; i < originalCount; i++) {
            var keep = true;
            var rawIndex = this.getRawIndex(i);
            for (var k = 0; k < dimSize; k++) {
              var dimk = dimensions[k];
              var val = this._getFast(dim, rawIndex);
              if (val < range[dimk][0] || val > range[dimk][1]) {
                keep = false;
              }
            }
            if (keep) {
              newIndices[offset++] = this.getRawIndex(i);
            }
          }
        }
      }
      if (offset < originalCount) {
        this._indices = newIndices;
      }
      this._count = offset;
      this._extent = {};
      this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return this;
    };
    listProto.mapArray = function(dimensions, cb, context, contextCompat) {
      "use strict";
      if (typeof dimensions === "function") {
        contextCompat = context;
        context = cb;
        cb = dimensions;
        dimensions = [];
      }
      context = context || contextCompat || this;
      var result = [];
      this.each(dimensions, function() {
        result.push(cb && cb.apply(this, arguments));
      }, context);
      return result;
    };
    function cloneListForMapAndSample(original, excludeDimensions) {
      var allDimensions = original.dimensions;
      var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);
      transferProperties(list, original);
      var storage = list._storage = {};
      var originalStorage = original._storage;
      for (var i = 0; i < allDimensions.length; i++) {
        var dim = allDimensions[i];
        if (originalStorage[dim]) {
          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
            storage[dim] = cloneDimStore(originalStorage[dim]);
            list._rawExtent[dim] = getInitialExtent();
            list._extent[dim] = null;
          } else {
            storage[dim] = originalStorage[dim];
          }
        }
      }
      return list;
    }
    function cloneDimStore(originalDimStore) {
      var newDimStore = new Array(originalDimStore.length);
      for (var j = 0; j < originalDimStore.length; j++) {
        newDimStore[j] = cloneChunk(originalDimStore[j]);
      }
      return newDimStore;
    }
    function getInitialExtent() {
      return [Infinity, -Infinity];
    }
    listProto.map = function(dimensions, cb, context, contextCompat) {
      "use strict";
      context = context || contextCompat || this;
      dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
      var list = cloneListForMapAndSample(this, dimensions);
      list._indices = this._indices;
      list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      var storage = list._storage;
      var tmpRetValue = [];
      var chunkSize = this._chunkSize;
      var dimSize = dimensions.length;
      var dataCount = this.count();
      var values = [];
      var rawExtent = list._rawExtent;
      for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
        for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {
          values[dimIndex] = this.get(
            dimensions[dimIndex],
            dataIndex
            /*, stack */
          );
        }
        values[dimSize] = dataIndex;
        var retValue = cb && cb.apply(context, values);
        if (retValue != null) {
          if (typeof retValue !== "object") {
            tmpRetValue[0] = retValue;
            retValue = tmpRetValue;
          }
          var rawIndex = this.getRawIndex(dataIndex);
          var chunkIndex = Math.floor(rawIndex / chunkSize);
          var chunkOffset = rawIndex % chunkSize;
          for (var i = 0; i < retValue.length; i++) {
            var dim = dimensions[i];
            var val = retValue[i];
            var rawExtentOnDim = rawExtent[dim];
            var dimStore = storage[dim];
            if (dimStore) {
              dimStore[chunkIndex][chunkOffset] = val;
            }
            if (val < rawExtentOnDim[0]) {
              rawExtentOnDim[0] = val;
            }
            if (val > rawExtentOnDim[1]) {
              rawExtentOnDim[1] = val;
            }
          }
        }
      }
      return list;
    };
    listProto.downSample = function(dimension, rate, sampleValue, sampleIndex) {
      var list = cloneListForMapAndSample(this, [dimension]);
      var targetStorage = list._storage;
      var frameValues = [];
      var frameSize = Math.floor(1 / rate);
      var dimStore = targetStorage[dimension];
      var len = this.count();
      var chunkSize = this._chunkSize;
      var rawExtentOnDim = list._rawExtent[dimension];
      var newIndices = new (getIndicesCtor(this))(len);
      var offset = 0;
      for (var i = 0; i < len; i += frameSize) {
        if (frameSize > len - i) {
          frameSize = len - i;
          frameValues.length = frameSize;
        }
        for (var k = 0; k < frameSize; k++) {
          var dataIdx = this.getRawIndex(i + k);
          var originalChunkIndex = Math.floor(dataIdx / chunkSize);
          var originalChunkOffset = dataIdx % chunkSize;
          frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];
        }
        var value = sampleValue(frameValues);
        var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
        var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);
        var sampleChunkOffset = sampleFrameIdx % chunkSize;
        dimStore[sampleChunkIndex][sampleChunkOffset] = value;
        if (value < rawExtentOnDim[0]) {
          rawExtentOnDim[0] = value;
        }
        if (value > rawExtentOnDim[1]) {
          rawExtentOnDim[1] = value;
        }
        newIndices[offset++] = sampleFrameIdx;
      }
      list._count = offset;
      list._indices = newIndices;
      list.getRawIndex = getRawIndexWithIndices;
      return list;
    };
    listProto.getItemModel = function(idx) {
      var hostModel = this.hostModel;
      return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
    };
    listProto.diff = function(otherList) {
      var thisList = this;
      return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function(idx) {
        return getId(otherList, idx);
      }, function(idx) {
        return getId(thisList, idx);
      });
    };
    listProto.getVisual = function(key) {
      var visual = this._visual;
      return visual && visual[key];
    };
    listProto.setVisual = function(key, val) {
      if (isObject(key)) {
        for (var name2 in key) {
          if (key.hasOwnProperty(name2)) {
            this.setVisual(name2, key[name2]);
          }
        }
        return;
      }
      this._visual = this._visual || {};
      this._visual[key] = val;
    };
    listProto.setLayout = function(key, val) {
      if (isObject(key)) {
        for (var name2 in key) {
          if (key.hasOwnProperty(name2)) {
            this.setLayout(name2, key[name2]);
          }
        }
        return;
      }
      this._layout[key] = val;
    };
    listProto.getLayout = function(key) {
      return this._layout[key];
    };
    listProto.getItemLayout = function(idx) {
      return this._itemLayouts[idx];
    };
    listProto.setItemLayout = function(idx, layout, merge) {
      this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
    };
    listProto.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    };
    listProto.getItemVisual = function(idx, key, ignoreParent) {
      var itemVisual = this._itemVisuals[idx];
      var val = itemVisual && itemVisual[key];
      if (val == null && !ignoreParent) {
        return this.getVisual(key);
      }
      return val;
    };
    listProto.setItemVisual = function(idx, key, value) {
      var itemVisual = this._itemVisuals[idx] || {};
      var hasItemVisual = this.hasItemVisual;
      this._itemVisuals[idx] = itemVisual;
      if (isObject(key)) {
        for (var name2 in key) {
          if (key.hasOwnProperty(name2)) {
            itemVisual[name2] = key[name2];
            hasItemVisual[name2] = true;
          }
        }
        return;
      }
      itemVisual[key] = value;
      hasItemVisual[key] = true;
    };
    listProto.clearAllVisual = function() {
      this._visual = {};
      this._itemVisuals = [];
      this.hasItemVisual = {};
    };
    var setItemDataAndSeriesIndex = function(child) {
      child.seriesIndex = this.seriesIndex;
      child.dataIndex = this.dataIndex;
      child.dataType = this.dataType;
    };
    listProto.setItemGraphicEl = function(idx, el) {
      var hostModel = this.hostModel;
      if (el) {
        el.dataIndex = idx;
        el.dataType = this.dataType;
        el.seriesIndex = hostModel && hostModel.seriesIndex;
        if (el.type === "group") {
          el.traverse(setItemDataAndSeriesIndex, el);
        }
      }
      this._graphicEls[idx] = el;
    };
    listProto.getItemGraphicEl = function(idx) {
      return this._graphicEls[idx];
    };
    listProto.eachItemGraphicEl = function(cb, context) {
      zrUtil.each(this._graphicEls, function(el, idx) {
        if (el) {
          cb && cb.call(context, el, idx);
        }
      });
    };
    listProto.cloneShallow = function(list) {
      if (!list) {
        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
        list = new List(dimensionInfoList, this.hostModel);
      }
      list._storage = this._storage;
      transferProperties(list, this);
      if (this._indices) {
        var Ctor = this._indices.constructor;
        list._indices = new Ctor(this._indices);
      } else {
        list._indices = null;
      }
      list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
      return list;
    };
    listProto.wrapMethod = function(methodName, injectFunction) {
      var originalMethod = this[methodName];
      if (typeof originalMethod !== "function") {
        return;
      }
      this.__wrappedMethods = this.__wrappedMethods || [];
      this.__wrappedMethods.push(methodName);
      this[methodName] = function() {
        var res = originalMethod.apply(this, arguments);
        return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
      };
    };
    listProto.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"];
    listProto.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    var _default = List;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/completeDimensions.js
var require_completeDimensions = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/completeDimensions.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    var isString = _util.isString;
    var defaults = _util.defaults;
    var extend = _util.extend;
    var isObject = _util.isObject;
    var clone = _util.clone;
    var _model = require_model();
    var normalizeToArray = _model.normalizeToArray;
    var _sourceHelper = require_sourceHelper();
    var guessOrdinal = _sourceHelper.guessOrdinal;
    var BE_ORDINAL = _sourceHelper.BE_ORDINAL;
    var Source = require_Source();
    var _dimensionHelper = require_dimensionHelper();
    var OTHER_DIMENSIONS = _dimensionHelper.OTHER_DIMENSIONS;
    var DataDimensionInfo = require_DataDimensionInfo();
    function completeDimensions(sysDims, source, opt) {
      if (!Source.isInstance(source)) {
        source = Source.seriesDataToSource(source);
      }
      opt = opt || {};
      sysDims = (sysDims || []).slice();
      var dimsDef = (opt.dimsDef || []).slice();
      var dataDimNameMap = createHashMap();
      var coordDimNameMap = createHashMap();
      var result = [];
      var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount);
      for (var i = 0; i < dimCount; i++) {
        var dimDefItem = dimsDef[i] = extend({}, isObject(dimsDef[i]) ? dimsDef[i] : {
          name: dimsDef[i]
        });
        var userDimName = dimDefItem.name;
        var resultItem = result[i] = new DataDimensionInfo();
        if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
          resultItem.name = resultItem.displayName = userDimName;
          dataDimNameMap.set(userDimName, i);
        }
        dimDefItem.type != null && (resultItem.type = dimDefItem.type);
        dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
      }
      var encodeDef = opt.encodeDef;
      if (!encodeDef && opt.encodeDefaulter) {
        encodeDef = opt.encodeDefaulter(source, dimCount);
      }
      encodeDef = createHashMap(encodeDef);
      encodeDef.each(function(dataDims, coordDim2) {
        dataDims = normalizeToArray(dataDims).slice();
        if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
          encodeDef.set(coordDim2, false);
          return;
        }
        var validDataDims = encodeDef.set(coordDim2, []);
        each(dataDims, function(resultDimIdx2, idx) {
          isString(resultDimIdx2) && (resultDimIdx2 = dataDimNameMap.get(resultDimIdx2));
          if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
            validDataDims[idx] = resultDimIdx2;
            applyDim(result[resultDimIdx2], coordDim2, idx);
          }
        });
      });
      var availDimIdx = 0;
      each(sysDims, function(sysDimItem, sysDimIndex) {
        var coordDim2;
        var sysDimItem;
        var sysDimItemDimsDef;
        var sysDimItemOtherDims;
        if (isString(sysDimItem)) {
          coordDim2 = sysDimItem;
          sysDimItem = {};
        } else {
          coordDim2 = sysDimItem.name;
          var ordinalMeta = sysDimItem.ordinalMeta;
          sysDimItem.ordinalMeta = null;
          sysDimItem = clone(sysDimItem);
          sysDimItem.ordinalMeta = ordinalMeta;
          sysDimItemDimsDef = sysDimItem.dimsDef;
          sysDimItemOtherDims = sysDimItem.otherDims;
          sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
        }
        var dataDims = encodeDef.get(coordDim2);
        if (dataDims === false) {
          return;
        }
        var dataDims = normalizeToArray(dataDims);
        if (!dataDims.length) {
          for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
            while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
              availDimIdx++;
            }
            availDimIdx < result.length && dataDims.push(availDimIdx++);
          }
        }
        each(dataDims, function(resultDimIdx2, coordDimIndex) {
          var resultItem2 = result[resultDimIdx2];
          applyDim(defaults(resultItem2, sysDimItem), coordDim2, coordDimIndex);
          if (resultItem2.name == null && sysDimItemDimsDef) {
            var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
            !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
              name: sysDimItemDimsDefItem
            });
            resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
            resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
          }
          sysDimItemOtherDims && defaults(resultItem2.otherDims, sysDimItemOtherDims);
        });
      });
      function applyDim(resultItem2, coordDim2, coordDimIndex) {
        if (OTHER_DIMENSIONS.get(coordDim2) != null) {
          resultItem2.otherDims[coordDim2] = coordDimIndex;
        } else {
          resultItem2.coordDim = coordDim2;
          resultItem2.coordDimIndex = coordDimIndex;
          coordDimNameMap.set(coordDim2, true);
        }
      }
      var generateCoord = opt.generateCoord;
      var generateCoordCount = opt.generateCoordCount;
      var fromZero = generateCoordCount != null;
      generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
      var extra = generateCoord || "value";
      for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo();
        var coordDim = resultItem.coordDim;
        if (coordDim == null) {
          resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);
          resultItem.coordDimIndex = 0;
          if (!generateCoord || generateCoordCount <= 0) {
            resultItem.isExtraCoord = true;
          }
          generateCoordCount--;
        }
        resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));
        if (resultItem.type == null && (guessOrdinal(source, resultDimIdx, resultItem.name) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
          resultItem.type = "ordinal";
        }
      }
      return result;
    }
    function getDimCount(source, sysDims, dimsDef, optDimCount) {
      var dimCount = Math.max(source.dimensionsDetectCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
      each(sysDims, function(sysDimItem) {
        var sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
      });
      return dimCount;
    }
    function genName(name2, map, fromZero) {
      if (fromZero || map.get(name2) != null) {
        var i = 0;
        while (map.get(name2 + i) != null) {
          i++;
        }
        name2 += i;
      }
      map.set(name2, true);
      return name2;
    }
    var _default = completeDimensions;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/createDimensions.js
var require_createDimensions = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/createDimensions.js"(exports, module) {
    var completeDimensions = require_completeDimensions();
    function _default(source, opt) {
      opt = opt || {};
      return completeDimensions(opt.coordDimensions || [], source, {
        dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
        encodeDef: opt.encodeDefine || source.encodeDefine,
        dimCount: opt.dimensionsCount,
        encodeDefaulter: opt.encodeDefaulter,
        generateCoord: opt.generateCoord,
        generateCoordCount: opt.generateCoordCount
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/referHelper.js
var require_referHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/model/referHelper.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var retrieve = _util.retrieve;
    var each = _util.each;
    function CoordSysInfo(coordSysName) {
      this.coordSysName = coordSysName;
      this.coordSysDims = [];
      this.axisMap = createHashMap();
      this.categoryAxisMap = createHashMap();
      this.firstCategoryDimIndex = null;
    }
    function getCoordSysInfoBySeries(seriesModel) {
      var coordSysName = seriesModel.get("coordinateSystem");
      var result = new CoordSysInfo(coordSysName);
      var fetch = fetchers[coordSysName];
      if (fetch) {
        fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
        return result;
      }
    }
    var fetchers = {
      cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
        var xAxisModel = seriesModel.getReferringComponents("xAxis")[0];
        var yAxisModel = seriesModel.getReferringComponents("yAxis")[0];
        result.coordSysDims = ["x", "y"];
        axisMap.set("x", xAxisModel);
        axisMap.set("y", yAxisModel);
        if (isCategory(xAxisModel)) {
          categoryAxisMap.set("x", xAxisModel);
          result.firstCategoryDimIndex = 0;
        }
        if (isCategory(yAxisModel)) {
          categoryAxisMap.set("y", yAxisModel);
          result.firstCategoryDimIndex == null & (result.firstCategoryDimIndex = 1);
        }
      },
      singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
        var singleAxisModel = seriesModel.getReferringComponents("singleAxis")[0];
        result.coordSysDims = ["single"];
        axisMap.set("single", singleAxisModel);
        if (isCategory(singleAxisModel)) {
          categoryAxisMap.set("single", singleAxisModel);
          result.firstCategoryDimIndex = 0;
        }
      },
      polar: function(seriesModel, result, axisMap, categoryAxisMap) {
        var polarModel = seriesModel.getReferringComponents("polar")[0];
        var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
        var angleAxisModel = polarModel.findAxisModel("angleAxis");
        result.coordSysDims = ["radius", "angle"];
        axisMap.set("radius", radiusAxisModel);
        axisMap.set("angle", angleAxisModel);
        if (isCategory(radiusAxisModel)) {
          categoryAxisMap.set("radius", radiusAxisModel);
          result.firstCategoryDimIndex = 0;
        }
        if (isCategory(angleAxisModel)) {
          categoryAxisMap.set("angle", angleAxisModel);
          result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
        }
      },
      geo: function(seriesModel, result, axisMap, categoryAxisMap) {
        result.coordSysDims = ["lng", "lat"];
      },
      parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
        var ecModel = seriesModel.ecModel;
        var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
        var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
        each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
          var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
          var axisDim = coordSysDims[index];
          axisMap.set(axisDim, axisModel);
          if (isCategory(axisModel) && result.firstCategoryDimIndex == null) {
            categoryAxisMap.set(axisDim, axisModel);
            result.firstCategoryDimIndex = index;
          }
        });
      }
    };
    function isCategory(axisModel) {
      return axisModel.get("type") === "category";
    }
    exports.getCoordSysInfoBySeries = getCoordSysInfoBySeries;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/dataStackHelper.js
var require_dataStackHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/dataStackHelper.js"(exports) {
    var _util = require_util();
    var each = _util.each;
    var isString = _util.isString;
    function enableDataStack(seriesModel, dimensionInfoList, opt) {
      opt = opt || {};
      var byIndex = opt.byIndex;
      var stackedCoordDimension = opt.stackedCoordDimension;
      var mayStack = !!(seriesModel && seriesModel.get("stack"));
      var stackedByDimInfo;
      var stackedDimInfo;
      var stackResultDimension;
      var stackedOverDimension;
      each(dimensionInfoList, function(dimensionInfo, index) {
        if (isString(dimensionInfo)) {
          dimensionInfoList[index] = dimensionInfo = {
            name: dimensionInfo
          };
        }
        if (mayStack && !dimensionInfo.isExtraCoord) {
          if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
            stackedByDimInfo = dimensionInfo;
          }
          if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
            stackedDimInfo = dimensionInfo;
          }
        }
      });
      if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
        byIndex = true;
      }
      if (stackedDimInfo) {
        stackResultDimension = "__\0ecstackresult";
        stackedOverDimension = "__\0ecstackedover";
        if (stackedByDimInfo) {
          stackedByDimInfo.createInvertedIndices = true;
        }
        var stackedDimCoordDim = stackedDimInfo.coordDim;
        var stackedDimType = stackedDimInfo.type;
        var stackedDimCoordIndex = 0;
        each(dimensionInfoList, function(dimensionInfo) {
          if (dimensionInfo.coordDim === stackedDimCoordDim) {
            stackedDimCoordIndex++;
          }
        });
        dimensionInfoList.push({
          name: stackResultDimension,
          coordDim: stackedDimCoordDim,
          coordDimIndex: stackedDimCoordIndex,
          type: stackedDimType,
          isExtraCoord: true,
          isCalculationCoord: true
        });
        stackedDimCoordIndex++;
        dimensionInfoList.push({
          name: stackedOverDimension,
          // This dimension contains stack base (generally, 0), so do not set it as
          // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
          coordDim: stackedOverDimension,
          coordDimIndex: stackedDimCoordIndex,
          type: stackedDimType,
          isExtraCoord: true,
          isCalculationCoord: true
        });
      }
      return {
        stackedDimension: stackedDimInfo && stackedDimInfo.name,
        stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
        isStackedByIndex: byIndex,
        stackedOverDimension,
        stackResultDimension
      };
    }
    function isDimensionStacked(data, stackedDim) {
      return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
    }
    function getStackedDimension(data, targetDim) {
      return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
    }
    exports.enableDataStack = enableDataStack;
    exports.isDimensionStacked = isDimensionStacked;
    exports.getStackedDimension = getStackedDimension;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createListFromArray.js
var require_createListFromArray = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createListFromArray.js"(exports, module) {
    var zrUtil = require_util();
    var List = require_List();
    var createDimensions = require_createDimensions();
    var _sourceType = require_sourceType();
    var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
    var _dimensionHelper = require_dimensionHelper();
    var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
    var _model = require_model();
    var getDataItemValue = _model.getDataItemValue;
    var CoordinateSystem = require_CoordinateSystem();
    var _referHelper = require_referHelper();
    var getCoordSysInfoBySeries = _referHelper.getCoordSysInfoBySeries;
    var Source = require_Source();
    var _dataStackHelper = require_dataStackHelper();
    var enableDataStack = _dataStackHelper.enableDataStack;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForAxisCoordSys = _sourceHelper.makeSeriesEncodeForAxisCoordSys;
    function createListFromArray(source, seriesModel, opt) {
      opt = opt || {};
      if (!Source.isInstance(source)) {
        source = Source.seriesDataToSource(source);
      }
      var coordSysName = seriesModel.get("coordinateSystem");
      var registeredCoordSys = CoordinateSystem.get(coordSysName);
      var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
      var coordSysDimDefs;
      if (coordSysInfo) {
        coordSysDimDefs = zrUtil.map(coordSysInfo.coordSysDims, function(dim) {
          var dimInfo = {
            name: dim
          };
          var axisModel = coordSysInfo.axisMap.get(dim);
          if (axisModel) {
            var axisType = axisModel.get("type");
            dimInfo.type = getDimensionTypeByAxis(axisType);
          }
          return dimInfo;
        });
      }
      if (!coordSysDimDefs) {
        coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
      }
      var dimInfoList = createDimensions(source, {
        coordDimensions: coordSysDimDefs,
        generateCoord: opt.generateCoord,
        encodeDefaulter: opt.useEncodeDefaulter ? zrUtil.curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null
      });
      var firstCategoryDimIndex;
      var hasNameEncode;
      coordSysInfo && zrUtil.each(dimInfoList, function(dimInfo, dimIndex) {
        var coordDim = dimInfo.coordDim;
        var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
        if (categoryAxisModel) {
          if (firstCategoryDimIndex == null) {
            firstCategoryDimIndex = dimIndex;
          }
          dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
        }
        if (dimInfo.otherDims.itemName != null) {
          hasNameEncode = true;
        }
      });
      if (!hasNameEncode && firstCategoryDimIndex != null) {
        dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
      }
      var stackCalculationInfo = enableDataStack(seriesModel, dimInfoList);
      var list = new List(dimInfoList, seriesModel);
      list.setCalculationInfo(stackCalculationInfo);
      var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
        return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
      } : null;
      list.hasItemOption = false;
      list.initData(source, null, dimValueGetter);
      return list;
    }
    function isNeedCompleteOrdinalData(source) {
      if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        var sampleItem = firstDataNotNull(source.data || []);
        return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));
      }
    }
    function firstDataNotNull(data) {
      var i = 0;
      while (i < data.length && data[i] == null) {
        i++;
      }
      return data[i];
    }
    var _default = createListFromArray;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Scale.js
var require_Scale = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Scale.js"(exports, module) {
    var clazzUtil = require_clazz();
    function Scale(setting) {
      this._setting = setting || {};
      this._extent = [Infinity, -Infinity];
      this._interval = 0;
      this.init && this.init.apply(this, arguments);
    }
    Scale.prototype.parse = function(val) {
      return val;
    };
    Scale.prototype.getSetting = function(name2) {
      return this._setting[name2];
    };
    Scale.prototype.contain = function(val) {
      var extent = this._extent;
      return val >= extent[0] && val <= extent[1];
    };
    Scale.prototype.normalize = function(val) {
      var extent = this._extent;
      if (extent[1] === extent[0]) {
        return 0.5;
      }
      return (val - extent[0]) / (extent[1] - extent[0]);
    };
    Scale.prototype.scale = function(val) {
      var extent = this._extent;
      return val * (extent[1] - extent[0]) + extent[0];
    };
    Scale.prototype.unionExtent = function(other) {
      var extent = this._extent;
      other[0] < extent[0] && (extent[0] = other[0]);
      other[1] > extent[1] && (extent[1] = other[1]);
    };
    Scale.prototype.unionExtentFromData = function(data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    };
    Scale.prototype.getExtent = function() {
      return this._extent.slice();
    };
    Scale.prototype.setExtent = function(start, end) {
      var thisExtent = this._extent;
      if (!isNaN(start)) {
        thisExtent[0] = start;
      }
      if (!isNaN(end)) {
        thisExtent[1] = end;
      }
    };
    Scale.prototype.isBlank = function() {
      return this._isBlank;
    }, /**
     * When axis extent depends on data and no data exists,
     * axis ticks should not be drawn, which is named 'blank'.
     */
    Scale.prototype.setBlank = function(isBlank) {
      this._isBlank = isBlank;
    };
    Scale.prototype.getLabel = null;
    clazzUtil.enableClassExtend(Scale);
    clazzUtil.enableClassManagement(Scale, {
      registerWhenExtend: true
    });
    var _default = Scale;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/OrdinalMeta.js
var require_OrdinalMeta = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/OrdinalMeta.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var isObject = _util.isObject;
    var map = _util.map;
    function OrdinalMeta(opt) {
      this.categories = opt.categories || [];
      this._needCollect = opt.needCollect;
      this._deduplication = opt.deduplication;
      this._map;
    }
    OrdinalMeta.createByAxisModel = function(axisModel) {
      var option = axisModel.option;
      var data = option.data;
      var categories = data && map(data, getName);
      return new OrdinalMeta({
        categories,
        needCollect: !categories,
        // deduplication is default in axis.
        deduplication: option.dedplication !== false
      });
    };
    var proto = OrdinalMeta.prototype;
    proto.getOrdinal = function(category) {
      return getOrCreateMap(this).get(category);
    };
    proto.parseAndCollect = function(category) {
      var index;
      var needCollect = this._needCollect;
      if (typeof category !== "string" && !needCollect) {
        return category;
      }
      if (needCollect && !this._deduplication) {
        index = this.categories.length;
        this.categories[index] = category;
        return index;
      }
      var map2 = getOrCreateMap(this);
      index = map2.get(category);
      if (index == null) {
        if (needCollect) {
          index = this.categories.length;
          this.categories[index] = category;
          map2.set(category, index);
        } else {
          index = NaN;
        }
      }
      return index;
    };
    function getOrCreateMap(ordinalMeta) {
      return ordinalMeta._map || (ordinalMeta._map = createHashMap(ordinalMeta.categories));
    }
    function getName(obj) {
      if (isObject(obj) && obj.value != null) {
        return obj.value;
      } else {
        return obj + "";
      }
    }
    var _default = OrdinalMeta;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Ordinal.js
var require_Ordinal = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Ordinal.js"(exports, module) {
    var zrUtil = require_util();
    var Scale = require_Scale();
    var OrdinalMeta = require_OrdinalMeta();
    var scaleProto = Scale.prototype;
    var OrdinalScale = Scale.extend({
      type: "ordinal",
      /**
       * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta
       */
      init: function(ordinalMeta, extent) {
        if (!ordinalMeta || zrUtil.isArray(ordinalMeta)) {
          ordinalMeta = new OrdinalMeta({
            categories: ordinalMeta
          });
        }
        this._ordinalMeta = ordinalMeta;
        this._extent = extent || [0, ordinalMeta.categories.length - 1];
      },
      parse: function(val) {
        return typeof val === "string" ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
      },
      contain: function(rank) {
        rank = this.parse(rank);
        return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;
      },
      /**
       * Normalize given rank or name to linear [0, 1]
       * @param {number|string} [val]
       * @return {number}
       */
      normalize: function(val) {
        return scaleProto.normalize.call(this, this.parse(val));
      },
      scale: function(val) {
        return Math.round(scaleProto.scale.call(this, val));
      },
      /**
       * @return {Array}
       */
      getTicks: function() {
        var ticks = [];
        var extent = this._extent;
        var rank = extent[0];
        while (rank <= extent[1]) {
          ticks.push(rank);
          rank++;
        }
        return ticks;
      },
      /**
       * Get item on rank n
       * @param {number} n
       * @return {string}
       */
      getLabel: function(n) {
        if (!this.isBlank()) {
          return this._ordinalMeta.categories[n];
        }
      },
      /**
       * @return {number}
       */
      count: function() {
        return this._extent[1] - this._extent[0] + 1;
      },
      /**
       * @override
       */
      unionExtentFromData: function(data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      },
      getOrdinalMeta: function() {
        return this._ordinalMeta;
      },
      niceTicks: zrUtil.noop,
      niceExtent: zrUtil.noop
    });
    OrdinalScale.create = function() {
      return new OrdinalScale();
    };
    var _default = OrdinalScale;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/helper.js
var require_helper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/helper.js"(exports) {
    var numberUtil = require_number();
    var roundNumber = numberUtil.round;
    function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
      var result = {};
      var span = extent[1] - extent[0];
      var interval = result.interval = numberUtil.nice(span / splitNumber, true);
      if (minInterval != null && interval < minInterval) {
        interval = result.interval = minInterval;
      }
      if (maxInterval != null && interval > maxInterval) {
        interval = result.interval = maxInterval;
      }
      var precision = result.intervalPrecision = getIntervalPrecision(interval);
      var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
      fixExtent(niceTickExtent, extent);
      return result;
    }
    function getIntervalPrecision(interval) {
      return numberUtil.getPrecisionSafe(interval) + 2;
    }
    function clamp(niceTickExtent, idx, extent) {
      niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
    }
    function fixExtent(niceTickExtent, extent) {
      !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
      !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
      clamp(niceTickExtent, 0, extent);
      clamp(niceTickExtent, 1, extent);
      if (niceTickExtent[0] > niceTickExtent[1]) {
        niceTickExtent[0] = niceTickExtent[1];
      }
    }
    exports.intervalScaleNiceTicks = intervalScaleNiceTicks;
    exports.getIntervalPrecision = getIntervalPrecision;
    exports.fixExtent = fixExtent;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Interval.js
var require_Interval = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Interval.js"(exports, module) {
    var numberUtil = require_number();
    var formatUtil = require_format();
    var Scale = require_Scale();
    var helper = require_helper();
    var roundNumber = numberUtil.round;
    var IntervalScale = Scale.extend({
      type: "interval",
      _interval: 0,
      _intervalPrecision: 2,
      setExtent: function(start, end) {
        var thisExtent = this._extent;
        if (!isNaN(start)) {
          thisExtent[0] = parseFloat(start);
        }
        if (!isNaN(end)) {
          thisExtent[1] = parseFloat(end);
        }
      },
      unionExtent: function(other) {
        var extent = this._extent;
        other[0] < extent[0] && (extent[0] = other[0]);
        other[1] > extent[1] && (extent[1] = other[1]);
        IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
      },
      /**
       * Get interval
       */
      getInterval: function() {
        return this._interval;
      },
      /**
       * Set interval
       */
      setInterval: function(interval) {
        this._interval = interval;
        this._niceExtent = this._extent.slice();
        this._intervalPrecision = helper.getIntervalPrecision(interval);
      },
      /**
       * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
       * @return {Array.<number>}
       */
      getTicks: function(expandToNicedExtent) {
        var interval = this._interval;
        var extent = this._extent;
        var niceTickExtent = this._niceExtent;
        var intervalPrecision = this._intervalPrecision;
        var ticks = [];
        if (!interval) {
          return ticks;
        }
        var safeLimit = 1e4;
        if (extent[0] < niceTickExtent[0]) {
          if (expandToNicedExtent) {
            ticks.push(roundNumber(niceTickExtent[0] - interval, intervalPrecision));
          } else {
            ticks.push(extent[0]);
          }
        }
        var tick = niceTickExtent[0];
        while (tick <= niceTickExtent[1]) {
          ticks.push(tick);
          tick = roundNumber(tick + interval, intervalPrecision);
          if (tick === ticks[ticks.length - 1]) {
            break;
          }
          if (ticks.length > safeLimit) {
            return [];
          }
        }
        var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];
        if (extent[1] > lastNiceTick) {
          if (expandToNicedExtent) {
            ticks.push(roundNumber(lastNiceTick + interval, intervalPrecision));
          } else {
            ticks.push(extent[1]);
          }
        }
        return ticks;
      },
      /**
       * @param {number} [splitNumber=5]
       * @return {Array.<Array.<number>>}
       */
      getMinorTicks: function(splitNumber) {
        var ticks = this.getTicks(true);
        var minorTicks = [];
        var extent = this.getExtent();
        for (var i = 1; i < ticks.length; i++) {
          var nextTick = ticks[i];
          var prevTick = ticks[i - 1];
          var count = 0;
          var minorTicksGroup = [];
          var interval = nextTick - prevTick;
          var minorInterval = interval / splitNumber;
          while (count < splitNumber - 1) {
            var minorTick = numberUtil.round(prevTick + (count + 1) * minorInterval);
            if (minorTick > extent[0] && minorTick < extent[1]) {
              minorTicksGroup.push(minorTick);
            }
            count++;
          }
          minorTicks.push(minorTicksGroup);
        }
        return minorTicks;
      },
      /**
       * @param {number} data
       * @param {Object} [opt]
       * @param {number|string} [opt.precision] If 'auto', use nice presision.
       * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
       * @return {string}
       */
      getLabel: function(data, opt) {
        if (data == null) {
          return "";
        }
        var precision = opt && opt.precision;
        if (precision == null) {
          precision = numberUtil.getPrecisionSafe(data) || 0;
        } else if (precision === "auto") {
          precision = this._intervalPrecision;
        }
        data = roundNumber(data, precision, true);
        return formatUtil.addCommas(data);
      },
      /**
       * Update interval and extent of intervals for nice ticks
       *
       * @param {number} [splitNumber = 5] Desired number of ticks
       * @param {number} [minInterval]
       * @param {number} [maxInterval]
       */
      niceTicks: function(splitNumber, minInterval, maxInterval) {
        splitNumber = splitNumber || 5;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        if (!isFinite(span)) {
          return;
        }
        if (span < 0) {
          span = -span;
          extent.reverse();
        }
        var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
        this._intervalPrecision = result.intervalPrecision;
        this._interval = result.interval;
        this._niceExtent = result.niceTickExtent;
      },
      /**
       * Nice extent.
       * @param {Object} opt
       * @param {number} [opt.splitNumber = 5] Given approx tick number
       * @param {boolean} [opt.fixMin=false]
       * @param {boolean} [opt.fixMax=false]
       * @param {boolean} [opt.minInterval]
       * @param {boolean} [opt.maxInterval]
       */
      niceExtent: function(opt) {
        var extent = this._extent;
        if (extent[0] === extent[1]) {
          if (extent[0] !== 0) {
            var expandSize = extent[0];
            if (!opt.fixMax) {
              extent[1] += expandSize / 2;
              extent[0] -= expandSize / 2;
            } else {
              extent[0] -= expandSize / 2;
            }
          } else {
            extent[1] = 1;
          }
        }
        var span = extent[1] - extent[0];
        if (!isFinite(span)) {
          extent[0] = 0;
          extent[1] = 1;
        }
        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
        var interval = this._interval;
        if (!opt.fixMin) {
          extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
        }
        if (!opt.fixMax) {
          extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
        }
      }
    });
    IntervalScale.create = function() {
      return new IntervalScale();
    };
    var _default = IntervalScale;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/barGrid.js
var require_barGrid = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/barGrid.js"(exports) {
    var zrUtil = require_util();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var createRenderPlanner = require_createRenderPlanner();
    var STACK_PREFIX = "__ec_stack_";
    var LARGE_BAR_MIN_WIDTH = 0.5;
    var LargeArr = typeof Float32Array !== "undefined" ? Float32Array : Array;
    function getSeriesStackId(seriesModel) {
      return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
    }
    function getAxisKey(axis) {
      return axis.dim + axis.index;
    }
    function getLayoutOnAxis(opt) {
      var params = [];
      var baseAxis = opt.axis;
      var axisKey = "axis0";
      if (baseAxis.type !== "category") {
        return;
      }
      var bandWidth = baseAxis.getBandWidth();
      for (var i = 0; i < opt.count || 0; i++) {
        params.push(zrUtil.defaults({
          bandWidth,
          axisKey,
          stackId: STACK_PREFIX + i
        }, opt));
      }
      var widthAndOffsets = doCalBarWidthAndOffset(params);
      var result = [];
      for (var i = 0; i < opt.count; i++) {
        var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
        item.offsetCenter = item.offset + item.width / 2;
        result.push(item);
      }
      return result;
    }
    function prepareLayoutBarSeries(seriesType, ecModel) {
      var seriesModels = [];
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {
          seriesModels.push(seriesModel);
        }
      });
      return seriesModels;
    }
    function getValueAxesMinGaps(barSeries) {
      var axisValues = {};
      zrUtil.each(barSeries, function(seriesModel) {
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        if (baseAxis.type !== "time" && baseAxis.type !== "value") {
          return;
        }
        var data = seriesModel.getData();
        var key2 = baseAxis.dim + "_" + baseAxis.index;
        var dim = data.mapDimension(baseAxis.dim);
        for (var i = 0, cnt = data.count(); i < cnt; ++i) {
          var value = data.get(dim, i);
          if (!axisValues[key2]) {
            axisValues[key2] = [value];
          } else {
            axisValues[key2].push(value);
          }
        }
      });
      var axisMinGaps = [];
      for (var key in axisValues) {
        if (axisValues.hasOwnProperty(key)) {
          var valuesInAxis = axisValues[key];
          if (valuesInAxis) {
            valuesInAxis.sort(function(a, b) {
              return a - b;
            });
            var min = null;
            for (var j = 1; j < valuesInAxis.length; ++j) {
              var delta = valuesInAxis[j] - valuesInAxis[j - 1];
              if (delta > 0) {
                min = min === null ? delta : Math.min(min, delta);
              }
            }
            axisMinGaps[key] = min;
          }
        }
      }
      return axisMinGaps;
    }
    function makeColumnLayout(barSeries) {
      var axisMinGaps = getValueAxesMinGaps(barSeries);
      var seriesInfoList = [];
      zrUtil.each(barSeries, function(seriesModel) {
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var axisExtent = baseAxis.getExtent();
        var bandWidth;
        if (baseAxis.type === "category") {
          bandWidth = baseAxis.getBandWidth();
        } else if (baseAxis.type === "value" || baseAxis.type === "time") {
          var key = baseAxis.dim + "_" + baseAxis.index;
          var minGap = axisMinGaps[key];
          var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
          var scale = baseAxis.scale.getExtent();
          var scaleSpan = Math.abs(scale[1] - scale[0]);
          bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
        } else {
          var data = seriesModel.getData();
          bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
        }
        var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
        var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
        var barMinWidth = parsePercent(
          // barMinWidth by default is 1 in cartesian. Because in value axis,
          // the auto-calculated bar width might be less than 1.
          seriesModel.get("barMinWidth") || 1,
          bandWidth
        );
        var barGap = seriesModel.get("barGap");
        var barCategoryGap = seriesModel.get("barCategoryGap");
        seriesInfoList.push({
          bandWidth,
          barWidth,
          barMaxWidth,
          barMinWidth,
          barGap,
          barCategoryGap,
          axisKey: getAxisKey(baseAxis),
          stackId: getSeriesStackId(seriesModel)
        });
      });
      return doCalBarWidthAndOffset(seriesInfoList);
    }
    function doCalBarWidthAndOffset(seriesInfoList) {
      var columnsMap = {};
      zrUtil.each(seriesInfoList, function(seriesInfo, idx) {
        var axisKey = seriesInfo.axisKey;
        var bandWidth = seriesInfo.bandWidth;
        var columnsOnAxis = columnsMap[axisKey] || {
          bandWidth,
          remainedWidth: bandWidth,
          autoWidthCount: 0,
          categoryGap: "20%",
          gap: "30%",
          stacks: {}
        };
        var stacks = columnsOnAxis.stacks;
        columnsMap[axisKey] = columnsOnAxis;
        var stackId = seriesInfo.stackId;
        if (!stacks[stackId]) {
          columnsOnAxis.autoWidthCount++;
        }
        stacks[stackId] = stacks[stackId] || {
          width: 0,
          maxWidth: 0
        };
        var barWidth = seriesInfo.barWidth;
        if (barWidth && !stacks[stackId].width) {
          stacks[stackId].width = barWidth;
          barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
          columnsOnAxis.remainedWidth -= barWidth;
        }
        var barMaxWidth = seriesInfo.barMaxWidth;
        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
        var barMinWidth = seriesInfo.barMinWidth;
        barMinWidth && (stacks[stackId].minWidth = barMinWidth);
        var barGap = seriesInfo.barGap;
        barGap != null && (columnsOnAxis.gap = barGap);
        var barCategoryGap = seriesInfo.barCategoryGap;
        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
      });
      var result = {};
      zrUtil.each(columnsMap, function(columnsOnAxis, coordSysName) {
        result[coordSysName] = {};
        var stacks = columnsOnAxis.stacks;
        var bandWidth = columnsOnAxis.bandWidth;
        var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
        var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
        var remainedWidth = columnsOnAxis.remainedWidth;
        var autoWidthCount = columnsOnAxis.autoWidthCount;
        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        zrUtil.each(stacks, function(column) {
          var maxWidth = column.maxWidth;
          var minWidth = column.minWidth;
          if (!column.width) {
            var finalWidth = autoWidth;
            if (maxWidth && maxWidth < finalWidth) {
              finalWidth = Math.min(maxWidth, remainedWidth);
            }
            if (minWidth && minWidth > finalWidth) {
              finalWidth = minWidth;
            }
            if (finalWidth !== autoWidth) {
              column.width = finalWidth;
              remainedWidth -= finalWidth + barGapPercent * finalWidth;
              autoWidthCount--;
            }
          } else {
            var finalWidth = column.width;
            if (maxWidth) {
              finalWidth = Math.min(finalWidth, maxWidth);
            }
            if (minWidth) {
              finalWidth = Math.max(finalWidth, minWidth);
            }
            column.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        });
        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        var widthSum = 0;
        var lastColumn;
        zrUtil.each(stacks, function(column, idx) {
          if (!column.width) {
            column.width = autoWidth;
          }
          lastColumn = column;
          widthSum += column.width * (1 + barGapPercent);
        });
        if (lastColumn) {
          widthSum -= lastColumn.width * barGapPercent;
        }
        var offset = -widthSum / 2;
        zrUtil.each(stacks, function(column, stackId) {
          result[coordSysName][stackId] = result[coordSysName][stackId] || {
            bandWidth,
            offset,
            width: column.width
          };
          offset += column.width * (1 + barGapPercent);
        });
      });
      return result;
    }
    function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
      if (barWidthAndOffset && axis) {
        var result = barWidthAndOffset[getAxisKey(axis)];
        if (result != null && seriesModel != null) {
          result = result[getSeriesStackId(seriesModel)];
        }
        return result;
      }
    }
    function layout(seriesType, ecModel) {
      var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
      var barWidthAndOffset = makeColumnLayout(seriesModels);
      var lastStackCoords = {};
      var lastStackCoordsOrigin = {};
      zrUtil.each(seriesModels, function(seriesModel) {
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var stackId = getSeriesStackId(seriesModel);
        var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
        var columnOffset = columnLayoutInfo.offset;
        var columnWidth = columnLayoutInfo.width;
        var valueAxis = cartesian.getOtherAxis(baseAxis);
        var barMinHeight = seriesModel.get("barMinHeight") || 0;
        lastStackCoords[stackId] = lastStackCoords[stackId] || [];
        lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || [];
        data.setLayout({
          bandWidth: columnLayoutInfo.bandWidth,
          offset: columnOffset,
          size: columnWidth
        });
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var stacked = isDimensionStacked(
          data,
          valueDim
          /*, baseDim*/
        );
        var isValueAxisH = valueAxis.isHorizontal();
        var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);
        for (var idx = 0, len = data.count(); idx < len; idx++) {
          var value = data.get(valueDim, idx);
          var baseValue = data.get(baseDim, idx);
          var sign = value >= 0 ? "p" : "n";
          var baseCoord = valueAxisStart;
          if (stacked) {
            if (!lastStackCoords[stackId][baseValue]) {
              lastStackCoords[stackId][baseValue] = {
                p: valueAxisStart,
                // Positive stack
                n: valueAxisStart
                // Negative stack
              };
            }
            baseCoord = lastStackCoords[stackId][baseValue][sign];
          }
          var x;
          var y;
          var width;
          var height;
          if (isValueAxisH) {
            var coord = cartesian.dataToPoint([value, baseValue]);
            x = baseCoord;
            y = coord[1] + columnOffset;
            width = coord[0] - valueAxisStart;
            height = columnWidth;
            if (Math.abs(width) < barMinHeight) {
              width = (width < 0 ? -1 : 1) * barMinHeight;
            }
            if (!isNaN(width)) {
              stacked && (lastStackCoords[stackId][baseValue][sign] += width);
            }
          } else {
            var coord = cartesian.dataToPoint([baseValue, value]);
            x = coord[0] + columnOffset;
            y = baseCoord;
            width = columnWidth;
            height = coord[1] - valueAxisStart;
            if (Math.abs(height) < barMinHeight) {
              height = (height <= 0 ? -1 : 1) * barMinHeight;
            }
            if (!isNaN(height)) {
              stacked && (lastStackCoords[stackId][baseValue][sign] += height);
            }
          }
          data.setItemLayout(idx, {
            x,
            y,
            width,
            height
          });
        }
      }, this);
    }
    var largeLayout = {
      seriesType: "bar",
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {
          return;
        }
        var data = seriesModel.getData();
        var cartesian = seriesModel.coordinateSystem;
        var coordLayout = cartesian.grid.getRect();
        var baseAxis = cartesian.getBaseAxis();
        var valueAxis = cartesian.getOtherAxis(baseAxis);
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var valueAxisHorizontal = valueAxis.isHorizontal();
        var valueDimIdx = valueAxisHorizontal ? 0 : 1;
        var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;
        if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {
          barWidth = LARGE_BAR_MIN_WIDTH;
        }
        return {
          progress
        };
        function progress(params, data2) {
          var count = params.count;
          var largePoints = new LargeArr(count * 2);
          var largeBackgroundPoints = new LargeArr(count * 2);
          var largeDataIndices = new LargeArr(count);
          var dataIndex;
          var coord = [];
          var valuePair = [];
          var pointsOffset = 0;
          var idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            valuePair[valueDimIdx] = data2.get(valueDim, dataIndex);
            valuePair[1 - valueDimIdx] = data2.get(baseDim, dataIndex);
            coord = cartesian.dataToPoint(valuePair, null, coord);
            largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];
            largePoints[pointsOffset++] = coord[0];
            largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;
            largePoints[pointsOffset++] = coord[1];
            largeDataIndices[idxOffset++] = dataIndex;
          }
          data2.setLayout({
            largePoints,
            largeDataIndices,
            largeBackgroundPoints,
            barWidth,
            valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),
            backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,
            valueAxisHorizontal
          });
        }
      }
    };
    function isOnCartesian(seriesModel) {
      return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
    }
    function isInLargeMode(seriesModel) {
      return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
    }
    function getValueAxisStart(baseAxis, valueAxis, stacked) {
      return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === "log" ? 1 : 0));
    }
    exports.getLayoutOnAxis = getLayoutOnAxis;
    exports.prepareLayoutBarSeries = prepareLayoutBarSeries;
    exports.makeColumnLayout = makeColumnLayout;
    exports.retrieveColumnLayout = retrieveColumnLayout;
    exports.layout = layout;
    exports.largeLayout = largeLayout;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Time.js
var require_Time = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Time.js"(exports, module) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    var formatUtil = require_format();
    var scaleHelper = require_helper();
    var IntervalScale = require_Interval();
    var intervalScaleProto = IntervalScale.prototype;
    var mathCeil = Math.ceil;
    var mathFloor = Math.floor;
    var ONE_SECOND = 1e3;
    var ONE_MINUTE = ONE_SECOND * 60;
    var ONE_HOUR = ONE_MINUTE * 60;
    var ONE_DAY = ONE_HOUR * 24;
    var bisect = function(a, x, lo, hi) {
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (a[mid][1] < x) {
          lo = mid + 1;
        } else {
          hi = mid;
        }
      }
      return lo;
    };
    var TimeScale = IntervalScale.extend({
      type: "time",
      /**
       * @override
       */
      getLabel: function(val) {
        var stepLvl = this._stepLvl;
        var date = new Date(val);
        return formatUtil.formatTime(stepLvl[0], date, this.getSetting("useUTC"));
      },
      /**
       * @override
       */
      niceExtent: function(opt) {
        var extent = this._extent;
        if (extent[0] === extent[1]) {
          extent[0] -= ONE_DAY;
          extent[1] += ONE_DAY;
        }
        if (extent[1] === -Infinity && extent[0] === Infinity) {
          var d = /* @__PURE__ */ new Date();
          extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
          extent[0] = extent[1] - ONE_DAY;
        }
        this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
        var interval = this._interval;
        if (!opt.fixMin) {
          extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
        }
        if (!opt.fixMax) {
          extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
        }
      },
      /**
       * @override
       */
      niceTicks: function(approxTickNum, minInterval, maxInterval) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        var approxInterval = span / approxTickNum;
        if (minInterval != null && approxInterval < minInterval) {
          approxInterval = minInterval;
        }
        if (maxInterval != null && approxInterval > maxInterval) {
          approxInterval = maxInterval;
        }
        var scaleLevelsLen = scaleLevels.length;
        var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
        var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
        var interval = level[1];
        if (level[0] === "year") {
          var yearSpan = span / interval;
          var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
          interval *= yearStep;
        }
        var timezoneOffset = this.getSetting("useUTC") ? 0 : (/* @__PURE__ */ new Date(+extent[0] || +extent[1])).getTimezoneOffset() * 60 * 1e3;
        var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
        scaleHelper.fixExtent(niceExtent, extent);
        this._stepLvl = level;
        this._interval = interval;
        this._niceExtent = niceExtent;
      },
      parse: function(val) {
        return +numberUtil.parseDate(val);
      }
    });
    zrUtil.each(["contain", "normalize"], function(methodName) {
      TimeScale.prototype[methodName] = function(val) {
        return intervalScaleProto[methodName].call(this, this.parse(val));
      };
    });
    var scaleLevels = [
      // Format              interval
      ["hh:mm:ss", ONE_SECOND],
      // 1s
      ["hh:mm:ss", ONE_SECOND * 5],
      // 5s
      ["hh:mm:ss", ONE_SECOND * 10],
      // 10s
      ["hh:mm:ss", ONE_SECOND * 15],
      // 15s
      ["hh:mm:ss", ONE_SECOND * 30],
      // 30s
      ["hh:mm\nMM-dd", ONE_MINUTE],
      // 1m
      ["hh:mm\nMM-dd", ONE_MINUTE * 5],
      // 5m
      ["hh:mm\nMM-dd", ONE_MINUTE * 10],
      // 10m
      ["hh:mm\nMM-dd", ONE_MINUTE * 15],
      // 15m
      ["hh:mm\nMM-dd", ONE_MINUTE * 30],
      // 30m
      ["hh:mm\nMM-dd", ONE_HOUR],
      // 1h
      ["hh:mm\nMM-dd", ONE_HOUR * 2],
      // 2h
      ["hh:mm\nMM-dd", ONE_HOUR * 6],
      // 6h
      ["hh:mm\nMM-dd", ONE_HOUR * 12],
      // 12h
      ["MM-dd\nyyyy", ONE_DAY],
      // 1d
      ["MM-dd\nyyyy", ONE_DAY * 2],
      // 2d
      ["MM-dd\nyyyy", ONE_DAY * 3],
      // 3d
      ["MM-dd\nyyyy", ONE_DAY * 4],
      // 4d
      ["MM-dd\nyyyy", ONE_DAY * 5],
      // 5d
      ["MM-dd\nyyyy", ONE_DAY * 6],
      // 6d
      ["week", ONE_DAY * 7],
      // 7d
      ["MM-dd\nyyyy", ONE_DAY * 10],
      // 10d
      ["week", ONE_DAY * 14],
      // 2w
      ["week", ONE_DAY * 21],
      // 3w
      ["month", ONE_DAY * 31],
      // 1M
      ["week", ONE_DAY * 42],
      // 6w
      ["month", ONE_DAY * 62],
      // 2M
      ["week", ONE_DAY * 70],
      // 10w
      ["quarter", ONE_DAY * 95],
      // 3M
      ["month", ONE_DAY * 31 * 4],
      // 4M
      ["month", ONE_DAY * 31 * 5],
      // 5M
      ["half-year", ONE_DAY * 380 / 2],
      // 6M
      ["month", ONE_DAY * 31 * 8],
      // 8M
      ["month", ONE_DAY * 31 * 10],
      // 10M
      ["year", ONE_DAY * 380]
      // 1Y
    ];
    TimeScale.create = function(model) {
      return new TimeScale({
        useUTC: model.ecModel.get("useUTC")
      });
    };
    var _default = TimeScale;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Log.js
var require_Log = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/scale/Log.js"(exports, module) {
    var zrUtil = require_util();
    var Scale = require_Scale();
    var numberUtil = require_number();
    var IntervalScale = require_Interval();
    var scaleProto = Scale.prototype;
    var intervalScaleProto = IntervalScale.prototype;
    var getPrecisionSafe = numberUtil.getPrecisionSafe;
    var roundingErrorFix = numberUtil.round;
    var mathFloor = Math.floor;
    var mathCeil = Math.ceil;
    var mathPow = Math.pow;
    var mathLog = Math.log;
    var LogScale = Scale.extend({
      type: "log",
      base: 10,
      $constructor: function() {
        Scale.apply(this, arguments);
        this._originalScale = new IntervalScale();
      },
      /**
       * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
       * @return {Array.<number>}
       */
      getTicks: function(expandToNicedExtent) {
        var originalScale = this._originalScale;
        var extent = this._extent;
        var originalExtent = originalScale.getExtent();
        return zrUtil.map(intervalScaleProto.getTicks.call(this, expandToNicedExtent), function(val) {
          var powVal = numberUtil.round(mathPow(this.base, val));
          powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
          powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
          return powVal;
        }, this);
      },
      /**
       * @param {number} splitNumber
       * @return {Array.<Array.<number>>}
       */
      getMinorTicks: intervalScaleProto.getMinorTicks,
      /**
       * @param {number} val
       * @return {string}
       */
      getLabel: intervalScaleProto.getLabel,
      /**
       * @param  {number} val
       * @return {number}
       */
      scale: function(val) {
        val = scaleProto.scale.call(this, val);
        return mathPow(this.base, val);
      },
      /**
       * @param {number} start
       * @param {number} end
       */
      setExtent: function(start, end) {
        var base = this.base;
        start = mathLog(start) / mathLog(base);
        end = mathLog(end) / mathLog(base);
        intervalScaleProto.setExtent.call(this, start, end);
      },
      /**
       * @return {number} end
       */
      getExtent: function() {
        var base = this.base;
        var extent = scaleProto.getExtent.call(this);
        extent[0] = mathPow(base, extent[0]);
        extent[1] = mathPow(base, extent[1]);
        var originalScale = this._originalScale;
        var originalExtent = originalScale.getExtent();
        originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
        originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
        return extent;
      },
      /**
       * @param  {Array.<number>} extent
       */
      unionExtent: function(extent) {
        this._originalScale.unionExtent(extent);
        var base = this.base;
        extent[0] = mathLog(extent[0]) / mathLog(base);
        extent[1] = mathLog(extent[1]) / mathLog(base);
        scaleProto.unionExtent.call(this, extent);
      },
      /**
       * @override
       */
      unionExtentFromData: function(data, dim) {
        this.unionExtent(data.getApproximateExtent(dim));
      },
      /**
       * Update interval and extent of intervals for nice ticks
       * @param  {number} [approxTickNum = 10] Given approx tick number
       */
      niceTicks: function(approxTickNum) {
        approxTickNum = approxTickNum || 10;
        var extent = this._extent;
        var span = extent[1] - extent[0];
        if (span === Infinity || span <= 0) {
          return;
        }
        var interval = numberUtil.quantity(span);
        var err = approxTickNum / span * interval;
        if (err <= 0.5) {
          interval *= 10;
        }
        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
          interval *= 10;
        }
        var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
        this._interval = interval;
        this._niceExtent = niceExtent;
      },
      /**
       * Nice extent.
       * @override
       */
      niceExtent: function(opt) {
        intervalScaleProto.niceExtent.call(this, opt);
        var originalScale = this._originalScale;
        originalScale.__fixMin = opt.fixMin;
        originalScale.__fixMax = opt.fixMax;
      }
    });
    zrUtil.each(["contain", "normalize"], function(methodName) {
      LogScale.prototype[methodName] = function(val) {
        val = mathLog(val) / mathLog(this.base);
        return scaleProto[methodName].call(this, val);
      };
    });
    LogScale.create = function() {
      return new LogScale();
    };
    function fixRoundingError(val, originalVal) {
      return roundingErrorFix(val, getPrecisionSafe(originalVal));
    }
    var _default = LogScale;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisHelper.js
var require_axisHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisHelper.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var OrdinalScale = require_Ordinal();
    var IntervalScale = require_Interval();
    var Scale = require_Scale();
    var numberUtil = require_number();
    var _barGrid = require_barGrid();
    var prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries;
    var makeColumnLayout = _barGrid.makeColumnLayout;
    var retrieveColumnLayout = _barGrid.retrieveColumnLayout;
    var BoundingRect = require_BoundingRect();
    require_Time();
    require_Log();
    function getScaleExtent(scale, model) {
      var scaleType = scale.type;
      var min = model.getMin();
      var max = model.getMax();
      var originalExtent = scale.getExtent();
      var axisDataLen;
      var boundaryGap;
      var span;
      if (scaleType === "ordinal") {
        axisDataLen = model.getCategories().length;
      } else {
        boundaryGap = model.get("boundaryGap");
        if (!zrUtil.isArray(boundaryGap)) {
          boundaryGap = [boundaryGap || 0, boundaryGap || 0];
        }
        if (typeof boundaryGap[0] === "boolean") {
          boundaryGap = [0, 0];
        }
        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
        span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
      }
      if (min === "dataMin") {
        min = originalExtent[0];
      } else if (typeof min === "function") {
        min = min({
          min: originalExtent[0],
          max: originalExtent[1]
        });
      }
      if (max === "dataMax") {
        max = originalExtent[1];
      } else if (typeof max === "function") {
        max = max({
          min: originalExtent[0],
          max: originalExtent[1]
        });
      }
      var fixMin = min != null;
      var fixMax = max != null;
      if (min == null) {
        min = scaleType === "ordinal" ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
      }
      if (max == null) {
        max = scaleType === "ordinal" ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
      }
      (min == null || !isFinite(min)) && (min = NaN);
      (max == null || !isFinite(max)) && (max = NaN);
      scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max) || scaleType === "ordinal" && !scale.getOrdinalMeta().categories.length);
      if (model.getNeedCrossZero()) {
        if (min > 0 && max > 0 && !fixMin) {
          min = 0;
        }
        if (min < 0 && max < 0 && !fixMax) {
          max = 0;
        }
      }
      var ecModel = model.ecModel;
      if (ecModel && scaleType === "time") {
        var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
        var isBaseAxisAndHasBarSeries;
        zrUtil.each(barSeriesModels, function(seriesModel) {
          isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;
        });
        if (isBaseAxisAndHasBarSeries) {
          var barWidthAndOffset = makeColumnLayout(barSeriesModels);
          var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);
          min = adjustedScale.min;
          max = adjustedScale.max;
        }
      }
      return {
        extent: [min, max],
        // "fix" means "fixed", the value should not be
        // changed in the subsequent steps.
        fixMin,
        fixMax
      };
    }
    function adjustScaleForOverflow(min, max, model, barWidthAndOffset) {
      var axisExtent = model.axis.getExtent();
      var axisLength = axisExtent[1] - axisExtent[0];
      var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
      if (barsOnCurrentAxis === void 0) {
        return {
          min,
          max
        };
      }
      var minOverflow = Infinity;
      zrUtil.each(barsOnCurrentAxis, function(item) {
        minOverflow = Math.min(item.offset, minOverflow);
      });
      var maxOverflow = -Infinity;
      zrUtil.each(barsOnCurrentAxis, function(item) {
        maxOverflow = Math.max(item.offset + item.width, maxOverflow);
      });
      minOverflow = Math.abs(minOverflow);
      maxOverflow = Math.abs(maxOverflow);
      var totalOverFlow = minOverflow + maxOverflow;
      var oldRange = max - min;
      var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
      var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
      max += overflowBuffer * (maxOverflow / totalOverFlow);
      min -= overflowBuffer * (minOverflow / totalOverFlow);
      return {
        min,
        max
      };
    }
    function niceScaleExtent(scale, model) {
      var extentInfo = getScaleExtent(scale, model);
      var extent = extentInfo.extent;
      var splitNumber = model.get("splitNumber");
      if (scale.type === "log") {
        scale.base = model.get("logBase");
      }
      var scaleType = scale.type;
      scale.setExtent(extent[0], extent[1]);
      scale.niceExtent({
        splitNumber,
        fixMin: extentInfo.fixMin,
        fixMax: extentInfo.fixMax,
        minInterval: scaleType === "interval" || scaleType === "time" ? model.get("minInterval") : null,
        maxInterval: scaleType === "interval" || scaleType === "time" ? model.get("maxInterval") : null
      });
      var interval = model.get("interval");
      if (interval != null) {
        scale.setInterval && scale.setInterval(interval);
      }
    }
    function createScaleByModel(model, axisType) {
      axisType = axisType || model.get("type");
      if (axisType) {
        switch (axisType) {
          case "category":
            return new OrdinalScale(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);
          case "value":
            return new IntervalScale();
          default:
            return (Scale.getClass(axisType) || IntervalScale).create(model);
        }
      }
    }
    function ifAxisCrossZero(axis) {
      var dataExtent = axis.scale.getExtent();
      var min = dataExtent[0];
      var max = dataExtent[1];
      return !(min > 0 && max > 0 || min < 0 && max < 0);
    }
    function makeLabelFormatter(axis) {
      var labelFormatter = axis.getLabelModel().get("formatter");
      var categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
      if (typeof labelFormatter === "string") {
        labelFormatter = /* @__PURE__ */ function(tpl) {
          return function(val) {
            val = axis.scale.getLabel(val);
            return tpl.replace("{value}", val != null ? val : "");
          };
        }(labelFormatter);
        return labelFormatter;
      } else if (typeof labelFormatter === "function") {
        return function(tickValue, idx) {
          if (categoryTickStart != null) {
            idx = tickValue - categoryTickStart;
          }
          return labelFormatter(getAxisRawValue(axis, tickValue), idx);
        };
      } else {
        return function(tick) {
          return axis.scale.getLabel(tick);
        };
      }
    }
    function getAxisRawValue(axis, value) {
      return axis.type === "category" ? axis.scale.getLabel(value) : value;
    }
    function estimateLabelUnionRect(axis) {
      var axisModel = axis.model;
      var scale = axis.scale;
      if (!axisModel.get("axisLabel.show") || scale.isBlank()) {
        return;
      }
      var isCategory = axis.type === "category";
      var realNumberScaleTicks;
      var tickCount;
      var categoryScaleExtent = scale.getExtent();
      if (isCategory) {
        tickCount = scale.count();
      } else {
        realNumberScaleTicks = scale.getTicks();
        tickCount = realNumberScaleTicks.length;
      }
      var axisLabelModel = axis.getLabelModel();
      var labelFormatter = makeLabelFormatter(axis);
      var rect;
      var step = 1;
      if (tickCount > 40) {
        step = Math.ceil(tickCount / 40);
      }
      for (var i = 0; i < tickCount; i += step) {
        var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;
        var label = labelFormatter(tickValue);
        var unrotatedSingleRect = axisLabelModel.getTextRect(label);
        var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
        rect ? rect.union(singleRect) : rect = singleRect;
      }
      return rect;
    }
    function rotateTextRect(textRect, rotate) {
      var rotateRadians = rotate * Math.PI / 180;
      var boundingBox = textRect.plain();
      var beforeWidth = boundingBox.width;
      var beforeHeight = boundingBox.height;
      var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
      var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
      var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
      return rotatedRect;
    }
    function getOptionCategoryInterval(model) {
      var interval = model.get("interval");
      return interval == null ? "auto" : interval;
    }
    function shouldShowAllLabels(axis) {
      return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
    }
    exports.getScaleExtent = getScaleExtent;
    exports.niceScaleExtent = niceScaleExtent;
    exports.createScaleByModel = createScaleByModel;
    exports.ifAxisCrossZero = ifAxisCrossZero;
    exports.makeLabelFormatter = makeLabelFormatter;
    exports.getAxisRawValue = getAxisRawValue;
    exports.estimateLabelUnionRect = estimateLabelUnionRect;
    exports.getOptionCategoryInterval = getOptionCategoryInterval;
    exports.shouldShowAllLabels = shouldShowAllLabels;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisModelCommonMixin.js
var require_axisModelCommonMixin = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisModelCommonMixin.js"(exports, module) {
    var zrUtil = require_util();
    var _default = {
      /**
       * @param {boolean} origin
       * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
       */
      getMin: function(origin) {
        var option = this.option;
        var min = !origin && option.rangeStart != null ? option.rangeStart : option.min;
        if (this.axis && min != null && min !== "dataMin" && typeof min !== "function" && !zrUtil.eqNaN(min)) {
          min = this.axis.scale.parse(min);
        }
        return min;
      },
      /**
       * @param {boolean} origin
       * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
       */
      getMax: function(origin) {
        var option = this.option;
        var max = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;
        if (this.axis && max != null && max !== "dataMax" && typeof max !== "function" && !zrUtil.eqNaN(max)) {
          max = this.axis.scale.parse(max);
        }
        return max;
      },
      /**
       * @return {boolean}
       */
      getNeedCrossZero: function() {
        var option = this.option;
        return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
      },
      /**
       * Should be implemented by each axis model if necessary.
       * @return {module:echarts/model/Component} coordinate system model
       */
      getCoordSysModel: zrUtil.noop,
      /**
       * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
       * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
       */
      setRange: function(rangeStart, rangeEnd) {
        this.option.rangeStart = rangeStart;
        this.option.rangeEnd = rangeEnd;
      },
      /**
       * Reset range
       */
      resetRange: function() {
        this.option.rangeStart = this.option.rangeEnd = null;
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/symbol.js
var require_symbol = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/symbol.js"(exports) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var BoundingRect = require_BoundingRect();
    var _text = require_text();
    var calculateTextPosition = _text.calculateTextPosition;
    var Triangle = graphic.extendShape({
      type: "triangle",
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function(path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy + height);
        path.lineTo(cx - width, cy + height);
        path.closePath();
      }
    });
    var Diamond = graphic.extendShape({
      type: "diamond",
      shape: {
        cx: 0,
        cy: 0,
        width: 0,
        height: 0
      },
      buildPath: function(path, shape) {
        var cx = shape.cx;
        var cy = shape.cy;
        var width = shape.width / 2;
        var height = shape.height / 2;
        path.moveTo(cx, cy - height);
        path.lineTo(cx + width, cy);
        path.lineTo(cx, cy + height);
        path.lineTo(cx - width, cy);
        path.closePath();
      }
    });
    var Pin = graphic.extendShape({
      type: "pin",
      shape: {
        // x, y on the cusp
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function(path, shape) {
        var x = shape.x;
        var y = shape.y;
        var w = shape.width / 5 * 3;
        var h = Math.max(w, shape.height);
        var r = w / 2;
        var dy = r * r / (h - r);
        var cy = y - h + r + dy;
        var angle = Math.asin(dy / r);
        var dx = Math.cos(angle) * r;
        var tanX = Math.sin(angle);
        var tanY = Math.cos(angle);
        var cpLen = r * 0.6;
        var cpLen2 = r * 0.7;
        path.moveTo(x - dx, cy + dy);
        path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
        path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
        path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
        path.closePath();
      }
    });
    var Arrow = graphic.extendShape({
      type: "arrow",
      shape: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      buildPath: function(ctx, shape) {
        var height = shape.height;
        var width = shape.width;
        var x = shape.x;
        var y = shape.y;
        var dx = width / 3 * 2;
        ctx.moveTo(x, y);
        ctx.lineTo(x + dx, y + height);
        ctx.lineTo(x, y + height / 4 * 3);
        ctx.lineTo(x - dx, y + height);
        ctx.lineTo(x, y);
        ctx.closePath();
      }
    });
    var symbolCtors = {
      line: graphic.Line,
      rect: graphic.Rect,
      roundRect: graphic.Rect,
      square: graphic.Rect,
      circle: graphic.Circle,
      diamond: Diamond,
      pin: Pin,
      arrow: Arrow,
      triangle: Triangle
    };
    var symbolShapeMakers = {
      line: function(x, y, w, h, shape) {
        shape.x1 = x;
        shape.y1 = y + h / 2;
        shape.x2 = x + w;
        shape.y2 = y + h / 2;
      },
      rect: function(x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
      },
      roundRect: function(x, y, w, h, shape) {
        shape.x = x;
        shape.y = y;
        shape.width = w;
        shape.height = h;
        shape.r = Math.min(w, h) / 4;
      },
      square: function(x, y, w, h, shape) {
        var size = Math.min(w, h);
        shape.x = x;
        shape.y = y;
        shape.width = size;
        shape.height = size;
      },
      circle: function(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.r = Math.min(w, h) / 2;
      },
      diamond: function(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      pin: function(x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      arrow: function(x, y, w, h, shape) {
        shape.x = x + w / 2;
        shape.y = y + h / 2;
        shape.width = w;
        shape.height = h;
      },
      triangle: function(x, y, w, h, shape) {
        shape.cx = x + w / 2;
        shape.cy = y + h / 2;
        shape.width = w;
        shape.height = h;
      }
    };
    var symbolBuildProxies = {};
    zrUtil.each(symbolCtors, function(Ctor, name2) {
      symbolBuildProxies[name2] = new Ctor();
    });
    var SymbolClz = graphic.extendShape({
      type: "symbol",
      shape: {
        symbolType: "",
        x: 0,
        y: 0,
        width: 0,
        height: 0
      },
      calculateTextPosition: function(out, style, rect) {
        var res = calculateTextPosition(out, style, rect);
        var shape = this.shape;
        if (shape && shape.symbolType === "pin" && style.textPosition === "inside") {
          res.y = rect.y + rect.height * 0.4;
        }
        return res;
      },
      buildPath: function(ctx, shape, inBundle) {
        var symbolType = shape.symbolType;
        if (symbolType !== "none") {
          var proxySymbol = symbolBuildProxies[symbolType];
          if (!proxySymbol) {
            symbolType = "rect";
            proxySymbol = symbolBuildProxies[symbolType];
          }
          symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
          proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
        }
      }
    });
    function symbolPathSetColor(color, innerColor) {
      if (this.type !== "image") {
        var symbolStyle = this.style;
        var symbolShape = this.shape;
        if (symbolShape && symbolShape.symbolType === "line") {
          symbolStyle.stroke = color;
        } else if (this.__isEmptyBrush) {
          symbolStyle.stroke = color;
          symbolStyle.fill = innerColor || "#fff";
        } else {
          symbolStyle.fill && (symbolStyle.fill = color);
          symbolStyle.stroke && (symbolStyle.stroke = color);
        }
        this.dirty(false);
      }
    }
    function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
      var isEmpty = symbolType.indexOf("empty") === 0;
      if (isEmpty) {
        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
      }
      var symbolPath;
      if (symbolType.indexOf("image://") === 0) {
        symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover");
      } else if (symbolType.indexOf("path://") === 0) {
        symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? "center" : "cover");
      } else {
        symbolPath = new SymbolClz({
          shape: {
            symbolType,
            x,
            y,
            width: w,
            height: h
          }
        });
      }
      symbolPath.__isEmptyBrush = isEmpty;
      symbolPath.setColor = symbolPathSetColor;
      symbolPath.setColor(color);
      return symbolPath;
    }
    exports.createSymbol = createSymbol;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/helper.js
var require_helper2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/helper.js"(exports) {
    var zrUtil = require_util();
    var createListFromArray = require_createListFromArray();
    var axisHelper = require_axisHelper();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var Model = require_Model();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    exports.getLayoutRect = _layout.getLayoutRect;
    var _dataStackHelper = require_dataStackHelper();
    var enableDataStack = _dataStackHelper.enableDataStack;
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    var _completeDimensions = require_completeDimensions();
    exports.completeDimensions = _completeDimensions;
    var _createDimensions = require_createDimensions();
    exports.createDimensions = _createDimensions;
    var _symbol = require_symbol();
    exports.createSymbol = _symbol.createSymbol;
    function createList(seriesModel) {
      return createListFromArray(seriesModel.getSource(), seriesModel);
    }
    var dataStack = {
      isDimensionStacked,
      enableDataStack,
      getStackedDimension
    };
    function createScale(dataExtent, option) {
      var axisModel = option;
      if (!Model.isInstance(option)) {
        axisModel = new Model(option);
        zrUtil.mixin(axisModel, axisModelCommonMixin);
      }
      var scale = axisHelper.createScaleByModel(axisModel);
      scale.setExtent(dataExtent[0], dataExtent[1]);
      axisHelper.niceScaleExtent(scale, axisModel);
      return scale;
    }
    function mixinAxisModelCommonMethods(Model2) {
      zrUtil.mixin(Model2, axisModelCommonMixin);
    }
    exports.createList = createList;
    exports.dataStack = dataStack;
    exports.createScale = createScale;
    exports.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/polygon.js
var require_polygon = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/contain/polygon.js"(exports) {
    var windingLine = require_windingLine();
    var EPSILON = 1e-8;
    function isAroundEqual(a, b) {
      return Math.abs(a - b) < EPSILON;
    }
    function contain(points, x, y) {
      var w = 0;
      var p = points[0];
      if (!p) {
        return false;
      }
      for (var i = 1; i < points.length; i++) {
        var p2 = points[i];
        w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
        p = p2;
      }
      var p0 = points[0];
      if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
        w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
      }
      return w !== 0;
    }
    exports.contain = contain;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/Region.js
var require_Region = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/Region.js"(exports, module) {
    var BoundingRect = require_BoundingRect();
    var bbox = require_bbox();
    var vec2 = require_vector();
    var polygonContain = require_polygon();
    function Region(name2, geometries, cp) {
      this.name = name2;
      this.geometries = geometries;
      if (!cp) {
        var rect = this.getBoundingRect();
        cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      } else {
        cp = [cp[0], cp[1]];
      }
      this.center = cp;
    }
    Region.prototype = {
      constructor: Region,
      properties: null,
      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getBoundingRect: function() {
        var rect = this._rect;
        if (rect) {
          return rect;
        }
        var MAX_NUMBER = Number.MAX_VALUE;
        var min = [MAX_NUMBER, MAX_NUMBER];
        var max = [-MAX_NUMBER, -MAX_NUMBER];
        var min2 = [];
        var max2 = [];
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
          if (geometries[i].type !== "polygon") {
            continue;
          }
          var exterior = geometries[i].exterior;
          bbox.fromPoints(exterior, min2, max2);
          vec2.min(min, min, min2);
          vec2.max(max, max, max2);
        }
        if (i === 0) {
          min[0] = min[1] = max[0] = max[1] = 0;
        }
        return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
      },
      /**
       * @param {<Array.<number>} coord
       * @return {boolean}
       */
      contain: function(coord) {
        var rect = this.getBoundingRect();
        var geometries = this.geometries;
        if (!rect.contain(coord[0], coord[1])) {
          return false;
        }
        loopGeo:
          for (var i = 0, len = geometries.length; i < len; i++) {
            if (geometries[i].type !== "polygon") {
              continue;
            }
            var exterior = geometries[i].exterior;
            var interiors = geometries[i].interiors;
            if (polygonContain.contain(exterior, coord[0], coord[1])) {
              for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
                if (polygonContain.contain(interiors[k])) {
                  continue loopGeo;
                }
              }
              return true;
            }
          }
        return false;
      },
      transformTo: function(x, y, width, height) {
        var rect = this.getBoundingRect();
        var aspect = rect.width / rect.height;
        if (!width) {
          width = aspect * height;
        } else if (!height) {
          height = width / aspect;
        }
        var target = new BoundingRect(x, y, width, height);
        var transform = rect.calculateTransform(target);
        var geometries = this.geometries;
        for (var i = 0; i < geometries.length; i++) {
          if (geometries[i].type !== "polygon") {
            continue;
          }
          var exterior = geometries[i].exterior;
          var interiors = geometries[i].interiors;
          for (var p = 0; p < exterior.length; p++) {
            vec2.applyTransform(exterior[p], exterior[p], transform);
          }
          for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
            for (var p = 0; p < interiors[h].length; p++) {
              vec2.applyTransform(interiors[h][p], interiors[h][p], transform);
            }
          }
        }
        rect = this._rect;
        rect.copy(target);
        this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      },
      cloneShallow: function(name2) {
        name2 == null && (name2 = this.name);
        var newRegion = new Region(name2, this.geometries, this.center);
        newRegion._rect = this._rect;
        newRegion.transformTo = null;
        return newRegion;
      }
    };
    var _default = Region;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/parseGeoJson.js
var require_parseGeoJson = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/parseGeoJson.js"(exports, module) {
    var zrUtil = require_util();
    var Region = require_Region();
    function decode(json) {
      if (!json.UTF8Encoding) {
        return json;
      }
      var encodeScale = json.UTF8Scale;
      if (encodeScale == null) {
        encodeScale = 1024;
      }
      var features = json.features;
      for (var f = 0; f < features.length; f++) {
        var feature = features[f];
        var geometry = feature.geometry;
        var coordinates = geometry.coordinates;
        var encodeOffsets = geometry.encodeOffsets;
        for (var c = 0; c < coordinates.length; c++) {
          var coordinate = coordinates[c];
          if (geometry.type === "Polygon") {
            coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
          } else if (geometry.type === "MultiPolygon") {
            for (var c2 = 0; c2 < coordinate.length; c2++) {
              var polygon = coordinate[c2];
              coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale);
            }
          }
        }
      }
      json.UTF8Encoding = false;
      return json;
    }
    function decodePolygon(coordinate, encodeOffsets, encodeScale) {
      var result = [];
      var prevX = encodeOffsets[0];
      var prevY = encodeOffsets[1];
      for (var i = 0; i < coordinate.length; i += 2) {
        var x = coordinate.charCodeAt(i) - 64;
        var y = coordinate.charCodeAt(i + 1) - 64;
        x = x >> 1 ^ -(x & 1);
        y = y >> 1 ^ -(y & 1);
        x += prevX;
        y += prevY;
        prevX = x;
        prevY = y;
        result.push([x / encodeScale, y / encodeScale]);
      }
      return result;
    }
    function _default(geoJson, nameProperty) {
      decode(geoJson);
      return zrUtil.map(zrUtil.filter(geoJson.features, function(featureObj) {
        return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
      }), function(featureObj) {
        var properties = featureObj.properties;
        var geo = featureObj.geometry;
        var coordinates = geo.coordinates;
        var geometries = [];
        if (geo.type === "Polygon") {
          geometries.push({
            type: "polygon",
            // According to the GeoJSON specification.
            // First must be exterior, and the rest are all interior(holes).
            exterior: coordinates[0],
            interiors: coordinates.slice(1)
          });
        }
        if (geo.type === "MultiPolygon") {
          zrUtil.each(coordinates, function(item) {
            if (item[0]) {
              geometries.push({
                type: "polygon",
                exterior: item[0],
                interiors: item.slice(1)
              });
            }
          });
        }
        var region = new Region(properties[nameProperty || "name"], geometries, properties.cp);
        region.properties = properties;
        return region;
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisTickLabelBuilder.js
var require_axisTickLabelBuilder = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisTickLabelBuilder.js"(exports) {
    var zrUtil = require_util();
    var textContain = require_text();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var _axisHelper = require_axisHelper();
    var makeLabelFormatter = _axisHelper.makeLabelFormatter;
    var getOptionCategoryInterval = _axisHelper.getOptionCategoryInterval;
    var shouldShowAllLabels = _axisHelper.shouldShowAllLabels;
    var inner = makeInner();
    function createAxisLabels(axis) {
      return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
    }
    function createAxisTicks(axis, tickModel) {
      return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {
        ticks: axis.scale.getTicks()
      };
    }
    function makeCategoryLabels(axis) {
      var labelModel = axis.getLabelModel();
      var result = makeCategoryLabelsActually(axis, labelModel);
      return !labelModel.get("show") || axis.scale.isBlank() ? {
        labels: [],
        labelCategoryInterval: result.labelCategoryInterval
      } : result;
    }
    function makeCategoryLabelsActually(axis, labelModel) {
      var labelsCache = getListCache(axis, "labels");
      var optionLabelInterval = getOptionCategoryInterval(labelModel);
      var result = listCacheGet(labelsCache, optionLabelInterval);
      if (result) {
        return result;
      }
      var labels;
      var numericLabelInterval;
      if (zrUtil.isFunction(optionLabelInterval)) {
        labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
      } else {
        numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
        labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
      }
      return listCacheSet(labelsCache, optionLabelInterval, {
        labels,
        labelCategoryInterval: numericLabelInterval
      });
    }
    function makeCategoryTicks(axis, tickModel) {
      var ticksCache = getListCache(axis, "ticks");
      var optionTickInterval = getOptionCategoryInterval(tickModel);
      var result = listCacheGet(ticksCache, optionTickInterval);
      if (result) {
        return result;
      }
      var ticks;
      var tickCategoryInterval;
      if (!tickModel.get("show") || axis.scale.isBlank()) {
        ticks = [];
      }
      if (zrUtil.isFunction(optionTickInterval)) {
        ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
      } else if (optionTickInterval === "auto") {
        var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
        tickCategoryInterval = labelsResult.labelCategoryInterval;
        ticks = zrUtil.map(labelsResult.labels, function(labelItem) {
          return labelItem.tickValue;
        });
      } else {
        tickCategoryInterval = optionTickInterval;
        ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
      }
      return listCacheSet(ticksCache, optionTickInterval, {
        ticks,
        tickCategoryInterval
      });
    }
    function makeRealNumberLabels(axis) {
      var ticks = axis.scale.getTicks();
      var labelFormatter = makeLabelFormatter(axis);
      return {
        labels: zrUtil.map(ticks, function(tickValue, idx) {
          return {
            formattedLabel: labelFormatter(tickValue, idx),
            rawLabel: axis.scale.getLabel(tickValue),
            tickValue
          };
        })
      };
    }
    function getListCache(axis, prop) {
      return inner(axis)[prop] || (inner(axis)[prop] = []);
    }
    function listCacheGet(cache, key) {
      for (var i = 0; i < cache.length; i++) {
        if (cache[i].key === key) {
          return cache[i].value;
        }
      }
    }
    function listCacheSet(cache, key, value) {
      cache.push({
        key,
        value
      });
      return value;
    }
    function makeAutoCategoryInterval(axis) {
      var result = inner(axis).autoInterval;
      return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();
    }
    function calculateCategoryInterval(axis) {
      var params = fetchAutoCategoryIntervalCalculationParams(axis);
      var labelFormatter = makeLabelFormatter(axis);
      var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
      var ordinalScale = axis.scale;
      var ordinalExtent = ordinalScale.getExtent();
      var tickCount = ordinalScale.count();
      if (ordinalExtent[1] - ordinalExtent[0] < 1) {
        return 0;
      }
      var step = 1;
      if (tickCount > 40) {
        step = Math.max(1, Math.floor(tickCount / 40));
      }
      var tickValue = ordinalExtent[0];
      var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
      var unitW = Math.abs(unitSpan * Math.cos(rotation));
      var unitH = Math.abs(unitSpan * Math.sin(rotation));
      var maxW = 0;
      var maxH = 0;
      for (; tickValue <= ordinalExtent[1]; tickValue += step) {
        var width = 0;
        var height = 0;
        var rect = textContain.getBoundingRect(labelFormatter(tickValue), params.font, "center", "top");
        width = rect.width * 1.3;
        height = rect.height * 1.3;
        maxW = Math.max(maxW, width, 7);
        maxH = Math.max(maxH, height, 7);
      }
      var dw = maxW / unitW;
      var dh = maxH / unitH;
      isNaN(dw) && (dw = Infinity);
      isNaN(dh) && (dh = Infinity);
      var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
      var cache = inner(axis.model);
      var axisExtent = axis.getExtent();
      var lastAutoInterval = cache.lastAutoInterval;
      var lastTickCount = cache.lastTickCount;
      if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtend0 === axisExtent[0] && cache.axisExtend1 === axisExtent[1]) {
        interval = lastAutoInterval;
      } else {
        cache.lastTickCount = tickCount;
        cache.lastAutoInterval = interval;
        cache.axisExtend0 = axisExtent[0];
        cache.axisExtend1 = axisExtent[1];
      }
      return interval;
    }
    function fetchAutoCategoryIntervalCalculationParams(axis) {
      var labelModel = axis.getLabelModel();
      return {
        axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
        labelRotate: labelModel.get("rotate") || 0,
        font: labelModel.getFont()
      };
    }
    function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
      var labelFormatter = makeLabelFormatter(axis);
      var ordinalScale = axis.scale;
      var ordinalExtent = ordinalScale.getExtent();
      var labelModel = axis.getLabelModel();
      var result = [];
      var step = Math.max((categoryInterval || 0) + 1, 1);
      var startTick = ordinalExtent[0];
      var tickCount = ordinalScale.count();
      if (startTick !== 0 && step > 1 && tickCount / step > 2) {
        startTick = Math.round(Math.ceil(startTick / step) * step);
      }
      var showAllLabel = shouldShowAllLabels(axis);
      var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
      var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
      if (includeMinLabel && startTick !== ordinalExtent[0]) {
        addItem(ordinalExtent[0]);
      }
      var tickValue = startTick;
      for (; tickValue <= ordinalExtent[1]; tickValue += step) {
        addItem(tickValue);
      }
      if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
        addItem(ordinalExtent[1]);
      }
      function addItem(tVal) {
        result.push(onlyTick ? tVal : {
          formattedLabel: labelFormatter(tVal),
          rawLabel: ordinalScale.getLabel(tVal),
          tickValue: tVal
        });
      }
      return result;
    }
    function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
      var ordinalScale = axis.scale;
      var labelFormatter = makeLabelFormatter(axis);
      var result = [];
      zrUtil.each(ordinalScale.getTicks(), function(tickValue) {
        var rawLabel = ordinalScale.getLabel(tickValue);
        if (categoryInterval(tickValue, rawLabel)) {
          result.push(onlyTick ? tickValue : {
            formattedLabel: labelFormatter(tickValue),
            rawLabel,
            tickValue
          });
        }
      });
      return result;
    }
    exports.createAxisLabels = createAxisLabels;
    exports.createAxisTicks = createAxisTicks;
    exports.calculateCategoryInterval = calculateCategoryInterval;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/Axis.js
var require_Axis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/Axis.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var map = _util.map;
    var _number = require_number();
    var linearMap = _number.linearMap;
    var getPixelPrecision = _number.getPixelPrecision;
    var round = _number.round;
    var _axisTickLabelBuilder = require_axisTickLabelBuilder();
    var createAxisTicks = _axisTickLabelBuilder.createAxisTicks;
    var createAxisLabels = _axisTickLabelBuilder.createAxisLabels;
    var calculateCategoryInterval = _axisTickLabelBuilder.calculateCategoryInterval;
    var NORMALIZED_EXTENT = [0, 1];
    var Axis = function(dim, scale, extent) {
      this.dim = dim;
      this.scale = scale;
      this._extent = extent || [0, 0];
      this.inverse = false;
      this.onBand = false;
    };
    Axis.prototype = {
      constructor: Axis,
      /**
       * If axis extent contain given coord
       * @param {number} coord
       * @return {boolean}
       */
      contain: function(coord) {
        var extent = this._extent;
        var min = Math.min(extent[0], extent[1]);
        var max = Math.max(extent[0], extent[1]);
        return coord >= min && coord <= max;
      },
      /**
       * If axis extent contain given data
       * @param {number} data
       * @return {boolean}
       */
      containData: function(data) {
        return this.scale.contain(data);
      },
      /**
       * Get coord extent.
       * @return {Array.<number>}
       */
      getExtent: function() {
        return this._extent.slice();
      },
      /**
       * Get precision used for formatting
       * @param {Array.<number>} [dataExtent]
       * @return {number}
       */
      getPixelPrecision: function(dataExtent) {
        return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
      },
      /**
       * Set coord extent
       * @param {number} start
       * @param {number} end
       */
      setExtent: function(start, end) {
        var extent = this._extent;
        extent[0] = start;
        extent[1] = end;
      },
      /**
       * Convert data to coord. Data is the rank if it has an ordinal scale
       * @param {number} data
       * @param  {boolean} clamp
       * @return {number}
       */
      dataToCoord: function(data, clamp) {
        var extent = this._extent;
        var scale = this.scale;
        data = scale.normalize(data);
        if (this.onBand && scale.type === "ordinal") {
          extent = extent.slice();
          fixExtentWithBands(extent, scale.count());
        }
        return linearMap(data, NORMALIZED_EXTENT, extent, clamp);
      },
      /**
       * Convert coord to data. Data is the rank if it has an ordinal scale
       * @param {number} coord
       * @param  {boolean} clamp
       * @return {number}
       */
      coordToData: function(coord, clamp) {
        var extent = this._extent;
        var scale = this.scale;
        if (this.onBand && scale.type === "ordinal") {
          extent = extent.slice();
          fixExtentWithBands(extent, scale.count());
        }
        var t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);
        return this.scale.scale(t);
      },
      /**
       * Convert pixel point to data in axis
       * @param {Array.<number>} point
       * @param  {boolean} clamp
       * @return {number} data
       */
      pointToData: function(point, clamp) {
      },
      /**
       * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
       * `axis.getTicksCoords` considers `onBand`, which is used by
       * `boundaryGap:true` of category axis and splitLine and splitArea.
       * @param {Object} [opt]
       * @param {Model} [opt.tickModel=axis.model.getModel('axisTick')]
       * @param {boolean} [opt.clamp] If `true`, the first and the last
       *        tick must be at the axis end points. Otherwise, clip ticks
       *        that outside the axis extent.
       * @return {Array.<Object>} [{
       *     coord: ...,
       *     tickValue: ...
       * }, ...]
       */
      getTicksCoords: function(opt) {
        opt = opt || {};
        var tickModel = opt.tickModel || this.getTickModel();
        var result = createAxisTicks(this, tickModel);
        var ticks = result.ticks;
        var ticksCoords = map(ticks, function(tickValue) {
          return {
            coord: this.dataToCoord(tickValue),
            tickValue
          };
        }, this);
        var alignWithLabel = tickModel.get("alignWithLabel");
        fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
        return ticksCoords;
      },
      /**
       * @return {Array.<Array.<Object>>} [{ coord: ..., tickValue: ...}]
       */
      getMinorTicksCoords: function() {
        if (this.scale.type === "ordinal") {
          return [];
        }
        var minorTickModel = this.model.getModel("minorTick");
        var splitNumber = minorTickModel.get("splitNumber");
        if (!(splitNumber > 0 && splitNumber < 100)) {
          splitNumber = 5;
        }
        var minorTicks = this.scale.getMinorTicks(splitNumber);
        var minorTicksCoords = map(minorTicks, function(minorTicksGroup) {
          return map(minorTicksGroup, function(minorTick) {
            return {
              coord: this.dataToCoord(minorTick),
              tickValue: minorTick
            };
          }, this);
        }, this);
        return minorTicksCoords;
      },
      /**
       * @return {Array.<Object>} [{
       *     formattedLabel: string,
       *     rawLabel: axis.scale.getLabel(tickValue)
       *     tickValue: number
       * }, ...]
       */
      getViewLabels: function() {
        return createAxisLabels(this).labels;
      },
      /**
       * @return {module:echarts/coord/model/Model}
       */
      getLabelModel: function() {
        return this.model.getModel("axisLabel");
      },
      /**
       * Notice here we only get the default tick model. For splitLine
       * or splitArea, we should pass the splitLineModel or splitAreaModel
       * manually when calling `getTicksCoords`.
       * In GL, this method may be overrided to:
       * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
       * @return {module:echarts/coord/model/Model}
       */
      getTickModel: function() {
        return this.model.getModel("axisTick");
      },
      /**
       * Get width of band
       * @return {number}
       */
      getBandWidth: function() {
        var axisExtent = this._extent;
        var dataExtent = this.scale.getExtent();
        var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
        len === 0 && (len = 1);
        var size = Math.abs(axisExtent[1] - axisExtent[0]);
        return Math.abs(size) / len;
      },
      /**
       * @abstract
       * @return {boolean} Is horizontal
       */
      isHorizontal: null,
      /**
       * @abstract
       * @return {number} Get axis rotate, by degree.
       */
      getRotate: null,
      /**
       * Only be called in category axis.
       * Can be overrided, consider other axes like in 3D.
       * @return {number} Auto interval for cateogry axis tick and label
       */
      calculateCategoryInterval: function() {
        return calculateCategoryInterval(this);
      }
    };
    function fixExtentWithBands(extent, nTick) {
      var size = extent[1] - extent[0];
      var len = nTick;
      var margin = size / len / 2;
      extent[0] += margin;
      extent[1] -= margin;
    }
    function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {
      var ticksLen = ticksCoords.length;
      if (!axis.onBand || alignWithLabel || !ticksLen) {
        return;
      }
      var axisExtent = axis.getExtent();
      var last;
      var diffSize;
      if (ticksLen === 1) {
        ticksCoords[0].coord = axisExtent[0];
        last = ticksCoords[1] = {
          coord: axisExtent[0]
        };
      } else {
        var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
        var shift = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
        each(ticksCoords, function(ticksItem) {
          ticksItem.coord -= shift / 2;
        });
        var dataExtent = axis.scale.getExtent();
        diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
        last = {
          coord: ticksCoords[ticksLen - 1].coord + shift * diffSize
        };
        ticksCoords.push(last);
      }
      var inverse = axisExtent[0] > axisExtent[1];
      if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
        clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
      }
      if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
        ticksCoords.unshift({
          coord: axisExtent[0]
        });
      }
      if (littleThan(axisExtent[1], last.coord)) {
        clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
      }
      if (clamp && littleThan(last.coord, axisExtent[1])) {
        ticksCoords.push({
          coord: axisExtent[1]
        });
      }
      function littleThan(a, b) {
        a = round(a);
        b = round(b);
        return inverse ? a > b : a < b;
      }
    }
    var _default = Axis;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/export.js
var require_export = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/export.js"(exports) {
    var zrender = require_zrender();
    exports.zrender = zrender;
    var matrix = require_matrix();
    exports.matrix = matrix;
    var vector = require_vector();
    exports.vector = vector;
    var zrUtil = require_util();
    var colorTool = require_color();
    exports.color = colorTool;
    var graphicUtil = require_graphic();
    var numberUtil = require_number();
    exports.number = numberUtil;
    var formatUtil = require_format();
    exports.format = formatUtil;
    var _throttle = require_throttle();
    var throttle = _throttle.throttle;
    exports.throttle = _throttle.throttle;
    var ecHelper = require_helper2();
    exports.helper = ecHelper;
    var parseGeoJSON = require_parseGeoJson();
    exports.parseGeoJSON = parseGeoJSON;
    var _List = require_List();
    exports.List = _List;
    var _Model = require_Model();
    exports.Model = _Model;
    var _Axis = require_Axis();
    exports.Axis = _Axis;
    var _env = require_env();
    exports.env = _env;
    var parseGeoJson = parseGeoJSON;
    var ecUtil = {};
    zrUtil.each(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function(name2) {
      ecUtil[name2] = zrUtil[name2];
    });
    var graphic = {};
    zrUtil.each(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "registerShape", "getShapeClass", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function(name2) {
      graphic[name2] = graphicUtil[name2];
    });
    exports.parseGeoJson = parseGeoJson;
    exports.util = ecUtil;
    exports.graphic = graphic;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/echarts.js
var require_echarts = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/echarts.js"(exports) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrender = require_zrender();
    var zrUtil = require_util();
    var colorTool = require_color();
    var env = require_env();
    var timsort = require_timsort();
    var Eventful = require_Eventful();
    var GlobalModel = require_Global();
    var ExtensionAPI = require_ExtensionAPI();
    var CoordinateSystemManager = require_CoordinateSystem();
    var OptionManager = require_OptionManager();
    var backwardCompat = require_backwardCompat();
    var dataStack = require_dataStack();
    var ComponentModel = require_Component();
    var SeriesModel = require_Series();
    var ComponentView = require_Component2();
    var ChartView = require_Chart();
    var graphic = require_graphic();
    var modelUtil = require_model();
    var _throttle = require_throttle();
    var throttle = _throttle.throttle;
    var seriesColor = require_seriesColor();
    var aria = require_aria();
    var loadingDefault = require_default();
    var Scheduler = require_Scheduler();
    var lightTheme = require_light();
    var darkTheme = require_dark();
    require_dataset();
    var mapDataStorage = require_mapDataStorage();
    var assert = zrUtil.assert;
    var each = zrUtil.each;
    var isFunction = zrUtil.isFunction;
    var isObject = zrUtil.isObject;
    var parseClassType = ComponentModel.parseClassType;
    var version = "4.9.0";
    var dependencies = {
      zrender: "4.3.2"
    };
    var TEST_FRAME_REMAIN_TIME = 1;
    var PRIORITY_PROCESSOR_FILTER = 1e3;
    var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
    var PRIORITY_PROCESSOR_DATASTACK = 900;
    var PRIORITY_PROCESSOR_STATISTIC = 5e3;
    var PRIORITY_VISUAL_LAYOUT = 1e3;
    var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
    var PRIORITY_VISUAL_GLOBAL = 2e3;
    var PRIORITY_VISUAL_CHART = 3e3;
    var PRIORITY_VISUAL_POST_CHART_LAYOUT = 3500;
    var PRIORITY_VISUAL_COMPONENT = 4e3;
    var PRIORITY_VISUAL_BRUSH = 5e3;
    var PRIORITY = {
      PROCESSOR: {
        FILTER: PRIORITY_PROCESSOR_FILTER,
        SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
        STATISTIC: PRIORITY_PROCESSOR_STATISTIC
      },
      VISUAL: {
        LAYOUT: PRIORITY_VISUAL_LAYOUT,
        PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
        GLOBAL: PRIORITY_VISUAL_GLOBAL,
        CHART: PRIORITY_VISUAL_CHART,
        POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
        COMPONENT: PRIORITY_VISUAL_COMPONENT,
        BRUSH: PRIORITY_VISUAL_BRUSH
      }
    };
    var IN_MAIN_PROCESS = "__flagInMainProcess";
    var OPTION_UPDATED = "__optionUpdated";
    var ACTION_REG = /^[a-zA-Z0-9_]+$/;
    function createRegisterEventWithLowercaseName(method, ignoreDisposed) {
      return function(eventName, handler, context) {
        if (!ignoreDisposed && this._disposed) {
          disposedWarning(this.id);
          return;
        }
        eventName = eventName && eventName.toLowerCase();
        Eventful.prototype[method].call(this, eventName, handler, context);
      };
    }
    function MessageCenter() {
      Eventful.call(this);
    }
    MessageCenter.prototype.on = createRegisterEventWithLowercaseName("on", true);
    MessageCenter.prototype.off = createRegisterEventWithLowercaseName("off", true);
    MessageCenter.prototype.one = createRegisterEventWithLowercaseName("one", true);
    zrUtil.mixin(MessageCenter, Eventful);
    function ECharts(dom, theme, opts) {
      opts = opts || {};
      if (typeof theme === "string") {
        theme = themeStorage[theme];
      }
      this.id;
      this.group;
      this._dom = dom;
      var defaultRenderer = "canvas";
      var zr = this._zr = zrender.init(dom, {
        renderer: opts.renderer || defaultRenderer,
        devicePixelRatio: opts.devicePixelRatio,
        width: opts.width,
        height: opts.height
      });
      this._throttledZrFlush = throttle(zrUtil.bind(zr.flush, zr), 17);
      var theme = zrUtil.clone(theme);
      theme && backwardCompat(theme, true);
      this._theme = theme;
      this._chartsViews = [];
      this._chartsMap = {};
      this._componentsViews = [];
      this._componentsMap = {};
      this._coordSysMgr = new CoordinateSystemManager();
      var api = this._api = createExtensionAPI(this);
      function prioritySortFunc(a, b) {
        return a.__prio - b.__prio;
      }
      timsort(visualFuncs, prioritySortFunc);
      timsort(dataProcessorFuncs, prioritySortFunc);
      this._scheduler = new Scheduler(this, api, dataProcessorFuncs, visualFuncs);
      Eventful.call(this, this._ecEventProcessor = new EventProcessor());
      this._messageCenter = new MessageCenter();
      this._initEvents();
      this.resize = zrUtil.bind(this.resize, this);
      this._pendingActions = [];
      zr.animation.on("frame", this._onframe, this);
      bindRenderedEvent(zr, this);
      zrUtil.setAsPrimitive(this);
    }
    var echartsProto = ECharts.prototype;
    echartsProto._onframe = function() {
      if (this._disposed) {
        return;
      }
      var scheduler = this._scheduler;
      if (this[OPTION_UPDATED]) {
        var silent = this[OPTION_UPDATED].silent;
        this[IN_MAIN_PROCESS] = true;
        prepare(this);
        updateMethods.update.call(this);
        this[IN_MAIN_PROCESS] = false;
        this[OPTION_UPDATED] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      } else if (scheduler.unfinished) {
        var remainTime = TEST_FRAME_REMAIN_TIME;
        var ecModel = this._model;
        var api = this._api;
        scheduler.unfinished = false;
        do {
          var startTime = +/* @__PURE__ */ new Date();
          scheduler.performSeriesTasks(ecModel);
          scheduler.performDataProcessorTasks(ecModel);
          updateStreamModes(this, ecModel);
          scheduler.performVisualTasks(ecModel);
          renderSeries(this, this._model, api, "remain");
          remainTime -= +/* @__PURE__ */ new Date() - startTime;
        } while (remainTime > 0 && scheduler.unfinished);
        if (!scheduler.unfinished) {
          this._zr.flush();
        }
      }
    };
    echartsProto.getDom = function() {
      return this._dom;
    };
    echartsProto.getZr = function() {
      return this._zr;
    };
    echartsProto.setOption = function(option, notMerge, lazyUpdate) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var silent;
      if (isObject(notMerge)) {
        lazyUpdate = notMerge.lazyUpdate;
        silent = notMerge.silent;
        notMerge = notMerge.notMerge;
      }
      this[IN_MAIN_PROCESS] = true;
      if (!this._model || notMerge) {
        var optionManager = new OptionManager(this._api);
        var theme = this._theme;
        var ecModel = this._model = new GlobalModel();
        ecModel.scheduler = this._scheduler;
        ecModel.init(null, null, theme, optionManager);
      }
      this._model.setOption(option, optionPreprocessorFuncs);
      if (lazyUpdate) {
        this[OPTION_UPDATED] = {
          silent
        };
        this[IN_MAIN_PROCESS] = false;
      } else {
        prepare(this);
        updateMethods.update.call(this);
        this._zr.flush();
        this[OPTION_UPDATED] = false;
        this[IN_MAIN_PROCESS] = false;
        flushPendingActions.call(this, silent);
        triggerUpdatedEvent.call(this, silent);
      }
    };
    echartsProto.setTheme = function() {
      console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    };
    echartsProto.getModel = function() {
      return this._model;
    };
    echartsProto.getOption = function() {
      return this._model && this._model.getOption();
    };
    echartsProto.getWidth = function() {
      return this._zr.getWidth();
    };
    echartsProto.getHeight = function() {
      return this._zr.getHeight();
    };
    echartsProto.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || window.devicePixelRatio || 1;
    };
    echartsProto.getRenderedCanvas = function(opts) {
      if (!env.canvasSupported) {
        return;
      }
      opts = opts || {};
      opts.pixelRatio = opts.pixelRatio || 1;
      opts.backgroundColor = opts.backgroundColor || this._model.get("backgroundColor");
      var zr = this._zr;
      return zr.painter.getRenderedCanvas(opts);
    };
    echartsProto.getSvgDataURL = function() {
      if (!env.svgSupported) {
        return;
      }
      var zr = this._zr;
      var list = zr.storage.getDisplayList();
      zrUtil.each(list, function(el) {
        el.stopAnimation(true);
      });
      return zr.painter.toDataURL();
    };
    echartsProto.getDataURL = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      opts = opts || {};
      var excludeComponents = opts.excludeComponents;
      var ecModel = this._model;
      var excludesComponentViews = [];
      var self2 = this;
      each(excludeComponents, function(componentType) {
        ecModel.eachComponent({
          mainType: componentType
        }, function(component) {
          var view = self2._componentsMap[component.__viewId];
          if (!view.group.ignore) {
            excludesComponentViews.push(view);
            view.group.ignore = true;
          }
        });
      });
      var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.getRenderedCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
      each(excludesComponentViews, function(view) {
        view.group.ignore = false;
      });
      return url;
    };
    echartsProto.getConnectedDataURL = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (!env.canvasSupported) {
        return;
      }
      var isSvg = opts.type === "svg";
      var groupId = this.group;
      var mathMin = Math.min;
      var mathMax = Math.max;
      var MAX_NUMBER = Infinity;
      if (connectedGroups[groupId]) {
        var left = MAX_NUMBER;
        var top = MAX_NUMBER;
        var right = -MAX_NUMBER;
        var bottom = -MAX_NUMBER;
        var canvasList = [];
        var dpr = opts && opts.pixelRatio || 1;
        zrUtil.each(instances, function(chart, id) {
          if (chart.group === groupId) {
            var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.getRenderedCanvas(zrUtil.clone(opts));
            var boundingRect = chart.getDom().getBoundingClientRect();
            left = mathMin(boundingRect.left, left);
            top = mathMin(boundingRect.top, top);
            right = mathMax(boundingRect.right, right);
            bottom = mathMax(boundingRect.bottom, bottom);
            canvasList.push({
              dom: canvas,
              left: boundingRect.left,
              top: boundingRect.top
            });
          }
        });
        left *= dpr;
        top *= dpr;
        right *= dpr;
        bottom *= dpr;
        var width = right - left;
        var height = bottom - top;
        var targetCanvas = zrUtil.createCanvas();
        var zr = zrender.init(targetCanvas, {
          renderer: isSvg ? "svg" : "canvas"
        });
        zr.resize({
          width,
          height
        });
        if (isSvg) {
          var content = "";
          each(canvasList, function(item) {
            var x = item.left - left;
            var y = item.top - top;
            content += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
          });
          zr.painter.getSvgRoot().innerHTML = content;
          if (opts.connectedBackgroundColor) {
            zr.painter.setBackgroundColor(opts.connectedBackgroundColor);
          }
          zr.refreshImmediately();
          return zr.painter.toDataURL();
        } else {
          if (opts.connectedBackgroundColor) {
            zr.add(new graphic.Rect({
              shape: {
                x: 0,
                y: 0,
                width,
                height
              },
              style: {
                fill: opts.connectedBackgroundColor
              }
            }));
          }
          each(canvasList, function(item) {
            var img = new graphic.Image({
              style: {
                x: item.left * dpr - left,
                y: item.top * dpr - top,
                image: item.dom
              }
            });
            zr.add(img);
          });
          zr.refreshImmediately();
          return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
        }
      } else {
        return this.getDataURL(opts);
      }
    };
    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, "convertToPixel");
    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, "convertFromPixel");
    function doConvertPixel(methodName, finder, value) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var ecModel = this._model;
      var coordSysList = this._coordSysMgr.getCoordinateSystems();
      var result;
      finder = modelUtil.parseFinder(ecModel, finder);
      for (var i = 0; i < coordSysList.length; i++) {
        var coordSys = coordSysList[i];
        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
          return result;
        }
      }
    }
    echartsProto.containPixel = function(finder, value) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var ecModel = this._model;
      var result;
      finder = modelUtil.parseFinder(ecModel, finder);
      zrUtil.each(finder, function(models, key) {
        key.indexOf("Models") >= 0 && zrUtil.each(models, function(model) {
          var coordSys = model.coordinateSystem;
          if (coordSys && coordSys.containPoint) {
            result |= !!coordSys.containPoint(value);
          } else if (key === "seriesModels") {
            var view = this._chartsMap[model.__viewId];
            if (view && view.containPoint) {
              result |= view.containPoint(value, model);
            } else {
            }
          } else {
          }
        }, this);
      }, this);
      return !!result;
    };
    echartsProto.getVisual = function(finder, visualType) {
      var ecModel = this._model;
      finder = modelUtil.parseFinder(ecModel, finder, {
        defaultMainType: "series"
      });
      var seriesModel = finder.seriesModel;
      var data = seriesModel.getData();
      var dataIndexInside = finder.hasOwnProperty("dataIndexInside") ? finder.dataIndexInside : finder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(finder.dataIndex) : null;
      return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
    };
    echartsProto.getViewOfComponentModel = function(componentModel) {
      return this._componentsMap[componentModel.__viewId];
    };
    echartsProto.getViewOfSeriesModel = function(seriesModel) {
      return this._chartsMap[seriesModel.__viewId];
    };
    var updateMethods = {
      prepareAndUpdate: function(payload) {
        prepare(this);
        updateMethods.update.call(this, payload);
      },
      /**
       * @param {Object} payload
       * @private
       */
      update: function(payload) {
        var ecModel = this._model;
        var api = this._api;
        var zr = this._zr;
        var coordSysMgr = this._coordSysMgr;
        var scheduler = this._scheduler;
        if (!ecModel) {
          return;
        }
        scheduler.restoreData(ecModel, payload);
        scheduler.performSeriesTasks(ecModel);
        coordSysMgr.create(ecModel, api);
        scheduler.performDataProcessorTasks(ecModel, payload);
        updateStreamModes(this, ecModel);
        coordSysMgr.update(ecModel, api);
        clearColorPalette(ecModel);
        scheduler.performVisualTasks(ecModel, payload);
        render(this, ecModel, api, payload);
        var backgroundColor = ecModel.get("backgroundColor") || "transparent";
        if (!env.canvasSupported) {
          var colorArr = colorTool.parse(backgroundColor);
          backgroundColor = colorTool.stringify(colorArr, "rgb");
          if (colorArr[3] === 0) {
            backgroundColor = "transparent";
          }
        } else {
          zr.setBackgroundColor(backgroundColor);
        }
        performPostUpdateFuncs(ecModel, api);
      },
      /**
       * @param {Object} payload
       * @private
       */
      updateTransform: function(payload) {
        var ecModel = this._model;
        var ecIns = this;
        var api = this._api;
        if (!ecModel) {
          return;
        }
        var componentDirtyList = [];
        ecModel.eachComponent(function(componentType, componentModel) {
          var componentView = ecIns.getViewOfComponentModel(componentModel);
          if (componentView && componentView.__alive) {
            if (componentView.updateTransform) {
              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
              result && result.update && componentDirtyList.push(componentView);
            } else {
              componentDirtyList.push(componentView);
            }
          }
        });
        var seriesDirtyMap = zrUtil.createHashMap();
        ecModel.eachSeries(function(seriesModel) {
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.updateTransform) {
            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
          } else {
            seriesDirtyMap.set(seriesModel.uid, 1);
          }
        });
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true,
          dirtyMap: seriesDirtyMap
        });
        renderSeries(ecIns, ecModel, api, payload, seriesDirtyMap);
        performPostUpdateFuncs(ecModel, this._api);
      },
      /**
       * @param {Object} payload
       * @private
       */
      updateView: function(payload) {
        var ecModel = this._model;
        if (!ecModel) {
          return;
        }
        ChartView.markUpdateMethod(payload, "updateView");
        clearColorPalette(ecModel);
        this._scheduler.performVisualTasks(ecModel, payload, {
          setDirty: true
        });
        render(this, this._model, this._api, payload);
        performPostUpdateFuncs(ecModel, this._api);
      },
      /**
       * @param {Object} payload
       * @private
       */
      updateVisual: function(payload) {
        updateMethods.update.call(this, payload);
      },
      /**
       * @param {Object} payload
       * @private
       */
      updateLayout: function(payload) {
        updateMethods.update.call(this, payload);
      }
    };
    function prepare(ecIns) {
      var ecModel = ecIns._model;
      var scheduler = ecIns._scheduler;
      scheduler.restorePipelines(ecModel);
      scheduler.prepareStageTasks();
      prepareView(ecIns, "component", ecModel, scheduler);
      prepareView(ecIns, "chart", ecModel, scheduler);
      scheduler.plan();
    }
    function updateDirectly(ecIns, method, payload, mainType, subType) {
      var ecModel = ecIns._model;
      if (!mainType) {
        each(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
        return;
      }
      var query = {};
      query[mainType + "Id"] = payload[mainType + "Id"];
      query[mainType + "Index"] = payload[mainType + "Index"];
      query[mainType + "Name"] = payload[mainType + "Name"];
      var condition = {
        mainType,
        query
      };
      subType && (condition.subType = subType);
      var excludeSeriesId = payload.excludeSeriesId;
      if (excludeSeriesId != null) {
        excludeSeriesId = zrUtil.createHashMap(modelUtil.normalizeToArray(excludeSeriesId));
      }
      ecModel && ecModel.eachComponent(condition, function(model) {
        if (!excludeSeriesId || excludeSeriesId.get(model.id) == null) {
          callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
        }
      }, ecIns);
      function callView(view) {
        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
      }
    }
    echartsProto.resize = function(opts) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._zr.resize(opts);
      var ecModel = this._model;
      this._loadingFX && this._loadingFX.resize();
      if (!ecModel) {
        return;
      }
      var optionChanged = ecModel.resetOption("media");
      var silent = opts && opts.silent;
      this[IN_MAIN_PROCESS] = true;
      optionChanged && prepare(this);
      updateMethods.update.call(this);
      this[IN_MAIN_PROCESS] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    };
    function updateStreamModes(ecIns, ecModel) {
      var chartsMap = ecIns._chartsMap;
      var scheduler = ecIns._scheduler;
      ecModel.eachSeries(function(seriesModel) {
        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
      });
    }
    echartsProto.showLoading = function(name2, cfg) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (isObject(name2)) {
        cfg = name2;
        name2 = "";
      }
      name2 = name2 || "default";
      this.hideLoading();
      if (!loadingEffects[name2]) {
        return;
      }
      var el = loadingEffects[name2](this._api, cfg);
      var zr = this._zr;
      this._loadingFX = el;
      zr.add(el);
    };
    echartsProto.hideLoading = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX);
      this._loadingFX = null;
    };
    echartsProto.makeActionFromEvent = function(eventObj) {
      var payload = zrUtil.extend({}, eventObj);
      payload.type = eventActionMap[eventObj.type];
      return payload;
    };
    echartsProto.dispatchAction = function(payload, opt) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      if (!isObject(opt)) {
        opt = {
          silent: !!opt
        };
      }
      if (!actions[payload.type]) {
        return;
      }
      if (!this._model) {
        return;
      }
      if (this[IN_MAIN_PROCESS]) {
        this._pendingActions.push(payload);
        return;
      }
      doDispatchAction.call(this, payload, opt.silent);
      if (opt.flush) {
        this._zr.flush(true);
      } else if (opt.flush !== false && env.browser.weChat) {
        this._throttledZrFlush();
      }
      flushPendingActions.call(this, opt.silent);
      triggerUpdatedEvent.call(this, opt.silent);
    };
    function doDispatchAction(payload, silent) {
      var payloadType = payload.type;
      var escapeConnect = payload.escapeConnect;
      var actionWrap = actions[payloadType];
      var actionInfo = actionWrap.actionInfo;
      var cptType = (actionInfo.update || "update").split(":");
      var updateMethod = cptType.pop();
      cptType = cptType[0] != null && parseClassType(cptType[0]);
      this[IN_MAIN_PROCESS] = true;
      var payloads = [payload];
      var batched = false;
      if (payload.batch) {
        batched = true;
        payloads = zrUtil.map(payload.batch, function(item) {
          item = zrUtil.defaults(zrUtil.extend({}, item), payload);
          item.batch = null;
          return item;
        });
      }
      var eventObjBatch = [];
      var eventObj;
      var isHighDown = payloadType === "highlight" || payloadType === "downplay";
      each(payloads, function(batchItem) {
        eventObj = actionWrap.action(batchItem, this._model, this._api);
        eventObj = eventObj || zrUtil.extend({}, batchItem);
        eventObj.type = actionInfo.event || eventObj.type;
        eventObjBatch.push(eventObj);
        if (isHighDown) {
          updateDirectly(this, updateMethod, batchItem, "series");
        } else if (cptType) {
          updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
        }
      }, this);
      if (updateMethod !== "none" && !isHighDown && !cptType) {
        if (this[OPTION_UPDATED]) {
          prepare(this);
          updateMethods.update.call(this, payload);
          this[OPTION_UPDATED] = false;
        } else {
          updateMethods[updateMethod].call(this, payload);
        }
      }
      if (batched) {
        eventObj = {
          type: actionInfo.event || payloadType,
          escapeConnect,
          batch: eventObjBatch
        };
      } else {
        eventObj = eventObjBatch[0];
      }
      this[IN_MAIN_PROCESS] = false;
      !silent && this._messageCenter.trigger(eventObj.type, eventObj);
    }
    function flushPendingActions(silent) {
      var pendingActions = this._pendingActions;
      while (pendingActions.length) {
        var payload = pendingActions.shift();
        doDispatchAction.call(this, payload, silent);
      }
    }
    function triggerUpdatedEvent(silent) {
      !silent && this.trigger("updated");
    }
    function bindRenderedEvent(zr, ecIns) {
      zr.on("rendered", function() {
        ecIns.trigger("rendered");
        if (
          // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          zr.animation.isFinished() && !ecIns[OPTION_UPDATED] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length
        ) {
          ecIns.trigger("finished");
        }
      });
    }
    echartsProto.appendData = function(params) {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      var seriesIndex = params.seriesIndex;
      var ecModel = this.getModel();
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      seriesModel.appendData(params);
      this._scheduler.unfinished = true;
    };
    echartsProto.on = createRegisterEventWithLowercaseName("on", false);
    echartsProto.off = createRegisterEventWithLowercaseName("off", false);
    echartsProto.one = createRegisterEventWithLowercaseName("one", false);
    function prepareView(ecIns, type, ecModel, scheduler) {
      var isComponent = type === "component";
      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
      var zr = ecIns._zr;
      var api = ecIns._api;
      for (var i = 0; i < viewList.length; i++) {
        viewList[i].__alive = false;
      }
      isComponent ? ecModel.eachComponent(function(componentType, model) {
        componentType !== "series" && doPrepare(model);
      }) : ecModel.eachSeries(doPrepare);
      function doPrepare(model) {
        var viewId = "_ec_" + model.id + "_" + model.type;
        var view2 = viewMap[viewId];
        if (!view2) {
          var classType = parseClassType(model.type);
          var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);
          view2 = new Clazz();
          view2.init(ecModel, api);
          viewMap[viewId] = view2;
          viewList.push(view2);
          zr.add(view2.group);
        }
        model.__viewId = view2.__id = viewId;
        view2.__alive = true;
        view2.__model = model;
        view2.group.__ecComponentInfo = {
          mainType: model.mainType,
          index: model.componentIndex
        };
        !isComponent && scheduler.prepareView(view2, model, ecModel, api);
      }
      for (var i = 0; i < viewList.length; ) {
        var view = viewList[i];
        if (!view.__alive) {
          !isComponent && view.renderTask.dispose();
          zr.remove(view.group);
          view.dispose(ecModel, api);
          viewList.splice(i, 1);
          delete viewMap[view.__id];
          view.__id = view.group.__ecComponentInfo = null;
        } else {
          i++;
        }
      }
    }
    function clearColorPalette(ecModel) {
      ecModel.clearColorPalette();
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.clearColorPalette();
      });
    }
    function render(ecIns, ecModel, api, payload) {
      renderComponents(ecIns, ecModel, api, payload);
      each(ecIns._chartsViews, function(chart) {
        chart.__alive = false;
      });
      renderSeries(ecIns, ecModel, api, payload);
      each(ecIns._chartsViews, function(chart) {
        if (!chart.__alive) {
          chart.remove(ecModel, api);
        }
      });
    }
    function renderComponents(ecIns, ecModel, api, payload, dirtyList) {
      each(dirtyList || ecIns._componentsViews, function(componentView) {
        var componentModel = componentView.__model;
        componentView.render(componentModel, ecModel, api, payload);
        updateZ(componentModel, componentView);
      });
    }
    function renderSeries(ecIns, ecModel, api, payload, dirtyMap) {
      var scheduler = ecIns._scheduler;
      var unfinished;
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        chartView.__alive = true;
        var renderTask = chartView.renderTask;
        scheduler.updatePayload(renderTask, payload);
        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
          renderTask.dirty();
        }
        unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask));
        chartView.group.silent = !!seriesModel.get("silent");
        updateZ(seriesModel, chartView);
        updateBlend(seriesModel, chartView);
      });
      scheduler.unfinished |= unfinished;
      updateHoverLayerStatus(ecIns, ecModel);
      aria(ecIns._zr.dom, ecModel);
    }
    function performPostUpdateFuncs(ecModel, api) {
      each(postUpdateFuncs, function(func) {
        func(ecModel, api);
      });
    }
    var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
    echartsProto._initEvents = function() {
      each(MOUSE_EVENT_NAMES, function(eveName) {
        var handler = function(e) {
          var ecModel = this.getModel();
          var el = e.target;
          var params;
          var isGlobalOut = eveName === "globalout";
          if (isGlobalOut) {
            params = {};
          } else if (el && el.dataIndex != null) {
            var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
            params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType, el) || {};
          } else if (el && el.eventData) {
            params = zrUtil.extend({}, el.eventData);
          }
          if (params) {
            var componentType = params.componentType;
            var componentIndex = params.componentIndex;
            if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
              componentType = "series";
              componentIndex = params.seriesIndex;
            }
            var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
            var view = model && this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
            params.event = e;
            params.type = eveName;
            this._ecEventProcessor.eventInfo = {
              targetEl: el,
              packedEvent: params,
              model,
              view
            };
            this.trigger(eveName, params);
          }
        };
        handler.zrEventfulCallAtLast = true;
        this._zr.on(eveName, handler, this);
      }, this);
      each(eventActionMap, function(actionType, eventType) {
        this._messageCenter.on(eventType, function(event) {
          this.trigger(eventType, event);
        }, this);
      }, this);
    };
    echartsProto.isDisposed = function() {
      return this._disposed;
    };
    echartsProto.clear = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this.setOption({
        series: []
      }, true);
    };
    echartsProto.dispose = function() {
      if (this._disposed) {
        disposedWarning(this.id);
        return;
      }
      this._disposed = true;
      modelUtil.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
      var api = this._api;
      var ecModel = this._model;
      each(this._componentsViews, function(component) {
        component.dispose(ecModel, api);
      });
      each(this._chartsViews, function(chart) {
        chart.dispose(ecModel, api);
      });
      this._zr.dispose();
      delete instances[this.id];
    };
    zrUtil.mixin(ECharts, Eventful);
    function disposedWarning(id) {
    }
    function updateHoverLayerStatus(ecIns, ecModel) {
      var zr = ecIns._zr;
      var storage = zr.storage;
      var elCount = 0;
      storage.traverse(function(el) {
        elCount++;
      });
      if (elCount > ecModel.get("hoverLayerThreshold") && !env.node) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.preventUsingHoverLayer) {
            return;
          }
          var chartView = ecIns._chartsMap[seriesModel.__viewId];
          if (chartView.__alive) {
            chartView.group.traverse(function(el) {
              el.useHoverLayer = true;
            });
          }
        });
      }
    }
    function updateBlend(seriesModel, chartView) {
      var blendMode = seriesModel.get("blendMode") || null;
      chartView.group.traverse(function(el) {
        if (!el.isGroup) {
          if (el.style.blend !== blendMode) {
            el.setStyle("blend", blendMode);
          }
        }
        if (el.eachPendingDisplayable) {
          el.eachPendingDisplayable(function(displayable) {
            displayable.setStyle("blend", blendMode);
          });
        }
      });
    }
    function updateZ(model, view) {
      var z = model.get("z");
      var zlevel = model.get("zlevel");
      view.group.traverse(function(el) {
        if (el.type !== "group") {
          z != null && (el.z = z);
          zlevel != null && (el.zlevel = zlevel);
        }
      });
    }
    function createExtensionAPI(ecInstance) {
      var coordSysMgr = ecInstance._coordSysMgr;
      return zrUtil.extend(new ExtensionAPI(ecInstance), {
        // Inject methods
        getCoordinateSystems: zrUtil.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
        getComponentByElement: function(el) {
          while (el) {
            var modelInfo = el.__ecComponentInfo;
            if (modelInfo != null) {
              return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
            }
            el = el.parent;
          }
        }
      });
    }
    function EventProcessor() {
      this.eventInfo;
    }
    EventProcessor.prototype = {
      constructor: EventProcessor,
      normalizeQuery: function(query) {
        var cptQuery = {};
        var dataQuery = {};
        var otherQuery = {};
        if (zrUtil.isString(query)) {
          var condCptType = parseClassType(query);
          cptQuery.mainType = condCptType.main || null;
          cptQuery.subType = condCptType.sub || null;
        } else {
          var suffixes = ["Index", "Name", "Id"];
          var dataKeys = {
            name: 1,
            dataIndex: 1,
            dataType: 1
          };
          zrUtil.each(query, function(val, key) {
            var reserved = false;
            for (var i = 0; i < suffixes.length; i++) {
              var propSuffix = suffixes[i];
              var suffixPos = key.lastIndexOf(propSuffix);
              if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
                var mainType = key.slice(0, suffixPos);
                if (mainType !== "data") {
                  cptQuery.mainType = mainType;
                  cptQuery[propSuffix.toLowerCase()] = val;
                  reserved = true;
                }
              }
            }
            if (dataKeys.hasOwnProperty(key)) {
              dataQuery[key] = val;
              reserved = true;
            }
            if (!reserved) {
              otherQuery[key] = val;
            }
          });
        }
        return {
          cptQuery,
          dataQuery,
          otherQuery
        };
      },
      filter: function(eventType, query, args) {
        var eventInfo = this.eventInfo;
        if (!eventInfo) {
          return true;
        }
        var targetEl = eventInfo.targetEl;
        var packedEvent = eventInfo.packedEvent;
        var model = eventInfo.model;
        var view = eventInfo.view;
        if (!model || !view) {
          return true;
        }
        var cptQuery = query.cptQuery;
        var dataQuery = query.dataQuery;
        return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
        function check(query2, host, prop, propOnHost) {
          return query2[prop] == null || host[propOnHost || prop] === query2[prop];
        }
      },
      afterTrigger: function() {
        this.eventInfo = null;
      }
    };
    var actions = {};
    var eventActionMap = {};
    var dataProcessorFuncs = [];
    var optionPreprocessorFuncs = [];
    var postUpdateFuncs = [];
    var visualFuncs = [];
    var themeStorage = {};
    var loadingEffects = {};
    var instances = {};
    var connectedGroups = {};
    var idBase = /* @__PURE__ */ new Date() - 0;
    var groupIdBase = /* @__PURE__ */ new Date() - 0;
    var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
    function enableConnect(chart) {
      var STATUS_PENDING = 0;
      var STATUS_UPDATING = 1;
      var STATUS_UPDATED = 2;
      var STATUS_KEY = "__connectUpdateStatus";
      function updateConnectedChartsStatus(charts, status) {
        for (var i = 0; i < charts.length; i++) {
          var otherChart = charts[i];
          otherChart[STATUS_KEY] = status;
        }
      }
      each(eventActionMap, function(actionType, eventType) {
        chart._messageCenter.on(eventType, function(event) {
          if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
            if (event && event.escapeConnect) {
              return;
            }
            var action = chart.makeActionFromEvent(event);
            var otherCharts = [];
            each(instances, function(otherChart) {
              if (otherChart !== chart && otherChart.group === chart.group) {
                otherCharts.push(otherChart);
              }
            });
            updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
            each(otherCharts, function(otherChart) {
              if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
                otherChart.dispatchAction(action);
              }
            });
            updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
          }
        });
      });
    }
    function init(dom, theme, opts) {
      var existInstance = getInstanceByDom(dom);
      if (existInstance) {
        return existInstance;
      }
      var chart = new ECharts(dom, theme, opts);
      chart.id = "ec_" + idBase++;
      instances[chart.id] = chart;
      modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
      enableConnect(chart);
      return chart;
    }
    function connect(groupId) {
      if (zrUtil.isArray(groupId)) {
        var charts = groupId;
        groupId = null;
        each(charts, function(chart) {
          if (chart.group != null) {
            groupId = chart.group;
          }
        });
        groupId = groupId || "g_" + groupIdBase++;
        each(charts, function(chart) {
          chart.group = groupId;
        });
      }
      connectedGroups[groupId] = true;
      return groupId;
    }
    function disConnect(groupId) {
      connectedGroups[groupId] = false;
    }
    var disconnect = disConnect;
    function dispose(chart) {
      if (typeof chart === "string") {
        chart = instances[chart];
      } else if (!(chart instanceof ECharts)) {
        chart = getInstanceByDom(chart);
      }
      if (chart instanceof ECharts && !chart.isDisposed()) {
        chart.dispose();
      }
    }
    function getInstanceByDom(dom) {
      return instances[modelUtil.getAttribute(dom, DOM_ATTRIBUTE_KEY)];
    }
    function getInstanceById(key) {
      return instances[key];
    }
    function registerTheme(name2, theme) {
      themeStorage[name2] = theme;
    }
    function registerPreprocessor(preprocessorFunc) {
      optionPreprocessorFuncs.push(preprocessorFunc);
    }
    function registerProcessor(priority, processor) {
      normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_FILTER);
    }
    function registerPostUpdate(postUpdateFunc) {
      postUpdateFuncs.push(postUpdateFunc);
    }
    function registerAction(actionInfo, eventName, action) {
      if (typeof eventName === "function") {
        action = eventName;
        eventName = "";
      }
      var actionType = isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
        event: eventName
      }][0];
      actionInfo.event = (actionInfo.event || actionType).toLowerCase();
      eventName = actionInfo.event;
      assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
      if (!actions[actionType]) {
        actions[actionType] = {
          action,
          actionInfo
        };
      }
      eventActionMap[eventName] = actionType;
    }
    function registerCoordinateSystem(type, CoordinateSystem) {
      CoordinateSystemManager.register(type, CoordinateSystem);
    }
    function getCoordinateSystemDimensions(type) {
      var coordSysCreator = CoordinateSystemManager.get(type);
      if (coordSysCreator) {
        return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
      }
    }
    function registerLayout(priority, layoutTask) {
      normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
    }
    function registerVisual(priority, visualTask) {
      normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
    }
    function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
      if (isFunction(priority) || isObject(priority)) {
        fn = priority;
        priority = defaultPriority;
      }
      var stageHandler = Scheduler.wrapStageHandler(fn, visualType);
      stageHandler.__prio = priority;
      stageHandler.__raw = fn;
      targetList.push(stageHandler);
      return stageHandler;
    }
    function registerLoading(name2, loadingFx) {
      loadingEffects[name2] = loadingFx;
    }
    function extendComponentModel(opts) {
      return ComponentModel.extend(opts);
    }
    function extendComponentView(opts) {
      return ComponentView.extend(opts);
    }
    function extendSeriesModel(opts) {
      return SeriesModel.extend(opts);
    }
    function extendChartView(opts) {
      return ChartView.extend(opts);
    }
    function setCanvasCreator(creator) {
      zrUtil.$override("createCanvas", creator);
    }
    function registerMap(mapName, geoJson, specialAreas) {
      mapDataStorage.registerMap(mapName, geoJson, specialAreas);
    }
    function getMap(mapName) {
      var records = mapDataStorage.retrieveMap(mapName);
      return records && records[0] && {
        geoJson: records[0].geoJSON,
        specialAreas: records[0].specialAreas
      };
    }
    registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor);
    registerPreprocessor(backwardCompat);
    registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
    registerLoading("default", loadingDefault);
    registerAction({
      type: "highlight",
      event: "highlight",
      update: "highlight"
    }, zrUtil.noop);
    registerAction({
      type: "downplay",
      event: "downplay",
      update: "downplay"
    }, zrUtil.noop);
    registerTheme("light", lightTheme);
    registerTheme("dark", darkTheme);
    var dataTool = {};
    exports.version = version;
    exports.dependencies = dependencies;
    exports.PRIORITY = PRIORITY;
    exports.init = init;
    exports.connect = connect;
    exports.disConnect = disConnect;
    exports.disconnect = disconnect;
    exports.dispose = dispose;
    exports.getInstanceByDom = getInstanceByDom;
    exports.getInstanceById = getInstanceById;
    exports.registerTheme = registerTheme;
    exports.registerPreprocessor = registerPreprocessor;
    exports.registerProcessor = registerProcessor;
    exports.registerPostUpdate = registerPostUpdate;
    exports.registerAction = registerAction;
    exports.registerCoordinateSystem = registerCoordinateSystem;
    exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
    exports.registerLayout = registerLayout;
    exports.registerVisual = registerVisual;
    exports.registerLoading = registerLoading;
    exports.extendComponentModel = extendComponentModel;
    exports.extendComponentView = extendComponentView;
    exports.extendSeriesModel = extendSeriesModel;
    exports.extendChartView = extendChartView;
    exports.setCanvasCreator = setCanvasCreator;
    exports.registerMap = registerMap;
    exports.getMap = getMap;
    exports.dataTool = dataTool;
    var ___ec_export = require_export();
    (function() {
      for (var key in ___ec_export) {
        if (___ec_export.hasOwnProperty(key)) {
          exports[key] = ___ec_export[key];
        }
      }
    })();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineSeries.js
var require_LineSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineSeries.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var createListFromArray = require_createListFromArray();
    var SeriesModel = require_Series();
    var _default = SeriesModel.extend({
      type: "series.line",
      dependencies: ["grid", "polar"],
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        hoverAnimation: true,
        // stack: null
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // polarIndex: 0,
        // If clip the overflow value
        clip: true,
        // cursor: null,
        label: {
          position: "top"
        },
        // itemStyle: {
        // },
        lineStyle: {
          width: 2,
          type: "solid"
        },
        // areaStyle: {
        // origin of areaStyle. Valid values:
        // `'auto'/null/undefined`: from axisLine to data
        // `'start'`: from min to data
        // `'end'`: from data to max
        // origin: 'auto'
        // },
        // false, 'start', 'end', 'middle'
        step: false,
        // Disabled if step is true
        smooth: false,
        smoothMonotone: null,
        symbol: "emptyCircle",
        symbolSize: 4,
        symbolRotate: null,
        showSymbol: true,
        // `false`: follow the label interval strategy.
        // `true`: show all symbols.
        // `'auto'`: If possible, show all symbols, otherwise
        //           follow the label interval strategy.
        showAllSymbol: "auto",
        // Whether to connect break point.
        connectNulls: false,
        // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.
        sampling: "none",
        animationEasing: "linear",
        // Disable progressive
        progressive: 0,
        hoverLayerThreshold: Infinity
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/labelHelper.js
var require_labelHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/labelHelper.js"(exports) {
    var _dataProvider = require_dataProvider();
    var retrieveRawValue = _dataProvider.retrieveRawValue;
    function getDefaultLabel(data, dataIndex) {
      var labelDims = data.mapDimension("defaultedLabel", true);
      var len = labelDims.length;
      if (len === 1) {
        return retrieveRawValue(data, dataIndex, labelDims[0]);
      } else if (len) {
        var vals = [];
        for (var i = 0; i < labelDims.length; i++) {
          var val = retrieveRawValue(data, dataIndex, labelDims[i]);
          vals.push(val);
        }
        return vals.join(" ");
      }
    }
    exports.getDefaultLabel = getDefaultLabel;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Symbol.js
var require_Symbol = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Symbol.js"(exports, module) {
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var graphic = require_graphic();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _labelHelper = require_labelHelper();
    var getDefaultLabel = _labelHelper.getDefaultLabel;
    function SymbolClz(data, idx, seriesScope) {
      graphic.Group.call(this);
      this.updateData(data, idx, seriesScope);
    }
    var symbolProto = SymbolClz.prototype;
    var getSymbolSize = SymbolClz.getSymbolSize = function(data, idx) {
      var symbolSize = data.getItemVisual(idx, "symbolSize");
      return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
    };
    function getScale(symbolSize) {
      return [symbolSize[0] / 2, symbolSize[1] / 2];
    }
    function driftSymbol(dx, dy) {
      this.parent.drift(dx, dy);
    }
    symbolProto._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
      this.removeAll();
      var color = data.getItemVisual(idx, "color");
      var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);
      symbolPath.attr({
        z2: 100,
        culling: true,
        scale: getScale(symbolSize)
      });
      symbolPath.drift = driftSymbol;
      this._symbolType = symbolType;
      this.add(symbolPath);
    };
    symbolProto.stopSymbolAnimation = function(toLastFrame) {
      this.childAt(0).stopAnimation(toLastFrame);
    };
    symbolProto.getSymbolPath = function() {
      return this.childAt(0);
    };
    symbolProto.getScale = function() {
      return this.childAt(0).scale;
    };
    symbolProto.highlight = function() {
      this.childAt(0).trigger("emphasis");
    };
    symbolProto.downplay = function() {
      this.childAt(0).trigger("normal");
    };
    symbolProto.setZ = function(zlevel, z) {
      var symbolPath = this.childAt(0);
      symbolPath.zlevel = zlevel;
      symbolPath.z = z;
    };
    symbolProto.setDraggable = function(draggable) {
      var symbolPath = this.childAt(0);
      symbolPath.draggable = draggable;
      symbolPath.cursor = draggable ? "move" : symbolPath.cursor;
    };
    symbolProto.updateData = function(data, idx, seriesScope) {
      this.silent = false;
      var symbolType = data.getItemVisual(idx, "symbol") || "circle";
      var seriesModel = data.hostModel;
      var symbolSize = getSymbolSize(data, idx);
      var isInit = symbolType !== this._symbolType;
      if (isInit) {
        var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
        this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
      } else {
        var symbolPath = this.childAt(0);
        symbolPath.silent = false;
        graphic.updateProps(symbolPath, {
          scale: getScale(symbolSize)
        }, seriesModel, idx);
      }
      this._updateCommon(data, idx, symbolSize, seriesScope);
      if (isInit) {
        var symbolPath = this.childAt(0);
        var fadeIn = seriesScope && seriesScope.fadeIn;
        var target = {
          scale: symbolPath.scale.slice()
        };
        fadeIn && (target.style = {
          opacity: symbolPath.style.opacity
        });
        symbolPath.scale = [0, 0];
        fadeIn && (symbolPath.style.opacity = 0);
        graphic.initProps(symbolPath, target, seriesModel, idx);
      }
      this._seriesModel = seriesModel;
    };
    var normalStyleAccessPath = ["itemStyle"];
    var emphasisStyleAccessPath = ["emphasis", "itemStyle"];
    var normalLabelAccessPath = ["label"];
    var emphasisLabelAccessPath = ["emphasis", "label"];
    symbolProto._updateCommon = function(data, idx, symbolSize, seriesScope) {
      var symbolPath = this.childAt(0);
      var seriesModel = data.hostModel;
      var color = data.getItemVisual(idx, "color");
      if (symbolPath.type !== "image") {
        symbolPath.useStyle({
          strokeNoScale: true
        });
      } else {
        symbolPath.setStyle({
          opacity: 1,
          shadowBlur: null,
          shadowOffsetX: null,
          shadowOffsetY: null,
          shadowColor: null
        });
      }
      var itemStyle = seriesScope && seriesScope.itemStyle;
      var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
      var symbolOffset = seriesScope && seriesScope.symbolOffset;
      var labelModel = seriesScope && seriesScope.labelModel;
      var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
      var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
      var cursorStyle = seriesScope && seriesScope.cursorStyle;
      if (!seriesScope || data.hasItemOption) {
        var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
        itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(["color"]);
        hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
        symbolOffset = itemModel.getShallow("symbolOffset");
        labelModel = itemModel.getModel(normalLabelAccessPath);
        hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
        hoverAnimation = itemModel.getShallow("hoverAnimation");
        cursorStyle = itemModel.getShallow("cursor");
      } else {
        hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
      }
      var elStyle = symbolPath.style;
      var symbolRotate = data.getItemVisual(idx, "symbolRotate");
      symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
      if (symbolOffset) {
        symbolPath.attr("position", [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);
      }
      cursorStyle && symbolPath.attr("cursor", cursorStyle);
      symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);
      symbolPath.setStyle(itemStyle);
      var opacity = data.getItemVisual(idx, "opacity");
      if (opacity != null) {
        elStyle.opacity = opacity;
      }
      var liftZ = data.getItemVisual(idx, "liftZ");
      var z2Origin = symbolPath.__z2Origin;
      if (liftZ != null) {
        if (z2Origin == null) {
          symbolPath.__z2Origin = symbolPath.z2;
          symbolPath.z2 += liftZ;
        }
      } else if (z2Origin != null) {
        symbolPath.z2 = z2Origin;
        symbolPath.__z2Origin = null;
      }
      var useNameLabel = seriesScope && seriesScope.useNameLabel;
      graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultText: getLabelDefaultText,
        isRectText: true,
        autoColor: color
      });
      function getLabelDefaultText(idx2, opt) {
        return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
      }
      symbolPath.__symbolOriginalScale = getScale(symbolSize);
      symbolPath.hoverStyle = hoverItemStyle;
      symbolPath.highDownOnUpdate = hoverAnimation && seriesModel.isAnimationEnabled() ? highDownOnUpdate : null;
      graphic.setHoverStyle(symbolPath);
    };
    function highDownOnUpdate(fromState, toState) {
      if (this.incremental || this.useHoverLayer) {
        return;
      }
      if (toState === "emphasis") {
        var scale = this.__symbolOriginalScale;
        var ratio = scale[1] / scale[0];
        var emphasisOpt = {
          scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
        };
        this.animateTo(emphasisOpt, 400, "elasticOut");
      } else if (toState === "normal") {
        this.animateTo({
          scale: this.__symbolOriginalScale
        }, 400, "elasticOut");
      }
    }
    symbolProto.fadeOut = function(cb, opt) {
      var symbolPath = this.childAt(0);
      this.silent = symbolPath.silent = true;
      !(opt && opt.keepLabel) && (symbolPath.style.text = null);
      graphic.updateProps(symbolPath, {
        style: {
          opacity: 0
        },
        scale: [0, 0]
      }, this._seriesModel, this.dataIndex, cb);
    };
    zrUtil.inherits(SymbolClz, graphic.Group);
    var _default = SymbolClz;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/SymbolDraw.js
var require_SymbolDraw = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/SymbolDraw.js"(exports, module) {
    var graphic = require_graphic();
    var SymbolClz = require_Symbol();
    var _util = require_util();
    var isObject = _util.isObject;
    function SymbolDraw(symbolCtor) {
      this.group = new graphic.Group();
      this._symbolCtor = symbolCtor || SymbolClz;
    }
    var symbolDrawProto = SymbolDraw.prototype;
    function symbolNeedsDraw(data, point, idx, opt) {
      return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
    }
    symbolDrawProto.updateData = function(data, opt) {
      opt = normalizeUpdateOpt(opt);
      var group = this.group;
      var seriesModel = data.hostModel;
      var oldData = this._data;
      var SymbolCtor = this._symbolCtor;
      var seriesScope = makeSeriesScope(data);
      if (!oldData) {
        group.removeAll();
      }
      data.diff(oldData).add(function(newIdx) {
        var point = data.getItemLayout(newIdx);
        if (symbolNeedsDraw(data, point, newIdx, opt)) {
          var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
          symbolEl.attr("position", point);
          data.setItemGraphicEl(newIdx, symbolEl);
          group.add(symbolEl);
        }
      }).update(function(newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        var point = data.getItemLayout(newIdx);
        if (!symbolNeedsDraw(data, point, newIdx, opt)) {
          group.remove(symbolEl);
          return;
        }
        if (!symbolEl) {
          symbolEl = new SymbolCtor(data, newIdx);
          symbolEl.attr("position", point);
        } else {
          symbolEl.updateData(data, newIdx, seriesScope);
          graphic.updateProps(symbolEl, {
            position: point
          }, seriesModel);
        }
        group.add(symbolEl);
        data.setItemGraphicEl(newIdx, symbolEl);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && el.fadeOut(function() {
          group.remove(el);
        });
      }).execute();
      this._data = data;
    };
    symbolDrawProto.isPersistent = function() {
      return true;
    };
    symbolDrawProto.updateLayout = function() {
      var data = this._data;
      if (data) {
        data.eachItemGraphicEl(function(el, idx) {
          var point = data.getItemLayout(idx);
          el.attr("position", point);
        });
      }
    };
    symbolDrawProto.incrementalPrepareUpdate = function(data) {
      this._seriesScope = makeSeriesScope(data);
      this._data = null;
      this.group.removeAll();
    };
    symbolDrawProto.incrementalUpdate = function(taskParams, data, opt) {
      opt = normalizeUpdateOpt(opt);
      function updateIncrementalAndHover(el2) {
        if (!el2.isGroup) {
          el2.incremental = el2.useHoverLayer = true;
        }
      }
      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var point = data.getItemLayout(idx);
        if (symbolNeedsDraw(data, point, idx, opt)) {
          var el = new this._symbolCtor(data, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          el.attr("position", point);
          this.group.add(el);
          data.setItemGraphicEl(idx, el);
        }
      }
    };
    function normalizeUpdateOpt(opt) {
      if (opt != null && !isObject(opt)) {
        opt = {
          isIgnore: opt
        };
      }
      return opt || {};
    }
    symbolDrawProto.remove = function(enableAnimation) {
      var group = this.group;
      var data = this._data;
      if (data && enableAnimation) {
        data.eachItemGraphicEl(function(el) {
          el.fadeOut(function() {
            group.remove(el);
          });
        });
      } else {
        group.removeAll();
      }
    };
    function makeSeriesScope(data) {
      var seriesModel = data.hostModel;
      return {
        itemStyle: seriesModel.getModel("itemStyle").getItemStyle(["color"]),
        hoverItemStyle: seriesModel.getModel("emphasis.itemStyle").getItemStyle(),
        symbolRotate: seriesModel.get("symbolRotate"),
        symbolOffset: seriesModel.get("symbolOffset"),
        hoverAnimation: seriesModel.get("hoverAnimation"),
        labelModel: seriesModel.getModel("label"),
        hoverLabelModel: seriesModel.getModel("emphasis.label"),
        cursorStyle: seriesModel.get("cursor")
      };
    }
    var _default = SymbolDraw;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/helper.js
var require_helper3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/helper.js"(exports) {
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var _util = require_util();
    var map = _util.map;
    function prepareDataCoordInfo(coordSys, data, valueOrigin) {
      var baseAxis = coordSys.getBaseAxis();
      var valueAxis = coordSys.getOtherAxis(baseAxis);
      var valueStart = getValueStart(valueAxis, valueOrigin);
      var baseAxisDim = baseAxis.dim;
      var valueAxisDim = valueAxis.dim;
      var valueDim = data.mapDimension(valueAxisDim);
      var baseDim = data.mapDimension(baseAxisDim);
      var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      var dims = map(coordSys.dimensions, function(coordDim) {
        return data.mapDimension(coordDim);
      });
      var stacked;
      var stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (stacked |= isDimensionStacked(
        data,
        dims[0]
        /*, dims[1]*/
      )) {
        dims[0] = stackResultDim;
      }
      if (stacked |= isDimensionStacked(
        data,
        dims[1]
        /*, dims[0]*/
      )) {
        dims[1] = stackResultDim;
      }
      return {
        dataDimsForPoint: dims,
        valueStart,
        valueAxisDim,
        baseAxisDim,
        stacked: !!stacked,
        valueDim,
        baseDim,
        baseDataOffset,
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
      };
    }
    function getValueStart(valueAxis, valueOrigin) {
      var valueStart = 0;
      var extent = valueAxis.scale.getExtent();
      if (valueOrigin === "start") {
        valueStart = extent[0];
      } else if (valueOrigin === "end") {
        valueStart = extent[1];
      } else {
        if (extent[0] > 0) {
          valueStart = extent[0];
        } else if (extent[1] < 0) {
          valueStart = extent[1];
        }
      }
      return valueStart;
    }
    function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
      var value = NaN;
      if (dataCoordInfo.stacked) {
        value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
      }
      if (isNaN(value)) {
        value = dataCoordInfo.valueStart;
      }
      var baseDataOffset = dataCoordInfo.baseDataOffset;
      var stackedData = [];
      stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
      stackedData[1 - baseDataOffset] = value;
      return coordSys.dataToPoint(stackedData);
    }
    exports.prepareDataCoordInfo = prepareDataCoordInfo;
    exports.getStackedOnPoint = getStackedOnPoint;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/lineAnimationDiff.js
var require_lineAnimationDiff = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/lineAnimationDiff.js"(exports, module) {
    var _helper = require_helper3();
    var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
    var getStackedOnPoint = _helper.getStackedOnPoint;
    function diffData(oldData, newData) {
      var diffResult = [];
      newData.diff(oldData).add(function(idx) {
        diffResult.push({
          cmd: "+",
          idx
        });
      }).update(function(newIdx, oldIdx) {
        diffResult.push({
          cmd: "=",
          idx: oldIdx,
          idx1: newIdx
        });
      }).remove(function(idx) {
        diffResult.push({
          cmd: "-",
          idx
        });
      }).execute();
      return diffResult;
    }
    function _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
      var diff = diffData(oldData, newData);
      var currPoints = [];
      var nextPoints = [];
      var currStackedPoints = [];
      var nextStackedPoints = [];
      var status = [];
      var sortedIndices = [];
      var rawIndices = [];
      var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
      var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);
      for (var i = 0; i < diff.length; i++) {
        var diffItem = diff[i];
        var pointAdded = true;
        switch (diffItem.cmd) {
          case "=":
            var currentPt = oldData.getItemLayout(diffItem.idx);
            var nextPt = newData.getItemLayout(diffItem.idx1);
            if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
              currentPt = nextPt.slice();
            }
            currPoints.push(currentPt);
            nextPoints.push(nextPt);
            currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
            nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
            rawIndices.push(newData.getRawIndex(diffItem.idx1));
            break;
          case "+":
            var idx = diffItem.idx;
            currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));
            nextPoints.push(newData.getItemLayout(idx).slice());
            currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));
            nextStackedPoints.push(newStackedOnPoints[idx]);
            rawIndices.push(newData.getRawIndex(idx));
            break;
          case "-":
            var idx = diffItem.idx;
            var rawIndex = oldData.getRawIndex(idx);
            if (rawIndex !== idx) {
              currPoints.push(oldData.getItemLayout(idx));
              nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));
              currStackedPoints.push(oldStackedOnPoints[idx]);
              nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));
              rawIndices.push(rawIndex);
            } else {
              pointAdded = false;
            }
        }
        if (pointAdded) {
          status.push(diffItem);
          sortedIndices.push(sortedIndices.length);
        }
      }
      sortedIndices.sort(function(a, b) {
        return rawIndices[a] - rawIndices[b];
      });
      var sortedCurrPoints = [];
      var sortedNextPoints = [];
      var sortedCurrStackedPoints = [];
      var sortedNextStackedPoints = [];
      var sortedStatus = [];
      for (var i = 0; i < sortedIndices.length; i++) {
        var idx = sortedIndices[i];
        sortedCurrPoints[i] = currPoints[idx];
        sortedNextPoints[i] = nextPoints[idx];
        sortedCurrStackedPoints[i] = currStackedPoints[idx];
        sortedNextStackedPoints[i] = nextStackedPoints[idx];
        sortedStatus[i] = status[idx];
      }
      return {
        current: sortedCurrPoints,
        next: sortedNextPoints,
        stackedOnCurrent: sortedCurrStackedPoints,
        stackedOnNext: sortedNextStackedPoints,
        status: sortedStatus
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/poly.js
var require_poly2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/poly.js"(exports) {
    var Path = require_Path();
    var vec2 = require_vector();
    var fixClipWithShadow = require_fixClipWithShadow();
    var vec2Min = vec2.min;
    var vec2Max = vec2.max;
    var scaleAndAdd = vec2.scaleAndAdd;
    var v2Copy = vec2.copy;
    var v = [];
    var cp0 = [];
    var cp1 = [];
    function isPointNull(p) {
      return isNaN(p[0]) || isNaN(p[1]);
    }
    function drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      if (smoothMonotone === "none" || !smoothMonotone) {
        return drawNonMono.apply(this, arguments);
      } else {
        return drawMono.apply(this, arguments);
      }
    }
    function drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      var prevIdx = 0;
      var idx = start;
      for (var k = 0; k < segLen; k++) {
        var p = points[idx];
        if (idx >= allLen || idx < 0) {
          break;
        }
        if (isPointNull(p)) {
          if (connectNulls) {
            idx += dir;
            continue;
          }
          break;
        }
        if (idx === start) {
          ctx[dir > 0 ? "moveTo" : "lineTo"](p[0], p[1]);
        } else {
          if (smooth > 0) {
            var prevP = points[prevIdx];
            var dim = smoothMonotone === "y" ? 1 : 0;
            var ctrlLen = (p[dim] - prevP[dim]) * smooth;
            v2Copy(cp0, prevP);
            cp0[dim] = prevP[dim] + ctrlLen;
            v2Copy(cp1, p);
            cp1[dim] = p[dim] - ctrlLen;
            ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
          } else {
            ctx.lineTo(p[0], p[1]);
          }
        }
        prevIdx = idx;
        idx += dir;
      }
      return k;
    }
    function drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
      var prevIdx = 0;
      var idx = start;
      for (var k = 0; k < segLen; k++) {
        var p = points[idx];
        if (idx >= allLen || idx < 0) {
          break;
        }
        if (isPointNull(p)) {
          if (connectNulls) {
            idx += dir;
            continue;
          }
          break;
        }
        if (idx === start) {
          ctx[dir > 0 ? "moveTo" : "lineTo"](p[0], p[1]);
          v2Copy(cp0, p);
        } else {
          if (smooth > 0) {
            var nextIdx = idx + dir;
            var nextP = points[nextIdx];
            if (connectNulls) {
              while (nextP && isPointNull(points[nextIdx])) {
                nextIdx += dir;
                nextP = points[nextIdx];
              }
            }
            var ratioNextSeg = 0.5;
            var prevP = points[prevIdx];
            var nextP = points[nextIdx];
            if (!nextP || isPointNull(nextP)) {
              v2Copy(cp1, p);
            } else {
              if (isPointNull(nextP) && !connectNulls) {
                nextP = p;
              }
              vec2.sub(v, nextP, prevP);
              var lenPrevSeg;
              var lenNextSeg;
              if (smoothMonotone === "x" || smoothMonotone === "y") {
                var dim = smoothMonotone === "x" ? 0 : 1;
                lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
                lenNextSeg = Math.abs(p[dim] - nextP[dim]);
              } else {
                lenPrevSeg = vec2.dist(p, prevP);
                lenNextSeg = vec2.dist(p, nextP);
              }
              ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
              scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
            }
            vec2Min(cp0, cp0, smoothMax);
            vec2Max(cp0, cp0, smoothMin);
            vec2Min(cp1, cp1, smoothMax);
            vec2Max(cp1, cp1, smoothMin);
            ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
            scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
          } else {
            ctx.lineTo(p[0], p[1]);
          }
        }
        prevIdx = idx;
        idx += dir;
      }
      return k;
    }
    function getBoundingBox(points, smoothConstraint) {
      var ptMin = [Infinity, Infinity];
      var ptMax = [-Infinity, -Infinity];
      if (smoothConstraint) {
        for (var i = 0; i < points.length; i++) {
          var pt = points[i];
          if (pt[0] < ptMin[0]) {
            ptMin[0] = pt[0];
          }
          if (pt[1] < ptMin[1]) {
            ptMin[1] = pt[1];
          }
          if (pt[0] > ptMax[0]) {
            ptMax[0] = pt[0];
          }
          if (pt[1] > ptMax[1]) {
            ptMax[1] = pt[1];
          }
        }
      }
      return {
        min: smoothConstraint ? ptMin : ptMax,
        max: smoothConstraint ? ptMax : ptMin
      };
    }
    var Polyline = Path.extend({
      type: "ec-polyline",
      shape: {
        points: [],
        smooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      style: {
        fill: null,
        stroke: "#000"
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var i = 0;
        var len = points.length;
        var result = getBoundingBox(points, shape.smoothConstraint);
        if (shape.connectNulls) {
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }
          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }
        while (i < len) {
          i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
        }
      }
    });
    var Polygon = Path.extend({
      type: "ec-polygon",
      shape: {
        points: [],
        // Offset between stacked base points and points
        stackedOnPoints: [],
        smooth: 0,
        stackedOnSmooth: 0,
        smoothConstraint: true,
        smoothMonotone: null,
        connectNulls: false
      },
      brush: fixClipWithShadow(Path.prototype.brush),
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var stackedOnPoints = shape.stackedOnPoints;
        var i = 0;
        var len = points.length;
        var smoothMonotone = shape.smoothMonotone;
        var bbox = getBoundingBox(points, shape.smoothConstraint);
        var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);
        if (shape.connectNulls) {
          for (; len > 0; len--) {
            if (!isPointNull(points[len - 1])) {
              break;
            }
          }
          for (; i < len; i++) {
            if (!isPointNull(points[i])) {
              break;
            }
          }
        }
        while (i < len) {
          var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);
          drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
          i += k + 1;
          ctx.closePath();
        }
      }
    });
    exports.Polyline = Polyline;
    exports.Polygon = Polygon;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js
var require_createClipPathFromCoordSys = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js"(exports) {
    var graphic = require_graphic();
    var _number = require_number();
    var round = _number.round;
    function createGridClipPath(cartesian, hasAnimation, seriesModel) {
      var rect = cartesian.getArea();
      var isHorizontal = cartesian.getBaseAxis().isHorizontal();
      var x = rect.x;
      var y = rect.y;
      var width = rect.width;
      var height = rect.height;
      var lineWidth = seriesModel.get("lineStyle.width") || 2;
      x -= lineWidth / 2;
      y -= lineWidth / 2;
      width += lineWidth;
      height += lineWidth;
      x = Math.floor(x);
      width = Math.round(width);
      var clipPath = new graphic.Rect({
        shape: {
          x,
          y,
          width,
          height
        }
      });
      if (hasAnimation) {
        clipPath.shape[isHorizontal ? "width" : "height"] = 0;
        graphic.initProps(clipPath, {
          shape: {
            width,
            height
          }
        }, seriesModel);
      }
      return clipPath;
    }
    function createPolarClipPath(polar, hasAnimation, seriesModel) {
      var sectorArea = polar.getArea();
      var clipPath = new graphic.Sector({
        shape: {
          cx: round(polar.cx, 1),
          cy: round(polar.cy, 1),
          r0: round(sectorArea.r0, 1),
          r: round(sectorArea.r, 1),
          startAngle: sectorArea.startAngle,
          endAngle: sectorArea.endAngle,
          clockwise: sectorArea.clockwise
        }
      });
      if (hasAnimation) {
        clipPath.shape.endAngle = sectorArea.startAngle;
        graphic.initProps(clipPath, {
          shape: {
            endAngle: sectorArea.endAngle
          }
        }, seriesModel);
      }
      return clipPath;
    }
    function createClipPath(coordSys, hasAnimation, seriesModel) {
      if (!coordSys) {
        return null;
      } else if (coordSys.type === "polar") {
        return createPolarClipPath(coordSys, hasAnimation, seriesModel);
      } else if (coordSys.type === "cartesian2d") {
        return createGridClipPath(coordSys, hasAnimation, seriesModel);
      }
      return null;
    }
    exports.createGridClipPath = createGridClipPath;
    exports.createPolarClipPath = createPolarClipPath;
    exports.createClipPath = createClipPath;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineView.js
var require_LineView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line/LineView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var _bbox = require_bbox();
    var fromPoints = _bbox.fromPoints;
    var SymbolDraw = require_SymbolDraw();
    var SymbolClz = require_Symbol();
    var lineAnimationDiff = require_lineAnimationDiff();
    var graphic = require_graphic();
    var modelUtil = require_model();
    var _poly = require_poly2();
    var Polyline = _poly.Polyline;
    var Polygon = _poly.Polygon;
    var ChartView = require_Chart();
    var _helper = require_helper3();
    var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
    var getStackedOnPoint = _helper.getStackedOnPoint;
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createGridClipPath = _createClipPathFromCoordSys.createGridClipPath;
    var createPolarClipPath = _createClipPathFromCoordSys.createPolarClipPath;
    function isPointsSame(points1, points2) {
      if (points1.length !== points2.length) {
        return;
      }
      for (var i = 0; i < points1.length; i++) {
        var p1 = points1[i];
        var p2 = points2[i];
        if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
          return;
        }
      }
      return true;
    }
    function getBoundingDiff(points1, points2) {
      var min1 = [];
      var max1 = [];
      var min2 = [];
      var max2 = [];
      fromPoints(points1, min1, max1);
      fromPoints(points2, min2, max2);
      return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
    }
    function getSmooth(smooth) {
      return typeof smooth === "number" ? smooth : smooth ? 0.5 : 0;
    }
    function getStackedOnPoints(coordSys, data, dataCoordInfo) {
      if (!dataCoordInfo.valueDim) {
        return [];
      }
      var points = [];
      for (var idx = 0, len = data.count(); idx < len; idx++) {
        points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));
      }
      return points;
    }
    function turnPointsIntoStep(points, coordSys, stepTurnAt) {
      var baseAxis = coordSys.getBaseAxis();
      var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
      var stepPoints = [];
      for (var i = 0; i < points.length - 1; i++) {
        var nextPt = points[i + 1];
        var pt = points[i];
        stepPoints.push(pt);
        var stepPt = [];
        switch (stepTurnAt) {
          case "end":
            stepPt[baseIndex] = nextPt[baseIndex];
            stepPt[1 - baseIndex] = pt[1 - baseIndex];
            stepPoints.push(stepPt);
            break;
          case "middle":
            var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
            var stepPt2 = [];
            stepPt[baseIndex] = stepPt2[baseIndex] = middle;
            stepPt[1 - baseIndex] = pt[1 - baseIndex];
            stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
            stepPoints.push(stepPt);
            stepPoints.push(stepPt2);
            break;
          default:
            stepPt[baseIndex] = pt[baseIndex];
            stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
            stepPoints.push(stepPt);
        }
      }
      points[i] && stepPoints.push(points[i]);
      return stepPoints;
    }
    function getVisualGradient(data, coordSys) {
      var visualMetaList = data.getVisual("visualMeta");
      if (!visualMetaList || !visualMetaList.length || !data.count()) {
        return;
      }
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      var coordDim;
      var visualMeta;
      for (var i = visualMetaList.length - 1; i >= 0; i--) {
        var dimIndex = visualMetaList[i].dimension;
        var dimName = data.dimensions[dimIndex];
        var dimInfo = data.getDimensionInfo(dimName);
        coordDim = dimInfo && dimInfo.coordDim;
        if (coordDim === "x" || coordDim === "y") {
          visualMeta = visualMetaList[i];
          break;
        }
      }
      if (!visualMeta) {
        return;
      }
      var axis = coordSys.getAxis(coordDim);
      var colorStops = zrUtil.map(visualMeta.stops, function(stop) {
        return {
          coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
          color: stop.color
        };
      });
      var stopLen = colorStops.length;
      var outerColors = visualMeta.outerColors.slice();
      if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
        colorStops.reverse();
        outerColors.reverse();
      }
      var tinyExtent = 10;
      var minCoord = colorStops[0].coord - tinyExtent;
      var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
      var coordSpan = maxCoord - minCoord;
      if (coordSpan < 1e-3) {
        return "transparent";
      }
      zrUtil.each(colorStops, function(stop) {
        stop.offset = (stop.coord - minCoord) / coordSpan;
      });
      colorStops.push({
        offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
        color: outerColors[1] || "transparent"
      });
      colorStops.unshift({
        // notice colorStops.length have been changed.
        offset: stopLen ? colorStops[0].offset : 0.5,
        color: outerColors[0] || "transparent"
      });
      var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
      gradient[coordDim] = minCoord;
      gradient[coordDim + "2"] = maxCoord;
      return gradient;
    }
    function getIsIgnoreFunc(seriesModel, data, coordSys) {
      var showAllSymbol = seriesModel.get("showAllSymbol");
      var isAuto = showAllSymbol === "auto";
      if (showAllSymbol && !isAuto) {
        return;
      }
      var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
      if (!categoryAxis) {
        return;
      }
      if (isAuto && canShowAllSymbolForCategory(categoryAxis, data)) {
        return;
      }
      var categoryDataDim = data.mapDimension(categoryAxis.dim);
      var labelMap = {};
      zrUtil.each(categoryAxis.getViewLabels(), function(labelItem) {
        labelMap[labelItem.tickValue] = 1;
      });
      return function(dataIndex) {
        return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
      };
    }
    function canShowAllSymbolForCategory(categoryAxis, data) {
      var axisExtent = categoryAxis.getExtent();
      var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
      isNaN(availSize) && (availSize = 0);
      var dataLen = data.count();
      var step = Math.max(1, Math.round(dataLen / 5));
      for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
        if (SymbolClz.getSymbolSize(
          data,
          dataIndex
          // Only for cartesian, where `isHorizontal` exists.
        )[categoryAxis.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
          return false;
        }
      }
      return true;
    }
    function createLineClipPath(coordSys, hasAnimation, seriesModel) {
      if (coordSys.type === "cartesian2d") {
        var isHorizontal = coordSys.getBaseAxis().isHorizontal();
        var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel);
        if (!seriesModel.get("clip", true)) {
          var rectShape = clipPath.shape;
          var expandSize = Math.max(rectShape.width, rectShape.height);
          if (isHorizontal) {
            rectShape.y -= expandSize;
            rectShape.height += expandSize * 2;
          } else {
            rectShape.x -= expandSize;
            rectShape.width += expandSize * 2;
          }
        }
        return clipPath;
      } else {
        return createPolarClipPath(coordSys, hasAnimation, seriesModel);
      }
    }
    var _default = ChartView.extend({
      type: "line",
      init: function() {
        var lineGroup = new graphic.Group();
        var symbolDraw = new SymbolDraw();
        this.group.add(symbolDraw.group);
        this._symbolDraw = symbolDraw;
        this._lineGroup = lineGroup;
      },
      render: function(seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var lineStyleModel = seriesModel.getModel("lineStyle");
        var areaStyleModel = seriesModel.getModel("areaStyle");
        var points = data.mapArray(data.getItemLayout);
        var isCoordSysPolar = coordSys.type === "polar";
        var prevCoordSys = this._coordSys;
        var symbolDraw = this._symbolDraw;
        var polyline = this._polyline;
        var polygon = this._polygon;
        var lineGroup = this._lineGroup;
        var hasAnimation = seriesModel.get("animation");
        var isAreaChart = !areaStyleModel.isEmpty();
        var valueOrigin = areaStyleModel.get("origin");
        var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
        var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);
        var showSymbol = seriesModel.get("showSymbol");
        var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
        var oldData = this._data;
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        if (!showSymbol) {
          symbolDraw.remove();
        }
        group.add(lineGroup);
        var step = !isCoordSysPolar && seriesModel.get("step");
        var clipShapeForSymbol;
        if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
          clipShapeForSymbol = coordSys.getArea();
          if (clipShapeForSymbol.width != null) {
            clipShapeForSymbol.x -= 0.1;
            clipShapeForSymbol.y -= 0.1;
            clipShapeForSymbol.width += 0.2;
            clipShapeForSymbol.height += 0.2;
          } else if (clipShapeForSymbol.r0) {
            clipShapeForSymbol.r0 -= 0.5;
            clipShapeForSymbol.r1 += 0.5;
          }
        }
        this._clipShapeForSymbol = clipShapeForSymbol;
        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol
          });
          if (step) {
            points = turnPointsIntoStep(points, coordSys, step);
            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
          }
          polyline = this._newPolyline(points, coordSys, hasAnimation);
          if (isAreaChart) {
            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
          }
          lineGroup.setClipPath(createLineClipPath(coordSys, true, seriesModel));
        } else {
          if (isAreaChart && !polygon) {
            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
          } else if (polygon && !isAreaChart) {
            lineGroup.remove(polygon);
            polygon = this._polygon = null;
          }
          lineGroup.setClipPath(createLineClipPath(coordSys, false, seriesModel));
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol
          });
          data.eachItemGraphicEl(function(el) {
            el.stopAnimation(true);
          });
          if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
            if (hasAnimation) {
              this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
            } else {
              if (step) {
                points = turnPointsIntoStep(points, coordSys, step);
                stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
              }
              polyline.setShape({
                points
              });
              polygon && polygon.setShape({
                points,
                stackedOnPoints
              });
            }
          }
        }
        var visualColor = getVisualGradient(data, coordSys) || data.getVisual("color");
        polyline.useStyle(zrUtil.defaults(
          // Use color in lineStyle first
          lineStyleModel.getLineStyle(),
          {
            fill: "none",
            stroke: visualColor,
            lineJoin: "bevel"
          }
        ));
        var smooth = seriesModel.get("smooth");
        smooth = getSmooth(seriesModel.get("smooth"));
        polyline.setShape({
          smooth,
          smoothMonotone: seriesModel.get("smoothMonotone"),
          connectNulls: seriesModel.get("connectNulls")
        });
        if (polygon) {
          var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
          var stackedOnSmooth = 0;
          polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
            fill: visualColor,
            opacity: 0.7,
            lineJoin: "bevel"
          }));
          if (stackedOnSeries) {
            stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
          }
          polygon.setShape({
            smooth,
            stackedOnSmooth,
            smoothMonotone: seriesModel.get("smoothMonotone"),
            connectNulls: seriesModel.get("connectNulls")
          });
        }
        this._data = data;
        this._coordSys = coordSys;
        this._stackedOnPoints = stackedOnPoints;
        this._points = points;
        this._step = step;
        this._valueOrigin = valueOrigin;
      },
      dispose: function() {
      },
      highlight: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = modelUtil.queryDataIndex(data, payload);
        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);
          if (!symbol) {
            var pt = data.getItemLayout(dataIndex);
            if (!pt) {
              return;
            }
            if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(pt[0], pt[1])) {
              return;
            }
            symbol = new SymbolClz(data, dataIndex);
            symbol.position = pt;
            symbol.setZ(seriesModel.get("zlevel"), seriesModel.get("z"));
            symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
            symbol.__temp = true;
            data.setItemGraphicEl(dataIndex, symbol);
            symbol.stopSymbolAnimation(true);
            this.group.add(symbol);
          }
          symbol.highlight();
        } else {
          ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
        }
      },
      downplay: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var dataIndex = modelUtil.queryDataIndex(data, payload);
        if (dataIndex != null && dataIndex >= 0) {
          var symbol = data.getItemGraphicEl(dataIndex);
          if (symbol) {
            if (symbol.__temp) {
              data.setItemGraphicEl(dataIndex, null);
              this.group.remove(symbol);
            } else {
              symbol.downplay();
            }
          }
        } else {
          ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
        }
      },
      /**
       * @param {module:zrender/container/Group} group
       * @param {Array.<Array.<number>>} points
       * @private
       */
      _newPolyline: function(points) {
        var polyline = this._polyline;
        if (polyline) {
          this._lineGroup.remove(polyline);
        }
        polyline = new Polyline({
          shape: {
            points
          },
          silent: true,
          z2: 10
        });
        this._lineGroup.add(polyline);
        this._polyline = polyline;
        return polyline;
      },
      /**
       * @param {module:zrender/container/Group} group
       * @param {Array.<Array.<number>>} stackedOnPoints
       * @param {Array.<Array.<number>>} points
       * @private
       */
      _newPolygon: function(points, stackedOnPoints) {
        var polygon = this._polygon;
        if (polygon) {
          this._lineGroup.remove(polygon);
        }
        polygon = new Polygon({
          shape: {
            points,
            stackedOnPoints
          },
          silent: true
        });
        this._lineGroup.add(polygon);
        this._polygon = polygon;
        return polygon;
      },
      /**
       * @private
       */
      // FIXME Two value axis
      _updateAnimation: function(data, stackedOnPoints, coordSys, api, step, valueOrigin) {
        var polyline = this._polyline;
        var polygon = this._polygon;
        var seriesModel = data.hostModel;
        var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
        var current = diff.current;
        var stackedOnCurrent = diff.stackedOnCurrent;
        var next = diff.next;
        var stackedOnNext = diff.stackedOnNext;
        if (step) {
          current = turnPointsIntoStep(diff.current, coordSys, step);
          stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
          next = turnPointsIntoStep(diff.next, coordSys, step);
          stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
        }
        if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
          polyline.setShape({
            points: next
          });
          if (polygon) {
            polygon.setShape({
              points: next,
              stackedOnPoints: stackedOnNext
            });
          }
          return;
        }
        polyline.shape.__points = diff.current;
        polyline.shape.points = current;
        graphic.updateProps(polyline, {
          shape: {
            points: next
          }
        }, seriesModel);
        if (polygon) {
          polygon.setShape({
            points: current,
            stackedOnPoints: stackedOnCurrent
          });
          graphic.updateProps(polygon, {
            shape: {
              points: next,
              stackedOnPoints: stackedOnNext
            }
          }, seriesModel);
        }
        var updatedDataInfo = [];
        var diffStatus = diff.status;
        for (var i = 0; i < diffStatus.length; i++) {
          var cmd = diffStatus[i].cmd;
          if (cmd === "=") {
            var el = data.getItemGraphicEl(diffStatus[i].idx1);
            if (el) {
              updatedDataInfo.push({
                el,
                ptIdx: i
                // Index of points
              });
            }
          }
        }
        if (polyline.animators && polyline.animators.length) {
          polyline.animators[0].during(function() {
            for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
              var el2 = updatedDataInfo[i2].el;
              el2.attr("position", polyline.shape.__points[updatedDataInfo[i2].ptIdx]);
            }
          });
        }
      },
      remove: function(ecModel) {
        var group = this.group;
        var oldData = this._data;
        this._lineGroup.removeAll();
        this._symbolDraw.remove(true);
        oldData && oldData.eachItemGraphicEl(function(el, idx) {
          if (el.__temp) {
            group.remove(el);
            oldData.setItemGraphicEl(idx, null);
          }
        });
        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/symbol.js
var require_symbol2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/symbol.js"(exports, module) {
    var _util = require_util();
    var isFunction = _util.isFunction;
    function _default(seriesType, defaultSymbolType, legendSymbol) {
      return {
        seriesType,
        // For legend.
        performRawSeries: true,
        reset: function(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var symbolType = seriesModel.get("symbol");
          var symbolSize = seriesModel.get("symbolSize");
          var keepAspect = seriesModel.get("symbolKeepAspect");
          var symbolRotate = seriesModel.get("symbolRotate");
          var hasSymbolTypeCallback = isFunction(symbolType);
          var hasSymbolSizeCallback = isFunction(symbolSize);
          var hasSymbolRotateCallback = isFunction(symbolRotate);
          var hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;
          var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : defaultSymbolType;
          var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;
          var seriesSymbolRotate = !hasSymbolRotateCallback ? seriesSymbolRotate : null;
          data.setVisual({
            legendSymbol: legendSymbol || seriesSymbol,
            // If seting callback functions on `symbol` or `symbolSize`, for simplicity and avoiding
            // to bring trouble, we do not pick a reuslt from one of its calling on data item here,
            // but just use the default value. Callback on `symbol` or `symbolSize` is convenient in
            // some cases but generally it is not recommanded.
            symbol: seriesSymbol,
            symbolSize: seriesSymbolSize,
            symbolKeepAspect: keepAspect,
            symbolRotate
          });
          if (ecModel.isSeriesFiltered(seriesModel)) {
            return;
          }
          function dataEach(data2, idx) {
            if (hasCallback) {
              var rawValue = seriesModel.getRawValue(idx);
              var params = seriesModel.getDataParams(idx);
              hasSymbolTypeCallback && data2.setItemVisual(idx, "symbol", symbolType(rawValue, params));
              hasSymbolSizeCallback && data2.setItemVisual(idx, "symbolSize", symbolSize(rawValue, params));
              hasSymbolRotateCallback && data2.setItemVisual(idx, "symbolRotate", symbolRotate(rawValue, params));
            }
            if (data2.hasItemOption) {
              var itemModel = data2.getItemModel(idx);
              var itemSymbolType = itemModel.getShallow("symbol", true);
              var itemSymbolSize = itemModel.getShallow("symbolSize", true);
              var itemSymbolRotate = itemModel.getShallow("symbolRotate", true);
              var itemSymbolKeepAspect = itemModel.getShallow("symbolKeepAspect", true);
              if (itemSymbolType != null) {
                data2.setItemVisual(idx, "symbol", itemSymbolType);
              }
              if (itemSymbolSize != null) {
                data2.setItemVisual(idx, "symbolSize", itemSymbolSize);
              }
              if (itemSymbolRotate != null) {
                data2.setItemVisual(idx, "symbolRotate", itemSymbolRotate);
              }
              if (itemSymbolKeepAspect != null) {
                data2.setItemVisual(idx, "symbolKeepAspect", itemSymbolKeepAspect);
              }
            }
          }
          return {
            dataEach: data.hasItemOption || hasCallback ? dataEach : null
          };
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/points.js
var require_points = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/points.js"(exports, module) {
    var _util = require_util();
    var map = _util.map;
    var createRenderPlanner = require_createRenderPlanner();
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    function _default(seriesType) {
      return {
        seriesType,
        plan: createRenderPlanner(),
        reset: function(seriesModel) {
          var data = seriesModel.getData();
          var coordSys = seriesModel.coordinateSystem;
          var pipelineContext = seriesModel.pipelineContext;
          var isLargeRender = pipelineContext.large;
          if (!coordSys) {
            return;
          }
          var dims = map(coordSys.dimensions, function(dim) {
            return data.mapDimension(dim);
          }).slice(0, 2);
          var dimLen = dims.length;
          var stackResultDim = data.getCalculationInfo("stackResultDimension");
          if (isDimensionStacked(
            data,
            dims[0]
            /*, dims[1]*/
          )) {
            dims[0] = stackResultDim;
          }
          if (isDimensionStacked(
            data,
            dims[1]
            /*, dims[0]*/
          )) {
            dims[1] = stackResultDim;
          }
          function progress(params, data2) {
            var segCount = params.end - params.start;
            var points = isLargeRender && new Float32Array(segCount * dimLen);
            for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
              var point;
              if (dimLen === 1) {
                var x = data2.get(dims[0], i);
                point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
              } else {
                var x = tmpIn[0] = data2.get(dims[0], i);
                var y = tmpIn[1] = data2.get(dims[1], i);
                point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
              }
              if (isLargeRender) {
                points[offset++] = point ? point[0] : NaN;
                points[offset++] = point ? point[1] : NaN;
              } else {
                data2.setItemLayout(i, point && point.slice() || [NaN, NaN]);
              }
            }
            isLargeRender && data2.setLayout("symbolPoints", points);
          }
          return dimLen && {
            progress
          };
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataSample.js
var require_dataSample = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataSample.js"(exports, module) {
    var samplers = {
      average: function(frame) {
        var sum = 0;
        var count = 0;
        for (var i = 0; i < frame.length; i++) {
          if (!isNaN(frame[i])) {
            sum += frame[i];
            count++;
          }
        }
        return count === 0 ? NaN : sum / count;
      },
      sum: function(frame) {
        var sum = 0;
        for (var i = 0; i < frame.length; i++) {
          sum += frame[i] || 0;
        }
        return sum;
      },
      max: function(frame) {
        var max = -Infinity;
        for (var i = 0; i < frame.length; i++) {
          frame[i] > max && (max = frame[i]);
        }
        return isFinite(max) ? max : NaN;
      },
      min: function(frame) {
        var min = Infinity;
        for (var i = 0; i < frame.length; i++) {
          frame[i] < min && (min = frame[i]);
        }
        return isFinite(min) ? min : NaN;
      },
      // TODO
      // Median
      nearest: function(frame) {
        return frame[0];
      }
    };
    var indexSampler = function(frame, value) {
      return Math.round(frame.length / 2);
    };
    function _default(seriesType) {
      return {
        seriesType,
        modifyOutputEnd: true,
        reset: function(seriesModel, ecModel, api) {
          var data = seriesModel.getData();
          var sampling = seriesModel.get("sampling");
          var coordSys = seriesModel.coordinateSystem;
          if (coordSys.type === "cartesian2d" && sampling) {
            var baseAxis = coordSys.getBaseAxis();
            var valueAxis = coordSys.getOtherAxis(baseAxis);
            var extent = baseAxis.getExtent();
            var size = Math.abs(extent[1] - extent[0]);
            var rate = Math.round(data.count() / size);
            if (rate > 1) {
              var sampler;
              if (typeof sampling === "string") {
                sampler = samplers[sampling];
              } else if (typeof sampling === "function") {
                sampler = sampling;
              }
              if (sampler) {
                seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
              }
            }
          }
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian.js
var require_Cartesian = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian.js"(exports, module) {
    var zrUtil = require_util();
    function dimAxisMapper(dim) {
      return this._axes[dim];
    }
    var Cartesian = function(name2) {
      this._axes = {};
      this._dimList = [];
      this.name = name2 || "";
    };
    Cartesian.prototype = {
      constructor: Cartesian,
      type: "cartesian",
      /**
       * Get axis
       * @param  {number|string} dim
       * @return {module:echarts/coord/Cartesian~Axis}
       */
      getAxis: function(dim) {
        return this._axes[dim];
      },
      /**
       * Get axes list
       * @return {Array.<module:echarts/coord/Cartesian~Axis>}
       */
      getAxes: function() {
        return zrUtil.map(this._dimList, dimAxisMapper, this);
      },
      /**
       * Get axes list by given scale type
       */
      getAxesByScale: function(scaleType) {
        scaleType = scaleType.toLowerCase();
        return zrUtil.filter(this.getAxes(), function(axis) {
          return axis.scale.type === scaleType;
        });
      },
      /**
       * Add axis
       * @param {module:echarts/coord/Cartesian.Axis}
       */
      addAxis: function(axis) {
        var dim = axis.dim;
        this._axes[dim] = axis;
        this._dimList.push(dim);
      },
      /**
       * Convert data to coord in nd space
       * @param {Array.<number>|Object.<string, number>} val
       * @return {Array.<number>|Object.<string, number>}
       */
      dataToCoord: function(val) {
        return this._dataCoordConvert(val, "dataToCoord");
      },
      /**
       * Convert coord in nd space to data
       * @param  {Array.<number>|Object.<string, number>} val
       * @return {Array.<number>|Object.<string, number>}
       */
      coordToData: function(val) {
        return this._dataCoordConvert(val, "coordToData");
      },
      _dataCoordConvert: function(input, method) {
        var dimList = this._dimList;
        var output = input instanceof Array ? [] : {};
        for (var i = 0; i < dimList.length; i++) {
          var dim = dimList[i];
          var axis = this._axes[dim];
          output[dim] = axis[method](input[dim]);
        }
        return output;
      }
    };
    var _default = Cartesian;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian2D.js
var require_Cartesian2D = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Cartesian2D.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var Cartesian = require_Cartesian();
    function Cartesian2D(name2) {
      Cartesian.call(this, name2);
    }
    Cartesian2D.prototype = {
      constructor: Cartesian2D,
      type: "cartesian2d",
      /**
       * @type {Array.<string>}
       * @readOnly
       */
      dimensions: ["x", "y"],
      /**
       * Base axis will be used on stacking.
       *
       * @return {module:echarts/coord/cartesian/Axis2D}
       */
      getBaseAxis: function() {
        return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
      },
      /**
       * If contain point
       * @param {Array.<number>} point
       * @return {boolean}
       */
      containPoint: function(point) {
        var axisX = this.getAxis("x");
        var axisY = this.getAxis("y");
        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
      },
      /**
       * If contain data
       * @param {Array.<number>} data
       * @return {boolean}
       */
      containData: function(data) {
        return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
      },
      /**
       * @param {Array.<number>} data
       * @param {Array.<number>} out
       * @return {Array.<number>}
       */
      dataToPoint: function(data, reserved, out) {
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out = out || [];
        out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));
        out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));
        return out;
      },
      /**
       * @param {Array.<number>} data
       * @param {Array.<number>} out
       * @return {Array.<number>}
       */
      clampData: function(data, out) {
        var xScale = this.getAxis("x").scale;
        var yScale = this.getAxis("y").scale;
        var xAxisExtent = xScale.getExtent();
        var yAxisExtent = yScale.getExtent();
        var x = xScale.parse(data[0]);
        var y = yScale.parse(data[1]);
        out = out || [];
        out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
        out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
        return out;
      },
      /**
       * @param {Array.<number>} point
       * @param {Array.<number>} out
       * @return {Array.<number>}
       */
      pointToData: function(point, out) {
        var xAxis = this.getAxis("x");
        var yAxis = this.getAxis("y");
        out = out || [];
        out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
        out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
        return out;
      },
      /**
       * Get other axis
       * @param {module:echarts/coord/cartesian/Axis2D} axis
       */
      getOtherAxis: function(axis) {
        return this.getAxis(axis.dim === "x" ? "y" : "x");
      },
      /**
       * Get rect area of cartesian.
       * Area will have a contain function to determine if a point is in the coordinate system.
       * @return {BoundingRect}
       */
      getArea: function() {
        var xExtent = this.getAxis("x").getGlobalExtent();
        var yExtent = this.getAxis("y").getGlobalExtent();
        var x = Math.min(xExtent[0], xExtent[1]);
        var y = Math.min(yExtent[0], yExtent[1]);
        var width = Math.max(xExtent[0], xExtent[1]) - x;
        var height = Math.max(yExtent[0], yExtent[1]) - y;
        var rect = new BoundingRect(x, y, width, height);
        return rect;
      }
    };
    zrUtil.inherits(Cartesian2D, Cartesian);
    var _default = Cartesian2D;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Axis2D.js
var require_Axis2D = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Axis2D.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var Axis2D = function(dim, scale, coordExtent, axisType, position) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.position = position || "bottom";
    };
    Axis2D.prototype = {
      constructor: Axis2D,
      /**
       * Index of axis, can be used as key
       */
      index: 0,
      /**
       * Implemented in <module:echarts/coord/cartesian/Grid>.
       * @return {Array.<module:echarts/coord/cartesian/Axis2D>}
       *         If not on zero of other axis, return null/undefined.
       *         If no axes, return an empty array.
       */
      getAxesOnZeroOf: null,
      /**
       * Axis model
       * @param {module:echarts/coord/cartesian/AxisModel}
       */
      model: null,
      isHorizontal: function() {
        var position = this.position;
        return position === "top" || position === "bottom";
      },
      /**
       * Each item cooresponds to this.getExtent(), which
       * means globalExtent[0] may greater than globalExtent[1],
       * unless `asc` is input.
       *
       * @param {boolean} [asc]
       * @return {Array.<number>}
       */
      getGlobalExtent: function(asc) {
        var ret = this.getExtent();
        ret[0] = this.toGlobalCoord(ret[0]);
        ret[1] = this.toGlobalCoord(ret[1]);
        asc && ret[0] > ret[1] && ret.reverse();
        return ret;
      },
      getOtherAxis: function() {
        this.grid.getOtherAxis();
      },
      /**
       * @override
       */
      pointToData: function(point, clamp) {
        return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp);
      },
      /**
       * Transform global coord to local coord,
       * i.e. var localCoord = axis.toLocalCoord(80);
       * designate by module:echarts/coord/cartesian/Grid.
       * @type {Function}
       */
      toLocalCoord: null,
      /**
       * Transform global coord to local coord,
       * i.e. var globalCoord = axis.toLocalCoord(40);
       * designate by module:echarts/coord/cartesian/Grid.
       * @type {Function}
       */
      toGlobalCoord: null
    };
    zrUtil.inherits(Axis2D, Axis);
    var _default = Axis2D;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisDefault.js
var require_axisDefault = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisDefault.js"(exports, module) {
    var zrUtil = require_util();
    var defaultOption = {
      show: true,
      zlevel: 0,
      z: 0,
      // Inverse the axis.
      inverse: false,
      // Axis name displayed.
      name: "",
      // 'start' | 'middle' | 'end'
      nameLocation: "end",
      // By degree. By default auto rotate by nameLocation.
      nameRotate: null,
      nameTruncate: {
        maxWidth: null,
        ellipsis: "...",
        placeholder: "."
      },
      // Use global text style by default.
      nameTextStyle: {},
      // The gap between axisName and axisLine.
      nameGap: 15,
      // Default `false` to support tooltip.
      silent: false,
      // Default `false` to avoid legacy user event listener fail.
      triggerEvent: false,
      tooltip: {
        show: false
      },
      axisPointer: {},
      axisLine: {
        show: true,
        onZero: true,
        onZeroAxisIndex: null,
        lineStyle: {
          color: "#333",
          width: 1,
          type: "solid"
        },
        // The arrow at both ends the the axis.
        symbol: ["none", "none"],
        symbolSize: [10, 15]
      },
      axisTick: {
        show: true,
        // Whether axisTick is inside the grid or outside the grid.
        inside: false,
        // The length of axisTick.
        length: 5,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        // Whether axisLabel is inside the grid or outside the grid.
        inside: false,
        rotate: 0,
        // true | false | null/undefined (auto)
        showMinLabel: null,
        // true | false | null/undefined (auto)
        showMaxLabel: null,
        margin: 8,
        // formatter: null,
        fontSize: 12
      },
      splitLine: {
        show: true,
        lineStyle: {
          color: ["#ccc"],
          width: 1,
          type: "solid"
        }
      },
      splitArea: {
        show: false,
        areaStyle: {
          color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
        }
      }
    };
    var axisDefault = {};
    axisDefault.categoryAxis = zrUtil.merge({
      // The gap at both ends of the axis. For categoryAxis, boolean.
      boundaryGap: true,
      // Set false to faster category collection.
      // Only usefull in the case like: category is
      // ['2012-01-01', '2012-01-02', ...], where the input
      // data has been ensured not duplicate and is large data.
      // null means "auto":
      // if axis.data provided, do not deduplication,
      // else do deduplication.
      deduplication: null,
      // splitArea: {
      // show: false
      // },
      splitLine: {
        show: false
      },
      axisTick: {
        // If tick is align with label when boundaryGap is true
        alignWithLabel: false,
        interval: "auto"
      },
      axisLabel: {
        interval: "auto"
      }
    }, defaultOption);
    axisDefault.valueAxis = zrUtil.merge({
      // The gap at both ends of the axis. For value axis, [GAP, GAP], where
      // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)
      boundaryGap: [0, 0],
      // TODO
      // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
      // Min value of the axis. can be:
      // + a number
      // + 'dataMin': use the min value in data.
      // + null/undefined: auto decide min value (consider pretty look and boundaryGap).
      // min: null,
      // Max value of the axis. can be:
      // + a number
      // + 'dataMax': use the max value in data.
      // + null/undefined: auto decide max value (consider pretty look and boundaryGap).
      // max: null,
      // Readonly prop, specifies start value of the range when using data zoom.
      // rangeStart: null
      // Readonly prop, specifies end value of the range when using data zoom.
      // rangeEnd: null
      // Optional value can be:
      // + `false`: always include value 0.
      // + `true`: the extent do not consider value 0.
      // scale: false,
      // AxisTick and axisLabel and splitLine are caculated based on splitNumber.
      splitNumber: 5,
      // Interval specifies the span of the ticks is mandatorily.
      // interval: null
      // Specify min interval when auto calculate tick interval.
      // minInterval: null
      // Specify max interval when auto calculate tick interval.
      // maxInterval: null
      minorTick: {
        // Minor tick, not available for cateogry axis.
        show: false,
        // Split number of minor ticks. The value should be in range of (0, 100)
        splitNumber: 5,
        // Lenght of minor tick
        length: 3,
        // Same inside with axisTick
        // Line style
        lineStyle: {
          // Default to be same with axisTick
        }
      },
      minorSplitLine: {
        show: false,
        lineStyle: {
          color: "#eee",
          width: 1
        }
      }
    }, defaultOption);
    axisDefault.timeAxis = zrUtil.defaults({
      scale: true,
      min: "dataMin",
      max: "dataMax"
    }, axisDefault.valueAxis);
    axisDefault.logAxis = zrUtil.defaults({
      scale: true,
      logBase: 10
    }, axisDefault.valueAxis);
    var _default = axisDefault;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisModelCreator.js
var require_axisModelCreator = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/axisModelCreator.js"(exports, module) {
    var zrUtil = require_util();
    var axisDefault = require_axisDefault();
    var ComponentModel = require_Component();
    var _layout = require_layout();
    var getLayoutParams = _layout.getLayoutParams;
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var OrdinalMeta = require_OrdinalMeta();
    var AXIS_TYPES = ["value", "category", "time", "log"];
    function _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
      zrUtil.each(AXIS_TYPES, function(axisType) {
        BaseAxisModelClass.extend({
          /**
           * @readOnly
           */
          type: axisName + "Axis." + axisType,
          mergeDefaultAndTheme: function(option, ecModel) {
            var layoutMode = this.layoutMode;
            var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
            var themeModel = ecModel.getTheme();
            zrUtil.merge(option, themeModel.get(axisType + "Axis"));
            zrUtil.merge(option, this.getDefaultOption());
            option.type = axisTypeDefaulter(axisName, option);
            if (layoutMode) {
              mergeLayoutParam(option, inputPositionParams, layoutMode);
            }
          },
          /**
           * @override
           */
          optionUpdated: function() {
            var thisOption = this.option;
            if (thisOption.type === "category") {
              this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);
            }
          },
          /**
           * Should not be called before all of 'getInitailData' finished.
           * Because categories are collected during initializing data.
           */
          getCategories: function(rawData) {
            var option = this.option;
            if (option.type === "category") {
              if (rawData) {
                return option.data;
              }
              return this.__ordinalMeta.categories;
            }
          },
          getOrdinalMeta: function() {
            return this.__ordinalMeta;
          },
          defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + "Axis"], extraDefaultOption], true)
        });
      });
      ComponentModel.registerSubTypeDefaulter(axisName + "Axis", zrUtil.curry(axisTypeDefaulter, axisName));
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/AxisModel.js
var require_AxisModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/AxisModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var axisModelCreator = require_axisModelCreator();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var AxisModel = ComponentModel.extend({
      type: "cartesian2dAxis",
      /**
       * @type {module:echarts/coord/cartesian/Axis2D}
       */
      axis: null,
      /**
       * @override
       */
      init: function() {
        AxisModel.superApply(this, "init", arguments);
        this.resetRange();
      },
      /**
       * @override
       */
      mergeOption: function() {
        AxisModel.superApply(this, "mergeOption", arguments);
        this.resetRange();
      },
      /**
       * @override
       */
      restoreData: function() {
        AxisModel.superApply(this, "restoreData", arguments);
        this.resetRange();
      },
      /**
       * @override
       * @return {module:echarts/model/Component}
       */
      getCoordSysModel: function() {
        return this.ecModel.queryComponents({
          mainType: "grid",
          index: this.option.gridIndex,
          id: this.option.gridId
        })[0];
      }
    });
    function getAxisType(axisDim, option) {
      return option.type || (option.data ? "category" : "value");
    }
    zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
    var extraOption = {
      // gridIndex: 0,
      // gridId: '',
      // Offset is for multiple axis on the same position
      offset: 0
    };
    axisModelCreator("x", AxisModel, getAxisType, extraOption);
    axisModelCreator("y", AxisModel, getAxisType, extraOption);
    var _default = AxisModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/GridModel.js
var require_GridModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/GridModel.js"(exports, module) {
    require_AxisModel();
    var ComponentModel = require_Component();
    var _default = ComponentModel.extend({
      type: "grid",
      dependencies: ["xAxis", "yAxis"],
      layoutMode: "box",
      /**
       * @type {module:echarts/coord/cartesian/Grid}
       */
      coordinateSystem: null,
      defaultOption: {
        show: false,
        zlevel: 0,
        z: 0,
        left: "10%",
        top: 60,
        right: "10%",
        bottom: 60,
        // If grid size contain label
        containLabel: false,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 1,
        borderColor: "#ccc"
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Grid.js
var require_Grid = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/Grid.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var isObject = _util.isObject;
    var each = _util.each;
    var map = _util.map;
    var indexOf = _util.indexOf;
    var retrieve = _util.retrieve;
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var _axisHelper = require_axisHelper();
    var createScaleByModel = _axisHelper.createScaleByModel;
    var ifAxisCrossZero = _axisHelper.ifAxisCrossZero;
    var niceScaleExtent = _axisHelper.niceScaleExtent;
    var estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;
    var Cartesian2D = require_Cartesian2D();
    var Axis2D = require_Axis2D();
    var CoordinateSystem = require_CoordinateSystem();
    var _dataStackHelper = require_dataStackHelper();
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    require_GridModel();
    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
      return axisModel.getCoordSysModel() === gridModel;
    }
    function Grid(gridModel, ecModel, api) {
      this._coordsMap = {};
      this._coordsList = [];
      this._axesMap = {};
      this._axesList = [];
      this._initCartesian(gridModel, ecModel, api);
      this.model = gridModel;
    }
    var gridProto = Grid.prototype;
    gridProto.type = "grid";
    gridProto.axisPointerEnabled = true;
    gridProto.getRect = function() {
      return this._rect;
    };
    gridProto.update = function(ecModel, api) {
      var axesMap = this._axesMap;
      this._updateScale(ecModel, this.model);
      each(axesMap.x, function(xAxis) {
        niceScaleExtent(xAxis.scale, xAxis.model);
      });
      each(axesMap.y, function(yAxis) {
        niceScaleExtent(yAxis.scale, yAxis.model);
      });
      var onZeroRecords = {};
      each(axesMap.x, function(xAxis) {
        fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
      });
      each(axesMap.y, function(yAxis) {
        fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
      });
      this.resize(this.model, api);
    };
    function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
      axis.getAxesOnZeroOf = function() {
        return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
      };
      var otherAxes = axesMap[otherAxisDim];
      var otherAxisOnZeroOf;
      var axisModel = axis.model;
      var onZero = axisModel.get("axisLine.onZero");
      var onZeroAxisIndex = axisModel.get("axisLine.onZeroAxisIndex");
      if (!onZero) {
        return;
      }
      if (onZeroAxisIndex != null) {
        if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
          otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
        }
      } else {
        for (var idx in otherAxes) {
          if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
            otherAxisOnZeroOf = otherAxes[idx];
            break;
          }
        }
      }
      if (otherAxisOnZeroOf) {
        onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
      }
      function getOnZeroRecordKey(axis2) {
        return axis2.dim + "_" + axis2.index;
      }
    }
    function canOnZeroToAxis(axis) {
      return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
    }
    gridProto.resize = function(gridModel, api, ignoreContainLabel) {
      var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._rect = gridRect;
      var axesList = this._axesList;
      adjustAxes();
      if (!ignoreContainLabel && gridModel.get("containLabel")) {
        each(axesList, function(axis) {
          if (!axis.model.get("axisLabel.inside")) {
            var labelUnionRect = estimateLabelUnionRect(axis);
            if (labelUnionRect) {
              var dim = axis.isHorizontal() ? "height" : "width";
              var margin = axis.model.get("axisLabel.margin");
              gridRect[dim] -= labelUnionRect[dim] + margin;
              if (axis.position === "top") {
                gridRect.y += labelUnionRect.height + margin;
              } else if (axis.position === "left") {
                gridRect.x += labelUnionRect.width + margin;
              }
            }
          }
        });
        adjustAxes();
      }
      function adjustAxes() {
        each(axesList, function(axis) {
          var isHorizontal = axis.isHorizontal();
          var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
          var idx = axis.inverse ? 1 : 0;
          axis.setExtent(extent[idx], extent[1 - idx]);
          updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
        });
      }
    };
    gridProto.getAxis = function(axisType, axisIndex) {
      var axesMapOnDim = this._axesMap[axisType];
      if (axesMapOnDim != null) {
        if (axisIndex == null) {
          for (var name2 in axesMapOnDim) {
            if (axesMapOnDim.hasOwnProperty(name2)) {
              return axesMapOnDim[name2];
            }
          }
        }
        return axesMapOnDim[axisIndex];
      }
    };
    gridProto.getAxes = function() {
      return this._axesList.slice();
    };
    gridProto.getCartesian = function(xAxisIndex, yAxisIndex) {
      if (xAxisIndex != null && yAxisIndex != null) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        return this._coordsMap[key];
      }
      if (isObject(xAxisIndex)) {
        yAxisIndex = xAxisIndex.yAxisIndex;
        xAxisIndex = xAxisIndex.xAxisIndex;
      }
      for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
        if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
          return coordList[i];
        }
      }
    };
    gridProto.getCartesians = function() {
      return this._coordsList.slice();
    };
    gridProto.convertToPixel = function(ecModel, finder, value) {
      var target = this._findConvertTarget(ecModel, finder);
      return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
    };
    gridProto.convertFromPixel = function(ecModel, finder, value) {
      var target = this._findConvertTarget(ecModel, finder);
      return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
    };
    gridProto._findConvertTarget = function(ecModel, finder) {
      var seriesModel = finder.seriesModel;
      var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis")[0];
      var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis")[0];
      var gridModel = finder.gridModel;
      var coordsList = this._coordsList;
      var cartesian;
      var axis;
      if (seriesModel) {
        cartesian = seriesModel.coordinateSystem;
        indexOf(coordsList, cartesian) < 0 && (cartesian = null);
      } else if (xAxisModel && yAxisModel) {
        cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      } else if (xAxisModel) {
        axis = this.getAxis("x", xAxisModel.componentIndex);
      } else if (yAxisModel) {
        axis = this.getAxis("y", yAxisModel.componentIndex);
      } else if (gridModel) {
        var grid = gridModel.coordinateSystem;
        if (grid === this) {
          cartesian = this._coordsList[0];
        }
      }
      return {
        cartesian,
        axis
      };
    };
    gridProto.containPoint = function(point) {
      var coord = this._coordsList[0];
      if (coord) {
        return coord.containPoint(point);
      }
    };
    gridProto._initCartesian = function(gridModel, ecModel, api) {
      var axisPositionUsed = {
        left: false,
        right: false,
        top: false,
        bottom: false
      };
      var axesMap = {
        x: {},
        y: {}
      };
      var axesCount = {
        x: 0,
        y: 0
      };
      ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
      ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
      if (!axesCount.x || !axesCount.y) {
        this._axesMap = {};
        this._axesList = [];
        return;
      }
      this._axesMap = axesMap;
      each(axesMap.x, function(xAxis, xAxisIndex) {
        each(axesMap.y, function(yAxis, yAxisIndex) {
          var key = "x" + xAxisIndex + "y" + yAxisIndex;
          var cartesian = new Cartesian2D(key);
          cartesian.grid = this;
          cartesian.model = gridModel;
          this._coordsMap[key] = cartesian;
          this._coordsList.push(cartesian);
          cartesian.addAxis(xAxis);
          cartesian.addAxis(yAxis);
        }, this);
      }, this);
      function createAxisCreator(axisType) {
        return function(axisModel, idx) {
          if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
            return;
          }
          var axisPosition = axisModel.get("position");
          if (axisType === "x") {
            if (axisPosition !== "top" && axisPosition !== "bottom") {
              axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
            }
          } else {
            if (axisPosition !== "left" && axisPosition !== "right") {
              axisPosition = axisPositionUsed.left ? "right" : "left";
            }
          }
          axisPositionUsed[axisPosition] = true;
          var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
          var isCategory = axis.type === "category";
          axis.onBand = isCategory && axisModel.get("boundaryGap");
          axis.inverse = axisModel.get("inverse");
          axisModel.axis = axis;
          axis.model = axisModel;
          axis.grid = this;
          axis.index = idx;
          this._axesList.push(axis);
          axesMap[axisType][idx] = axis;
          axesCount[axisType]++;
        };
      }
    };
    gridProto._updateScale = function(ecModel, gridModel) {
      each(this._axesList, function(axis) {
        axis.scale.setExtent(Infinity, -Infinity);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (isCartesian2D(seriesModel)) {
          var axesModels = findAxesModels(seriesModel, ecModel);
          var xAxisModel = axesModels[0];
          var yAxisModel = axesModels[1];
          if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
            return;
          }
          var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
          var data = seriesModel.getData();
          var xAxis = cartesian.getAxis("x");
          var yAxis = cartesian.getAxis("y");
          if (data.type === "list") {
            unionExtent(data, xAxis, seriesModel);
            unionExtent(data, yAxis, seriesModel);
          }
        }
      }, this);
      function unionExtent(data, axis, seriesModel) {
        each(data.mapDimension(axis.dim, true), function(dim) {
          axis.scale.unionExtentFromData(
            // For example, the extent of the orginal dimension
            // is [0.1, 0.5], the extent of the `stackResultDimension`
            // is [7, 9], the final extent should not include [0.1, 0.5].
            data,
            getStackedDimension(data, dim)
          );
        });
      }
    };
    gridProto.getTooltipAxes = function(dim) {
      var baseAxes = [];
      var otherAxes = [];
      each(this.getCartesians(), function(cartesian) {
        var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
        var otherAxis = cartesian.getOtherAxis(baseAxis);
        indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
        indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
      });
      return {
        baseAxes,
        otherAxes
      };
    };
    function updateAxisTransform(axis, coordBase) {
      var axisExtent = axis.getExtent();
      var axisExtentSum = axisExtent[0] + axisExtent[1];
      axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
        return coord + coordBase;
      } : function(coord) {
        return axisExtentSum - coord + coordBase;
      };
      axis.toLocalCoord = axis.dim === "x" ? function(coord) {
        return coord - coordBase;
      } : function(coord) {
        return axisExtentSum - coord + coordBase;
      };
    }
    var axesTypes = ["xAxis", "yAxis"];
    function findAxesModels(seriesModel, ecModel) {
      return map(axesTypes, function(axisType) {
        var axisModel = seriesModel.getReferringComponents(axisType)[0];
        return axisModel;
      });
    }
    function isCartesian2D(seriesModel) {
      return seriesModel.get("coordinateSystem") === "cartesian2d";
    }
    Grid.create = function(ecModel, api) {
      var grids = [];
      ecModel.eachComponent("grid", function(gridModel, idx) {
        var grid = new Grid(gridModel, ecModel, api);
        grid.name = "grid_" + idx;
        grid.resize(gridModel, api, true);
        gridModel.coordinateSystem = grid;
        grids.push(grid);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (!isCartesian2D(seriesModel)) {
          return;
        }
        var axesModels = findAxesModels(seriesModel, ecModel);
        var xAxisModel = axesModels[0];
        var yAxisModel = axesModels[1];
        var gridModel = xAxisModel.getCoordSysModel();
        var grid = gridModel.coordinateSystem;
        seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      });
      return grids;
    };
    Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;
    CoordinateSystem.register("cartesian2d", Grid);
    var _default = Grid;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisBuilder.js
var require_AxisBuilder = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisBuilder.js"(exports, module) {
    var _util = require_util();
    var retrieve = _util.retrieve;
    var defaults = _util.defaults;
    var extend = _util.extend;
    var each = _util.each;
    var formatUtil = require_format();
    var graphic = require_graphic();
    var Model = require_Model();
    var _number = require_number();
    var isRadianAroundZero = _number.isRadianAroundZero;
    var remRadian = _number.remRadian;
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var matrixUtil = require_matrix();
    var _vector = require_vector();
    var v2ApplyTransform = _vector.applyTransform;
    var _axisHelper = require_axisHelper();
    var shouldShowAllLabels = _axisHelper.shouldShowAllLabels;
    var PI = Math.PI;
    var AxisBuilder = function(axisModel, opt) {
      this.opt = opt;
      this.axisModel = axisModel;
      defaults(opt, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: true
      });
      this.group = new graphic.Group();
      var dumbGroup = new graphic.Group({
        position: opt.position.slice(),
        rotation: opt.rotation
      });
      dumbGroup.updateTransform();
      this._transform = dumbGroup.transform;
      this._dumbGroup = dumbGroup;
    };
    AxisBuilder.prototype = {
      constructor: AxisBuilder,
      hasBuilder: function(name2) {
        return !!builders[name2];
      },
      add: function(name2) {
        builders[name2].call(this);
      },
      getGroup: function() {
        return this.group;
      }
    };
    var builders = {
      /**
       * @private
       */
      axisLine: function() {
        var opt = this.opt;
        var axisModel = this.axisModel;
        if (!axisModel.get("axisLine.show")) {
          return;
        }
        var extent = this.axisModel.axis.getExtent();
        var matrix = this._transform;
        var pt1 = [extent[0], 0];
        var pt2 = [extent[1], 0];
        if (matrix) {
          v2ApplyTransform(pt1, pt1, matrix);
          v2ApplyTransform(pt2, pt2, matrix);
        }
        var lineStyle = extend({
          lineCap: "round"
        }, axisModel.getModel("axisLine.lineStyle").getLineStyle());
        this.group.add(new graphic.Line({
          // Id for animation
          anid: "line",
          subPixelOptimize: true,
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          },
          style: lineStyle,
          strokeContainThreshold: opt.strokeContainThreshold || 5,
          silent: true,
          z2: 1
        }));
        var arrows = axisModel.get("axisLine.symbol");
        var arrowSize = axisModel.get("axisLine.symbolSize");
        var arrowOffset = axisModel.get("axisLine.symbolOffset") || 0;
        if (typeof arrowOffset === "number") {
          arrowOffset = [arrowOffset, arrowOffset];
        }
        if (arrows != null) {
          if (typeof arrows === "string") {
            arrows = [arrows, arrows];
          }
          if (typeof arrowSize === "string" || typeof arrowSize === "number") {
            arrowSize = [arrowSize, arrowSize];
          }
          var symbolWidth = arrowSize[0];
          var symbolHeight = arrowSize[1];
          each([{
            rotate: opt.rotation + Math.PI / 2,
            offset: arrowOffset[0],
            r: 0
          }, {
            rotate: opt.rotation - Math.PI / 2,
            offset: arrowOffset[1],
            r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
          }], function(point, index) {
            if (arrows[index] !== "none" && arrows[index] != null) {
              var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);
              var r = point.r + point.offset;
              var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];
              symbol.attr({
                rotation: point.rotate,
                position: pos,
                silent: true,
                z2: 11
              });
              this.group.add(symbol);
            }
          }, this);
        }
      },
      /**
       * @private
       */
      axisTickLabel: function() {
        var axisModel = this.axisModel;
        var opt = this.opt;
        var ticksEls = buildAxisMajorTicks(this, axisModel, opt);
        var labelEls = buildAxisLabel(this, axisModel, opt);
        fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
        buildAxisMinorTicks(this, axisModel, opt);
      },
      /**
       * @private
       */
      axisName: function() {
        var opt = this.opt;
        var axisModel = this.axisModel;
        var name2 = retrieve(opt.axisName, axisModel.get("name"));
        if (!name2) {
          return;
        }
        var nameLocation = axisModel.get("nameLocation");
        var nameDirection = opt.nameDirection;
        var textStyleModel = axisModel.getModel("nameTextStyle");
        var gap = axisModel.get("nameGap") || 0;
        var extent = this.axisModel.axis.getExtent();
        var gapSignal = extent[0] > extent[1] ? -1 : 1;
        var pos = [
          nameLocation === "start" ? extent[0] - gapSignal * gap : nameLocation === "end" ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,
          // 'middle'
          // Reuse labelOffset.
          isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
        ];
        var labelLayout;
        var nameRotation = axisModel.get("nameRotate");
        if (nameRotation != null) {
          nameRotation = nameRotation * PI / 180;
        }
        var axisNameAvailableWidth;
        if (isNameLocationCenter(nameLocation)) {
          labelLayout = innerTextLayout(
            opt.rotation,
            nameRotation != null ? nameRotation : opt.rotation,
            // Adapt to axis.
            nameDirection
          );
        } else {
          labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
          axisNameAvailableWidth = opt.axisNameAvailableWidth;
          if (axisNameAvailableWidth != null) {
            axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
            !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
          }
        }
        var textFont = textStyleModel.getFont();
        var truncateOpt = axisModel.get("nameTruncate", true) || {};
        var ellipsis = truncateOpt.ellipsis;
        var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
        var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name2, maxWidth, textFont, ellipsis, {
          minChar: 2,
          placeholder: truncateOpt.placeholder
        }) : name2;
        var tooltipOpt = axisModel.get("tooltip", true);
        var mainType = axisModel.mainType;
        var formatterParams = {
          componentType: mainType,
          name: name2,
          $vars: ["name"]
        };
        formatterParams[mainType + "Index"] = axisModel.componentIndex;
        var textEl = new graphic.Text({
          // Id for animation
          anid: "name",
          __fullText: name2,
          __truncatedText: truncatedText,
          position: pos,
          rotation: labelLayout.rotation,
          silent: isLabelSilent(axisModel),
          z2: 1,
          tooltip: tooltipOpt && tooltipOpt.show ? extend({
            content: name2,
            formatter: function() {
              return name2;
            },
            formatterParams
          }, tooltipOpt) : null
        });
        graphic.setTextStyle(textEl.style, textStyleModel, {
          text: truncatedText,
          textFont,
          textFill: textStyleModel.getTextColor() || axisModel.get("axisLine.lineStyle.color"),
          textAlign: textStyleModel.get("align") || labelLayout.textAlign,
          textVerticalAlign: textStyleModel.get("verticalAlign") || labelLayout.textVerticalAlign
        });
        if (axisModel.get("triggerEvent")) {
          textEl.eventData = makeAxisEventDataBase(axisModel);
          textEl.eventData.targetType = "axisName";
          textEl.eventData.name = name2;
        }
        this._dumbGroup.add(textEl);
        textEl.updateTransform();
        this.group.add(textEl);
        textEl.decomposeTransform();
      }
    };
    var makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function(axisModel) {
      var eventData = {
        componentType: axisModel.mainType,
        componentIndex: axisModel.componentIndex
      };
      eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
      return eventData;
    };
    var innerTextLayout = AxisBuilder.innerTextLayout = function(axisRotation, textRotation, direction) {
      var rotationDiff = remRadian(textRotation - axisRotation);
      var textAlign;
      var textVerticalAlign;
      if (isRadianAroundZero(rotationDiff)) {
        textVerticalAlign = direction > 0 ? "top" : "bottom";
        textAlign = "center";
      } else if (isRadianAroundZero(rotationDiff - PI)) {
        textVerticalAlign = direction > 0 ? "bottom" : "top";
        textAlign = "center";
      } else {
        textVerticalAlign = "middle";
        if (rotationDiff > 0 && rotationDiff < PI) {
          textAlign = direction > 0 ? "right" : "left";
        } else {
          textAlign = direction > 0 ? "left" : "right";
        }
      }
      return {
        rotation: rotationDiff,
        textAlign,
        textVerticalAlign
      };
    };
    function endTextLayout(opt, textPosition, textRotate, extent) {
      var rotationDiff = remRadian(textRotate - opt.rotation);
      var textAlign;
      var textVerticalAlign;
      var inverse = extent[0] > extent[1];
      var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
      if (isRadianAroundZero(rotationDiff - PI / 2)) {
        textVerticalAlign = onLeft ? "bottom" : "top";
        textAlign = "center";
      } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
        textVerticalAlign = onLeft ? "top" : "bottom";
        textAlign = "center";
      } else {
        textVerticalAlign = "middle";
        if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
          textAlign = onLeft ? "left" : "right";
        } else {
          textAlign = onLeft ? "right" : "left";
        }
      }
      return {
        rotation: rotationDiff,
        textAlign,
        textVerticalAlign
      };
    }
    var isLabelSilent = AxisBuilder.isLabelSilent = function(axisModel) {
      var tooltipOpt = axisModel.get("tooltip");
      return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
    };
    function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
      if (shouldShowAllLabels(axisModel.axis)) {
        return;
      }
      var showMinLabel = axisModel.get("axisLabel.showMinLabel");
      var showMaxLabel = axisModel.get("axisLabel.showMaxLabel");
      labelEls = labelEls || [];
      tickEls = tickEls || [];
      var firstLabel = labelEls[0];
      var nextLabel = labelEls[1];
      var lastLabel = labelEls[labelEls.length - 1];
      var prevLabel = labelEls[labelEls.length - 2];
      var firstTick = tickEls[0];
      var nextTick = tickEls[1];
      var lastTick = tickEls[tickEls.length - 1];
      var prevTick = tickEls[tickEls.length - 2];
      if (showMinLabel === false) {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
      } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
        if (showMinLabel) {
          ignoreEl(nextLabel);
          ignoreEl(nextTick);
        } else {
          ignoreEl(firstLabel);
          ignoreEl(firstTick);
        }
      }
      if (showMaxLabel === false) {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
      } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
        if (showMaxLabel) {
          ignoreEl(prevLabel);
          ignoreEl(prevTick);
        } else {
          ignoreEl(lastLabel);
          ignoreEl(lastTick);
        }
      }
    }
    function ignoreEl(el) {
      el && (el.ignore = true);
    }
    function isTwoLabelOverlapped(current, next, labelLayout) {
      var firstRect = current && current.getBoundingRect().clone();
      var nextRect = next && next.getBoundingRect().clone();
      if (!firstRect || !nextRect) {
        return;
      }
      var mRotationBack = matrixUtil.identity([]);
      matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
      firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
      nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
      return firstRect.intersect(nextRect);
    }
    function isNameLocationCenter(nameLocation) {
      return nameLocation === "middle" || nameLocation === "center";
    }
    function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, aniid) {
      var tickEls = [];
      var pt1 = [];
      var pt2 = [];
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = ticksCoords[i].coord;
        pt1[0] = tickCoord;
        pt1[1] = 0;
        pt2[0] = tickCoord;
        pt2[1] = tickEndCoord;
        if (tickTransform) {
          v2ApplyTransform(pt1, pt1, tickTransform);
          v2ApplyTransform(pt2, pt2, tickTransform);
        }
        var tickEl = new graphic.Line({
          // Id for animation
          anid: aniid + "_" + ticksCoords[i].tickValue,
          subPixelOptimize: true,
          shape: {
            x1: pt1[0],
            y1: pt1[1],
            x2: pt2[0],
            y2: pt2[1]
          },
          style: tickLineStyle,
          z2: 2,
          silent: true
        });
        tickEls.push(tickEl);
      }
      return tickEls;
    }
    function buildAxisMajorTicks(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var tickModel = axisModel.getModel("axisTick");
      if (!tickModel.get("show") || axis.scale.isBlank()) {
        return;
      }
      var lineStyleModel = tickModel.getModel("lineStyle");
      var tickEndCoord = opt.tickDirection * tickModel.get("length");
      var ticksCoords = axis.getTicksCoords();
      var ticksEls = createTicks(ticksCoords, axisBuilder._transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
        stroke: axisModel.get("axisLine.lineStyle.color")
      }), "ticks");
      for (var i = 0; i < ticksEls.length; i++) {
        axisBuilder.group.add(ticksEls[i]);
      }
      return ticksEls;
    }
    function buildAxisMinorTicks(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var minorTickModel = axisModel.getModel("minorTick");
      if (!minorTickModel.get("show") || axis.scale.isBlank()) {
        return;
      }
      var minorTicksCoords = axis.getMinorTicksCoords();
      if (!minorTicksCoords.length) {
        return;
      }
      var lineStyleModel = minorTickModel.getModel("lineStyle");
      var tickEndCoord = opt.tickDirection * minorTickModel.get("length");
      var minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
        stroke: axisModel.get("axisLine.lineStyle.color")
      }));
      for (var i = 0; i < minorTicksCoords.length; i++) {
        var minorTicksEls = createTicks(minorTicksCoords[i], axisBuilder._transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
        for (var k = 0; k < minorTicksEls.length; k++) {
          axisBuilder.group.add(minorTicksEls[k]);
        }
      }
    }
    function buildAxisLabel(axisBuilder, axisModel, opt) {
      var axis = axisModel.axis;
      var show = retrieve(opt.axisLabelShow, axisModel.get("axisLabel.show"));
      if (!show || axis.scale.isBlank()) {
        return;
      }
      var labelModel = axisModel.getModel("axisLabel");
      var labelMargin = labelModel.get("margin");
      var labels = axis.getViewLabels();
      var labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI / 180;
      var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
      var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
      var labelEls = [];
      var silent = isLabelSilent(axisModel);
      var triggerEvent = axisModel.get("triggerEvent");
      each(labels, function(labelItem, index) {
        var tickValue = labelItem.tickValue;
        var formattedLabel = labelItem.formattedLabel;
        var rawLabel = labelItem.rawLabel;
        var itemLabelModel = labelModel;
        if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
          itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);
        }
        var textColor = itemLabelModel.getTextColor() || axisModel.get("axisLine.lineStyle.color");
        var tickCoord = axis.dataToCoord(tickValue);
        var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
        var textEl = new graphic.Text({
          // Id for animation
          anid: "label_" + tickValue,
          position: pos,
          rotation: labelLayout.rotation,
          silent,
          z2: 10
        });
        graphic.setTextStyle(textEl.style, itemLabelModel, {
          text: formattedLabel,
          textAlign: itemLabelModel.getShallow("align", true) || labelLayout.textAlign,
          textVerticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout.textVerticalAlign,
          textFill: typeof textColor === "function" ? textColor(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user repalce ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue,
            index
          ) : textColor
        });
        if (triggerEvent) {
          textEl.eventData = makeAxisEventDataBase(axisModel);
          textEl.eventData.targetType = "axisLabel";
          textEl.eventData.value = rawLabel;
        }
        axisBuilder._dumbGroup.add(textEl);
        textEl.updateTransform();
        labelEls.push(textEl);
        axisBuilder.group.add(textEl);
        textEl.decomposeTransform();
      });
      return labelEls;
    }
    var _default = AxisBuilder;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/modelHelper.js
var require_modelHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/modelHelper.js"(exports) {
    var zrUtil = require_util();
    var Model = require_Model();
    var each = zrUtil.each;
    var curry = zrUtil.curry;
    function collect(ecModel, api) {
      var result = {
        /**
         * key: makeKey(axis.model)
         * value: {
         *      axis,
         *      coordSys,
         *      axisPointerModel,
         *      triggerTooltip,
         *      involveSeries,
         *      snap,
         *      seriesModels,
         *      seriesDataCount
         * }
         */
        axesInfo: {},
        seriesInvolved: false,
        /**
         * key: makeKey(coordSys.model)
         * value: Object: key makeKey(axis.model), value: axisInfo
         */
        coordSysAxesInfo: {},
        coordSysMap: {}
      };
      collectAxesInfo(result, ecModel, api);
      result.seriesInvolved && collectSeriesInfo(result, ecModel);
      return result;
    }
    function collectAxesInfo(result, ecModel, api) {
      var globalTooltipModel = ecModel.getComponent("tooltip");
      var globalAxisPointerModel = ecModel.getComponent("axisPointer");
      var linksOption = globalAxisPointerModel.get("link", true) || [];
      var linkGroups = [];
      each(api.getCoordinateSystems(), function(coordSys) {
        if (!coordSys.axisPointerEnabled) {
          return;
        }
        var coordSysKey = makeKey(coordSys.model);
        var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
        result.coordSysMap[coordSysKey] = coordSys;
        var coordSysModel = coordSys.model;
        var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
        each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));
        if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
          var triggerAxis = baseTooltipModel.get("trigger") === "axis";
          var cross = baseTooltipModel.get("axisPointer.type") === "cross";
          var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get("axisPointer.axis"));
          if (triggerAxis || cross) {
            each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
          }
          if (cross) {
            each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", false));
          }
        }
        function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
          var axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
          var axisPointerShow = axisPointerModel.get("show");
          if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
            return;
          }
          if (triggerTooltip == null) {
            triggerTooltip = axisPointerModel.get("triggerTooltip");
          }
          axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
          var snap = axisPointerModel.get("snap");
          var key = makeKey(axis.model);
          var involveSeries = triggerTooltip || snap || axis.type === "category";
          var axisInfo = result.axesInfo[key] = {
            key,
            axis,
            coordSys,
            axisPointerModel,
            triggerTooltip,
            involveSeries,
            snap,
            useHandle: isHandleTrigger(axisPointerModel),
            seriesModels: []
          };
          axesInfoInCoordSys[key] = axisInfo;
          result.seriesInvolved |= involveSeries;
          var groupIndex = getLinkGroupIndex(linksOption, axis);
          if (groupIndex != null) {
            var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
              axesInfo: {}
            });
            linkGroup.axesInfo[key] = axisInfo;
            linkGroup.mapper = linksOption[groupIndex].mapper;
            axisInfo.linkGroup = linkGroup;
          }
        }
      });
    }
    function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
      var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
      var volatileOption = {};
      each(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function(field) {
        volatileOption[field] = zrUtil.clone(tooltipAxisPointerModel.get(field));
      });
      volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
      if (tooltipAxisPointerModel.get("type") === "cross") {
        volatileOption.type = "line";
      }
      var labelOption = volatileOption.label || (volatileOption.label = {});
      labelOption.show == null && (labelOption.show = false);
      if (fromTooltip === "cross") {
        var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get("label.show");
        labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
        if (!triggerTooltip) {
          var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
          crossStyle && zrUtil.defaults(labelOption, crossStyle.textStyle);
        }
      }
      return axis.model.getModel("axisPointer", new Model(volatileOption, globalAxisPointerModel, ecModel));
    }
    function collectSeriesInfo(result, ecModel) {
      ecModel.eachSeries(function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesTooltipTrigger = seriesModel.get("tooltip.trigger", true);
        var seriesTooltipShow = seriesModel.get("tooltip.show", true);
        if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get("axisPointer.show", true) === false) {
          return;
        }
        each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
          var axis = axisInfo.axis;
          if (coordSys.getAxis(axis.dim) === axis) {
            axisInfo.seriesModels.push(seriesModel);
            axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
            axisInfo.seriesDataCount += seriesModel.getData().count();
          }
        });
      }, this);
    }
    function getLinkGroupIndex(linksOption, axis) {
      var axisModel = axis.model;
      var dim = axis.dim;
      for (var i = 0; i < linksOption.length; i++) {
        var linkOption = linksOption[i] || {};
        if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
          return i;
        }
      }
    }
    function checkPropInLink(linkPropValue, axisPropValue) {
      return linkPropValue === "all" || zrUtil.isArray(linkPropValue) && zrUtil.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
    }
    function fixValue(axisModel) {
      var axisInfo = getAxisInfo(axisModel);
      if (!axisInfo) {
        return;
      }
      var axisPointerModel = axisInfo.axisPointerModel;
      var scale = axisInfo.axis.scale;
      var option = axisPointerModel.option;
      var status = axisPointerModel.get("status");
      var value = axisPointerModel.get("value");
      if (value != null) {
        value = scale.parse(value);
      }
      var useHandle = isHandleTrigger(axisPointerModel);
      if (status == null) {
        option.status = useHandle ? "show" : "hide";
      }
      var extent = scale.getExtent().slice();
      extent[0] > extent[1] && extent.reverse();
      if (
        // Pick a value on axis when initializing.
        value == null || value > extent[1]
      ) {
        value = extent[1];
      }
      if (value < extent[0]) {
        value = extent[0];
      }
      option.value = value;
      if (useHandle) {
        option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
      }
    }
    function getAxisInfo(axisModel) {
      var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
      return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
    }
    function getAxisPointerModel(axisModel) {
      var axisInfo = getAxisInfo(axisModel);
      return axisInfo && axisInfo.axisPointerModel;
    }
    function isHandleTrigger(axisPointerModel) {
      return !!axisPointerModel.get("handle.show");
    }
    function makeKey(model) {
      return model.type + "||" + model.id;
    }
    exports.collect = collect;
    exports.fixValue = fixValue;
    exports.getAxisInfo = getAxisInfo;
    exports.getAxisPointerModel = getAxisPointerModel;
    exports.makeKey = makeKey;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisView.js
var require_AxisView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AxisView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var axisPointerModelHelper = require_modelHelper();
    var AxisView = echarts.extendComponentView({
      type: "axis",
      /**
       * @private
       */
      _axisPointer: null,
      /**
       * @protected
       * @type {string}
       */
      axisPointerClass: null,
      /**
       * @override
       */
      render: function(axisModel, ecModel, api, payload) {
        this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
        AxisView.superApply(this, "render", arguments);
        updateAxisPointer(this, axisModel, ecModel, api, payload, true);
      },
      /**
       * Action handler.
       * @public
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/model/Global} ecModel
       * @param {module:echarts/ExtensionAPI} api
       * @param {Object} payload
       */
      updateAxisPointer: function(axisModel, ecModel, api, payload, force) {
        updateAxisPointer(this, axisModel, ecModel, api, payload, false);
      },
      /**
       * @override
       */
      remove: function(ecModel, api) {
        var axisPointer = this._axisPointer;
        axisPointer && axisPointer.remove(api);
        AxisView.superApply(this, "remove", arguments);
      },
      /**
       * @override
       */
      dispose: function(ecModel, api) {
        disposeAxisPointer(this, api);
        AxisView.superApply(this, "dispose", arguments);
      }
    });
    function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
      var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);
      if (!Clazz) {
        return;
      }
      var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
      axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
    }
    function disposeAxisPointer(axisView, ecModel, api) {
      var axisPointer = axisView._axisPointer;
      axisPointer && axisPointer.dispose(ecModel, api);
      axisView._axisPointer = null;
    }
    var axisPointerClazz = [];
    AxisView.registerAxisPointerClass = function(type, clazz) {
      axisPointerClazz[type] = clazz;
    };
    AxisView.getAxisPointerClass = function(type) {
      return type && axisPointerClazz[type];
    };
    var _default = AxisView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js
var require_cartesianAxisHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/cartesianAxisHelper.js"(exports) {
    var zrUtil = require_util();
    function layout(gridModel, axisModel, opt) {
      opt = opt || {};
      var grid = gridModel.coordinateSystem;
      var axis = axisModel.axis;
      var layout2 = {};
      var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
      var rawAxisPosition = axis.position;
      var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
      var axisDim = axis.dim;
      var rect = grid.getRect();
      var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
      var idx = {
        left: 0,
        right: 1,
        top: 0,
        bottom: 1,
        onZero: 2
      };
      var axisOffset = axisModel.get("offset") || 0;
      var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
      if (otherAxisOnZeroOf) {
        var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
        posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
      }
      layout2.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
      layout2.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
      var dirMap = {
        top: -1,
        bottom: 1,
        left: -1,
        right: 1
      };
      layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = dirMap[rawAxisPosition];
      layout2.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
      if (axisModel.get("axisTick.inside")) {
        layout2.tickDirection = -layout2.tickDirection;
      }
      if (zrUtil.retrieve(opt.labelInside, axisModel.get("axisLabel.inside"))) {
        layout2.labelDirection = -layout2.labelDirection;
      }
      var labelRotate = axisModel.get("axisLabel.rotate");
      layout2.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
      layout2.z2 = 1;
      return layout2;
    }
    exports.layout = layout;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/axisSplitHelper.js
var require_axisSplitHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/axisSplitHelper.js"(exports) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
      var axis = axisModel.axis;
      if (axis.scale.isBlank()) {
        return;
      }
      var splitAreaModel = axisModel.getModel("splitArea");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var areaColors = areaStyleModel.get("color");
      var gridRect = gridModel.coordinateSystem.getRect();
      var ticksCoords = axis.getTicksCoords({
        tickModel: splitAreaModel,
        clamp: true
      });
      if (!ticksCoords.length) {
        return;
      }
      var areaColorsLen = areaColors.length;
      var lastSplitAreaColors = axisView.__splitAreaColors;
      var newSplitAreaColors = zrUtil.createHashMap();
      var colorIndex = 0;
      if (lastSplitAreaColors) {
        for (var i = 0; i < ticksCoords.length; i++) {
          var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
          if (cIndex != null) {
            colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
            break;
          }
        }
      }
      var prev = axis.toGlobalCoord(ticksCoords[0].coord);
      var areaStyle = areaStyleModel.getAreaStyle();
      areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
      for (var i = 1; i < ticksCoords.length; i++) {
        var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
        var x;
        var y;
        var width;
        var height;
        if (axis.isHorizontal()) {
          x = prev;
          y = gridRect.y;
          width = tickCoord - x;
          height = gridRect.height;
          prev = x + width;
        } else {
          x = gridRect.x;
          y = prev;
          width = gridRect.width;
          height = tickCoord - y;
          prev = y + height;
        }
        var tickValue = ticksCoords[i - 1].tickValue;
        tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
        axisGroup.add(new graphic.Rect({
          anid: tickValue != null ? "area_" + tickValue : null,
          shape: {
            x,
            y,
            width,
            height
          },
          style: zrUtil.defaults({
            fill: areaColors[colorIndex]
          }, areaStyle),
          silent: true
        }));
        colorIndex = (colorIndex + 1) % areaColorsLen;
      }
      axisView.__splitAreaColors = newSplitAreaColors;
    }
    function rectCoordAxisHandleRemove(axisView) {
      axisView.__splitAreaColors = null;
    }
    exports.rectCoordAxisBuildSplitArea = rectCoordAxisBuildSplitArea;
    exports.rectCoordAxisHandleRemove = rectCoordAxisHandleRemove;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/CartesianAxisView.js
var require_CartesianAxisView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/CartesianAxisView.js"() {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var AxisBuilder = require_AxisBuilder();
    var AxisView = require_AxisView();
    var cartesianAxisHelper = require_cartesianAxisHelper();
    var _axisSplitHelper = require_axisSplitHelper();
    var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
    var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine"];
    var CartesianAxisView = AxisView.extend({
      type: "cartesianAxis",
      axisPointerClass: "CartesianAxisPointer",
      /**
       * @override
       */
      render: function(axisModel, ecModel, api, payload) {
        this.group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic.Group();
        this.group.add(this._axisGroup);
        if (!axisModel.get("show")) {
          return;
        }
        var gridModel = axisModel.getCoordSysModel();
        var layout = cartesianAxisHelper.layout(gridModel, axisModel);
        var axisBuilder = new AxisBuilder(axisModel, layout);
        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        this._axisGroup.add(axisBuilder.getGroup());
        zrUtil.each(selfBuilderAttrs, function(name2) {
          if (axisModel.get(name2 + ".show")) {
            this["_" + name2](axisModel, gridModel);
          }
        }, this);
        graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
        CartesianAxisView.superCall(this, "render", axisModel, ecModel, api, payload);
      },
      remove: function() {
        rectCoordAxisHandleRemove(this);
      },
      /**
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/coord/cartesian/GridModel} gridModel
       * @private
       */
      _splitLine: function(axisModel, gridModel) {
        var axis = axisModel.axis;
        if (axis.scale.isBlank()) {
          return;
        }
        var splitLineModel = axisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineColors = lineStyleModel.get("color");
        lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
        var gridRect = gridModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var lineCount = 0;
        var ticksCoords = axis.getTicksCoords({
          tickModel: splitLineModel
        });
        var p1 = [];
        var p2 = [];
        var lineStyle = lineStyleModel.getLineStyle();
        for (var i = 0; i < ticksCoords.length; i++) {
          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          var colorIndex = lineCount++ % lineColors.length;
          var tickValue = ticksCoords[i].tickValue;
          this._axisGroup.add(new graphic.Line({
            anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
            subPixelOptimize: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: zrUtil.defaults({
              stroke: lineColors[colorIndex]
            }, lineStyle),
            silent: true
          }));
        }
      },
      /**
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/coord/cartesian/GridModel} gridModel
       * @private
       */
      _minorSplitLine: function(axisModel, gridModel) {
        var axis = axisModel.axis;
        var minorSplitLineModel = axisModel.getModel("minorSplitLine");
        var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
        var gridRect = gridModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var minorTicksCoords = axis.getMinorTicksCoords();
        if (!minorTicksCoords.length) {
          return;
        }
        var p1 = [];
        var p2 = [];
        var lineStyle = lineStyleModel.getLineStyle();
        for (var i = 0; i < minorTicksCoords.length; i++) {
          for (var k = 0; k < minorTicksCoords[i].length; k++) {
            var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
            if (isHorizontal) {
              p1[0] = tickCoord;
              p1[1] = gridRect.y;
              p2[0] = tickCoord;
              p2[1] = gridRect.y + gridRect.height;
            } else {
              p1[0] = gridRect.x;
              p1[1] = tickCoord;
              p2[0] = gridRect.x + gridRect.width;
              p2[1] = tickCoord;
            }
            this._axisGroup.add(new graphic.Line({
              anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
              subPixelOptimize: true,
              shape: {
                x1: p1[0],
                y1: p1[1],
                x2: p2[0],
                y2: p2[1]
              },
              style: lineStyle,
              silent: true
            }));
          }
        }
      },
      /**
       * @param {module:echarts/coord/cartesian/AxisModel} axisModel
       * @param {module:echarts/coord/cartesian/GridModel} gridModel
       * @private
       */
      _splitArea: function(axisModel, gridModel) {
        rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, gridModel);
      }
    });
    CartesianAxisView.extend({
      type: "xAxis"
    });
    CartesianAxisView.extend({
      type: "yAxis"
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis.js
var require_axis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis.js"() {
    require_AxisModel();
    require_CartesianAxisView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/gridSimple.js
var require_gridSimple = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/gridSimple.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    require_Grid();
    require_axis();
    echarts.extendComponentView({
      type: "grid",
      render: function(gridModel, ecModel) {
        this.group.removeAll();
        if (gridModel.get("show")) {
          this.group.add(new graphic.Rect({
            shape: gridModel.coordinateSystem.getRect(),
            style: zrUtil.defaults({
              fill: gridModel.get("backgroundColor")
            }, gridModel.getItemStyle()),
            silent: true,
            z2: -1
          }));
        }
      }
    });
    echarts.registerPreprocessor(function(option) {
      if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {};
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line.js
var require_line2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/line.js"() {
    var echarts = require_echarts();
    require_LineSeries();
    require_LineView();
    var visualSymbol = require_symbol2();
    var layoutPoints = require_points();
    var dataSample = require_dataSample();
    require_gridSimple();
    echarts.registerVisual(visualSymbol("line", "circle", "line"));
    echarts.registerLayout(layoutPoints("line"));
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BaseBarSeries.js
var require_BaseBarSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BaseBarSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createListFromArray = require_createListFromArray();
    var _default = SeriesModel.extend({
      type: "series.__base_bar__",
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      getMarkerPosition: function(value) {
        var coordSys = this.coordinateSystem;
        if (coordSys) {
          var pt = coordSys.dataToPoint(coordSys.clampData(value));
          var data = this.getData();
          var offset = data.getLayout("offset");
          var size = data.getLayout("size");
          var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
          pt[offsetIndex] += offset + size / 2;
          return pt;
        }
        return [NaN, NaN];
      },
      defaultOption: {
        zlevel: 0,
        // 一级层叠
        z: 2,
        // 二级层叠
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        // stack: null
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // 最小高度改为0
        barMinHeight: 0,
        // 最小角度为0，仅对极坐标系下的柱状图有效
        barMinAngle: 0,
        // cursor: null,
        large: false,
        largeThreshold: 400,
        progressive: 3e3,
        progressiveChunkMode: "mod",
        // barMaxWidth: null,
        // In cartesian, the default value is 1. Otherwise null.
        // barMinWidth: null,
        // 默认自适应
        // barWidth: null,
        // 柱间距离，默认为柱形宽度的30%，可设固定值
        // barGap: '30%',
        // 类目间柱形距离，默认为类目间距的20%，可设固定值
        // barCategoryGap: '20%',
        // label: {
        //      show: false
        // },
        itemStyle: {},
        emphasis: {}
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarSeries.js
var require_BarSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarSeries.js"(exports, module) {
    var BaseBarSeries = require_BaseBarSeries();
    var _default = BaseBarSeries.extend({
      type: "series.bar",
      dependencies: ["grid", "polar"],
      brushSelector: "rect",
      /**
       * @override
       */
      getProgressive: function() {
        return this.get("large") ? this.get("progressive") : false;
      },
      /**
       * @override
       */
      getProgressiveThreshold: function() {
        var progressiveThreshold = this.get("progressiveThreshold");
        var largeThreshold = this.get("largeThreshold");
        if (largeThreshold > progressiveThreshold) {
          progressiveThreshold = largeThreshold;
        }
        return progressiveThreshold;
      },
      defaultOption: {
        // If clipped
        // Only available on cartesian2d
        clip: true,
        // If use caps on two sides of bars
        // Only available on tangential polar bar
        roundCap: false,
        showBackground: false,
        backgroundStyle: {
          color: "rgba(180, 180, 180, 0.2)",
          borderColor: null,
          borderWidth: 0,
          borderType: "solid",
          borderRadius: 0,
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        }
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/helper.js
var require_helper4 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/helper.js"(exports) {
    var graphic = require_graphic();
    var _labelHelper = require_labelHelper();
    var getDefaultLabel = _labelHelper.getDefaultLabel;
    function setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {
      var labelModel = itemModel.getModel("label");
      var hoverLabelModel = itemModel.getModel("emphasis.label");
      graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
        labelFetcher: seriesModel,
        labelDataIndex: dataIndex,
        defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
        isRectText: true,
        autoColor: color
      });
      fixPosition(normalStyle);
      fixPosition(hoverStyle);
    }
    function fixPosition(style, labelPositionOutside) {
      if (style.textPosition === "outside") {
        style.textPosition = labelPositionOutside;
      }
    }
    exports.setLabel = setLabel;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/barItemStyle.js
var require_barItemStyle = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/barItemStyle.js"(exports, module) {
    var makeStyleMapper = require_makeStyleMapper();
    var getBarItemStyle = makeStyleMapper([
      ["fill", "color"],
      ["stroke", "borderColor"],
      ["lineWidth", "borderWidth"],
      // Compatitable with 2
      ["stroke", "barBorderColor"],
      ["lineWidth", "barBorderWidth"],
      ["opacity"],
      ["shadowBlur"],
      ["shadowOffsetX"],
      ["shadowOffsetY"],
      ["shadowColor"]
    ]);
    var _default = {
      getBarItemStyle: function(excludes) {
        var style = getBarItemStyle(this, excludes);
        if (this.getBorderLineDash) {
          var lineDash = this.getBorderLineDash();
          lineDash && (style.lineDash = lineDash);
        }
        return style;
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/shape/sausage.js
var require_sausage = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/shape/sausage.js"(exports, module) {
    var _graphic = require_graphic();
    var extendShape = _graphic.extendShape;
    var _default = extendShape({
      type: "sausage",
      shape: {
        cx: 0,
        cy: 0,
        r0: 0,
        r: 0,
        startAngle: 0,
        endAngle: Math.PI * 2,
        clockwise: true
      },
      buildPath: function(ctx, shape) {
        var x = shape.cx;
        var y = shape.cy;
        var r0 = Math.max(shape.r0 || 0, 0);
        var r = Math.max(shape.r, 0);
        var dr = (r - r0) * 0.5;
        var rCenter = r0 + dr;
        var startAngle = shape.startAngle;
        var endAngle = shape.endAngle;
        var clockwise = shape.clockwise;
        var unitStartX = Math.cos(startAngle);
        var unitStartY = Math.sin(startAngle);
        var unitEndX = Math.cos(endAngle);
        var unitEndY = Math.sin(endAngle);
        var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;
        if (lessThanCircle) {
          ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
          ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
        }
        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
        ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
        ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
        if (r0 !== 0) {
          ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
          ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
        }
        ctx.closePath();
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarView.js
var require_BarView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/BarView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var _helper = require_helper4();
    var setLabel = _helper.setLabel;
    var Model = require_Model();
    var barItemStyle = require_barItemStyle();
    var Path = require_Path();
    var Group = require_Group();
    var _throttle = require_throttle();
    var throttle = _throttle.throttle;
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var Sausage = require_sausage();
    var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "barBorderWidth"];
    var _eventPos = [0, 0];
    zrUtil.extend(Model.prototype, barItemStyle);
    function getClipArea(coord, data) {
      var coordSysClipArea = coord.getArea && coord.getArea();
      if (coord.type === "cartesian2d") {
        var baseAxis = coord.getBaseAxis();
        if (baseAxis.type !== "category" || !baseAxis.onBand) {
          var expandWidth = data.getLayout("bandWidth");
          if (baseAxis.isHorizontal()) {
            coordSysClipArea.x -= expandWidth;
            coordSysClipArea.width += expandWidth * 2;
          } else {
            coordSysClipArea.y -= expandWidth;
            coordSysClipArea.height += expandWidth * 2;
          }
        }
      }
      return coordSysClipArea;
    }
    var _default = echarts.extendChartView({
      type: "bar",
      render: function(seriesModel, ecModel, api) {
        this._updateDrawMode(seriesModel);
        var coordinateSystemType = seriesModel.get("coordinateSystem");
        if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
          this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);
        } else {
        }
        return this.group;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this._clear();
        this._updateDrawMode(seriesModel);
      },
      incrementalRender: function(params, seriesModel, ecModel, api) {
        this._incrementalRenderLarge(params, seriesModel);
      },
      _updateDrawMode: function(seriesModel) {
        var isLargeDraw = seriesModel.pipelineContext.large;
        if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw;
          this._clear();
        }
      },
      _renderNormal: function(seriesModel, ecModel, api) {
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        var coord = seriesModel.coordinateSystem;
        var baseAxis = coord.getBaseAxis();
        var isHorizontalOrRadial;
        if (coord.type === "cartesian2d") {
          isHorizontalOrRadial = baseAxis.isHorizontal();
        } else if (coord.type === "polar") {
          isHorizontalOrRadial = baseAxis.dim === "angle";
        }
        var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
        var needsClip = seriesModel.get("clip", true);
        var coordSysClipArea = getClipArea(coord, data);
        group.removeClipPath();
        var roundCap = seriesModel.get("roundCap", true);
        var drawBackground = seriesModel.get("showBackground", true);
        var backgroundModel = seriesModel.getModel("backgroundStyle");
        var barBorderRadius = backgroundModel.get("barBorderRadius") || 0;
        var bgEls = [];
        var oldBgEls = this._backgroundEls || [];
        var createBackground = function(dataIndex) {
          var bgLayout = getLayout[coord.type](data, dataIndex);
          var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
          bgEl.useStyle(backgroundModel.getBarItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          }
          bgEls[dataIndex] = bgEl;
          return bgEl;
        };
        data.diff(oldData).add(function(dataIndex) {
          var itemModel = data.getItemModel(dataIndex);
          var layout = getLayout[coord.type](data, dataIndex, itemModel);
          if (drawBackground) {
            createBackground(dataIndex);
          }
          if (!data.hasValue(dataIndex)) {
            return;
          }
          if (needsClip) {
            var isClipped = clip[coord.type](coordSysClipArea, layout);
            if (isClipped) {
              group.remove(el);
              return;
            }
          }
          var el = elementCreator[coord.type](dataIndex, layout, isHorizontalOrRadial, animationModel, false, roundCap);
          data.setItemGraphicEl(dataIndex, el);
          group.add(el);
          updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === "polar");
        }).update(function(newIndex, oldIndex) {
          var itemModel = data.getItemModel(newIndex);
          var layout = getLayout[coord.type](data, newIndex, itemModel);
          if (drawBackground) {
            var bgEl;
            if (oldBgEls.length === 0) {
              bgEl = createBackground(oldIndex);
            } else {
              bgEl = oldBgEls[oldIndex];
              bgEl.useStyle(backgroundModel.getBarItemStyle());
              if (coord.type === "cartesian2d") {
                bgEl.setShape("r", barBorderRadius);
              }
              bgEls[newIndex] = bgEl;
            }
            var bgLayout = getLayout[coord.type](data, newIndex);
            var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
            graphic.updateProps(bgEl, {
              shape
            }, animationModel, newIndex);
          }
          var el = oldData.getItemGraphicEl(oldIndex);
          if (!data.hasValue(newIndex)) {
            group.remove(el);
            return;
          }
          if (needsClip) {
            var isClipped = clip[coord.type](coordSysClipArea, layout);
            if (isClipped) {
              group.remove(el);
              return;
            }
          }
          if (el) {
            graphic.updateProps(el, {
              shape: layout
            }, animationModel, newIndex);
          } else {
            el = elementCreator[coord.type](newIndex, layout, isHorizontalOrRadial, animationModel, true, roundCap);
          }
          data.setItemGraphicEl(newIndex, el);
          group.add(el);
          updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === "polar");
        }).remove(function(dataIndex) {
          var el = oldData.getItemGraphicEl(dataIndex);
          if (coord.type === "cartesian2d") {
            el && removeRect(dataIndex, animationModel, el);
          } else {
            el && removeSector(dataIndex, animationModel, el);
          }
        }).execute();
        var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());
        bgGroup.removeAll();
        for (var i = 0; i < bgEls.length; ++i) {
          bgGroup.add(bgEls[i]);
        }
        group.add(bgGroup);
        this._backgroundEls = bgEls;
        this._data = data;
      },
      _renderLarge: function(seriesModel, ecModel, api) {
        this._clear();
        createLarge(seriesModel, this.group);
        var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
        if (clipPath) {
          this.group.setClipPath(clipPath);
        } else {
          this.group.removeClipPath();
        }
      },
      _incrementalRenderLarge: function(params, seriesModel) {
        this._removeBackground();
        createLarge(seriesModel, this.group, true);
      },
      dispose: zrUtil.noop,
      remove: function(ecModel) {
        this._clear(ecModel);
      },
      _clear: function(ecModel) {
        var group = this.group;
        var data = this._data;
        if (ecModel && ecModel.get("animation") && data && !this._isLargeDraw) {
          this._removeBackground();
          this._backgroundEls = [];
          data.eachItemGraphicEl(function(el) {
            if (el.type === "sector") {
              removeSector(el.dataIndex, ecModel, el);
            } else {
              removeRect(el.dataIndex, ecModel, el);
            }
          });
        } else {
          group.removeAll();
        }
        this._data = null;
      },
      _removeBackground: function() {
        this.group.remove(this._backgroundGroup);
        this._backgroundGroup = null;
      }
    });
    var mathMax = Math.max;
    var mathMin = Math.min;
    var clip = {
      cartesian2d: function(coordSysBoundingRect, layout) {
        var signWidth = layout.width < 0 ? -1 : 1;
        var signHeight = layout.height < 0 ? -1 : 1;
        if (signWidth < 0) {
          layout.x += layout.width;
          layout.width = -layout.width;
        }
        if (signHeight < 0) {
          layout.y += layout.height;
          layout.height = -layout.height;
        }
        var x = mathMax(layout.x, coordSysBoundingRect.x);
        var x2 = mathMin(layout.x + layout.width, coordSysBoundingRect.x + coordSysBoundingRect.width);
        var y = mathMax(layout.y, coordSysBoundingRect.y);
        var y2 = mathMin(layout.y + layout.height, coordSysBoundingRect.y + coordSysBoundingRect.height);
        layout.x = x;
        layout.y = y;
        layout.width = x2 - x;
        layout.height = y2 - y;
        var clipped = layout.width < 0 || layout.height < 0;
        if (signWidth < 0) {
          layout.x += layout.width;
          layout.width = -layout.width;
        }
        if (signHeight < 0) {
          layout.y += layout.height;
          layout.height = -layout.height;
        }
        return clipped;
      },
      polar: function(coordSysClipArea, layout) {
        var signR = layout.r0 <= layout.r ? 1 : -1;
        if (signR < 0) {
          var r = layout.r;
          layout.r = layout.r0;
          layout.r0 = r;
        }
        var r = mathMin(layout.r, coordSysClipArea.r);
        var r0 = mathMax(layout.r0, coordSysClipArea.r0);
        layout.r = r;
        layout.r0 = r0;
        var clipped = r - r0 < 0;
        if (signR < 0) {
          var r = layout.r;
          layout.r = layout.r0;
          layout.r0 = r;
        }
        return clipped;
      }
    };
    var elementCreator = {
      cartesian2d: function(dataIndex, layout, isHorizontal, animationModel, isUpdate) {
        var rect = new graphic.Rect({
          shape: zrUtil.extend({}, layout),
          z2: 1
        });
        rect.name = "item";
        if (animationModel) {
          var rectShape = rect.shape;
          var animateProperty = isHorizontal ? "height" : "width";
          var animateTarget = {};
          rectShape[animateProperty] = 0;
          animateTarget[animateProperty] = layout[animateProperty];
          graphic[isUpdate ? "updateProps" : "initProps"](rect, {
            shape: animateTarget
          }, animationModel, dataIndex);
        }
        return rect;
      },
      polar: function(dataIndex, layout, isRadial, animationModel, isUpdate, roundCap) {
        var clockwise = layout.startAngle < layout.endAngle;
        var ShapeClass = !isRadial && roundCap ? Sausage : graphic.Sector;
        var sector = new ShapeClass({
          shape: zrUtil.defaults({
            clockwise
          }, layout),
          z2: 1
        });
        sector.name = "item";
        if (animationModel) {
          var sectorShape = sector.shape;
          var animateProperty = isRadial ? "r" : "endAngle";
          var animateTarget = {};
          sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
          animateTarget[animateProperty] = layout[animateProperty];
          graphic[isUpdate ? "updateProps" : "initProps"](sector, {
            shape: animateTarget
          }, animationModel, dataIndex);
        }
        return sector;
      }
    };
    function removeRect(dataIndex, animationModel, el) {
      el.style.text = null;
      graphic.updateProps(el, {
        shape: {
          width: 0
        }
      }, animationModel, dataIndex, function() {
        el.parent && el.parent.remove(el);
      });
    }
    function removeSector(dataIndex, animationModel, el) {
      el.style.text = null;
      graphic.updateProps(el, {
        shape: {
          r: el.shape.r0
        }
      }, animationModel, dataIndex, function() {
        el.parent && el.parent.remove(el);
      });
    }
    var getLayout = {
      // itemModel is only used to get borderWidth, which is not needed
      // when calculating bar background layout.
      cartesian2d: function(data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0;
        var signX = layout.width > 0 ? 1 : -1;
        var signY = layout.height > 0 ? 1 : -1;
        return {
          x: layout.x + signX * fixedLineWidth / 2,
          y: layout.y + signY * fixedLineWidth / 2,
          width: layout.width - signX * fixedLineWidth,
          height: layout.height - signY * fixedLineWidth
        };
      },
      polar: function(data, dataIndex, itemModel) {
        var layout = data.getItemLayout(dataIndex);
        return {
          cx: layout.cx,
          cy: layout.cy,
          r0: layout.r0,
          r: layout.r,
          startAngle: layout.startAngle,
          endAngle: layout.endAngle
        };
      }
    };
    function isZeroOnPolar(layout) {
      return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
    }
    function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
      var color = data.getItemVisual(dataIndex, "color");
      var opacity = data.getItemVisual(dataIndex, "opacity");
      var stroke = data.getVisual("borderColor");
      var itemStyleModel = itemModel.getModel("itemStyle");
      var hoverStyle = itemModel.getModel("emphasis.itemStyle").getBarItemStyle();
      if (!isPolar) {
        el.setShape("r", itemStyleModel.get("barBorderRadius") || 0);
      }
      el.useStyle(zrUtil.defaults({
        stroke: isZeroOnPolar(layout) ? "none" : stroke,
        fill: isZeroOnPolar(layout) ? "none" : color,
        opacity
      }, itemStyleModel.getBarItemStyle()));
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && el.attr("cursor", cursorStyle);
      var labelPositionOutside = isHorizontal ? layout.height > 0 ? "bottom" : "top" : layout.width > 0 ? "left" : "right";
      if (!isPolar) {
        setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);
      }
      if (isZeroOnPolar(layout)) {
        hoverStyle.fill = hoverStyle.stroke = "none";
      }
      graphic.setHoverStyle(el, hoverStyle);
    }
    function getLineWidth(itemModel, rawLayout) {
      var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
      var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
      var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
      return Math.min(lineWidth, width, height);
    }
    var LargePath = Path.extend({
      type: "largeBar",
      shape: {
        points: []
      },
      buildPath: function(ctx, shape) {
        var points = shape.points;
        var startPoint = this.__startPoint;
        var baseDimIdx = this.__baseDimIdx;
        for (var i = 0; i < points.length; i += 2) {
          startPoint[baseDimIdx] = points[i + baseDimIdx];
          ctx.moveTo(startPoint[0], startPoint[1]);
          ctx.lineTo(points[i], points[i + 1]);
        }
      }
    });
    function createLarge(seriesModel, group, incremental) {
      var data = seriesModel.getData();
      var startPoint = [];
      var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
      startPoint[1 - baseDimIdx] = data.getLayout("valueAxisStart");
      var largeDataIndices = data.getLayout("largeDataIndices");
      var barWidth = data.getLayout("barWidth");
      var backgroundModel = seriesModel.getModel("backgroundStyle");
      var drawBackground = seriesModel.get("showBackground", true);
      if (drawBackground) {
        var points = data.getLayout("largeBackgroundPoints");
        var backgroundStartPoint = [];
        backgroundStartPoint[1 - baseDimIdx] = data.getLayout("backgroundStart");
        var bgEl = new LargePath({
          shape: {
            points
          },
          incremental: !!incremental,
          __startPoint: backgroundStartPoint,
          __baseDimIdx: baseDimIdx,
          __largeDataIndices: largeDataIndices,
          __barWidth: barWidth,
          silent: true,
          z2: 0
        });
        setLargeBackgroundStyle(bgEl, backgroundModel, data);
        group.add(bgEl);
      }
      var el = new LargePath({
        shape: {
          points: data.getLayout("largePoints")
        },
        incremental: !!incremental,
        __startPoint: startPoint,
        __baseDimIdx: baseDimIdx,
        __largeDataIndices: largeDataIndices,
        __barWidth: barWidth
      });
      group.add(el);
      setLargeStyle(el, seriesModel, data);
      el.seriesIndex = seriesModel.seriesIndex;
      if (!seriesModel.get("silent")) {
        el.on("mousedown", largePathUpdateDataIndex);
        el.on("mousemove", largePathUpdateDataIndex);
      }
    }
    var largePathUpdateDataIndex = throttle(function(event) {
      var largePath = this;
      var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
      largePath.dataIndex = dataIndex >= 0 ? dataIndex : null;
    }, 30, false);
    function largePathFindDataIndex(largePath, x, y) {
      var baseDimIdx = largePath.__baseDimIdx;
      var valueDimIdx = 1 - baseDimIdx;
      var points = largePath.shape.points;
      var largeDataIndices = largePath.__largeDataIndices;
      var barWidthHalf = Math.abs(largePath.__barWidth / 2);
      var startValueVal = largePath.__startPoint[valueDimIdx];
      _eventPos[0] = x;
      _eventPos[1] = y;
      var pointerBaseVal = _eventPos[baseDimIdx];
      var pointerValueVal = _eventPos[1 - baseDimIdx];
      var baseLowerBound = pointerBaseVal - barWidthHalf;
      var baseUpperBound = pointerBaseVal + barWidthHalf;
      for (var i = 0, len = points.length / 2; i < len; i++) {
        var ii = i * 2;
        var barBaseVal = points[ii + baseDimIdx];
        var barValueVal = points[ii + valueDimIdx];
        if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
          return largeDataIndices[i];
        }
      }
      return -1;
    }
    function setLargeStyle(el, seriesModel, data) {
      var borderColor = data.getVisual("borderColor") || data.getVisual("color");
      var itemStyle = seriesModel.getModel("itemStyle").getItemStyle(["color", "borderColor"]);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
      el.style.lineWidth = data.getLayout("barWidth");
    }
    function setLargeBackgroundStyle(el, backgroundModel, data) {
      var borderColor = backgroundModel.get("borderColor") || backgroundModel.get("color");
      var itemStyle = backgroundModel.getItemStyle(["color", "borderColor"]);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
      el.style.lineWidth = data.getLayout("barWidth");
    }
    function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
      var coordLayout;
      var isPolar = coord.type === "polar";
      if (isPolar) {
        coordLayout = coord.getArea();
      } else {
        coordLayout = coord.grid.getRect();
      }
      if (isPolar) {
        return {
          cx: coordLayout.cx,
          cy: coordLayout.cy,
          r0: isHorizontalOrRadial ? coordLayout.r0 : layout.r0,
          r: isHorizontalOrRadial ? coordLayout.r : layout.r,
          startAngle: isHorizontalOrRadial ? layout.startAngle : 0,
          endAngle: isHorizontalOrRadial ? layout.endAngle : Math.PI * 2
        };
      } else {
        return {
          x: isHorizontalOrRadial ? layout.x : coordLayout.x,
          y: isHorizontalOrRadial ? coordLayout.y : layout.y,
          width: isHorizontalOrRadial ? layout.width : coordLayout.width,
          height: isHorizontalOrRadial ? coordLayout.height : layout.height
        };
      }
    }
    function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
      var ElementClz = coord.type === "polar" ? graphic.Sector : graphic.Rect;
      return new ElementClz({
        shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
        silent: true,
        z2: 0
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar.js
var require_bar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _barGrid = require_barGrid();
    var layout = _barGrid.layout;
    var largeLayout = _barGrid.largeLayout;
    require_Grid();
    require_BarSeries();
    require_BarView();
    require_gridSimple();
    echarts.registerLayout(echarts.PRIORITY.VISUAL.LAYOUT, zrUtil.curry(layout, "bar"));
    echarts.registerLayout(echarts.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout);
    echarts.registerVisual({
      seriesType: "bar",
      reset: function(seriesModel) {
        seriesModel.getData().setVisual("legendSymbol", "roundRect");
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createListSimply.js
var require_createListSimply = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createListSimply.js"(exports, module) {
    var createDimensions = require_createDimensions();
    var List = require_List();
    var _util = require_util();
    var extend = _util.extend;
    var isArray = _util.isArray;
    function _default(seriesModel, opt, nameList) {
      opt = isArray(opt) && {
        coordDimensions: opt
      } || extend({}, opt);
      var source = seriesModel.getSource();
      var dimensionsInfo = createDimensions(source, opt);
      var list = new List(dimensionsInfo, seriesModel);
      list.initData(source, nameList);
      return list;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/selectableMixin.js
var require_selectableMixin = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/selectableMixin.js"(exports, module) {
    var zrUtil = require_util();
    var _default = {
      /**
       * @param {Array.<Object>} targetList [{name, value, selected}, ...]
       *        If targetList is an array, it should like [{name: ..., value: ...}, ...].
       *        If targetList is a "List", it must have coordDim: 'value' dimension and name.
       */
      updateSelectedMap: function(targetList) {
        this._targetList = zrUtil.isArray(targetList) ? targetList.slice() : [];
        this._selectTargetMap = zrUtil.reduce(targetList || [], function(targetMap, target) {
          targetMap.set(target.name, target);
          return targetMap;
        }, zrUtil.createHashMap());
      },
      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      // PENGING If selectedMode is null ?
      select: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        var selectedMode = this.get("selectedMode");
        if (selectedMode === "single") {
          this._selectTargetMap.each(function(target2) {
            target2.selected = false;
          });
        }
        target && (target.selected = true);
      },
      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      unSelect: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        target && (target.selected = false);
      },
      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      toggleSelected: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        if (target != null) {
          this[target.selected ? "unSelect" : "select"](name2, id);
          return target.selected;
        }
      },
      /**
       * Either name or id should be passed as input here.
       * If both of them are defined, id is used.
       *
       * @param {string|undefined} name name of data
       * @param {number|undefined} id dataIndex of data
       */
      isSelected: function(name2, id) {
        var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
        return target && target.selected;
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/LegendVisualProvider.js
var require_LegendVisualProvider = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/LegendVisualProvider.js"(exports, module) {
    function LegendVisualProvider(getDataWithEncodedVisual, getRawData) {
      this.getAllNames = function() {
        var rawData = getRawData();
        return rawData.mapArray(rawData.getName);
      };
      this.containName = function(name2) {
        var rawData = getRawData();
        return rawData.indexOfName(name2) >= 0;
      };
      this.indexOfName = function(name2) {
        var dataWithEncodedVisual = getDataWithEncodedVisual();
        return dataWithEncodedVisual.indexOfName(name2);
      };
      this.getItemVisual = function(dataIndex, key) {
        var dataWithEncodedVisual = getDataWithEncodedVisual();
        return dataWithEncodedVisual.getItemVisual(dataIndex, key);
      };
    }
    var _default = LegendVisualProvider;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieSeries.js
var require_PieSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieSeries.js"(exports, module) {
    var echarts = require_echarts();
    var createListSimply = require_createListSimply();
    var zrUtil = require_util();
    var modelUtil = require_model();
    var _number = require_number();
    var getPercentWithPrecision = _number.getPercentWithPrecision;
    var dataSelectableMixin = require_selectableMixin();
    var _dataProvider = require_dataProvider();
    var retrieveRawAttr = _dataProvider.retrieveRawAttr;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;
    var LegendVisualProvider = require_LegendVisualProvider();
    var PieSeries = echarts.extendSeriesModel({
      type: "series.pie",
      // Overwrite
      init: function(option) {
        PieSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
        this.updateSelectedMap(this._createSelectableList());
        this._defaultLabelLine(option);
      },
      // Overwrite
      mergeOption: function(newOption) {
        PieSeries.superCall(this, "mergeOption", newOption);
        this.updateSelectedMap(this._createSelectableList());
      },
      getInitialData: function(option, ecModel) {
        return createListSimply(this, {
          coordDimensions: ["value"],
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
        });
      },
      _createSelectableList: function() {
        var data = this.getRawData();
        var valueDim = data.mapDimension("value");
        var targetList = [];
        for (var i = 0, len = data.count(); i < len; i++) {
          targetList.push({
            name: data.getName(i),
            value: data.get(valueDim, i),
            selected: retrieveRawAttr(data, i, "selected")
          });
        }
        return targetList;
      },
      // Overwrite
      getDataParams: function(dataIndex) {
        var data = this.getData();
        var params = PieSeries.superCall(this, "getDataParams", dataIndex);
        var valueList = [];
        data.each(data.mapDimension("value"), function(value) {
          valueList.push(value);
        });
        params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get("percentPrecision"));
        params.$vars.push("percent");
        return params;
      },
      _defaultLabelLine: function(option) {
        modelUtil.defaultEmphasis(option, "labelLine", ["show"]);
        var labelLineNormalOpt = option.labelLine;
        var labelLineEmphasisOpt = option.emphasis.labelLine;
        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        hoverAnimation: true,
        // 默认全局居中
        center: ["50%", "50%"],
        radius: [0, "75%"],
        // 默认顺时针
        clockwise: true,
        startAngle: 90,
        // 最小角度改为0
        minAngle: 0,
        // If the angle of a sector less than `minShowLabelAngle`,
        // the label will not be displayed.
        minShowLabelAngle: 0,
        // 选中时扇区偏移量
        selectedOffset: 10,
        // 高亮扇区偏移量
        hoverOffset: 10,
        // If use strategy to avoid label overlapping
        avoidLabelOverlap: true,
        // 选择模式，默认关闭，可选single，multiple
        // selectedMode: false,
        // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
        // roseType: null,
        percentPrecision: 2,
        // If still show when all data zero.
        stillShowZeroSum: true,
        // cursor: null,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          // If rotate around circle
          rotate: false,
          show: true,
          // 'outer', 'inside', 'center'
          position: "outer",
          // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
          alignTo: "none",
          // Closest distance between label and chart edge.
          // Works only position is 'outer' and alignTo is 'edge'.
          margin: "25%",
          // Works only position is 'outer' and alignTo is not 'edge'.
          bleedMargin: 10,
          // Distance between text and label line.
          distanceToLabelLine: 5
          // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
          // 默认使用全局文本样式，详见TEXTSTYLE
          // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
        },
        // Enabled when label.normal.position is 'outer'
        labelLine: {
          show: true,
          // 引导线两段中的第一段长度
          length: 15,
          // 引导线两段中的第二段长度
          length2: 15,
          smooth: false,
          lineStyle: {
            // color: 各异,
            width: 1,
            type: "solid"
          }
        },
        itemStyle: {
          borderWidth: 1
        },
        // Animation type. Valid values: expansion, scale
        animationType: "expansion",
        // Animation type when update. Valid values: transition, expansion
        animationTypeUpdate: "transition",
        animationEasing: "cubicOut"
      }
    });
    zrUtil.mixin(PieSeries, dataSelectableMixin);
    var _default = PieSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieView.js
var require_PieView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/PieView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var ChartView = require_Chart();
    function updateDataSelected(uid, seriesModel, hasAnimation, api) {
      var data = seriesModel.getData();
      var dataIndex = this.dataIndex;
      var name2 = data.getName(dataIndex);
      var selectedOffset = seriesModel.get("selectedOffset");
      api.dispatchAction({
        type: "pieToggleSelect",
        from: uid,
        name: name2,
        seriesId: seriesModel.id
      });
      data.each(function(idx) {
        toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
      });
    }
    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
      var midAngle = (layout.startAngle + layout.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var offset = isSelected ? selectedOffset : 0;
      var position = [dx * offset, dy * offset];
      hasAnimation ? el.animate().when(200, {
        position
      }).start("bounceOut") : el.attr("position", position);
    }
    function PiePiece(data, idx) {
      graphic.Group.call(this);
      var sector = new graphic.Sector({
        z2: 2
      });
      var polyline = new graphic.Polyline();
      var text = new graphic.Text();
      this.add(sector);
      this.add(polyline);
      this.add(text);
      this.updateData(data, idx, true);
    }
    var piePieceProto = PiePiece.prototype;
    piePieceProto.updateData = function(data, idx, firstCreate) {
      var sector = this.childAt(0);
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var sectorShape = zrUtil.extend({}, layout);
      sectorShape.label = null;
      var animationTypeUpdate = seriesModel.getShallow("animationTypeUpdate");
      if (firstCreate) {
        sector.setShape(sectorShape);
        var animationType = seriesModel.getShallow("animationType");
        if (animationType === "scale") {
          sector.shape.r = layout.r0;
          graphic.initProps(sector, {
            shape: {
              r: layout.r
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout.startAngle;
          graphic.updateProps(sector, {
            shape: {
              endAngle: layout.endAngle
            }
          }, seriesModel, idx);
        }
      } else {
        if (animationTypeUpdate === "expansion") {
          sector.setShape(sectorShape);
        } else {
          graphic.updateProps(sector, {
            shape: sectorShape
          }, seriesModel, idx);
        }
      }
      var visualColor = data.getItemVisual(idx, "color");
      sector.useStyle(zrUtil.defaults({
        lineJoin: "bevel",
        fill: visualColor
      }, itemModel.getModel("itemStyle").getItemStyle()));
      sector.hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && sector.attr("cursor", cursorStyle);
      toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), seriesModel.get("selectedOffset"), seriesModel.get("animation"));
      var withAnimation = !firstCreate && animationTypeUpdate === "transition";
      this._updateLabel(data, idx, withAnimation);
      this.highDownOnUpdate = !seriesModel.get("silent") ? function(fromState, toState) {
        var hasAnimation = seriesModel.isAnimationEnabled() && itemModel.get("hoverAnimation");
        if (toState === "emphasis") {
          labelLine.ignore = labelLine.hoverIgnore;
          labelText.ignore = labelText.hoverIgnore;
          if (hasAnimation) {
            sector.stopAnimation(true);
            sector.animateTo({
              shape: {
                r: layout.r + seriesModel.get("hoverOffset")
              }
            }, 300, "elasticOut");
          }
        } else {
          labelLine.ignore = labelLine.normalIgnore;
          labelText.ignore = labelText.normalIgnore;
          if (hasAnimation) {
            sector.stopAnimation(true);
            sector.animateTo({
              shape: {
                r: layout.r
              }
            }, 300, "elasticOut");
          }
        }
      } : null;
      graphic.setHoverStyle(this);
    };
    piePieceProto._updateLabel = function(data, idx, withAnimation) {
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var labelLayout = layout.label;
      var visualColor = data.getItemVisual(idx, "color");
      if (!labelLayout || isNaN(labelLayout.x) || isNaN(labelLayout.y)) {
        labelText.ignore = labelText.normalIgnore = labelText.hoverIgnore = labelLine.ignore = labelLine.normalIgnore = labelLine.hoverIgnore = true;
        return;
      }
      var targetLineShape = {
        points: labelLayout.linePoints || [[labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]]
      };
      var targetTextStyle = {
        x: labelLayout.x,
        y: labelLayout.y
      };
      if (withAnimation) {
        graphic.updateProps(labelLine, {
          shape: targetLineShape
        }, seriesModel, idx);
        graphic.updateProps(labelText, {
          style: targetTextStyle
        }, seriesModel, idx);
      } else {
        labelLine.attr({
          shape: targetLineShape
        });
        labelText.attr({
          style: targetTextStyle
        });
      }
      labelText.attr({
        rotation: labelLayout.rotation,
        origin: [labelLayout.x, labelLayout.y],
        z2: 10
      });
      var labelModel = itemModel.getModel("label");
      var labelHoverModel = itemModel.getModel("emphasis.label");
      var labelLineModel = itemModel.getModel("labelLine");
      var labelLineHoverModel = itemModel.getModel("emphasis.labelLine");
      var visualColor = data.getItemVisual(idx, "color");
      graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        defaultText: labelLayout.text,
        autoColor: visualColor,
        useInsideStyle: !!labelLayout.inside
      }, {
        textAlign: labelLayout.textAlign,
        textVerticalAlign: labelLayout.verticalAlign,
        opacity: data.getItemVisual(idx, "opacity")
      });
      labelText.ignore = labelText.normalIgnore = !labelModel.get("show");
      labelText.hoverIgnore = !labelHoverModel.get("show");
      labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get("show");
      labelLine.hoverIgnore = !labelLineHoverModel.get("show");
      labelLine.setStyle({
        stroke: visualColor,
        opacity: data.getItemVisual(idx, "opacity")
      });
      labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle());
      labelLine.hoverStyle = labelLineHoverModel.getModel("lineStyle").getLineStyle();
      var smooth = labelLineModel.get("smooth");
      if (smooth && smooth === true) {
        smooth = 0.4;
      }
      labelLine.setShape({
        smooth
      });
    };
    zrUtil.inherits(PiePiece, graphic.Group);
    var PieView = ChartView.extend({
      type: "pie",
      init: function() {
        var sectorGroup = new graphic.Group();
        this._sectorGroup = sectorGroup;
      },
      render: function(seriesModel, ecModel, api, payload) {
        if (payload && payload.from === this.uid) {
          return;
        }
        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        var hasAnimation = ecModel.get("animation");
        var isFirstRender = !oldData;
        var animationType = seriesModel.get("animationType");
        var animationTypeUpdate = seriesModel.get("animationTypeUpdate");
        var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
        var selectedMode = seriesModel.get("selectedMode");
        data.diff(oldData).add(function(idx) {
          var piePiece = new PiePiece(data, idx);
          if (isFirstRender && animationType !== "scale") {
            piePiece.eachChild(function(child) {
              child.stopAnimation(true);
            });
          }
          selectedMode && piePiece.on("click", onSectorClick);
          data.setItemGraphicEl(idx, piePiece);
          group.add(piePiece);
        }).update(function(newIdx, oldIdx) {
          var piePiece = oldData.getItemGraphicEl(oldIdx);
          if (!isFirstRender && animationTypeUpdate !== "transition") {
            piePiece.eachChild(function(child) {
              child.stopAnimation(true);
            });
          }
          piePiece.updateData(data, newIdx);
          piePiece.off("click");
          selectedMode && piePiece.on("click", onSectorClick);
          group.add(piePiece);
          data.setItemGraphicEl(newIdx, piePiece);
        }).remove(function(idx) {
          var piePiece = oldData.getItemGraphicEl(idx);
          group.remove(piePiece);
        }).execute();
        if (hasAnimation && data.count() > 0 && (isFirstRender ? animationType !== "scale" : animationTypeUpdate !== "transition")) {
          var shape = data.getItemLayout(0);
          for (var s = 1; isNaN(shape.startAngle) && s < data.count(); ++s) {
            shape = data.getItemLayout(s);
          }
          var r = Math.max(api.getWidth(), api.getHeight()) / 2;
          var removeClipPath = zrUtil.bind(group.removeClipPath, group);
          group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel, isFirstRender));
        } else {
          group.removeClipPath();
        }
        this._data = data;
      },
      dispose: function() {
      },
      _createClipPath: function(cx, cy, r, startAngle, clockwise, cb, seriesModel, isFirstRender) {
        var clipPath = new graphic.Sector({
          shape: {
            cx,
            cy,
            r0: 0,
            r,
            startAngle,
            endAngle: startAngle,
            clockwise
          }
        });
        var initOrUpdate = isFirstRender ? graphic.initProps : graphic.updateProps;
        initOrUpdate(clipPath, {
          shape: {
            endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2
          }
        }, seriesModel, cb);
        return clipPath;
      },
      /**
       * @implement
       */
      containPoint: function(point, seriesModel) {
        var data = seriesModel.getData();
        var itemLayout = data.getItemLayout(0);
        if (itemLayout) {
          var dx = point[0] - itemLayout.cx;
          var dy = point[1] - itemLayout.cy;
          var radius = Math.sqrt(dx * dx + dy * dy);
          return radius <= itemLayout.r && radius >= itemLayout.r0;
        }
      }
    });
    var _default = PieView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/createDataSelectAction.js
var require_createDataSelectAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/createDataSelectAction.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    function _default(seriesType, actionInfos) {
      zrUtil.each(actionInfos, function(actionInfo) {
        actionInfo.update = "updateView";
        echarts.registerAction(actionInfo, function(payload, ecModel) {
          var selected = {};
          ecModel.eachComponent({
            mainType: "series",
            subType: seriesType,
            query: payload
          }, function(seriesModel) {
            if (seriesModel[actionInfo.method]) {
              seriesModel[actionInfo.method](payload.name, payload.dataIndex);
            }
            var data = seriesModel.getData();
            data.each(function(idx) {
              var name2 = data.getName(idx);
              selected[name2] = seriesModel.isSelected(name2) || false;
            });
          });
          return {
            name: payload.name,
            selected,
            seriesId: payload.seriesId
          };
        });
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/dataColor.js
var require_dataColor = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/dataColor.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    function _default(seriesType) {
      return {
        getTargetSeries: function(ecModel) {
          var paletteScope = {};
          var seiresModelMap = createHashMap();
          ecModel.eachSeriesByType(seriesType, function(seriesModel) {
            seriesModel.__paletteScope = paletteScope;
            seiresModelMap.set(seriesModel.uid, seriesModel);
          });
          return seiresModelMap;
        },
        reset: function(seriesModel, ecModel) {
          var dataAll = seriesModel.getRawData();
          var idxMap = {};
          var data = seriesModel.getData();
          data.each(function(idx) {
            var rawIdx = data.getRawIndex(idx);
            idxMap[rawIdx] = idx;
          });
          dataAll.each(function(rawIdx) {
            var filteredIdx = idxMap[rawIdx];
            var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, "color", true);
            var singleDataBorderColor = filteredIdx != null && data.getItemVisual(filteredIdx, "borderColor", true);
            var itemModel;
            if (!singleDataColor || !singleDataBorderColor) {
              itemModel = dataAll.getItemModel(rawIdx);
            }
            if (!singleDataColor) {
              var color = itemModel.get("itemStyle.color") || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + "", seriesModel.__paletteScope, dataAll.count());
              if (filteredIdx != null) {
                data.setItemVisual(filteredIdx, "color", color);
              }
            }
            if (!singleDataBorderColor) {
              var borderColor = itemModel.get("itemStyle.borderColor");
              if (filteredIdx != null) {
                data.setItemVisual(filteredIdx, "borderColor", borderColor);
              }
            }
          });
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/labelLayout.js
var require_labelLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/labelLayout.js"(exports, module) {
    var textContain = require_text();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var RADIAN = Math.PI / 180;
    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
      list.sort(function(a, b) {
        return a.y - b.y;
      });
      function shiftDown(start, end, delta2, dir2) {
        for (var j = start; j < end; j++) {
          if (list[j].y + delta2 > viewTop + viewHeight) {
            break;
          }
          list[j].y += delta2;
          if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
            shiftUp(j, delta2 / 2);
            return;
          }
        }
        shiftUp(end - 1, delta2 / 2);
      }
      function shiftUp(end, delta2) {
        for (var j = end; j >= 0; j--) {
          if (list[j].y - delta2 < viewTop) {
            break;
          }
          list[j].y -= delta2;
          if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
            break;
          }
        }
      }
      function changeX(list2, isDownList, cx2, cy2, r2, dir2) {
        var lastDeltaX = dir2 > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;
        for (var i2 = 0, l = list2.length; i2 < l; i2++) {
          if (list2[i2].labelAlignTo !== "none") {
            continue;
          }
          var deltaY = Math.abs(list2[i2].y - cy2);
          var length = list2[i2].len;
          var length2 = list2[i2].len2;
          var deltaX = deltaY < r2 + length ? Math.sqrt((r2 + length + length2) * (r2 + length + length2) - deltaY * deltaY) : Math.abs(list2[i2].x - cx2);
          if (isDownList && deltaX >= lastDeltaX) {
            deltaX = lastDeltaX - 10;
          }
          if (!isDownList && deltaX <= lastDeltaX) {
            deltaX = lastDeltaX + 10;
          }
          list2[i2].x = cx2 + deltaX * dir2;
          lastDeltaX = deltaX;
        }
      }
      var lastY = 0;
      var delta;
      var len = list.length;
      var upList = [];
      var downList = [];
      for (var i = 0; i < len; i++) {
        if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
          var dx = list[i].x - farthestX;
          list[i].linePoints[1][0] += dx;
          list[i].x = farthestX;
        }
        delta = list[i].y - lastY;
        if (delta < 0) {
          shiftDown(i, len, -delta, dir);
        }
        lastY = list[i].y + list[i].height;
      }
      if (viewHeight - lastY < 0) {
        shiftUp(len - 1, lastY - viewHeight);
      }
      for (var i = 0; i < len; i++) {
        if (list[i].y >= cy) {
          downList.push(list[i]);
        } else {
          upList.push(list[i]);
        }
      }
      changeX(upList, false, cx, cy, r, dir);
      changeX(downList, true, cx, cy, r, dir);
    }
    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
      var leftList = [];
      var rightList = [];
      var leftmostX = Number.MAX_VALUE;
      var rightmostX = -Number.MAX_VALUE;
      for (var i = 0; i < labelLayoutList.length; i++) {
        if (isPositionCenter(labelLayoutList[i])) {
          continue;
        }
        if (labelLayoutList[i].x < cx) {
          leftmostX = Math.min(leftmostX, labelLayoutList[i].x);
          leftList.push(labelLayoutList[i]);
        } else {
          rightmostX = Math.max(rightmostX, labelLayoutList[i].x);
          rightList.push(labelLayoutList[i]);
        }
      }
      adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
      adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
      for (var i = 0; i < labelLayoutList.length; i++) {
        var layout = labelLayoutList[i];
        if (isPositionCenter(layout)) {
          continue;
        }
        var linePoints = layout.linePoints;
        if (linePoints) {
          var isAlignToEdge = layout.labelAlignTo === "edge";
          var realTextWidth = layout.textRect.width;
          var targetTextWidth;
          if (isAlignToEdge) {
            if (layout.x < cx) {
              targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.labelMargin;
            } else {
              targetTextWidth = viewLeft + viewWidth - layout.labelMargin - linePoints[2][0] - layout.labelDistance;
            }
          } else {
            if (layout.x < cx) {
              targetTextWidth = layout.x - viewLeft - layout.bleedMargin;
            } else {
              targetTextWidth = viewLeft + viewWidth - layout.x - layout.bleedMargin;
            }
          }
          if (targetTextWidth < layout.textRect.width) {
            layout.text = textContain.truncateText(layout.text, targetTextWidth, layout.font);
            if (layout.labelAlignTo === "edge") {
              realTextWidth = textContain.getWidth(layout.text, layout.font);
            }
          }
          var dist = linePoints[1][0] - linePoints[2][0];
          if (isAlignToEdge) {
            if (layout.x < cx) {
              linePoints[2][0] = viewLeft + layout.labelMargin + realTextWidth + layout.labelDistance;
            } else {
              linePoints[2][0] = viewLeft + viewWidth - layout.labelMargin - realTextWidth - layout.labelDistance;
            }
          } else {
            if (layout.x < cx) {
              linePoints[2][0] = layout.x + layout.labelDistance;
            } else {
              linePoints[2][0] = layout.x - layout.labelDistance;
            }
            linePoints[1][0] = linePoints[2][0] + dist;
          }
          linePoints[1][1] = linePoints[2][1] = layout.y;
        }
      }
    }
    function isPositionCenter(layout) {
      return layout.position === "center";
    }
    function _default(seriesModel, r, viewWidth, viewHeight, viewLeft, viewTop) {
      var data = seriesModel.getData();
      var labelLayoutList = [];
      var cx;
      var cy;
      var hasLabelRotate = false;
      var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN;
      data.each(function(idx) {
        var layout = data.getItemLayout(idx);
        var itemModel = data.getItemModel(idx);
        var labelModel = itemModel.getModel("label");
        var labelPosition = labelModel.get("position") || itemModel.get("emphasis.label.position");
        var labelDistance = labelModel.get("distanceToLabelLine");
        var labelAlignTo = labelModel.get("alignTo");
        var labelMargin = parsePercent(labelModel.get("margin"), viewWidth);
        var bleedMargin = labelModel.get("bleedMargin");
        var font = labelModel.getFont();
        var labelLineModel = itemModel.getModel("labelLine");
        var labelLineLen = labelLineModel.get("length");
        labelLineLen = parsePercent(labelLineLen, viewWidth);
        var labelLineLen2 = labelLineModel.get("length2");
        labelLineLen2 = parsePercent(labelLineLen2, viewWidth);
        if (layout.angle < minShowLabelRadian) {
          return;
        }
        var midAngle = (layout.startAngle + layout.endAngle) / 2;
        var dx = Math.cos(midAngle);
        var dy = Math.sin(midAngle);
        var textX;
        var textY;
        var linePoints;
        var textAlign;
        cx = layout.cx;
        cy = layout.cy;
        var text = seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx);
        var textRect = textContain.getBoundingRect(text, font, textAlign, "top");
        var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
        if (labelPosition === "center") {
          textX = layout.cx;
          textY = layout.cy;
          textAlign = "center";
        } else {
          var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
          var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;
          textX = x1 + dx * 3;
          textY = y1 + dy * 3;
          if (!isLabelInside) {
            var x2 = x1 + dx * (labelLineLen + r - layout.r);
            var y2 = y1 + dy * (labelLineLen + r - layout.r);
            var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;
            var y3 = y2;
            if (labelAlignTo === "edge") {
              textX = dx < 0 ? viewLeft + labelMargin : viewLeft + viewWidth - labelMargin;
            } else {
              textX = x3 + (dx < 0 ? -labelDistance : labelDistance);
            }
            textY = y3;
            linePoints = [[x1, y1], [x2, y2], [x3, y3]];
          }
          textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? dx > 0 ? "right" : "left" : dx > 0 ? "left" : "right";
        }
        var labelRotate;
        var rotate = labelModel.get("rotate");
        if (typeof rotate === "number") {
          labelRotate = rotate * (Math.PI / 180);
        } else {
          labelRotate = rotate ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;
        }
        hasLabelRotate = !!labelRotate;
        layout.label = {
          x: textX,
          y: textY,
          position: labelPosition,
          height: textRect.height,
          len: labelLineLen,
          len2: labelLineLen2,
          linePoints,
          textAlign,
          verticalAlign: "middle",
          rotation: labelRotate,
          inside: isLabelInside,
          labelDistance,
          labelAlignTo,
          labelMargin,
          bleedMargin,
          textRect,
          text,
          font
        };
        if (!isLabelInside) {
          labelLayoutList.push(layout.label);
        }
      });
      if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
        avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/pieLayout.js
var require_pieLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie/pieLayout.js"(exports, module) {
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var linearMap = _number.linearMap;
    var layout = require_layout();
    var labelLayout = require_labelLayout();
    var zrUtil = require_util();
    var PI2 = Math.PI * 2;
    var RADIAN = Math.PI / 180;
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function _default(seriesType, ecModel, api, payload) {
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var viewRect = getViewRect(seriesModel, api);
        var center = seriesModel.get("center");
        var radius = seriesModel.get("radius");
        if (!zrUtil.isArray(radius)) {
          radius = [0, radius];
        }
        if (!zrUtil.isArray(center)) {
          center = [center, center];
        }
        var width = parsePercent(viewRect.width, api.getWidth());
        var height = parsePercent(viewRect.height, api.getHeight());
        var size = Math.min(width, height);
        var cx = parsePercent(center[0], width) + viewRect.x;
        var cy = parsePercent(center[1], height) + viewRect.y;
        var r0 = parsePercent(radius[0], size / 2);
        var r = parsePercent(radius[1], size / 2);
        var startAngle = -seriesModel.get("startAngle") * RADIAN;
        var minAngle = seriesModel.get("minAngle") * RADIAN;
        var validDataCount = 0;
        data.each(valueDim, function(value) {
          !isNaN(value) && validDataCount++;
        });
        var sum = data.getSum(valueDim);
        var unitRadian = Math.PI / (sum || validDataCount) * 2;
        var clockwise = seriesModel.get("clockwise");
        var roseType = seriesModel.get("roseType");
        var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
        var extent = data.getDataExtent(valueDim);
        extent[0] = 0;
        var restAngle = PI2;
        var valueSumLargerThanMinAngle = 0;
        var currentAngle = startAngle;
        var dir = clockwise ? 1 : -1;
        data.each(valueDim, function(value, idx) {
          var angle2;
          if (isNaN(value)) {
            data.setItemLayout(idx, {
              angle: NaN,
              startAngle: NaN,
              endAngle: NaN,
              clockwise,
              cx,
              cy,
              r0,
              r: roseType ? NaN : r,
              viewRect
            });
            return;
          }
          if (roseType !== "area") {
            angle2 = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
          } else {
            angle2 = PI2 / validDataCount;
          }
          if (angle2 < minAngle) {
            angle2 = minAngle;
            restAngle -= minAngle;
          } else {
            valueSumLargerThanMinAngle += value;
          }
          var endAngle = currentAngle + dir * angle2;
          data.setItemLayout(idx, {
            angle: angle2,
            startAngle: currentAngle,
            endAngle,
            clockwise,
            cx,
            cy,
            r0,
            r: roseType ? linearMap(value, extent, [r0, r]) : r,
            viewRect
          });
          currentAngle = endAngle;
        });
        if (restAngle < PI2 && validDataCount) {
          if (restAngle <= 1e-3) {
            var angle = PI2 / validDataCount;
            data.each(valueDim, function(value, idx) {
              if (!isNaN(value)) {
                var layout2 = data.getItemLayout(idx);
                layout2.angle = angle;
                layout2.startAngle = startAngle + dir * idx * angle;
                layout2.endAngle = startAngle + dir * (idx + 1) * angle;
              }
            });
          } else {
            unitRadian = restAngle / valueSumLargerThanMinAngle;
            currentAngle = startAngle;
            data.each(valueDim, function(value, idx) {
              if (!isNaN(value)) {
                var layout2 = data.getItemLayout(idx);
                var angle2 = layout2.angle === minAngle ? minAngle : value * unitRadian;
                layout2.startAngle = currentAngle;
                layout2.endAngle = currentAngle + dir * angle2;
                currentAngle += dir * angle2;
              }
            });
          }
        }
        labelLayout(seriesModel, r, viewRect.width, viewRect.height, viewRect.x, viewRect.y);
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataFilter.js
var require_dataFilter = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/processor/dataFilter.js"(exports, module) {
    function _default(seriesType) {
      return {
        seriesType,
        reset: function(seriesModel, ecModel) {
          var legendModels = ecModel.findComponents({
            mainType: "legend"
          });
          if (!legendModels || !legendModels.length) {
            return;
          }
          var data = seriesModel.getData();
          data.filterSelf(function(idx) {
            var name2 = data.getName(idx);
            for (var i = 0; i < legendModels.length; i++) {
              if (!legendModels[i].isSelected(name2)) {
                return false;
              }
            }
            return true;
          });
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie.js
var require_pie = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pie.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_PieSeries();
    require_PieView();
    var createDataSelectAction = require_createDataSelectAction();
    var dataColor = require_dataColor();
    var pieLayout = require_pieLayout();
    var dataFilter = require_dataFilter();
    createDataSelectAction("pie", [{
      type: "pieToggleSelect",
      event: "pieselectchanged",
      method: "toggleSelected"
    }, {
      type: "pieSelect",
      event: "pieselected",
      method: "select"
    }, {
      type: "pieUnSelect",
      event: "pieunselected",
      method: "unSelect"
    }]);
    echarts.registerVisual(dataColor("pie"));
    echarts.registerLayout(zrUtil.curry(pieLayout, "pie"));
    echarts.registerProcessor(dataFilter("pie"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterSeries.js
var require_ScatterSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterSeries.js"(exports, module) {
    var createListFromArray = require_createListFromArray();
    var SeriesModel = require_Series();
    var _default = SeriesModel.extend({
      type: "series.scatter",
      dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      brushSelector: "point",
      getProgressive: function() {
        var progressive = this.option.progressive;
        if (progressive == null) {
          return this.option.large ? 5e3 : this.get("progressive");
        }
        return progressive;
      },
      getProgressiveThreshold: function() {
        var progressiveThreshold = this.option.progressiveThreshold;
        if (progressiveThreshold == null) {
          return this.option.large ? 1e4 : this.get("progressiveThreshold");
        }
        return progressiveThreshold;
      },
      defaultOption: {
        coordinateSystem: "cartesian2d",
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        hoverAnimation: true,
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Polar coordinate system
        // polarIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,
        // symbol: null,        // 图形类型
        symbolSize: 10,
        // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
        // symbolRotate: null,  // 图形旋转控制
        large: false,
        // Available when large is true
        largeThreshold: 2e3,
        // cursor: null,
        // label: {
        // show: false
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
        // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
        //           'inside'|'left'|'right'|'top'|'bottom'
        // 默认使用全局文本样式，详见TEXTSTYLE
        // },
        itemStyle: {
          opacity: 0.8
          // color: 各异
        },
        // If clip the overflow graphics
        // Works on cartesian / polar series
        clip: true
        // progressive: null
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js
var require_LargeSymbolDraw = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeSymbolDraw.js"(exports, module) {
    var graphic = require_graphic();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var IncrementalDisplayable = require_IncrementalDisplayable();
    var BOOST_SIZE_THRESHOLD = 4;
    var LargeSymbolPath = graphic.extendShape({
      shape: {
        points: null
      },
      symbolProxy: null,
      softClipShape: null,
      buildPath: function(path, shape) {
        var points = shape.points;
        var size = shape.size;
        var symbolProxy = this.symbolProxy;
        var symbolProxyShape = symbolProxy.shape;
        var ctx = path.getContext ? path.getContext() : path;
        var canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
        if (canBoost) {
          return;
        }
        for (var i = 0; i < points.length; ) {
          var x = points[i++];
          var y = points[i++];
          if (isNaN(x) || isNaN(y)) {
            continue;
          }
          if (this.softClipShape && !this.softClipShape.contain(x, y)) {
            continue;
          }
          symbolProxyShape.x = x - size[0] / 2;
          symbolProxyShape.y = y - size[1] / 2;
          symbolProxyShape.width = size[0];
          symbolProxyShape.height = size[1];
          symbolProxy.buildPath(path, symbolProxyShape, true);
        }
      },
      afterBrush: function(ctx) {
        var shape = this.shape;
        var points = shape.points;
        var size = shape.size;
        var canBoost = size[0] < BOOST_SIZE_THRESHOLD;
        if (!canBoost) {
          return;
        }
        this.setTransform(ctx);
        for (var i = 0; i < points.length; ) {
          var x = points[i++];
          var y = points[i++];
          if (isNaN(x) || isNaN(y)) {
            continue;
          }
          if (this.softClipShape && !this.softClipShape.contain(x, y)) {
            continue;
          }
          ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
        }
        this.restoreTransform(ctx);
      },
      findDataIndex: function(x, y) {
        var shape = this.shape;
        var points = shape.points;
        var size = shape.size;
        var w = Math.max(size[0], 4);
        var h = Math.max(size[1], 4);
        for (var idx = points.length / 2 - 1; idx >= 0; idx--) {
          var i = idx * 2;
          var x0 = points[i] - w / 2;
          var y0 = points[i + 1] - h / 2;
          if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
            return idx;
          }
        }
        return -1;
      }
    });
    function LargeSymbolDraw() {
      this.group = new graphic.Group();
    }
    var largeSymbolProto = LargeSymbolDraw.prototype;
    largeSymbolProto.isPersistent = function() {
      return !this._incremental;
    };
    largeSymbolProto.updateData = function(data, opt) {
      this.group.removeAll();
      var symbolEl = new LargeSymbolPath({
        rectHover: true,
        cursor: "default"
      });
      symbolEl.setShape({
        points: data.getLayout("symbolPoints")
      });
      this._setCommon(symbolEl, data, false, opt);
      this.group.add(symbolEl);
      this._incremental = null;
    };
    largeSymbolProto.updateLayout = function(data) {
      if (this._incremental) {
        return;
      }
      var points = data.getLayout("symbolPoints");
      this.group.eachChild(function(child) {
        if (child.startIndex != null) {
          var len = (child.endIndex - child.startIndex) * 2;
          var byteOffset = child.startIndex * 4 * 2;
          points = new Float32Array(points.buffer, byteOffset, len);
        }
        child.setShape("points", points);
      });
    };
    largeSymbolProto.incrementalPrepareUpdate = function(data) {
      this.group.removeAll();
      this._clearIncremental();
      if (data.count() > 2e6) {
        if (!this._incremental) {
          this._incremental = new IncrementalDisplayable({
            silent: true
          });
        }
        this.group.add(this._incremental);
      } else {
        this._incremental = null;
      }
    };
    largeSymbolProto.incrementalUpdate = function(taskParams, data, opt) {
      var symbolEl;
      if (this._incremental) {
        symbolEl = new LargeSymbolPath();
        this._incremental.addDisplayable(symbolEl, true);
      } else {
        symbolEl = new LargeSymbolPath({
          rectHover: true,
          cursor: "default",
          startIndex: taskParams.start,
          endIndex: taskParams.end
        });
        symbolEl.incremental = true;
        this.group.add(symbolEl);
      }
      symbolEl.setShape({
        points: data.getLayout("symbolPoints")
      });
      this._setCommon(symbolEl, data, !!this._incremental, opt);
    };
    largeSymbolProto._setCommon = function(symbolEl, data, isIncremental, opt) {
      var hostModel = data.hostModel;
      opt = opt || {};
      var size = data.getVisual("symbolSize");
      symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
      symbolEl.softClipShape = opt.clipShape || null;
      symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
      symbolEl.setColor = symbolEl.symbolProxy.setColor;
      var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
      symbolEl.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var visualColor = data.getVisual("color");
      if (visualColor) {
        symbolEl.setColor(visualColor);
      }
      if (!isIncremental) {
        symbolEl.seriesIndex = hostModel.seriesIndex;
        symbolEl.on("mousemove", function(e) {
          symbolEl.dataIndex = null;
          var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);
          if (dataIndex >= 0) {
            symbolEl.dataIndex = dataIndex + (symbolEl.startIndex || 0);
          }
        });
      }
    };
    largeSymbolProto.remove = function() {
      this._clearIncremental();
      this._incremental = null;
      this.group.removeAll();
    };
    largeSymbolProto._clearIncremental = function() {
      var incremental = this._incremental;
      if (incremental) {
        incremental.clearDisplaybles();
      }
    };
    var _default = LargeSymbolDraw;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterView.js
var require_ScatterView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter/ScatterView.js"() {
    var echarts = require_echarts();
    var SymbolDraw = require_SymbolDraw();
    var LargeSymbolDraw = require_LargeSymbolDraw();
    var pointsLayout = require_points();
    echarts.extendChartView({
      type: "scatter",
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolDraw = this._updateSymbolDraw(data, seriesModel);
        symbolDraw.updateData(data, {
          // TODO
          // If this parameter should be a shape or a bounding volume
          // shape will be more general.
          // But bounding volume like bounding rect will be much faster in the contain calculation
          clipShape: this._getClipShape(seriesModel)
        });
        this._finished = true;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolDraw = this._updateSymbolDraw(data, seriesModel);
        symbolDraw.incrementalPrepareUpdate(data);
        this._finished = false;
      },
      incrementalRender: function(taskParams, seriesModel, ecModel) {
        this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
          clipShape: this._getClipShape(seriesModel)
        });
        this._finished = taskParams.end === seriesModel.getData().count();
      },
      updateTransform: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        this.group.dirty();
        if (!this._finished || data.count() > 1e4 || !this._symbolDraw.isPersistent()) {
          return {
            update: true
          };
        } else {
          var res = pointsLayout().reset(seriesModel);
          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count()
            }, data);
          }
          this._symbolDraw.updateLayout(data);
        }
      },
      _getClipShape: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
        return seriesModel.get("clip", true) ? clipArea : null;
      },
      _updateSymbolDraw: function(data, seriesModel) {
        var symbolDraw = this._symbolDraw;
        var pipelineContext = seriesModel.pipelineContext;
        var isLargeDraw = pipelineContext.large;
        if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
          symbolDraw && symbolDraw.remove();
          symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw();
          this._isLargeDraw = isLargeDraw;
          this.group.removeAll();
        }
        this.group.add(symbolDraw.group);
        return symbolDraw;
      },
      remove: function(ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove(true);
        this._symbolDraw = null;
      },
      dispose: function() {
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter.js
var require_scatter = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/scatter.js"() {
    var echarts = require_echarts();
    require_ScatterSeries();
    require_ScatterView();
    var visualSymbol = require_symbol2();
    var layoutPoints = require_points();
    require_gridSimple();
    echarts.registerVisual(visualSymbol("scatter", "circle"));
    echarts.registerLayout(layoutPoints("scatter"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/IndicatorAxis.js
var require_IndicatorAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/IndicatorAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    function IndicatorAxis(dim, scale, radiusExtent) {
      Axis.call(this, dim, scale, radiusExtent);
      this.type = "value";
      this.angle = 0;
      this.name = "";
      this.model;
    }
    zrUtil.inherits(IndicatorAxis, Axis);
    var _default = IndicatorAxis;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/Radar.js
var require_Radar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/Radar.js"(exports, module) {
    var zrUtil = require_util();
    var IndicatorAxis = require_IndicatorAxis();
    var IntervalScale = require_Interval();
    var numberUtil = require_number();
    var _axisHelper = require_axisHelper();
    var getScaleExtent = _axisHelper.getScaleExtent;
    var niceScaleExtent = _axisHelper.niceScaleExtent;
    var CoordinateSystem = require_CoordinateSystem();
    var LogScale = require_Log();
    function Radar(radarModel, ecModel, api) {
      this._model = radarModel;
      this.dimensions = [];
      this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
        var dim = "indicator_" + idx;
        var indicatorAxis = new IndicatorAxis(dim, indicatorModel.get("axisType") === "log" ? new LogScale() : new IntervalScale());
        indicatorAxis.name = indicatorModel.get("name");
        indicatorAxis.model = indicatorModel;
        indicatorModel.axis = indicatorAxis;
        this.dimensions.push(dim);
        return indicatorAxis;
      }, this);
      this.resize(radarModel, api);
      this.cx;
      this.cy;
      this.r;
      this.r0;
      this.startAngle;
    }
    Radar.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    };
    Radar.prototype.dataToPoint = function(value, indicatorIndex) {
      var indicatorAxis = this._indicatorAxes[indicatorIndex];
      return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
    };
    Radar.prototype.coordToPoint = function(coord, indicatorIndex) {
      var indicatorAxis = this._indicatorAxes[indicatorIndex];
      var angle = indicatorAxis.angle;
      var x = this.cx + coord * Math.cos(angle);
      var y = this.cy - coord * Math.sin(angle);
      return [x, y];
    };
    Radar.prototype.pointToData = function(pt) {
      var dx = pt[0] - this.cx;
      var dy = pt[1] - this.cy;
      var radius = Math.sqrt(dx * dx + dy * dy);
      dx /= radius;
      dy /= radius;
      var radian = Math.atan2(-dy, dx);
      var minRadianDiff = Infinity;
      var closestAxis;
      var closestAxisIdx = -1;
      for (var i = 0; i < this._indicatorAxes.length; i++) {
        var indicatorAxis = this._indicatorAxes[i];
        var diff = Math.abs(radian - indicatorAxis.angle);
        if (diff < minRadianDiff) {
          closestAxis = indicatorAxis;
          closestAxisIdx = i;
          minRadianDiff = diff;
        }
      }
      return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
    };
    Radar.prototype.resize = function(radarModel, api) {
      var center = radarModel.get("center");
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      var viewSize = Math.min(viewWidth, viewHeight) / 2;
      this.cx = numberUtil.parsePercent(center[0], viewWidth);
      this.cy = numberUtil.parsePercent(center[1], viewHeight);
      this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
      var radius = radarModel.get("radius");
      if (typeof radius === "string" || typeof radius === "number") {
        radius = [0, radius];
      }
      this.r0 = numberUtil.parsePercent(radius[0], viewSize);
      this.r = numberUtil.parsePercent(radius[1], viewSize);
      zrUtil.each(this._indicatorAxes, function(indicatorAxis, idx) {
        indicatorAxis.setExtent(this.r0, this.r);
        var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
        angle = Math.atan2(Math.sin(angle), Math.cos(angle));
        indicatorAxis.angle = angle;
      }, this);
    };
    Radar.prototype.update = function(ecModel, api) {
      var indicatorAxes = this._indicatorAxes;
      var radarModel = this._model;
      zrUtil.each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.setExtent(Infinity, -Infinity);
      });
      ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
        if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
          return;
        }
        var data = radarSeries.getData();
        zrUtil.each(indicatorAxes, function(indicatorAxis) {
          indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
        });
      }, this);
      var splitNumber = radarModel.get("splitNumber");
      function increaseInterval(interval) {
        var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));
        var f = interval / exp10;
        if (f === 2) {
          f = 5;
        } else {
          f *= 2;
        }
        return f * exp10;
      }
      zrUtil.each(indicatorAxes, function(indicatorAxis, idx) {
        var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model).extent;
        niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);
        var axisModel = indicatorAxis.model;
        var scale = indicatorAxis.scale;
        var fixedMin = axisModel.getMin();
        var fixedMax = axisModel.getMax();
        var interval = scale.getInterval();
        if (fixedMin != null && fixedMax != null) {
          scale.setExtent(+fixedMin, +fixedMax);
          scale.setInterval((fixedMax - fixedMin) / splitNumber);
        } else if (fixedMin != null) {
          var max;
          do {
            max = fixedMin + interval * splitNumber;
            scale.setExtent(+fixedMin, max);
            scale.setInterval(interval);
            interval = increaseInterval(interval);
          } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
        } else if (fixedMax != null) {
          var min;
          do {
            min = fixedMax - interval * splitNumber;
            scale.setExtent(min, +fixedMax);
            scale.setInterval(interval);
            interval = increaseInterval(interval);
          } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
        } else {
          var nicedSplitNumber = scale.getTicks().length - 1;
          if (nicedSplitNumber > splitNumber) {
            interval = increaseInterval(interval);
          }
          var max = Math.ceil(rawExtent[1] / interval) * interval;
          var min = numberUtil.round(max - interval * splitNumber);
          scale.setExtent(min, max);
          scale.setInterval(interval);
        }
      });
    };
    Radar.dimensions = [];
    Radar.create = function(ecModel, api) {
      var radarList = [];
      ecModel.eachComponent("radar", function(radarModel) {
        var radar = new Radar(radarModel, ecModel, api);
        radarList.push(radar);
        radarModel.coordinateSystem = radar;
      });
      ecModel.eachSeriesByType("radar", function(radarSeries) {
        if (radarSeries.get("coordinateSystem") === "radar") {
          radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
        }
      });
      return radarList;
    };
    CoordinateSystem.register("radar", Radar);
    var _default = Radar;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/RadarModel.js
var require_RadarModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/radar/RadarModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var axisDefault = require_axisDefault();
    var Model = require_Model();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var valueAxisDefault = axisDefault.valueAxis;
    function defaultsShow(opt, show) {
      return zrUtil.defaults({
        show
      }, opt);
    }
    var RadarModel = echarts.extendComponentModel({
      type: "radar",
      optionUpdated: function() {
        var boundaryGap = this.get("boundaryGap");
        var splitNumber = this.get("splitNumber");
        var scale = this.get("scale");
        var axisLine = this.get("axisLine");
        var axisTick = this.get("axisTick");
        var axisType = this.get("axisType");
        var axisLabel = this.get("axisLabel");
        var nameTextStyle = this.get("name");
        var showName = this.get("name.show");
        var nameFormatter = this.get("name.formatter");
        var nameGap = this.get("nameGap");
        var triggerEvent = this.get("triggerEvent");
        var indicatorModels = zrUtil.map(this.get("indicator") || [], function(indicatorOpt) {
          if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
            indicatorOpt.min = 0;
          } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
            indicatorOpt.max = 0;
          }
          var iNameTextStyle = nameTextStyle;
          if (indicatorOpt.color != null) {
            iNameTextStyle = zrUtil.defaults({
              color: indicatorOpt.color
            }, nameTextStyle);
          }
          indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {
            boundaryGap,
            splitNumber,
            scale,
            axisLine,
            axisTick,
            axisType,
            axisLabel,
            // Compatible with 2 and use text
            name: indicatorOpt.text,
            nameLocation: "end",
            nameGap,
            // min: 0,
            nameTextStyle: iNameTextStyle,
            triggerEvent
          }, false);
          if (!showName) {
            indicatorOpt.name = "";
          }
          if (typeof nameFormatter === "string") {
            var indName = indicatorOpt.name;
            indicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
          } else if (typeof nameFormatter === "function") {
            indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);
          }
          var model = zrUtil.extend(new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin);
          model.mainType = "radar";
          model.componentIndex = this.componentIndex;
          return model;
        }, this);
        this.getIndicatorModels = function() {
          return indicatorModels;
        };
      },
      defaultOption: {
        zlevel: 0,
        z: 0,
        center: ["50%", "50%"],
        radius: "75%",
        startAngle: 90,
        name: {
          show: true
          // formatter: null
          // textStyle: {}
        },
        boundaryGap: [0, 0],
        splitNumber: 5,
        nameGap: 15,
        scale: false,
        // Polygon or circle
        shape: "polygon",
        axisLine: zrUtil.merge({
          lineStyle: {
            color: "#bbb"
          }
        }, valueAxisDefault.axisLine),
        axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
        axisTick: defaultsShow(valueAxisDefault.axisTick, false),
        axisType: "interval",
        splitLine: defaultsShow(valueAxisDefault.splitLine, true),
        splitArea: defaultsShow(valueAxisDefault.splitArea, true),
        // {text, min, max}
        indicator: []
      }
    });
    var _default = RadarModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar/RadarView.js
var require_RadarView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar/RadarView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var AxisBuilder = require_AxisBuilder();
    var graphic = require_graphic();
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var _default = echarts.extendComponentView({
      type: "radar",
      render: function(radarModel, ecModel, api) {
        var group = this.group;
        group.removeAll();
        this._buildAxes(radarModel);
        this._buildSplitLineAndArea(radarModel);
      },
      _buildAxes: function(radarModel) {
        var radar = radarModel.coordinateSystem;
        var indicatorAxes = radar.getIndicatorAxes();
        var axisBuilders = zrUtil.map(indicatorAxes, function(indicatorAxis) {
          var axisBuilder = new AxisBuilder(indicatorAxis.model, {
            position: [radar.cx, radar.cy],
            rotation: indicatorAxis.angle,
            labelDirection: -1,
            tickDirection: -1,
            nameDirection: 1
          });
          return axisBuilder;
        });
        zrUtil.each(axisBuilders, function(axisBuilder) {
          zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
          this.group.add(axisBuilder.getGroup());
        }, this);
      },
      _buildSplitLineAndArea: function(radarModel) {
        var radar = radarModel.coordinateSystem;
        var indicatorAxes = radar.getIndicatorAxes();
        if (!indicatorAxes.length) {
          return;
        }
        var shape = radarModel.get("shape");
        var splitLineModel = radarModel.getModel("splitLine");
        var splitAreaModel = radarModel.getModel("splitArea");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var areaStyleModel = splitAreaModel.getModel("areaStyle");
        var showSplitLine = splitLineModel.get("show");
        var showSplitArea = splitAreaModel.get("show");
        var splitLineColors = lineStyleModel.get("color");
        var splitAreaColors = areaStyleModel.get("color");
        splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
        splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
        var splitLines = [];
        var splitAreas = [];
        function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
          var colorIndex2 = idx % areaOrLineColorList.length;
          areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
          return colorIndex2;
        }
        if (shape === "circle") {
          var ticksRadius = indicatorAxes[0].getTicksCoords();
          var cx = radar.cx;
          var cy = radar.cy;
          for (var i = 0; i < ticksRadius.length; i++) {
            if (showSplitLine) {
              var colorIndex = getColorIndex(splitLines, splitLineColors, i);
              splitLines[colorIndex].push(new graphic.Circle({
                shape: {
                  cx,
                  cy,
                  r: ticksRadius[i].coord
                }
              }));
            }
            if (showSplitArea && i < ticksRadius.length - 1) {
              var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
              splitAreas[colorIndex].push(new graphic.Ring({
                shape: {
                  cx,
                  cy,
                  r0: ticksRadius[i].coord,
                  r: ticksRadius[i + 1].coord
                }
              }));
            }
          }
        } else {
          var realSplitNumber;
          var axesTicksPoints = zrUtil.map(indicatorAxes, function(indicatorAxis, idx) {
            var ticksCoords = indicatorAxis.getTicksCoords();
            realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);
            return zrUtil.map(ticksCoords, function(tickCoord) {
              return radar.coordToPoint(tickCoord.coord, idx);
            });
          });
          var prevPoints = [];
          for (var i = 0; i <= realSplitNumber; i++) {
            var points = [];
            for (var j = 0; j < indicatorAxes.length; j++) {
              points.push(axesTicksPoints[j][i]);
            }
            if (points[0]) {
              points.push(points[0].slice());
            } else {
            }
            if (showSplitLine) {
              var colorIndex = getColorIndex(splitLines, splitLineColors, i);
              splitLines[colorIndex].push(new graphic.Polyline({
                shape: {
                  points
                }
              }));
            }
            if (showSplitArea && prevPoints) {
              var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
              splitAreas[colorIndex].push(new graphic.Polygon({
                shape: {
                  points: points.concat(prevPoints)
                }
              }));
            }
            prevPoints = points.slice().reverse();
          }
        }
        var lineStyle = lineStyleModel.getLineStyle();
        var areaStyle = areaStyleModel.getAreaStyle();
        zrUtil.each(splitAreas, function(splitAreas2, idx) {
          this.group.add(graphic.mergePath(splitAreas2, {
            style: zrUtil.defaults({
              stroke: "none",
              fill: splitAreaColors[idx % splitAreaColors.length]
            }, areaStyle),
            silent: true
          }));
        }, this);
        zrUtil.each(splitLines, function(splitLines2, idx) {
          this.group.add(graphic.mergePath(splitLines2, {
            style: zrUtil.defaults({
              fill: "none",
              stroke: splitLineColors[idx % splitLineColors.length]
            }, lineStyle),
            silent: true
          }));
        }, this);
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar.js
var require_radar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radar.js"() {
    require_Radar();
    require_RadarModel();
    require_RadarView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarSeries.js
var require_RadarSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createListSimply = require_createListSimply();
    var zrUtil = require_util();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var LegendVisualProvider = require_LegendVisualProvider();
    var RadarSeries = SeriesModel.extend({
      type: "series.radar",
      dependencies: ["radar"],
      // Overwrite
      init: function(option) {
        RadarSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
      },
      getInitialData: function(option, ecModel) {
        return createListSimply(this, {
          generateCoord: "indicator_",
          generateCoordCount: Infinity
        });
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var data = this.getData();
        var coordSys = this.coordinateSystem;
        var indicatorAxes = coordSys.getIndicatorAxes();
        var name2 = this.getData().getName(dataIndex);
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        return encodeHTML(name2 === "" ? this.name : name2) + newLine + zrUtil.map(indicatorAxes, function(axis, idx) {
          var val = data.get(data.mapDimension(axis.dim), dataIndex);
          return encodeHTML(axis.name + " : " + val);
        }).join(newLine);
      },
      /**
       * @implement
       */
      getTooltipPosition: function(dataIndex) {
        if (dataIndex != null) {
          var data = this.getData();
          var coordSys = this.coordinateSystem;
          var values = data.getValues(zrUtil.map(coordSys.dimensions, function(dim) {
            return data.mapDimension(dim);
          }), dataIndex, true);
          for (var i = 0, len = values.length; i < len; i++) {
            if (!isNaN(values[i])) {
              var indicatorAxes = coordSys.getIndicatorAxes();
              return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
            }
          }
        }
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "radar",
        legendHoverLink: true,
        radarIndex: 0,
        lineStyle: {
          width: 2,
          type: "solid"
        },
        label: {
          position: "top"
        },
        // areaStyle: {
        // },
        // itemStyle: {}
        symbol: "emptyCircle",
        symbolSize: 4
        // symbolRotate: null
      }
    });
    var _default = RadarSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarView.js
var require_RadarView2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/RadarView.js"(exports, module) {
    var echarts = require_echarts();
    var graphic = require_graphic();
    var zrUtil = require_util();
    var symbolUtil = require_symbol();
    function normalizeSymbolSize(symbolSize) {
      if (!zrUtil.isArray(symbolSize)) {
        symbolSize = [+symbolSize, +symbolSize];
      }
      return symbolSize;
    }
    var _default = echarts.extendChartView({
      type: "radar",
      render: function(seriesModel, ecModel, api) {
        var polar = seriesModel.coordinateSystem;
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        function createSymbol(data2, idx) {
          var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
          var color = data2.getItemVisual(idx, "color");
          if (symbolType === "none") {
            return;
          }
          var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
          var symbolPath = symbolUtil.createSymbol(symbolType, -1, -1, 2, 2, color);
          var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
          symbolPath.attr({
            style: {
              strokeNoScale: true
            },
            z2: 100,
            scale: [symbolSize[0] / 2, symbolSize[1] / 2],
            rotation: symbolRotate * Math.PI / 180 || 0
          });
          return symbolPath;
        }
        function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
          symbolGroup.removeAll();
          for (var i = 0; i < newPoints.length - 1; i++) {
            var symbolPath = createSymbol(data2, idx);
            if (symbolPath) {
              symbolPath.__dimIdx = i;
              if (oldPoints[i]) {
                symbolPath.attr("position", oldPoints[i]);
                graphic[isInit ? "initProps" : "updateProps"](symbolPath, {
                  position: newPoints[i]
                }, seriesModel, idx);
              } else {
                symbolPath.attr("position", newPoints[i]);
              }
              symbolGroup.add(symbolPath);
            }
          }
        }
        function getInitialPoints(points) {
          return zrUtil.map(points, function(pt) {
            return [polar.cx, polar.cy];
          });
        }
        data.diff(oldData).add(function(idx) {
          var points = data.getItemLayout(idx);
          if (!points) {
            return;
          }
          var polygon = new graphic.Polygon();
          var polyline = new graphic.Polyline();
          var target = {
            shape: {
              points
            }
          };
          polygon.shape.points = getInitialPoints(points);
          polyline.shape.points = getInitialPoints(points);
          graphic.initProps(polygon, target, seriesModel, idx);
          graphic.initProps(polyline, target, seriesModel, idx);
          var itemGroup = new graphic.Group();
          var symbolGroup = new graphic.Group();
          itemGroup.add(polyline);
          itemGroup.add(polygon);
          itemGroup.add(symbolGroup);
          updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);
          data.setItemGraphicEl(idx, itemGroup);
        }).update(function(newIdx, oldIdx) {
          var itemGroup = oldData.getItemGraphicEl(oldIdx);
          var polyline = itemGroup.childAt(0);
          var polygon = itemGroup.childAt(1);
          var symbolGroup = itemGroup.childAt(2);
          var target = {
            shape: {
              points: data.getItemLayout(newIdx)
            }
          };
          if (!target.shape.points) {
            return;
          }
          updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
          graphic.updateProps(polyline, target, seriesModel);
          graphic.updateProps(polygon, target, seriesModel);
          data.setItemGraphicEl(newIdx, itemGroup);
        }).remove(function(idx) {
          group.remove(oldData.getItemGraphicEl(idx));
        }).execute();
        data.eachItemGraphicEl(function(itemGroup, idx) {
          var itemModel = data.getItemModel(idx);
          var polyline = itemGroup.childAt(0);
          var polygon = itemGroup.childAt(1);
          var symbolGroup = itemGroup.childAt(2);
          var color = data.getItemVisual(idx, "color");
          group.add(itemGroup);
          polyline.useStyle(zrUtil.defaults(itemModel.getModel("lineStyle").getLineStyle(), {
            fill: "none",
            stroke: color
          }));
          polyline.hoverStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
          var areaStyleModel = itemModel.getModel("areaStyle");
          var hoverAreaStyleModel = itemModel.getModel("emphasis.areaStyle");
          var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
          var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();
          hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
          polygon.ignore = polygonIgnore;
          polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
            fill: color,
            opacity: 0.7
          }));
          polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();
          var itemStyle = itemModel.getModel("itemStyle").getItemStyle(["color"]);
          var itemHoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
          var labelModel = itemModel.getModel("label");
          var labelHoverModel = itemModel.getModel("emphasis.label");
          symbolGroup.eachChild(function(symbolPath) {
            symbolPath.setStyle(itemStyle);
            symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);
            var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
            (defaultText == null || isNaN(defaultText)) && (defaultText = "");
            graphic.setLabelStyle(symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel, {
              labelFetcher: data.hostModel,
              labelDataIndex: idx,
              labelDimIndex: symbolPath.__dimIdx,
              defaultText,
              autoColor: color,
              isRectText: true
            });
          });
          itemGroup.highDownOnUpdate = function(fromState, toState) {
            polygon.attr("ignore", toState === "emphasis" ? hoverPolygonIgnore : polygonIgnore);
          };
          graphic.setHoverStyle(itemGroup);
        });
        this._data = data;
      },
      remove: function() {
        this.group.removeAll();
        this._data = null;
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/radarLayout.js
var require_radarLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/radarLayout.js"(exports, module) {
    var zrUtil = require_util();
    function _default(ecModel) {
      ecModel.eachSeriesByType("radar", function(seriesModel) {
        var data = seriesModel.getData();
        var points = [];
        var coordSys = seriesModel.coordinateSystem;
        if (!coordSys) {
          return;
        }
        var axes = coordSys.getIndicatorAxes();
        zrUtil.each(axes, function(axis, axisIndex) {
          data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
            points[dataIndex] = points[dataIndex] || [];
            var point = coordSys.dataToPoint(val, axisIndex);
            points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
          });
        });
        data.each(function(idx) {
          var firstPoint = zrUtil.find(points[idx], function(point) {
            return isValidPoint(point);
          }) || getValueMissingPoint(coordSys);
          points[idx].push(firstPoint.slice());
          data.setItemLayout(idx, points[idx]);
        });
      });
    }
    function isValidPoint(point) {
      return !isNaN(point[0]) && !isNaN(point[1]);
    }
    function getValueMissingPoint(coordSys) {
      return [coordSys.cx, coordSys.cy];
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/backwardCompat.js
var require_backwardCompat2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar/backwardCompat.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      var polarOptArr = option.polar;
      if (polarOptArr) {
        if (!zrUtil.isArray(polarOptArr)) {
          polarOptArr = [polarOptArr];
        }
        var polarNotRadar = [];
        zrUtil.each(polarOptArr, function(polarOpt, idx) {
          if (polarOpt.indicator) {
            if (polarOpt.type && !polarOpt.shape) {
              polarOpt.shape = polarOpt.type;
            }
            option.radar = option.radar || [];
            if (!zrUtil.isArray(option.radar)) {
              option.radar = [option.radar];
            }
            option.radar.push(polarOpt);
          } else {
            polarNotRadar.push(polarOpt);
          }
        });
        option.polar = polarNotRadar;
      }
      zrUtil.each(option.series, function(seriesOpt) {
        if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
          seriesOpt.radarIndex = seriesOpt.polarIndex;
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar.js
var require_radar2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/radar.js"() {
    var echarts = require_echarts();
    require_radar();
    require_RadarSeries();
    require_RadarView2();
    var dataColor = require_dataColor();
    var visualSymbol = require_symbol2();
    var radarLayout = require_radarLayout();
    var dataFilter = require_dataFilter();
    var backwardCompat = require_backwardCompat2();
    echarts.registerVisual(dataColor("radar"));
    echarts.registerVisual(visualSymbol("radar", "circle"));
    echarts.registerLayout(radarLayout);
    echarts.registerProcessor(dataFilter("radar"));
    echarts.registerPreprocessor(backwardCompat);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/nanhai.js
var require_nanhai = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/nanhai.js"(exports, module) {
    var zrUtil = require_util();
    var Region = require_Region();
    var geoCoord = [126, 25];
    var points = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
    for (i = 0; i < points.length; i++) {
      for (k = 0; k < points[i].length; k++) {
        points[i][k][0] /= 10.5;
        points[i][k][1] /= -10.5 / 0.75;
        points[i][k][0] += geoCoord[0];
        points[i][k][1] += geoCoord[1];
      }
    }
    var k;
    var i;
    function _default(mapType, regions) {
      if (mapType === "china") {
        regions.push(new Region("南海诸岛", zrUtil.map(points, function(exterior) {
          return {
            type: "polygon",
            exterior
          };
        }), geoCoord));
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/textCoord.js
var require_textCoord = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/textCoord.js"(exports, module) {
    var coordsOffsetMap = {
      "南海诸岛": [32, 80],
      // 全国
      "广东": [0, -10],
      "香港": [10, 5],
      "澳门": [-10, 10],
      //'北京': [-10, 0],
      "天津": [5, 5]
    };
    function _default(mapType, region) {
      if (mapType === "china") {
        var coordFix = coordsOffsetMap[region.name];
        if (coordFix) {
          var cp = region.center;
          cp[0] += coordFix[0] / 10.5;
          cp[1] += -coordFix[1] / (10.5 / 0.75);
        }
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/geoCoord.js
var require_geoCoord = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/geoCoord.js"(exports, module) {
    var geoCoordMap = {
      "Russia": [100, 60],
      "United States": [-99, 38],
      "United States of America": [-99, 38]
    };
    function _default(mapType, region) {
      if (mapType === "world") {
        var geoCoord = geoCoordMap[region.name];
        if (geoCoord) {
          var cp = region.center;
          cp[0] = geoCoord[0];
          cp[1] = geoCoord[1];
        }
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js
var require_diaoyuIsland = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/fix/diaoyuIsland.js"(exports, module) {
    var points = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
    function _default(mapType, region) {
      if (mapType === "china" && region.name === "台湾") {
        region.geometries.push({
          type: "polygon",
          exterior: points[0]
        });
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoJSONLoader.js
var require_geoJSONLoader = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoJSONLoader.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var parseGeoJson = require_parseGeoJson();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var fixNanhai = require_nanhai();
    var fixTextCoord = require_textCoord();
    var fixGeoCoord = require_geoCoord();
    var fixDiaoyuIsland = require_diaoyuIsland();
    var inner = makeInner();
    var _default = {
      /**
       * @param {string} mapName
       * @param {Object} mapRecord {specialAreas, geoJSON}
       * @param {string} nameProperty
       * @return {Object} {regions, boundingRect}
       */
      load: function(mapName, mapRecord, nameProperty) {
        var parsed = inner(mapRecord).parsed;
        if (parsed) {
          return parsed;
        }
        var specialAreas = mapRecord.specialAreas || {};
        var geoJSON = mapRecord.geoJSON;
        var regions;
        try {
          regions = geoJSON ? parseGeoJson(geoJSON, nameProperty) : [];
        } catch (e) {
          throw new Error("Invalid geoJson format\n" + e.message);
        }
        fixNanhai(mapName, regions);
        each(regions, function(region) {
          var regionName = region.name;
          fixTextCoord(mapName, region);
          fixGeoCoord(mapName, region);
          fixDiaoyuIsland(mapName, region);
          var specialArea = specialAreas[regionName];
          if (specialArea) {
            region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
          }
        });
        return inner(mapRecord).parsed = {
          regions,
          boundingRect: getBoundingRect(regions)
        };
      }
    };
    function getBoundingRect(regions) {
      var rect;
      for (var i = 0; i < regions.length; i++) {
        var regionRect = regions[i].getBoundingRect();
        rect = rect || regionRect.clone();
        rect.union(regionRect);
      }
      return rect;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSVGLoader.js
var require_geoSVGLoader = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSVGLoader.js"(exports, module) {
    var _parseSVG = require_parseSVG();
    var parseSVG = _parseSVG.parseSVG;
    var makeViewBoxTransform = _parseSVG.makeViewBoxTransform;
    var Group = require_Group();
    var Rect = require_Rect();
    var _util = require_util();
    var assert = _util.assert;
    var createHashMap = _util.createHashMap;
    var BoundingRect = require_BoundingRect();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    var _default = {
      /**
       * @param {string} mapName
       * @param {Object} mapRecord {specialAreas, geoJSON}
       * @return {Object} {root, boundingRect}
       */
      load: function(mapName, mapRecord) {
        var originRoot = inner(mapRecord).originRoot;
        if (originRoot) {
          return {
            root: originRoot,
            boundingRect: inner(mapRecord).boundingRect
          };
        }
        var graphic = buildGraphic(mapRecord);
        inner(mapRecord).originRoot = graphic.root;
        inner(mapRecord).boundingRect = graphic.boundingRect;
        return graphic;
      },
      makeGraphic: function(mapName, mapRecord, hostKey) {
        var field = inner(mapRecord);
        var rootMap = field.rootMap || (field.rootMap = createHashMap());
        var root = rootMap.get(hostKey);
        if (root) {
          return root;
        }
        var originRoot = field.originRoot;
        var boundingRect = field.boundingRect;
        if (!field.originRootHostKey) {
          field.originRootHostKey = hostKey;
          root = originRoot;
        } else {
          root = buildGraphic(mapRecord, boundingRect).root;
        }
        return rootMap.set(hostKey, root);
      },
      removeGraphic: function(mapName, mapRecord, hostKey) {
        var field = inner(mapRecord);
        var rootMap = field.rootMap;
        rootMap && rootMap.removeKey(hostKey);
        if (hostKey === field.originRootHostKey) {
          field.originRootHostKey = null;
        }
      }
    };
    function buildGraphic(mapRecord, boundingRect) {
      var svgXML = mapRecord.svgXML;
      var result;
      var root;
      try {
        result = svgXML && parseSVG(svgXML, {
          ignoreViewBox: true,
          ignoreRootClip: true
        }) || {};
        root = result.root;
        assert(root != null);
      } catch (e) {
        throw new Error("Invalid svg format\n" + e.message);
      }
      var svgWidth = result.width;
      var svgHeight = result.height;
      var viewBoxRect = result.viewBoxRect;
      if (!boundingRect) {
        boundingRect = svgWidth == null || svgHeight == null ? (
          // If svg width / height not specified, calculate
          // bounding rect as the width / height
          root.getBoundingRect()
        ) : new BoundingRect(0, 0, 0, 0);
        if (svgWidth != null) {
          boundingRect.width = svgWidth;
        }
        if (svgHeight != null) {
          boundingRect.height = svgHeight;
        }
      }
      if (viewBoxRect) {
        var viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect.width, boundingRect.height);
        var elRoot = root;
        root = new Group();
        root.add(elRoot);
        elRoot.scale = viewBoxTransform.scale;
        elRoot.position = viewBoxTransform.position;
      }
      root.setClipPath(new Rect({
        shape: boundingRect.plain()
      }));
      return {
        root,
        boundingRect
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSourceManager.js
var require_geoSourceManager = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoSourceManager.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _util = require_util();
    var each = _util.each;
    var createHashMap = _util.createHashMap;
    var mapDataStorage = require_mapDataStorage();
    var geoJSONLoader = require_geoJSONLoader();
    var geoSVGLoader = require_geoSVGLoader();
    var BoundingRect = require_BoundingRect();
    var loaders = {
      geoJSON: geoJSONLoader,
      svg: geoSVGLoader
    };
    var _default = {
      /**
       * @param {string} mapName
       * @param {Object} nameMap
       * @param {string} nameProperty
       * @return {Object} source {regions, regionsMap, nameCoordMap, boundingRect}
       */
      load: function(mapName, nameMap, nameProperty) {
        var regions = [];
        var regionsMap = createHashMap();
        var nameCoordMap = createHashMap();
        var boundingRect;
        var mapRecords = retrieveMap(mapName);
        each(mapRecords, function(record) {
          var singleSource = loaders[record.type].load(mapName, record, nameProperty);
          each(singleSource.regions, function(region) {
            var regionName = region.name;
            if (nameMap && nameMap.hasOwnProperty(regionName)) {
              region = region.cloneShallow(regionName = nameMap[regionName]);
            }
            regions.push(region);
            regionsMap.set(regionName, region);
            nameCoordMap.set(regionName, region.center);
          });
          var rect = singleSource.boundingRect;
          if (rect) {
            boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();
          }
        });
        return {
          regions,
          regionsMap,
          nameCoordMap,
          // FIXME Always return new ?
          boundingRect: boundingRect || new BoundingRect(0, 0, 0, 0)
        };
      },
      /**
       * @param {string} mapName
       * @param {string} hostKey For cache.
       * @return {Array.<module:zrender/Element>} Roots.
       */
      makeGraphic: makeInvoker("makeGraphic"),
      /**
       * @param {string} mapName
       * @param {string} hostKey For cache.
       */
      removeGraphic: makeInvoker("removeGraphic")
    };
    function makeInvoker(methodName) {
      return function(mapName, hostKey) {
        var mapRecords = retrieveMap(mapName);
        var results = [];
        each(mapRecords, function(record) {
          var method = loaders[record.type][methodName];
          method && results.push(method(mapName, record, hostKey));
        });
        return results;
      };
    }
    function retrieveMap(mapName) {
      var mapRecords = mapDataStorage.retrieveMap(mapName) || [];
      return mapRecords;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapSeries.js
var require_MapSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapSeries.js"(exports, module) {
    var zrUtil = require_util();
    var createListSimply = require_createListSimply();
    var SeriesModel = require_Series();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var addCommas = _format.addCommas;
    var dataSelectableMixin = require_selectableMixin();
    var _dataProvider = require_dataProvider();
    var retrieveRawAttr = _dataProvider.retrieveRawAttr;
    var geoSourceManager = require_geoSourceManager();
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;
    var MapSeries = SeriesModel.extend({
      type: "series.map",
      dependencies: ["geo"],
      layoutMode: "box",
      /**
       * Only first map series of same mapType will drawMap
       * @type {boolean}
       */
      needsDrawMap: false,
      /**
       * Group of all map series with same mapType
       * @type {boolean}
       */
      seriesGroup: [],
      getInitialData: function(option) {
        var data = createListSimply(this, {
          coordDimensions: ["value"],
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
        });
        var valueDim = data.mapDimension("value");
        var dataNameMap = zrUtil.createHashMap();
        var selectTargetList = [];
        var toAppendNames = [];
        for (var i = 0, len = data.count(); i < len; i++) {
          var name2 = data.getName(i);
          dataNameMap.set(name2, true);
          selectTargetList.push({
            name: name2,
            value: data.get(valueDim, i),
            selected: retrieveRawAttr(data, i, "selected")
          });
        }
        var geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
        zrUtil.each(geoSource.regions, function(region) {
          var name3 = region.name;
          if (!dataNameMap.get(name3)) {
            selectTargetList.push({
              name: name3
            });
            toAppendNames.push(name3);
          }
        });
        this.updateSelectedMap(selectTargetList);
        data.appendValues([], toAppendNames);
        return data;
      },
      /**
       * If no host geo model, return null, which means using a
       * inner exclusive geo model.
       */
      getHostGeoModel: function() {
        var geoIndex = this.option.geoIndex;
        return geoIndex != null ? this.dependentModels.geo[geoIndex] : null;
      },
      getMapType: function() {
        return (this.getHostGeoModel() || this).option.map;
      },
      // _fillOption: function (option, mapName) {
      // Shallow clone
      // option = zrUtil.extend({}, option);
      // option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);
      // return option;
      // },
      getRawValue: function(dataIndex) {
        var data = this.getData();
        return data.get(data.mapDimension("value"), dataIndex);
      },
      /**
       * Get model of region
       * @param  {string} name
       * @return {module:echarts/model/Model}
       */
      getRegionModel: function(regionName) {
        var data = this.getData();
        return data.getItemModel(data.indexOfName(regionName));
      },
      /**
       * Map tooltip formatter
       *
       * @param {number} dataIndex
       */
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var data = this.getData();
        var formattedValue = addCommas(this.getRawValue(dataIndex));
        var name2 = data.getName(dataIndex);
        var seriesGroup = this.seriesGroup;
        var seriesNames = [];
        for (var i = 0; i < seriesGroup.length; i++) {
          var otherIndex = seriesGroup[i].originalData.indexOfName(name2);
          var valueDim = data.mapDimension("value");
          if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
            seriesNames.push(encodeHTML(seriesGroup[i].name));
          }
        }
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        return seriesNames.join(", ") + newLine + encodeHTML(name2 + " : " + formattedValue);
      },
      /**
       * @implement
       */
      getTooltipPosition: function(dataIndex) {
        if (dataIndex != null) {
          var name2 = this.getData().getName(dataIndex);
          var geo = this.coordinateSystem;
          var region = geo.getRegion(name2);
          return region && geo.dataToPoint(region.center);
        }
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      },
      defaultOption: {
        // 一级层叠
        zlevel: 0,
        // 二级层叠
        z: 2,
        coordinateSystem: "geo",
        // map should be explicitly specified since ec3.
        map: "",
        // If `geoIndex` is not specified, a exclusive geo will be
        // created. Otherwise use the specified geo component, and
        // `map` and `mapType` are ignored.
        // geoIndex: 0,
        // 'center' | 'left' | 'right' | 'x%' | {number}
        left: "center",
        // 'center' | 'top' | 'bottom' | 'x%' | {number}
        top: "center",
        // right
        // bottom
        // width:
        // height
        // Aspect is width / height. Inited to be geoJson bbox aspect
        // This parameter is used for scale this aspect
        aspectScale: 0.75,
        ///// Layout with center and size
        // If you wan't to put map in a fixed size box with right aspect ratio
        // This two properties may more conveninet
        // layoutCenter: [50%, 50%]
        // layoutSize: 100
        // 数值合并方式，默认加和，可选为：
        // 'sum' | 'average' | 'max' | 'min'
        // mapValueCalculation: 'sum',
        // 地图数值计算结果小数精度
        // mapValuePrecision: 0,
        // 显示图例颜色标识（系列标识的小圆点），图例开启时有效
        showLegendSymbol: true,
        // 选择模式，默认关闭，可选single，multiple
        // selectedMode: false,
        dataRangeHoverLink: true,
        // 是否开启缩放及漫游模式
        // roam: false,
        // Define left-top, right-bottom coords to control view
        // For example, [ [180, 90], [-180, -90] ],
        // higher priority than center and zoom
        boundingCoords: null,
        // Default on center of map
        center: null,
        zoom: 1,
        scaleLimit: null,
        label: {
          show: false,
          color: "#000"
        },
        // scaleLimit: null,
        itemStyle: {
          borderWidth: 0.5,
          borderColor: "#444",
          areaColor: "#eee"
        },
        emphasis: {
          label: {
            show: true,
            color: "rgb(100,0,0)"
          },
          itemStyle: {
            areaColor: "rgba(255,215,0,0.8)"
          }
        },
        nameProperty: "name"
      }
    });
    zrUtil.mixin(MapSeries, dataSelectableMixin);
    var _default = MapSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/interactionMutex.js
var require_interactionMutex = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/interactionMutex.js"(exports) {
    var echarts = require_echarts();
    var ATTR = "\0_ec_interaction_mutex";
    function take(zr, resourceKey, userKey) {
      var store = getStore(zr);
      store[resourceKey] = userKey;
    }
    function release(zr, resourceKey, userKey) {
      var store = getStore(zr);
      var uKey = store[resourceKey];
      if (uKey === userKey) {
        store[resourceKey] = null;
      }
    }
    function isTaken(zr, resourceKey) {
      return !!getStore(zr)[resourceKey];
    }
    function getStore(zr) {
      return zr[ATTR] || (zr[ATTR] = {});
    }
    echarts.registerAction({
      type: "takeGlobalCursor",
      event: "globalCursorTaken",
      update: "update"
    }, function() {
    });
    exports.take = take;
    exports.release = release;
    exports.isTaken = isTaken;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/RoamController.js
var require_RoamController = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/RoamController.js"(exports, module) {
    var zrUtil = require_util();
    var Eventful = require_Eventful();
    var eventTool = require_event();
    var interactionMutex = require_interactionMutex();
    function RoamController(zr) {
      this.pointerChecker;
      this._zr = zr;
      this._opt = {};
      var bind = zrUtil.bind;
      var mousedownHandler = bind(mousedown, this);
      var mousemoveHandler = bind(mousemove, this);
      var mouseupHandler = bind(mouseup, this);
      var mousewheelHandler = bind(mousewheel, this);
      var pinchHandler = bind(pinch, this);
      Eventful.call(this);
      this.setPointerChecker = function(pointerChecker) {
        this.pointerChecker = pointerChecker;
      };
      this.enable = function(controlType, opt) {
        this.disable();
        this._opt = zrUtil.defaults(zrUtil.clone(opt) || {}, {
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: false,
          preventDefaultMouseMove: true
        });
        if (controlType == null) {
          controlType = true;
        }
        if (controlType === true || controlType === "move" || controlType === "pan") {
          zr.on("mousedown", mousedownHandler);
          zr.on("mousemove", mousemoveHandler);
          zr.on("mouseup", mouseupHandler);
        }
        if (controlType === true || controlType === "scale" || controlType === "zoom") {
          zr.on("mousewheel", mousewheelHandler);
          zr.on("pinch", pinchHandler);
        }
      };
      this.disable = function() {
        zr.off("mousedown", mousedownHandler);
        zr.off("mousemove", mousemoveHandler);
        zr.off("mouseup", mouseupHandler);
        zr.off("mousewheel", mousewheelHandler);
        zr.off("pinch", pinchHandler);
      };
      this.dispose = this.disable;
      this.isDragging = function() {
        return this._dragging;
      };
      this.isPinching = function() {
        return this._pinching;
      };
    }
    zrUtil.mixin(RoamController, Eventful);
    function mousedown(e) {
      if (eventTool.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {
        return;
      }
      var x = e.offsetX;
      var y = e.offsetY;
      if (this.pointerChecker && this.pointerChecker(e, x, y)) {
        this._x = x;
        this._y = y;
        this._dragging = true;
      }
    }
    function mousemove(e) {
      if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e, this._opt) || e.gestureEvent === "pinch" || interactionMutex.isTaken(this._zr, "globalPan")) {
        return;
      }
      var x = e.offsetX;
      var y = e.offsetY;
      var oldX = this._x;
      var oldY = this._y;
      var dx = x - oldX;
      var dy = y - oldY;
      this._x = x;
      this._y = y;
      this._opt.preventDefaultMouseMove && eventTool.stop(e.event);
      trigger(this, "pan", "moveOnMouseMove", e, {
        dx,
        dy,
        oldX,
        oldY,
        newX: x,
        newY: y
      });
    }
    function mouseup(e) {
      if (!eventTool.isMiddleOrRightButtonOnMouseUpDown(e)) {
        this._dragging = false;
      }
    }
    function mousewheel(e) {
      var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e, this._opt);
      var shouldMove = isAvailableBehavior("moveOnMouseWheel", e, this._opt);
      var wheelDelta = e.wheelDelta;
      var absWheelDeltaDelta = Math.abs(wheelDelta);
      var originX = e.offsetX;
      var originY = e.offsetY;
      if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
        return;
      }
      if (shouldZoom) {
        var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
        var scale = wheelDelta > 0 ? factor : 1 / factor;
        checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e, {
          scale,
          originX,
          originY
        });
      }
      if (shouldMove) {
        var absDelta = Math.abs(wheelDelta);
        var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
        checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e, {
          scrollDelta,
          originX,
          originY
        });
      }
    }
    function pinch(e) {
      if (interactionMutex.isTaken(this._zr, "globalPan")) {
        return;
      }
      var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
      checkPointerAndTrigger(this, "zoom", null, e, {
        scale,
        originX: e.pinchX,
        originY: e.pinchY
      });
    }
    function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
      if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
        eventTool.stop(e.event);
        trigger(controller, eventName, behaviorToCheck, e, contollerEvent);
      }
    }
    function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
      contollerEvent.isAvailableBehavior = zrUtil.bind(isAvailableBehavior, null, behaviorToCheck, e);
      controller.trigger(eventName, contollerEvent);
    }
    function isAvailableBehavior(behaviorToCheck, e, settings) {
      var setting = settings[behaviorToCheck];
      return !behaviorToCheck || setting && (!zrUtil.isString(setting) || e.event[setting + "Key"]);
    }
    var _default = RoamController;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/roamHelper.js
var require_roamHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/roamHelper.js"(exports) {
    function updateViewOnPan(controllerHost, dx, dy) {
      var target = controllerHost.target;
      var pos = target.position;
      pos[0] += dx;
      pos[1] += dy;
      target.dirty();
    }
    function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
      var target = controllerHost.target;
      var zoomLimit = controllerHost.zoomLimit;
      var pos = target.position;
      var scale = target.scale;
      var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
      newZoom *= zoomDelta;
      if (zoomLimit) {
        var zoomMin = zoomLimit.min || 0;
        var zoomMax = zoomLimit.max || Infinity;
        newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
      }
      var zoomScale = newZoom / controllerHost.zoom;
      controllerHost.zoom = newZoom;
      pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
      pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
      scale[0] *= zoomScale;
      scale[1] *= zoomScale;
      target.dirty();
    }
    exports.updateViewOnPan = updateViewOnPan;
    exports.updateViewOnZoom = updateViewOnZoom;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/cursorHelper.js
var require_cursorHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/cursorHelper.js"(exports) {
    var IRRELEVANT_EXCLUDES = {
      "axisPointer": 1,
      "tooltip": 1,
      "brush": 1
    };
    function onIrrelevantElement(e, api, targetCoordSysModel) {
      var model = api.getComponentByElement(e.topTarget);
      var coordSys = model && model.coordinateSystem;
      return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
    }
    exports.onIrrelevantElement = onIrrelevantElement;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/MapDraw.js
var require_MapDraw = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/MapDraw.js"(exports, module) {
    var zrUtil = require_util();
    var RoamController = require_RoamController();
    var roamHelper = require_roamHelper();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var graphic = require_graphic();
    var geoSourceManager = require_geoSourceManager();
    var _component = require_component();
    var getUID = _component.getUID;
    var Transformable = require_Transformable();
    function getFixedItemStyle(model) {
      var itemStyle = model.getItemStyle();
      var areaColor = model.get("areaColor");
      if (areaColor != null) {
        itemStyle.fill = areaColor;
      }
      return itemStyle;
    }
    function updateMapSelectHandler(mapDraw, mapOrGeoModel, regionsGroup, api, fromView) {
      regionsGroup.off("click");
      regionsGroup.off("mousedown");
      if (mapOrGeoModel.get("selectedMode")) {
        regionsGroup.on("mousedown", function() {
          mapDraw._mouseDownFlag = true;
        });
        regionsGroup.on("click", function(e) {
          if (!mapDraw._mouseDownFlag) {
            return;
          }
          mapDraw._mouseDownFlag = false;
          var el = e.target;
          while (!el.__regions) {
            el = el.parent;
          }
          if (!el) {
            return;
          }
          var action = {
            type: (mapOrGeoModel.mainType === "geo" ? "geo" : "map") + "ToggleSelect",
            batch: zrUtil.map(el.__regions, function(region) {
              return {
                name: region.name,
                from: fromView.uid
              };
            })
          };
          action[mapOrGeoModel.mainType + "Id"] = mapOrGeoModel.id;
          api.dispatchAction(action);
          updateMapSelected(mapOrGeoModel, regionsGroup);
        });
      }
    }
    function updateMapSelected(mapOrGeoModel, regionsGroup) {
      regionsGroup.eachChild(function(otherRegionEl) {
        zrUtil.each(otherRegionEl.__regions, function(region) {
          otherRegionEl.trigger(mapOrGeoModel.isSelected(region.name) ? "emphasis" : "normal");
        });
      });
    }
    function MapDraw(api, updateGroup) {
      var group = new graphic.Group();
      this.uid = getUID("ec_map_draw");
      this._controller = new RoamController(api.getZr());
      this._controllerHost = {
        target: updateGroup ? group : null
      };
      this.group = group;
      this._updateGroup = updateGroup;
      this._mouseDownFlag;
      this._mapName;
      this._initialized;
      group.add(this._regionsGroup = new graphic.Group());
      group.add(this._backgroundGroup = new graphic.Group());
    }
    MapDraw.prototype = {
      constructor: MapDraw,
      draw: function(mapOrGeoModel, ecModel, api, fromView, payload) {
        var isGeo = mapOrGeoModel.mainType === "geo";
        var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
        isGeo && ecModel.eachComponent({
          mainType: "series",
          subType: "map"
        }, function(mapSeries) {
          if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
            data = mapSeries.getData();
          }
        });
        var geo = mapOrGeoModel.coordinateSystem;
        this._updateBackground(geo);
        var regionsGroup = this._regionsGroup;
        var group = this.group;
        var transformInfo = geo.getTransformInfo();
        var isFirstDraw = !regionsGroup.childAt(0) || payload;
        var targetScale;
        if (isFirstDraw) {
          group.transform = transformInfo.roamTransform;
          group.decomposeTransform();
          group.dirty();
        } else {
          var target = new Transformable();
          target.transform = transformInfo.roamTransform;
          target.decomposeTransform();
          var props = {
            scale: target.scale,
            position: target.position
          };
          targetScale = target.scale;
          graphic.updateProps(group, props, mapOrGeoModel);
        }
        var scale = transformInfo.rawScale;
        var position = transformInfo.rawPosition;
        regionsGroup.removeAll();
        var itemStyleAccessPath = ["itemStyle"];
        var hoverItemStyleAccessPath = ["emphasis", "itemStyle"];
        var labelAccessPath = ["label"];
        var hoverLabelAccessPath = ["emphasis", "label"];
        var nameMap = zrUtil.createHashMap();
        zrUtil.each(geo.regions, function(region) {
          var regionGroup = nameMap.get(region.name) || nameMap.set(region.name, new graphic.Group());
          var compoundPath = new graphic.CompoundPath({
            segmentIgnoreThreshold: 1,
            shape: {
              paths: []
            }
          });
          regionGroup.add(compoundPath);
          var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;
          var itemStyleModel = regionModel.getModel(itemStyleAccessPath);
          var hoverItemStyleModel = regionModel.getModel(hoverItemStyleAccessPath);
          var itemStyle = getFixedItemStyle(itemStyleModel);
          var hoverItemStyle = getFixedItemStyle(hoverItemStyleModel);
          var labelModel = regionModel.getModel(labelAccessPath);
          var hoverLabelModel = regionModel.getModel(hoverLabelAccessPath);
          var dataIdx;
          if (data) {
            dataIdx = data.indexOfName(region.name);
            var visualColor = data.getItemVisual(dataIdx, "color", true);
            if (visualColor) {
              itemStyle.fill = visualColor;
            }
          }
          var transformPoint = function(point) {
            return [point[0] * scale[0] + position[0], point[1] * scale[1] + position[1]];
          };
          zrUtil.each(region.geometries, function(geometry) {
            if (geometry.type !== "polygon") {
              return;
            }
            var points = [];
            for (var i = 0; i < geometry.exterior.length; ++i) {
              points.push(transformPoint(geometry.exterior[i]));
            }
            compoundPath.shape.paths.push(new graphic.Polygon({
              segmentIgnoreThreshold: 1,
              shape: {
                points
              }
            }));
            for (var i = 0; i < (geometry.interiors ? geometry.interiors.length : 0); ++i) {
              var interior = geometry.interiors[i];
              var points = [];
              for (var j = 0; j < interior.length; ++j) {
                points.push(transformPoint(interior[j]));
              }
              compoundPath.shape.paths.push(new graphic.Polygon({
                segmentIgnoreThreshold: 1,
                shape: {
                  points
                }
              }));
            }
          });
          compoundPath.setStyle(itemStyle);
          compoundPath.style.strokeNoScale = true;
          compoundPath.culling = true;
          var showLabel = labelModel.get("show");
          var hoverShowLabel = hoverLabelModel.get("show");
          var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
          var itemLayout = data && data.getItemLayout(dataIdx);
          if (isGeo || isDataNaN && (showLabel || hoverShowLabel) || itemLayout && itemLayout.showLabel) {
            var query = !isGeo ? dataIdx : region.name;
            var labelFetcher;
            if (!data || dataIdx >= 0) {
              labelFetcher = mapOrGeoModel;
            }
            var textEl = new graphic.Text({
              position: transformPoint(region.center.slice()),
              // FIXME
              // label rotation is not support yet in geo or regions of series-map
              // that has no data. The rotation will be effected by this `scale`.
              // So needed to change to RectText?
              scale: [1 / group.scale[0], 1 / group.scale[1]],
              z2: 10,
              silent: true
            });
            graphic.setLabelStyle(textEl.style, textEl.hoverStyle = {}, labelModel, hoverLabelModel, {
              labelFetcher,
              labelDataIndex: query,
              defaultText: region.name,
              useInsideStyle: false
            }, {
              textAlign: "center",
              textVerticalAlign: "middle"
            });
            if (!isFirstDraw) {
              var textScale = [1 / targetScale[0], 1 / targetScale[1]];
              graphic.updateProps(textEl, {
                scale: textScale
              }, mapOrGeoModel);
            }
            regionGroup.add(textEl);
          }
          if (data) {
            data.setItemGraphicEl(dataIdx, regionGroup);
          } else {
            var regionModel = mapOrGeoModel.getRegionModel(region.name);
            compoundPath.eventData = {
              componentType: "geo",
              componentIndex: mapOrGeoModel.componentIndex,
              geoIndex: mapOrGeoModel.componentIndex,
              name: region.name,
              region: regionModel && regionModel.option || {}
            };
          }
          var groupRegions = regionGroup.__regions || (regionGroup.__regions = []);
          groupRegions.push(region);
          regionGroup.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
          graphic.setHoverStyle(regionGroup, hoverItemStyle);
          regionsGroup.add(regionGroup);
        });
        this._updateController(mapOrGeoModel, ecModel, api);
        updateMapSelectHandler(this, mapOrGeoModel, regionsGroup, api, fromView);
        updateMapSelected(mapOrGeoModel, regionsGroup);
      },
      remove: function() {
        this._regionsGroup.removeAll();
        this._backgroundGroup.removeAll();
        this._controller.dispose();
        this._mapName && geoSourceManager.removeGraphic(this._mapName, this.uid);
        this._mapName = null;
        this._controllerHost = {};
      },
      _updateBackground: function(geo) {
        var mapName = geo.map;
        if (this._mapName !== mapName) {
          zrUtil.each(geoSourceManager.makeGraphic(mapName, this.uid), function(root) {
            this._backgroundGroup.add(root);
          }, this);
        }
        this._mapName = mapName;
      },
      _updateController: function(mapOrGeoModel, ecModel, api) {
        var geo = mapOrGeoModel.coordinateSystem;
        var controller = this._controller;
        var controllerHost = this._controllerHost;
        controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
        controllerHost.zoom = geo.getZoom();
        controller.enable(mapOrGeoModel.get("roam") || false);
        var mainType = mapOrGeoModel.mainType;
        function makeActionBase() {
          var action = {
            type: "geoRoam",
            componentType: mainType
          };
          action[mainType + "Id"] = mapOrGeoModel.id;
          return action;
        }
        controller.off("pan").on("pan", function(e) {
          this._mouseDownFlag = false;
          roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
          api.dispatchAction(zrUtil.extend(makeActionBase(), {
            dx: e.dx,
            dy: e.dy
          }));
        }, this);
        controller.off("zoom").on("zoom", function(e) {
          this._mouseDownFlag = false;
          roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
          api.dispatchAction(zrUtil.extend(makeActionBase(), {
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          }));
          if (this._updateGroup) {
            var scale = this.group.scale;
            this._regionsGroup.traverse(function(el) {
              if (el.type === "text") {
                el.attr("scale", [1 / scale[0], 1 / scale[1]]);
              }
            });
          }
        }, this);
        controller.setPointerChecker(function(e, x, y) {
          return geo.getViewRectAfterRoam().contain(x, y) && !onIrrelevantElement(e, api, mapOrGeoModel);
        });
      }
    };
    var _default = MapDraw;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapView.js
var require_MapView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/MapView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var MapDraw = require_MapDraw();
    var HIGH_DOWN_PROP = "__seriesMapHighDown";
    var RECORD_VERSION_PROP = "__seriesMapCallKey";
    var _default = echarts.extendChartView({
      type: "map",
      render: function(mapModel, ecModel, api, payload) {
        if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
          return;
        }
        var group = this.group;
        group.removeAll();
        if (mapModel.getHostGeoModel()) {
          return;
        }
        if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
          if (mapModel.needsDrawMap) {
            var mapDraw = this._mapDraw || new MapDraw(api, true);
            group.add(mapDraw.group);
            mapDraw.draw(mapModel, ecModel, api, this, payload);
            this._mapDraw = mapDraw;
          } else {
            this._mapDraw && this._mapDraw.remove();
            this._mapDraw = null;
          }
        } else {
          var mapDraw = this._mapDraw;
          mapDraw && group.add(mapDraw.group);
        }
        mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
      },
      remove: function() {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
        this.group.removeAll();
      },
      dispose: function() {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      },
      _renderSymbols: function(mapModel, ecModel, api) {
        var originalData = mapModel.originalData;
        var group = this.group;
        originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
          if (isNaN(value)) {
            return;
          }
          var layout = originalData.getItemLayout(originalDataIndex);
          if (!layout || !layout.point) {
            return;
          }
          var point = layout.point;
          var offset = layout.offset;
          var circle = new graphic.Circle({
            style: {
              // Because the special of map draw.
              // Which needs statistic of multiple series and draw on one map.
              // And each series also need a symbol with legend color
              //
              // Layout and visual are put one the different data
              fill: mapModel.getData().getVisual("color")
            },
            shape: {
              cx: point[0] + offset * 9,
              cy: point[1],
              r: 3
            },
            silent: true,
            // Do not overlap the first series, on which labels are displayed.
            z2: 8 + (!offset ? graphic.Z2_EMPHASIS_LIFT + 1 : 0)
          });
          if (!offset) {
            var fullData = mapModel.mainSeries.getData();
            var name2 = originalData.getName(originalDataIndex);
            var fullIndex = fullData.indexOfName(name2);
            var itemModel = originalData.getItemModel(originalDataIndex);
            var labelModel = itemModel.getModel("label");
            var hoverLabelModel = itemModel.getModel("emphasis.label");
            var regionGroup = fullData.getItemGraphicEl(fullIndex);
            var normalText = zrUtil.retrieve2(mapModel.getFormattedLabel(fullIndex, "normal"), name2);
            var emphasisText = zrUtil.retrieve2(mapModel.getFormattedLabel(fullIndex, "emphasis"), normalText);
            var highDownRecord = regionGroup[HIGH_DOWN_PROP];
            var recordVersion = Math.random();
            if (!highDownRecord) {
              highDownRecord = regionGroup[HIGH_DOWN_PROP] = {};
              var onEmphasis = zrUtil.curry(onRegionHighDown, true);
              var onNormal = zrUtil.curry(onRegionHighDown, false);
              regionGroup.on("mouseover", onEmphasis).on("mouseout", onNormal).on("emphasis", onEmphasis).on("normal", onNormal);
            }
            regionGroup[RECORD_VERSION_PROP] = recordVersion;
            zrUtil.extend(highDownRecord, {
              recordVersion,
              circle,
              labelModel,
              hoverLabelModel,
              emphasisText,
              normalText
            });
            enterRegionHighDown(highDownRecord, false);
          }
          group.add(circle);
        });
      }
    });
    function onRegionHighDown(toHighOrDown) {
      var highDownRecord = this[HIGH_DOWN_PROP];
      if (highDownRecord && highDownRecord.recordVersion === this[RECORD_VERSION_PROP]) {
        enterRegionHighDown(highDownRecord, toHighOrDown);
      }
    }
    function enterRegionHighDown(highDownRecord, toHighOrDown) {
      var circle = highDownRecord.circle;
      var labelModel = highDownRecord.labelModel;
      var hoverLabelModel = highDownRecord.hoverLabelModel;
      var emphasisText = highDownRecord.emphasisText;
      var normalText = highDownRecord.normalText;
      if (toHighOrDown) {
        circle.style.extendFrom(graphic.setTextStyle({}, hoverLabelModel, {
          text: hoverLabelModel.get("show") ? emphasisText : null
        }, {
          isRectText: true,
          useInsideStyle: false
        }, true));
        circle.__mapOriginalZ2 = circle.z2;
        circle.z2 += graphic.Z2_EMPHASIS_LIFT;
      } else {
        graphic.setTextStyle(circle.style, labelModel, {
          text: labelModel.get("show") ? normalText : null,
          textPosition: labelModel.getShallow("position") || "bottom"
        }, {
          isRectText: true,
          useInsideStyle: false
        });
        circle.dirty(false);
        if (circle.__mapOriginalZ2 != null) {
          circle.z2 = circle.__mapOriginalZ2;
          circle.__mapOriginalZ2 = null;
        }
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/roamHelper.js
var require_roamHelper2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/roamHelper.js"(exports) {
    function updateCenterAndZoom(view, payload, zoomLimit) {
      var previousZoom = view.getZoom();
      var center = view.getCenter();
      var zoom = payload.zoom;
      var point = view.dataToPoint(center);
      if (payload.dx != null && payload.dy != null) {
        point[0] -= payload.dx;
        point[1] -= payload.dy;
        var center = view.pointToData(point);
        view.setCenter(center);
      }
      if (zoom != null) {
        if (zoomLimit) {
          var zoomMin = zoomLimit.min || 0;
          var zoomMax = zoomLimit.max || Infinity;
          zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
        }
        view.scale[0] *= zoom;
        view.scale[1] *= zoom;
        var position = view.position;
        var fixX = (payload.originX - position[0]) * (zoom - 1);
        var fixY = (payload.originY - position[1]) * (zoom - 1);
        position[0] -= fixX;
        position[1] -= fixY;
        view.updateTransform();
        var center = view.pointToData(point);
        view.setCenter(center);
        view.setZoom(zoom * previousZoom);
      }
      return {
        center: view.getCenter(),
        zoom: view.getZoom()
      };
    }
    exports.updateCenterAndZoom = updateCenterAndZoom;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/geoRoam.js
var require_geoRoam = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/action/geoRoam.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _roamHelper = require_roamHelper2();
    var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
    echarts.registerAction({
      type: "geoRoam",
      event: "geoRoam",
      update: "updateTransform"
    }, function(payload, ecModel) {
      var componentType = payload.componentType || "series";
      ecModel.eachComponent({
        mainType: componentType,
        query: payload
      }, function(componentModel) {
        var geo = componentModel.coordinateSystem;
        if (geo.type !== "geo") {
          return;
        }
        var res = updateCenterAndZoom(geo, payload, componentModel.get("scaleLimit"));
        componentModel.setCenter && componentModel.setCenter(res.center);
        componentModel.setZoom && componentModel.setZoom(res.zoom);
        if (componentType === "series") {
          zrUtil.each(componentModel.seriesGroup, function(seriesModel) {
            seriesModel.setCenter(res.center);
            seriesModel.setZoom(res.zoom);
          });
        }
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/View.js
var require_View = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/View.js"(exports, module) {
    var zrUtil = require_util();
    var vector = require_vector();
    var matrix = require_matrix();
    var BoundingRect = require_BoundingRect();
    var Transformable = require_Transformable();
    var v2ApplyTransform = vector.applyTransform;
    function TransformDummy() {
      Transformable.call(this);
    }
    zrUtil.mixin(TransformDummy, Transformable);
    function View(name2) {
      this.name = name2;
      this.zoomLimit;
      Transformable.call(this);
      this._roamTransformable = new TransformDummy();
      this._rawTransformable = new TransformDummy();
      this._center;
      this._zoom;
    }
    View.prototype = {
      constructor: View,
      type: "view",
      /**
       * @param {Array.<string>}
       * @readOnly
       */
      dimensions: ["x", "y"],
      /**
       * Set bounding rect
       * @param {number} x
       * @param {number} y
       * @param {number} width
       * @param {number} height
       */
      // PENDING to getRect
      setBoundingRect: function(x, y, width, height) {
        this._rect = new BoundingRect(x, y, width, height);
        return this._rect;
      },
      /**
       * @return {module:zrender/core/BoundingRect}
       */
      // PENDING to getRect
      getBoundingRect: function() {
        return this._rect;
      },
      /**
       * @param {number} x
       * @param {number} y
       * @param {number} width
       * @param {number} height
       */
      setViewRect: function(x, y, width, height) {
        this.transformTo(x, y, width, height);
        this._viewRect = new BoundingRect(x, y, width, height);
      },
      /**
       * Transformed to particular position and size
       * @param {number} x
       * @param {number} y
       * @param {number} width
       * @param {number} height
       */
      transformTo: function(x, y, width, height) {
        var rect = this.getBoundingRect();
        var rawTransform = this._rawTransformable;
        rawTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
        rawTransform.decomposeTransform();
        this._updateTransform();
      },
      /**
       * Set center of view
       * @param {Array.<number>} [centerCoord]
       */
      setCenter: function(centerCoord) {
        if (!centerCoord) {
          return;
        }
        this._center = centerCoord;
        this._updateCenterAndZoom();
      },
      /**
       * @param {number} zoom
       */
      setZoom: function(zoom) {
        zoom = zoom || 1;
        var zoomLimit = this.zoomLimit;
        if (zoomLimit) {
          if (zoomLimit.max != null) {
            zoom = Math.min(zoomLimit.max, zoom);
          }
          if (zoomLimit.min != null) {
            zoom = Math.max(zoomLimit.min, zoom);
          }
        }
        this._zoom = zoom;
        this._updateCenterAndZoom();
      },
      /**
       * Get default center without roam
       */
      getDefaultCenter: function() {
        var rawRect = this.getBoundingRect();
        var cx = rawRect.x + rawRect.width / 2;
        var cy = rawRect.y + rawRect.height / 2;
        return [cx, cy];
      },
      getCenter: function() {
        return this._center || this.getDefaultCenter();
      },
      getZoom: function() {
        return this._zoom || 1;
      },
      /**
       * @return {Array.<number}
       */
      getRoamTransform: function() {
        return this._roamTransformable.getLocalTransform();
      },
      /**
       * Remove roam
       */
      _updateCenterAndZoom: function() {
        var rawTransformMatrix = this._rawTransformable.getLocalTransform();
        var roamTransform = this._roamTransformable;
        var defaultCenter = this.getDefaultCenter();
        var center = this.getCenter();
        var zoom = this.getZoom();
        center = vector.applyTransform([], center, rawTransformMatrix);
        defaultCenter = vector.applyTransform([], defaultCenter, rawTransformMatrix);
        roamTransform.origin = center;
        roamTransform.position = [defaultCenter[0] - center[0], defaultCenter[1] - center[1]];
        roamTransform.scale = [zoom, zoom];
        this._updateTransform();
      },
      /**
       * Update transform from roam and mapLocation
       * @private
       */
      _updateTransform: function() {
        var roamTransformable = this._roamTransformable;
        var rawTransformable = this._rawTransformable;
        rawTransformable.parent = roamTransformable;
        roamTransformable.updateTransform();
        rawTransformable.updateTransform();
        matrix.copy(this.transform || (this.transform = []), rawTransformable.transform || matrix.create());
        this._rawTransform = rawTransformable.getLocalTransform();
        this.invTransform = this.invTransform || [];
        matrix.invert(this.invTransform, this.transform);
        this.decomposeTransform();
      },
      getTransformInfo: function() {
        var roamTransform = this._roamTransformable.transform;
        var rawTransformable = this._rawTransformable;
        return {
          roamTransform: roamTransform ? zrUtil.slice(roamTransform) : matrix.create(),
          rawScale: zrUtil.slice(rawTransformable.scale),
          rawPosition: zrUtil.slice(rawTransformable.position)
        };
      },
      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getViewRect: function() {
        return this._viewRect;
      },
      /**
       * Get view rect after roam transform
       * @return {module:zrender/core/BoundingRect}
       */
      getViewRectAfterRoam: function() {
        var rect = this.getBoundingRect().clone();
        rect.applyTransform(this.transform);
        return rect;
      },
      /**
       * Convert a single (lon, lat) data item to (x, y) point.
       * @param {Array.<number>} data
       * @param {boolean} noRoam
       * @param {Array.<number>} [out]
       * @return {Array.<number>}
       */
      dataToPoint: function(data, noRoam, out) {
        var transform = noRoam ? this._rawTransform : this.transform;
        out = out || [];
        return transform ? v2ApplyTransform(out, data, transform) : vector.copy(out, data);
      },
      /**
       * Convert a (x, y) point to (lon, lat) data
       * @param {Array.<number>} point
       * @return {Array.<number>}
       */
      pointToData: function(point) {
        var invTransform = this.invTransform;
        return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
      },
      /**
       * @implements
       * see {module:echarts/CoodinateSystem}
       */
      convertToPixel: zrUtil.curry(doConvert, "dataToPoint"),
      /**
       * @implements
       * see {module:echarts/CoodinateSystem}
       */
      convertFromPixel: zrUtil.curry(doConvert, "pointToData"),
      /**
       * @implements
       * see {module:echarts/CoodinateSystem}
       */
      containPoint: function(point) {
        return this.getViewRectAfterRoam().contain(point[0], point[1]);
      }
      /**
       * @return {number}
       */
      // getScalarScale: function () {
      //     // Use determinant square root of transform to mutiply scalar
      //     var m = this.transform;
      //     var det = Math.sqrt(Math.abs(m[0] * m[3] - m[2] * m[1]));
      //     return det;
      // }
    };
    zrUtil.mixin(View, Transformable);
    function doConvert(methodName, ecModel, finder, value) {
      var seriesModel = finder.seriesModel;
      var coordSys = seriesModel ? seriesModel.coordinateSystem : null;
      return coordSys === this ? coordSys[methodName](value) : null;
    }
    var _default = View;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/Geo.js
var require_Geo = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/Geo.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var View = require_View();
    var geoSourceManager = require_geoSourceManager();
    function Geo(name2, map, nameMap, invertLongitute) {
      View.call(this, name2);
      this.map = map;
      var source = geoSourceManager.load(map, nameMap);
      this._nameCoordMap = source.nameCoordMap;
      this._regionsMap = source.regionsMap;
      this._invertLongitute = invertLongitute == null ? true : invertLongitute;
      this.regions = source.regions;
      this._rect = source.boundingRect;
    }
    Geo.prototype = {
      constructor: Geo,
      type: "geo",
      /**
       * @param {Array.<string>}
       * @readOnly
       */
      dimensions: ["lng", "lat"],
      /**
       * If contain given lng,lat coord
       * @param {Array.<number>}
       * @readOnly
       */
      containCoord: function(coord) {
        var regions = this.regions;
        for (var i = 0; i < regions.length; i++) {
          if (regions[i].contain(coord)) {
            return true;
          }
        }
        return false;
      },
      /**
       * @override
       */
      transformTo: function(x, y, width, height) {
        var rect = this.getBoundingRect();
        var invertLongitute = this._invertLongitute;
        rect = rect.clone();
        if (invertLongitute) {
          rect.y = -rect.y - rect.height;
        }
        var rawTransformable = this._rawTransformable;
        rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
        rawTransformable.decomposeTransform();
        if (invertLongitute) {
          var scale = rawTransformable.scale;
          scale[1] = -scale[1];
        }
        rawTransformable.updateTransform();
        this._updateTransform();
      },
      /**
       * @param {string} name
       * @return {module:echarts/coord/geo/Region}
       */
      getRegion: function(name2) {
        return this._regionsMap.get(name2);
      },
      getRegionByCoord: function(coord) {
        var regions = this.regions;
        for (var i = 0; i < regions.length; i++) {
          if (regions[i].contain(coord)) {
            return regions[i];
          }
        }
      },
      /**
       * Add geoCoord for indexing by name
       * @param {string} name
       * @param {Array.<number>} geoCoord
       */
      addGeoCoord: function(name2, geoCoord) {
        this._nameCoordMap.set(name2, geoCoord);
      },
      /**
       * Get geoCoord by name
       * @param {string} name
       * @return {Array.<number>}
       */
      getGeoCoord: function(name2) {
        return this._nameCoordMap.get(name2);
      },
      /**
       * @override
       */
      getBoundingRect: function() {
        return this._rect;
      },
      /**
       * @param {string|Array.<number>} data
       * @param {boolean} noRoam
       * @param {Array.<number>} [out]
       * @return {Array.<number>}
       */
      dataToPoint: function(data, noRoam, out) {
        if (typeof data === "string") {
          data = this.getGeoCoord(data);
        }
        if (data) {
          return View.prototype.dataToPoint.call(this, data, noRoam, out);
        }
      },
      /**
       * @override
       */
      convertToPixel: zrUtil.curry(doConvert, "dataToPoint"),
      /**
       * @override
       */
      convertFromPixel: zrUtil.curry(doConvert, "pointToData")
    };
    zrUtil.mixin(Geo, View);
    function doConvert(methodName, ecModel, finder, value) {
      var geoModel = finder.geoModel;
      var seriesModel = finder.seriesModel;
      var coordSys = geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo")[0] || {}).coordinateSystem : null;
      return coordSys === this ? coordSys[methodName](value) : null;
    }
    var _default = Geo;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoCreator.js
var require_geoCreator = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/geoCreator.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var Geo = require_Geo();
    var layout = require_layout();
    var numberUtil = require_number();
    var geoSourceManager = require_geoSourceManager();
    var mapDataStorage = require_mapDataStorage();
    function resizeGeo(geoModel, api) {
      var boundingCoords = geoModel.get("boundingCoords");
      if (boundingCoords != null) {
        var leftTop = boundingCoords[0];
        var rightBottom = boundingCoords[1];
        if (isNaN(leftTop[0]) || isNaN(leftTop[1]) || isNaN(rightBottom[0]) || isNaN(rightBottom[1])) {
        } else {
          this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);
        }
      }
      var rect = this.getBoundingRect();
      var boxLayoutOption;
      var center = geoModel.get("layoutCenter");
      var size = geoModel.get("layoutSize");
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      var aspect = rect.width / rect.height * this.aspectScale;
      var useCenterAndSize = false;
      if (center && size) {
        center = [numberUtil.parsePercent(center[0], viewWidth), numberUtil.parsePercent(center[1], viewHeight)];
        size = numberUtil.parsePercent(size, Math.min(viewWidth, viewHeight));
        if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
          useCenterAndSize = true;
        } else {
        }
      }
      var viewRect;
      if (useCenterAndSize) {
        var viewRect = {};
        if (aspect > 1) {
          viewRect.width = size;
          viewRect.height = size / aspect;
        } else {
          viewRect.height = size;
          viewRect.width = size * aspect;
        }
        viewRect.y = center[1] - viewRect.height / 2;
        viewRect.x = center[0] - viewRect.width / 2;
      } else {
        boxLayoutOption = geoModel.getBoxLayoutParams();
        boxLayoutOption.aspect = aspect;
        viewRect = layout.getLayoutRect(boxLayoutOption, {
          width: viewWidth,
          height: viewHeight
        });
      }
      this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
      this.setCenter(geoModel.get("center"));
      this.setZoom(geoModel.get("zoom"));
    }
    function setGeoCoords(geo, model) {
      zrUtil.each(model.get("geoCoord"), function(geoCoord, name2) {
        geo.addGeoCoord(name2, geoCoord);
      });
    }
    var geoCreator = {
      // For deciding which dimensions to use when creating list data
      dimensions: Geo.prototype.dimensions,
      create: function(ecModel, api) {
        var geoList = [];
        ecModel.eachComponent("geo", function(geoModel, idx) {
          var name2 = geoModel.get("map");
          var aspectScale = geoModel.get("aspectScale");
          var invertLongitute = true;
          var mapRecords = mapDataStorage.retrieveMap(name2);
          if (mapRecords && mapRecords[0] && mapRecords[0].type === "svg") {
            aspectScale == null && (aspectScale = 1);
            invertLongitute = false;
          } else {
            aspectScale == null && (aspectScale = 0.75);
          }
          var geo = new Geo(name2 + idx, name2, geoModel.get("nameMap"), invertLongitute);
          geo.aspectScale = aspectScale;
          geo.zoomLimit = geoModel.get("scaleLimit");
          geoList.push(geo);
          setGeoCoords(geo, geoModel);
          geoModel.coordinateSystem = geo;
          geo.model = geoModel;
          geo.resize = resizeGeo;
          geo.resize(geoModel, api);
        });
        ecModel.eachSeries(function(seriesModel) {
          var coordSys = seriesModel.get("coordinateSystem");
          if (coordSys === "geo") {
            var geoIndex = seriesModel.get("geoIndex") || 0;
            seriesModel.coordinateSystem = geoList[geoIndex];
          }
        });
        var mapModelGroupBySeries = {};
        ecModel.eachSeriesByType("map", function(seriesModel) {
          if (!seriesModel.getHostGeoModel()) {
            var mapType = seriesModel.getMapType();
            mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
            mapModelGroupBySeries[mapType].push(seriesModel);
          }
        });
        zrUtil.each(mapModelGroupBySeries, function(mapSeries, mapType) {
          var nameMapList = zrUtil.map(mapSeries, function(singleMapSeries) {
            return singleMapSeries.get("nameMap");
          });
          var geo = new Geo(mapType, mapType, zrUtil.mergeAll(nameMapList));
          geo.zoomLimit = zrUtil.retrieve.apply(null, zrUtil.map(mapSeries, function(singleMapSeries) {
            return singleMapSeries.get("scaleLimit");
          }));
          geoList.push(geo);
          geo.resize = resizeGeo;
          geo.aspectScale = mapSeries[0].get("aspectScale");
          geo.resize(mapSeries[0], api);
          zrUtil.each(mapSeries, function(singleMapSeries) {
            singleMapSeries.coordinateSystem = geo;
            setGeoCoords(geo, singleMapSeries);
          });
        });
        return geoList;
      },
      /**
       * Fill given regions array
       * @param  {Array.<Object>} originRegionArr
       * @param  {string} mapName
       * @param  {Object} [nameMap]
       * @return {Array}
       */
      getFilledRegions: function(originRegionArr, mapName, nameMap) {
        var regionsArr = (originRegionArr || []).slice();
        var dataNameMap = zrUtil.createHashMap();
        for (var i = 0; i < regionsArr.length; i++) {
          dataNameMap.set(regionsArr[i].name, regionsArr[i]);
        }
        var source = geoSourceManager.load(mapName, nameMap);
        zrUtil.each(source.regions, function(region) {
          var name2 = region.name;
          !dataNameMap.get(name2) && regionsArr.push({
            name: name2
          });
        });
        return regionsArr;
      }
    };
    echarts.registerCoordinateSystem("geo", geoCreator);
    var _default = geoCreator;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapSymbolLayout.js
var require_mapSymbolLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapSymbolLayout.js"(exports, module) {
    var zrUtil = require_util();
    function _default(ecModel) {
      var processedMapType = {};
      ecModel.eachSeriesByType("map", function(mapSeries) {
        var mapType = mapSeries.getMapType();
        if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
          return;
        }
        var mapSymbolOffsets = {};
        zrUtil.each(mapSeries.seriesGroup, function(subMapSeries) {
          var geo = subMapSeries.coordinateSystem;
          var data2 = subMapSeries.originalData;
          if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
            data2.each(data2.mapDimension("value"), function(value, idx) {
              var name2 = data2.getName(idx);
              var region = geo.getRegion(name2);
              if (!region || isNaN(value)) {
                return;
              }
              var offset = mapSymbolOffsets[name2] || 0;
              var point = geo.dataToPoint(region.center);
              mapSymbolOffsets[name2] = offset + 1;
              data2.setItemLayout(idx, {
                point,
                offset
              });
            });
          }
        });
        var data = mapSeries.getData();
        data.each(function(idx) {
          var name2 = data.getName(idx);
          var layout = data.getItemLayout(idx) || {};
          layout.showLabel = !mapSymbolOffsets[name2];
          data.setItemLayout(idx, layout);
        });
        processedMapType[mapType] = true;
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapVisual.js
var require_mapVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapVisual.js"(exports, module) {
    function _default(ecModel) {
      ecModel.eachSeriesByType("map", function(seriesModel) {
        var colorList = seriesModel.get("color");
        var itemStyleModel = seriesModel.getModel("itemStyle");
        var areaColor = itemStyleModel.get("areaColor");
        var color = itemStyleModel.get("color") || colorList[seriesModel.seriesIndex % colorList.length];
        seriesModel.getData().setVisual({
          "areaColor": areaColor,
          "color": color
        });
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapDataStatistic.js
var require_mapDataStatistic = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/mapDataStatistic.js"(exports, module) {
    var zrUtil = require_util();
    function dataStatistics(datas, statisticType) {
      var dataNameMap = {};
      zrUtil.each(datas, function(data) {
        data.each(data.mapDimension("value"), function(value, idx) {
          var mapKey = "ec-" + data.getName(idx);
          dataNameMap[mapKey] = dataNameMap[mapKey] || [];
          if (!isNaN(value)) {
            dataNameMap[mapKey].push(value);
          }
        });
      });
      return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
        var mapKey = "ec-" + datas[0].getName(idx);
        var sum = 0;
        var min = Infinity;
        var max = -Infinity;
        var len = dataNameMap[mapKey].length;
        for (var i = 0; i < len; i++) {
          min = Math.min(min, dataNameMap[mapKey][i]);
          max = Math.max(max, dataNameMap[mapKey][i]);
          sum += dataNameMap[mapKey][i];
        }
        var result;
        if (statisticType === "min") {
          result = min;
        } else if (statisticType === "max") {
          result = max;
        } else if (statisticType === "average") {
          result = sum / len;
        } else {
          result = sum;
        }
        return len === 0 ? NaN : result;
      });
    }
    function _default(ecModel) {
      var seriesGroups = {};
      ecModel.eachSeriesByType("map", function(seriesModel) {
        var hostGeoModel = seriesModel.getHostGeoModel();
        var key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
        (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
      });
      zrUtil.each(seriesGroups, function(seriesList, key) {
        var data = dataStatistics(zrUtil.map(seriesList, function(seriesModel) {
          return seriesModel.getData();
        }), seriesList[0].get("mapValueCalculation"));
        for (var i = 0; i < seriesList.length; i++) {
          seriesList[i].originalData = seriesList[i].getData();
        }
        for (var i = 0; i < seriesList.length; i++) {
          seriesList[i].seriesGroup = seriesList;
          seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
          seriesList[i].setData(data.cloneShallow());
          seriesList[i].mainSeries = seriesList[0];
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/backwardCompat.js
var require_backwardCompat3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map/backwardCompat.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      var mapSeries = [];
      zrUtil.each(option.series, function(seriesOpt) {
        if (seriesOpt && seriesOpt.type === "map") {
          mapSeries.push(seriesOpt);
          seriesOpt.map = seriesOpt.map || seriesOpt.mapType;
          zrUtil.defaults(seriesOpt, seriesOpt.mapLocation);
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map.js
var require_map = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/map.js"() {
    var echarts = require_echarts();
    require_MapSeries();
    require_MapView();
    require_geoRoam();
    require_geoCreator();
    var mapSymbolLayout = require_mapSymbolLayout();
    var mapVisual = require_mapVisual();
    var mapDataStatistic = require_mapDataStatistic();
    var backwardCompat = require_backwardCompat3();
    var createDataSelectAction = require_createDataSelectAction();
    echarts.registerLayout(mapSymbolLayout);
    echarts.registerVisual(mapVisual);
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
    echarts.registerPreprocessor(backwardCompat);
    createDataSelectAction("map", [{
      type: "mapToggleSelect",
      event: "mapselectchanged",
      method: "toggleSelected"
    }, {
      type: "mapSelect",
      event: "mapselected",
      method: "select"
    }, {
      type: "mapUnSelect",
      event: "mapunselected",
      method: "unSelect"
    }]);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/linkList.js
var require_linkList = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/helper/linkList.js"(exports, module) {
    var zrUtil = require_util();
    var each = zrUtil.each;
    var DATAS = "\0__link_datas";
    var MAIN_DATA = "\0__link_mainData";
    function linkList(opt) {
      var mainData = opt.mainData;
      var datas = opt.datas;
      if (!datas) {
        datas = {
          main: mainData
        };
        opt.datasAttr = {
          main: "data"
        };
      }
      opt.datas = opt.mainData = null;
      linkAll(mainData, datas, opt);
      each(datas, function(data) {
        each(mainData.TRANSFERABLE_METHODS, function(methodName) {
          data.wrapMethod(methodName, zrUtil.curry(transferInjection, opt));
        });
      });
      mainData.wrapMethod("cloneShallow", zrUtil.curry(cloneShallowInjection, opt));
      each(mainData.CHANGABLE_METHODS, function(methodName) {
        mainData.wrapMethod(methodName, zrUtil.curry(changeInjection, opt));
      });
      zrUtil.assert(datas[mainData.dataType] === mainData);
    }
    function transferInjection(opt, res) {
      if (isMainData(this)) {
        var datas = zrUtil.extend({}, this[DATAS]);
        datas[this.dataType] = res;
        linkAll(res, datas, opt);
      } else {
        linkSingle(res, this.dataType, this[MAIN_DATA], opt);
      }
      return res;
    }
    function changeInjection(opt, res) {
      opt.struct && opt.struct.update(this);
      return res;
    }
    function cloneShallowInjection(opt, res) {
      each(res[DATAS], function(data, dataType) {
        data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
      });
      return res;
    }
    function getLinkedData(dataType) {
      var mainData = this[MAIN_DATA];
      return dataType == null || mainData == null ? mainData : mainData[DATAS][dataType];
    }
    function isMainData(data) {
      return data[MAIN_DATA] === data;
    }
    function linkAll(mainData, datas, opt) {
      mainData[DATAS] = {};
      each(datas, function(data, dataType) {
        linkSingle(data, dataType, mainData, opt);
      });
    }
    function linkSingle(data, dataType, mainData, opt) {
      mainData[DATAS][dataType] = data;
      data[MAIN_DATA] = mainData;
      data.dataType = dataType;
      if (opt.struct) {
        data[opt.structAttr] = opt.struct;
        opt.struct[opt.datasAttr[dataType]] = data;
      }
      data.getLinkedData = getLinkedData;
    }
    var _default = linkList;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Tree.js
var require_Tree = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Tree.js"(exports, module) {
    var zrUtil = require_util();
    var linkList = require_linkList();
    var List = require_List();
    var createDimensions = require_createDimensions();
    var TreeNode = function(name2, hostTree) {
      this.name = name2 || "";
      this.depth = 0;
      this.height = 0;
      this.parentNode = null;
      this.dataIndex = -1;
      this.children = [];
      this.viewChildren = [];
      this.hostTree = hostTree;
    };
    TreeNode.prototype = {
      constructor: TreeNode,
      /**
       * The node is removed.
       * @return {boolean} is removed.
       */
      isRemoved: function() {
        return this.dataIndex < 0;
      },
      /**
       * Travel this subtree (include this node).
       * Usage:
       *    node.eachNode(function () { ... }); // preorder
       *    node.eachNode('preorder', function () { ... }); // preorder
       *    node.eachNode('postorder', function () { ... }); // postorder
       *    node.eachNode(
       *        {order: 'postorder', attr: 'viewChildren'},
       *        function () { ... }
       *    ); // postorder
       *
       * @param {(Object|string)} options If string, means order.
       * @param {string=} options.order 'preorder' or 'postorder'
       * @param {string=} options.attr 'children' or 'viewChildren'
       * @param {Function} cb If in preorder and return false,
       *                      its subtree will not be visited.
       * @param {Object} [context]
       */
      eachNode: function(options, cb, context) {
        if (typeof options === "function") {
          context = cb;
          cb = options;
          options = null;
        }
        options = options || {};
        if (zrUtil.isString(options)) {
          options = {
            order: options
          };
        }
        var order = options.order || "preorder";
        var children = this[options.attr || "children"];
        var suppressVisitSub;
        order === "preorder" && (suppressVisitSub = cb.call(context, this));
        for (var i = 0; !suppressVisitSub && i < children.length; i++) {
          children[i].eachNode(options, cb, context);
        }
        order === "postorder" && cb.call(context, this);
      },
      /**
       * Update depth and height of this subtree.
       *
       * @param  {number} depth
       */
      updateDepthAndHeight: function(depth) {
        var height = 0;
        this.depth = depth;
        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          child.updateDepthAndHeight(depth + 1);
          if (child.height > height) {
            height = child.height;
          }
        }
        this.height = height + 1;
      },
      /**
       * @param  {string} id
       * @return {module:echarts/data/Tree~TreeNode}
       */
      getNodeById: function(id) {
        if (this.getId() === id) {
          return this;
        }
        for (var i = 0, children = this.children, len = children.length; i < len; i++) {
          var res = children[i].getNodeById(id);
          if (res) {
            return res;
          }
        }
      },
      /**
       * @param {module:echarts/data/Tree~TreeNode} node
       * @return {boolean}
       */
      contains: function(node) {
        if (node === this) {
          return true;
        }
        for (var i = 0, children = this.children, len = children.length; i < len; i++) {
          var res = children[i].contains(node);
          if (res) {
            return res;
          }
        }
      },
      /**
       * @param {boolean} includeSelf Default false.
       * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]
       */
      getAncestors: function(includeSelf) {
        var ancestors = [];
        var node = includeSelf ? this : this.parentNode;
        while (node) {
          ancestors.push(node);
          node = node.parentNode;
        }
        ancestors.reverse();
        return ancestors;
      },
      /**
       * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3
       * @return {number} Value.
       */
      getValue: function(dimension) {
        var data = this.hostTree.data;
        return data.get(data.getDimension(dimension || "value"), this.dataIndex);
      },
      /**
       * @param {Object} layout
       * @param {boolean=} [merge=false]
       */
      setLayout: function(layout, merge) {
        this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
      },
      /**
       * @return {Object} layout
       */
      getLayout: function() {
        return this.hostTree.data.getItemLayout(this.dataIndex);
      },
      /**
       * @param {string} [path]
       * @return {module:echarts/model/Model}
       */
      getModel: function(path) {
        if (this.dataIndex < 0) {
          return;
        }
        var hostTree = this.hostTree;
        var itemModel = hostTree.data.getItemModel(this.dataIndex);
        return itemModel.getModel(path);
      },
      /**
       * @example
       *  setItemVisual('color', color);
       *  setItemVisual({
       *      'color': color
       *  });
       */
      setVisual: function(key, value) {
        this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
      },
      /**
       * Get item visual
       */
      getVisual: function(key, ignoreParent) {
        return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
      },
      /**
       * @public
       * @return {number}
       */
      getRawIndex: function() {
        return this.hostTree.data.getRawIndex(this.dataIndex);
      },
      /**
       * @public
       * @return {string}
       */
      getId: function() {
        return this.hostTree.data.getId(this.dataIndex);
      },
      /**
       * if this is an ancestor of another node
       *
       * @public
       * @param {TreeNode} node another node
       * @return {boolean} if is ancestor
       */
      isAncestorOf: function(node) {
        var parent = node.parentNode;
        while (parent) {
          if (parent === this) {
            return true;
          }
          parent = parent.parentNode;
        }
        return false;
      },
      /**
       * if this is an descendant of another node
       *
       * @public
       * @param {TreeNode} node another node
       * @return {boolean} if is descendant
       */
      isDescendantOf: function(node) {
        return node !== this && node.isAncestorOf(this);
      }
    };
    function Tree(hostModel) {
      this.root;
      this.data;
      this._nodes = [];
      this.hostModel = hostModel;
    }
    Tree.prototype = {
      constructor: Tree,
      type: "tree",
      /**
       * Travel this subtree (include this node).
       * Usage:
       *    node.eachNode(function () { ... }); // preorder
       *    node.eachNode('preorder', function () { ... }); // preorder
       *    node.eachNode('postorder', function () { ... }); // postorder
       *    node.eachNode(
       *        {order: 'postorder', attr: 'viewChildren'},
       *        function () { ... }
       *    ); // postorder
       *
       * @param {(Object|string)} options If string, means order.
       * @param {string=} options.order 'preorder' or 'postorder'
       * @param {string=} options.attr 'children' or 'viewChildren'
       * @param {Function} cb
       * @param {Object}   [context]
       */
      eachNode: function(options, cb, context) {
        this.root.eachNode(options, cb, context);
      },
      /**
       * @param {number} dataIndex
       * @return {module:echarts/data/Tree~TreeNode}
       */
      getNodeByDataIndex: function(dataIndex) {
        var rawIndex = this.data.getRawIndex(dataIndex);
        return this._nodes[rawIndex];
      },
      /**
       * @param {string} name
       * @return {module:echarts/data/Tree~TreeNode}
       */
      getNodeByName: function(name2) {
        return this.root.getNodeByName(name2);
      },
      /**
       * Update item available by list,
       * when list has been performed options like 'filterSelf' or 'map'.
       */
      update: function() {
        var data = this.data;
        var nodes = this._nodes;
        for (var i = 0, len = nodes.length; i < len; i++) {
          nodes[i].dataIndex = -1;
        }
        for (var i = 0, len = data.count(); i < len; i++) {
          nodes[data.getRawIndex(i)].dataIndex = i;
        }
      },
      /**
       * Clear all layouts
       */
      clearLayouts: function() {
        this.data.clearItemLayouts();
      }
    };
    Tree.createTree = function(dataRoot, hostModel, beforeLink) {
      var tree = new Tree(hostModel);
      var listData = [];
      var dimMax = 1;
      buildHierarchy(dataRoot);
      function buildHierarchy(dataNode, parentNode) {
        var value = dataNode.value;
        dimMax = Math.max(dimMax, zrUtil.isArray(value) ? value.length : 1);
        listData.push(dataNode);
        var node = new TreeNode(dataNode.name, tree);
        parentNode ? addChild(node, parentNode) : tree.root = node;
        tree._nodes.push(node);
        var children = dataNode.children;
        if (children) {
          for (var i = 0; i < children.length; i++) {
            buildHierarchy(children[i], node);
          }
        }
      }
      tree.root.updateDepthAndHeight(0);
      var dimensionsInfo = createDimensions(listData, {
        coordDimensions: ["value"],
        dimensionsCount: dimMax
      });
      var list = new List(dimensionsInfo, hostModel);
      list.initData(listData);
      beforeLink && beforeLink(list);
      linkList({
        mainData: list,
        struct: tree,
        structAttr: "tree"
      });
      tree.update();
      return tree;
    };
    function addChild(child, node) {
      var children = node.children;
      if (child.parentNode === node) {
        return;
      }
      children.push(child);
      child.parentNode = node;
    }
    var _default = Tree;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeSeries.js
var require_TreeSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var Tree = require_Tree();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var Model = require_Model();
    var _default = SeriesModel.extend({
      type: "series.tree",
      layoutInfo: null,
      // can support the position parameters 'left', 'top','right','bottom', 'width',
      // 'height' in the setOption() with 'merge' mode normal.
      layoutMode: "box",
      /**
       * Init a tree data structure from data in option series
       * @param  {Object} option  the object used to config echarts view
       * @return {module:echarts/data/List} storage initial data
       */
      getInitialData: function(option) {
        var root = {
          name: option.name,
          children: option.data
        };
        var leaves = option.leaves || {};
        var leavesModel = new Model(leaves, this, this.ecModel);
        var tree = Tree.createTree(root, this, beforeLink);
        function beforeLink(nodeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            var node = tree.getNodeByDataIndex(idx);
            if (!node.children.length || !node.isExpand) {
              model.parentModel = leavesModel;
            }
            return model;
          });
        }
        var treeDepth = 0;
        tree.eachNode("preorder", function(node) {
          if (node.depth > treeDepth) {
            treeDepth = node.depth;
          }
        });
        var expandAndCollapse = option.expandAndCollapse;
        var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
        tree.root.eachNode("preorder", function(node) {
          var item = node.hostTree.data.getRawDataItem(node.dataIndex);
          node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
        });
        return tree.data;
      },
      /**
       * Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.
       * @returns {string} orient
       */
      getOrient: function() {
        var orient = this.get("orient");
        if (orient === "horizontal") {
          orient = "LR";
        } else if (orient === "vertical") {
          orient = "TB";
        }
        return orient;
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      },
      /**
       * @override
       * @param {number} dataIndex
       */
      formatTooltip: function(dataIndex) {
        var tree = this.getData().tree;
        var realRoot = tree.root.children[0];
        var node = tree.getNodeByDataIndex(dataIndex);
        var value = node.getValue();
        var name2 = node.name;
        while (node && node !== realRoot) {
          name2 = node.parentNode.name + "." + name2;
          node = node.parentNode;
        }
        return encodeHTML(name2 + (isNaN(value) || value == null ? "" : " : " + value));
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "view",
        // the position of the whole view
        left: "12%",
        top: "12%",
        right: "12%",
        bottom: "12%",
        // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
        layout: "orthogonal",
        // value can be 'polyline'
        edgeShape: "curve",
        edgeForkPosition: "50%",
        // true | false | 'move' | 'scale', see module:component/helper/RoamController.
        roam: false,
        // Symbol size scale ratio in roam
        nodeScaleRatio: 0.4,
        // Default on center of graph
        center: null,
        zoom: 1,
        // The orient of orthoginal layout, can be setted to 'LR', 'TB', 'RL', 'BT'.
        // and the backward compatibility configuration 'horizontal = LR', 'vertical = TB'.
        orient: "LR",
        symbol: "emptyCircle",
        symbolSize: 7,
        expandAndCollapse: true,
        initialTreeDepth: 2,
        lineStyle: {
          color: "#ccc",
          width: 1.5,
          curveness: 0.5
        },
        itemStyle: {
          color: "lightsteelblue",
          borderColor: "#c23531",
          borderWidth: 1.5
        },
        label: {
          show: true,
          color: "#555"
        },
        leaves: {
          label: {
            show: true
          }
        },
        animationEasing: "linear",
        animationDuration: 700,
        animationDurationUpdate: 1e3
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/layoutHelper.js
var require_layoutHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/layoutHelper.js"(exports) {
    var layout = require_layout();
    function init(root) {
      root.hierNode = {
        defaultAncestor: null,
        ancestor: root,
        prelim: 0,
        modifier: 0,
        change: 0,
        shift: 0,
        i: 0,
        thread: null
      };
      var nodes = [root];
      var node;
      var children;
      while (node = nodes.pop()) {
        children = node.children;
        if (node.isExpand && children.length) {
          var n = children.length;
          for (var i = n - 1; i >= 0; i--) {
            var child = children[i];
            child.hierNode = {
              defaultAncestor: null,
              ancestor: child,
              prelim: 0,
              modifier: 0,
              change: 0,
              shift: 0,
              i,
              thread: null
            };
            nodes.push(child);
          }
        }
      }
    }
    function firstWalk(node, separation2) {
      var children = node.isExpand ? node.children : [];
      var siblings = node.parentNode.children;
      var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
      if (children.length) {
        executeShifts(node);
        var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
        if (subtreeW) {
          node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
          node.hierNode.modifier = node.hierNode.prelim - midPoint;
        } else {
          node.hierNode.prelim = midPoint;
        }
      } else if (subtreeW) {
        node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
      }
      node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
    }
    function secondWalk(node) {
      var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
      node.setLayout({
        x: nodeX
      }, true);
      node.hierNode.modifier += node.parentNode.hierNode.modifier;
    }
    function separation(cb) {
      return arguments.length ? cb : defaultSeparation;
    }
    function radialCoordinate(x, y) {
      var radialCoor = {};
      x -= Math.PI / 2;
      radialCoor.x = y * Math.cos(x);
      radialCoor.y = y * Math.sin(x);
      return radialCoor;
    }
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function executeShifts(node) {
      var children = node.children;
      var n = children.length;
      var shift = 0;
      var change = 0;
      while (--n >= 0) {
        var child = children[n];
        child.hierNode.prelim += shift;
        child.hierNode.modifier += shift;
        change += child.hierNode.change;
        shift += child.hierNode.shift + change;
      }
    }
    function apportion(subtreeV, subtreeW, ancestor, separation2) {
      if (subtreeW) {
        var nodeOutRight = subtreeV;
        var nodeInRight = subtreeV;
        var nodeOutLeft = nodeInRight.parentNode.children[0];
        var nodeInLeft = subtreeW;
        var sumOutRight = nodeOutRight.hierNode.modifier;
        var sumInRight = nodeInRight.hierNode.modifier;
        var sumOutLeft = nodeOutLeft.hierNode.modifier;
        var sumInLeft = nodeInLeft.hierNode.modifier;
        while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
          nodeOutRight = nextRight(nodeOutRight);
          nodeOutLeft = nextLeft(nodeOutLeft);
          nodeOutRight.hierNode.ancestor = subtreeV;
          var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
          if (shift > 0) {
            moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
            sumInRight += shift;
            sumOutRight += shift;
          }
          sumInLeft += nodeInLeft.hierNode.modifier;
          sumInRight += nodeInRight.hierNode.modifier;
          sumOutRight += nodeOutRight.hierNode.modifier;
          sumOutLeft += nodeOutLeft.hierNode.modifier;
        }
        if (nodeInLeft && !nextRight(nodeOutRight)) {
          nodeOutRight.hierNode.thread = nodeInLeft;
          nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
        }
        if (nodeInRight && !nextLeft(nodeOutLeft)) {
          nodeOutLeft.hierNode.thread = nodeInRight;
          nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
          ancestor = subtreeV;
        }
      }
      return ancestor;
    }
    function nextRight(node) {
      var children = node.children;
      return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
    }
    function nextLeft(node) {
      var children = node.children;
      return children.length && node.isExpand ? children[0] : node.hierNode.thread;
    }
    function nextAncestor(nodeInLeft, node, ancestor) {
      return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
    }
    function moveSubtree(wl, wr, shift) {
      var change = shift / (wr.hierNode.i - wl.hierNode.i);
      wr.hierNode.change -= change;
      wr.hierNode.shift += shift;
      wr.hierNode.modifier += shift;
      wr.hierNode.prelim += shift;
      wl.hierNode.change += change;
    }
    function defaultSeparation(node1, node2) {
      return node1.parentNode === node2.parentNode ? 1 : 2;
    }
    exports.init = init;
    exports.firstWalk = firstWalk;
    exports.secondWalk = secondWalk;
    exports.separation = separation;
    exports.radialCoordinate = radialCoordinate;
    exports.getViewRect = getViewRect;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeView.js
var require_TreeView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/TreeView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var SymbolClz = require_Symbol();
    var _layoutHelper = require_layoutHelper();
    var radialCoordinate = _layoutHelper.radialCoordinate;
    var echarts = require_echarts();
    var bbox = require_bbox();
    var View = require_View();
    var roamHelper = require_roamHelper();
    var RoamController = require_RoamController();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var TreeShape = graphic.extendShape({
      shape: {
        parentPoint: [],
        childPoints: [],
        orient: "",
        forkPosition: ""
      },
      style: {
        stroke: "#000",
        fill: null
      },
      buildPath: function(ctx, shape) {
        var childPoints = shape.childPoints;
        var childLen = childPoints.length;
        var parentPoint = shape.parentPoint;
        var firstChildPos = childPoints[0];
        var lastChildPos = childPoints[childLen - 1];
        if (childLen === 1) {
          ctx.moveTo(parentPoint[0], parentPoint[1]);
          ctx.lineTo(firstChildPos[0], firstChildPos[1]);
          return;
        }
        var orient = shape.orient;
        var forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
        var otherDim = 1 - forkDim;
        var forkPosition = parsePercent(shape.forkPosition, 1);
        var tmpPoint = [];
        tmpPoint[forkDim] = parentPoint[forkDim];
        tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
        ctx.moveTo(parentPoint[0], parentPoint[1]);
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        ctx.moveTo(firstChildPos[0], firstChildPos[1]);
        tmpPoint[forkDim] = firstChildPos[forkDim];
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        tmpPoint[forkDim] = lastChildPos[forkDim];
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        ctx.lineTo(lastChildPos[0], lastChildPos[1]);
        for (var i = 1; i < childLen - 1; i++) {
          var point = childPoints[i];
          ctx.moveTo(point[0], point[1]);
          tmpPoint[forkDim] = point[forkDim];
          ctx.lineTo(tmpPoint[0], tmpPoint[1]);
        }
      }
    });
    var _default = echarts.extendChartView({
      type: "tree",
      /**
       * Init the chart
       * @override
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      init: function(ecModel, api) {
        this._oldTree;
        this._mainGroup = new graphic.Group();
        this._controller = new RoamController(api.getZr());
        this._controllerHost = {
          target: this.group
        };
        this.group.add(this._mainGroup);
      },
      render: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var layoutInfo = seriesModel.layoutInfo;
        var group = this._mainGroup;
        var layout = seriesModel.get("layout");
        if (layout === "radial") {
          group.attr("position", [layoutInfo.x + layoutInfo.width / 2, layoutInfo.y + layoutInfo.height / 2]);
        } else {
          group.attr("position", [layoutInfo.x, layoutInfo.y]);
        }
        this._updateViewCoordSys(seriesModel, layoutInfo, layout);
        this._updateController(seriesModel, ecModel, api);
        var oldData = this._data;
        var seriesScope = {
          expandAndCollapse: seriesModel.get("expandAndCollapse"),
          layout,
          edgeShape: seriesModel.get("edgeShape"),
          edgeForkPosition: seriesModel.get("edgeForkPosition"),
          orient: seriesModel.getOrient(),
          curvature: seriesModel.get("lineStyle.curveness"),
          symbolRotate: seriesModel.get("symbolRotate"),
          symbolOffset: seriesModel.get("symbolOffset"),
          hoverAnimation: seriesModel.get("hoverAnimation"),
          useNameLabel: true,
          fadeIn: true
        };
        data.diff(oldData).add(function(newIdx) {
          if (symbolNeedsDraw(data, newIdx)) {
            updateNode(data, newIdx, null, group, seriesModel, seriesScope);
          }
        }).update(function(newIdx, oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          if (!symbolNeedsDraw(data, newIdx)) {
            symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
            return;
          }
          updateNode(data, newIdx, symbolEl, group, seriesModel, seriesScope);
        }).remove(function(oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          if (symbolEl) {
            removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
          }
        }).execute();
        this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
        this._updateNodeAndLinkScale(seriesModel);
        if (seriesScope.expandAndCollapse === true) {
          data.eachItemGraphicEl(function(el, dataIndex) {
            el.off("click").on("click", function() {
              api.dispatchAction({
                type: "treeExpandAndCollapse",
                seriesId: seriesModel.id,
                dataIndex
              });
            });
          });
        }
        this._data = data;
      },
      _updateViewCoordSys: function(seriesModel) {
        var data = seriesModel.getData();
        var points = [];
        data.each(function(idx) {
          var layout = data.getItemLayout(idx);
          if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {
            points.push([+layout.x, +layout.y]);
          }
        });
        var min = [];
        var max = [];
        bbox.fromPoints(points, min, max);
        var oldMin = this._min;
        var oldMax = this._max;
        if (max[0] - min[0] === 0) {
          min[0] = oldMin ? oldMin[0] : min[0] - 1;
          max[0] = oldMax ? oldMax[0] : max[0] + 1;
        }
        if (max[1] - min[1] === 0) {
          min[1] = oldMin ? oldMin[1] : min[1] - 1;
          max[1] = oldMax ? oldMax[1] : max[1] + 1;
        }
        var viewCoordSys = seriesModel.coordinateSystem = new View();
        viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
        viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
        viewCoordSys.setCenter(seriesModel.get("center"));
        viewCoordSys.setZoom(seriesModel.get("zoom"));
        this.group.attr({
          position: viewCoordSys.position,
          scale: viewCoordSys.scale
        });
        this._viewCoordSys = viewCoordSys;
        this._min = min;
        this._max = max;
      },
      _updateController: function(seriesModel, ecModel, api) {
        var controller = this._controller;
        var controllerHost = this._controllerHost;
        var group = this.group;
        controller.setPointerChecker(function(e, x, y) {
          var rect = group.getBoundingRect();
          rect.applyTransform(group.transform);
          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);
        });
        controller.enable(seriesModel.get("roam"));
        controllerHost.zoomLimit = seriesModel.get("scaleLimit");
        controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
        controller.off("pan").off("zoom").on("pan", function(e) {
          roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "treeRoam",
            dx: e.dx,
            dy: e.dy
          });
        }, this).on("zoom", function(e) {
          roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "treeRoam",
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          });
          this._updateNodeAndLinkScale(seriesModel);
        }, this);
      },
      _updateNodeAndLinkScale: function(seriesModel) {
        var data = seriesModel.getData();
        var nodeScale = this._getNodeGlobalScale(seriesModel);
        var invScale = [nodeScale, nodeScale];
        data.eachItemGraphicEl(function(el, idx) {
          el.attr("scale", invScale);
        });
      },
      _getNodeGlobalScale: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys.type !== "view") {
          return 1;
        }
        var nodeScaleRatio = this._nodeScaleRatio;
        var groupScale = coordSys.scale;
        var groupZoom = groupScale && groupScale[0] || 1;
        var roamZoom = coordSys.getZoom();
        var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
        return nodeScale / groupZoom;
      },
      dispose: function() {
        this._controller && this._controller.dispose();
        this._controllerHost = {};
      },
      remove: function() {
        this._mainGroup.removeAll();
        this._data = null;
      }
    });
    function symbolNeedsDraw(data, dataIndex) {
      var layout = data.getItemLayout(dataIndex);
      return layout && !isNaN(layout.x) && !isNaN(layout.y) && data.getItemVisual(dataIndex, "symbol") !== "none";
    }
    function getTreeNodeStyle(node, itemModel, seriesScope) {
      seriesScope.itemModel = itemModel;
      seriesScope.itemStyle = itemModel.getModel("itemStyle").getItemStyle();
      seriesScope.hoverItemStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
      seriesScope.lineStyle = itemModel.getModel("lineStyle").getLineStyle();
      seriesScope.labelModel = itemModel.getModel("label");
      seriesScope.hoverLabelModel = itemModel.getModel("emphasis.label");
      if (node.isExpand === false && node.children.length !== 0) {
        seriesScope.symbolInnerColor = seriesScope.itemStyle.fill;
      } else {
        seriesScope.symbolInnerColor = "#fff";
      }
      return seriesScope;
    }
    function updateNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
      var isInit = !symbolEl;
      var node = data.tree.getNodeByDataIndex(dataIndex);
      var itemModel = node.getModel();
      var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
      var virtualRoot = data.tree.root;
      var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
      var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
      var sourceLayout = source.getLayout();
      var sourceOldLayout = sourceSymbolEl ? {
        x: sourceSymbolEl.position[0],
        y: sourceSymbolEl.position[1],
        rawX: sourceSymbolEl.__radialOldRawX,
        rawY: sourceSymbolEl.__radialOldRawY
      } : sourceLayout;
      var targetLayout = node.getLayout();
      if (isInit) {
        symbolEl = new SymbolClz(data, dataIndex, seriesScope);
        symbolEl.attr("position", [sourceOldLayout.x, sourceOldLayout.y]);
      } else {
        symbolEl.updateData(data, dataIndex, seriesScope);
      }
      symbolEl.__radialOldRawX = symbolEl.__radialRawX;
      symbolEl.__radialOldRawY = symbolEl.__radialRawY;
      symbolEl.__radialRawX = targetLayout.rawX;
      symbolEl.__radialRawY = targetLayout.rawY;
      group.add(symbolEl);
      data.setItemGraphicEl(dataIndex, symbolEl);
      graphic.updateProps(symbolEl, {
        position: [targetLayout.x, targetLayout.y]
      }, seriesModel);
      var symbolPath = symbolEl.getSymbolPath();
      if (seriesScope.layout === "radial") {
        var realRoot = virtualRoot.children[0];
        var rootLayout = realRoot.getLayout();
        var length = realRoot.children.length;
        var rad;
        var isLeft;
        if (targetLayout.x === rootLayout.x && node.isExpand === true) {
          var center = {};
          center.x = (realRoot.children[0].getLayout().x + realRoot.children[length - 1].getLayout().x) / 2;
          center.y = (realRoot.children[0].getLayout().y + realRoot.children[length - 1].getLayout().y) / 2;
          rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x);
          if (rad < 0) {
            rad = Math.PI * 2 + rad;
          }
          isLeft = center.x < rootLayout.x;
          if (isLeft) {
            rad = rad - Math.PI;
          }
        } else {
          rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
          if (rad < 0) {
            rad = Math.PI * 2 + rad;
          }
          if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
            isLeft = targetLayout.x < rootLayout.x;
            if (isLeft) {
              rad = rad - Math.PI;
            }
          } else {
            isLeft = targetLayout.x > rootLayout.x;
            if (!isLeft) {
              rad = rad - Math.PI;
            }
          }
        }
        var textPosition = isLeft ? "left" : "right";
        var rotate = seriesScope.labelModel.get("rotate");
        var labelRotateRadian = rotate * (Math.PI / 180);
        symbolPath.setStyle({
          textPosition: seriesScope.labelModel.get("position") || textPosition,
          textRotation: rotate == null ? -rad : labelRotateRadian,
          textOrigin: "center",
          verticalAlign: "middle"
        });
      }
      drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope);
    }
    function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope) {
      var edgeShape = seriesScope.edgeShape;
      var edge = symbolEl.__edge;
      if (edgeShape === "curve") {
        if (node.parentNode && node.parentNode !== virtualRoot) {
          if (!edge) {
            edge = symbolEl.__edge = new graphic.BezierCurve({
              shape: getEdgeShape(seriesScope, sourceOldLayout, sourceOldLayout),
              style: zrUtil.defaults({
                opacity: 0,
                strokeNoScale: true
              }, seriesScope.lineStyle)
            });
          }
          graphic.updateProps(edge, {
            shape: getEdgeShape(seriesScope, sourceLayout, targetLayout),
            style: zrUtil.defaults({
              opacity: 1
            }, seriesScope.lineStyle)
          }, seriesModel);
        }
      } else if (edgeShape === "polyline") {
        if (seriesScope.layout === "orthogonal") {
          if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
            var children = node.children;
            var childPoints = [];
            for (var i = 0; i < children.length; i++) {
              var childLayout = children[i].getLayout();
              childPoints.push([childLayout.x, childLayout.y]);
            }
            if (!edge) {
              edge = symbolEl.__edge = new TreeShape({
                shape: {
                  parentPoint: [targetLayout.x, targetLayout.y],
                  childPoints: [[targetLayout.x, targetLayout.y]],
                  orient: seriesScope.orient,
                  forkPosition: seriesScope.edgeForkPosition
                },
                style: zrUtil.defaults({
                  opacity: 0,
                  strokeNoScale: true
                }, seriesScope.lineStyle)
              });
            }
            graphic.updateProps(edge, {
              shape: {
                parentPoint: [targetLayout.x, targetLayout.y],
                childPoints
              },
              style: zrUtil.defaults({
                opacity: 1
              }, seriesScope.lineStyle)
            }, seriesModel);
          }
        } else {
        }
      }
      group.add(edge);
    }
    function removeNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
      var node = data.tree.getNodeByDataIndex(dataIndex);
      var virtualRoot = data.tree.root;
      var itemModel = node.getModel();
      var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
      var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
      var edgeShape = seriesScope.edgeShape;
      var sourceLayout;
      while (sourceLayout = source.getLayout(), sourceLayout == null) {
        source = source.parentNode === virtualRoot ? source : source.parentNode || source;
      }
      graphic.updateProps(symbolEl, {
        position: [sourceLayout.x + 1, sourceLayout.y + 1]
      }, seriesModel, function() {
        group.remove(symbolEl);
        data.setItemGraphicEl(dataIndex, null);
      });
      symbolEl.fadeOut(null, {
        keepLabel: true
      });
      var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
      var sourceEdge = sourceSymbolEl.__edge;
      var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
      var edgeShape = seriesScope.edgeShape;
      if (edge) {
        if (edgeShape === "curve") {
          graphic.updateProps(edge, {
            shape: getEdgeShape(seriesScope, sourceLayout, sourceLayout),
            style: {
              opacity: 0
            }
          }, seriesModel, function() {
            group.remove(edge);
          });
        } else if (edgeShape === "polyline" && seriesScope.layout === "orthogonal") {
          graphic.updateProps(edge, {
            shape: {
              parentPoint: [sourceLayout.x, sourceLayout.y],
              childPoints: [[sourceLayout.x, sourceLayout.y]]
            },
            style: {
              opacity: 0
            }
          }, seriesModel, function() {
            group.remove(edge);
          });
        }
      }
    }
    function getEdgeShape(seriesScope, sourceLayout, targetLayout) {
      var cpx1;
      var cpy1;
      var cpx2;
      var cpy2;
      var orient = seriesScope.orient;
      var x1;
      var x2;
      var y1;
      var y2;
      if (seriesScope.layout === "radial") {
        x1 = sourceLayout.rawX;
        y1 = sourceLayout.rawY;
        x2 = targetLayout.rawX;
        y2 = targetLayout.rawY;
        var radialCoor1 = radialCoordinate(x1, y1);
        var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * seriesScope.curvature);
        var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * seriesScope.curvature);
        var radialCoor4 = radialCoordinate(x2, y2);
        return {
          x1: radialCoor1.x,
          y1: radialCoor1.y,
          x2: radialCoor4.x,
          y2: radialCoor4.y,
          cpx1: radialCoor2.x,
          cpy1: radialCoor2.y,
          cpx2: radialCoor3.x,
          cpy2: radialCoor3.y
        };
      } else {
        x1 = sourceLayout.x;
        y1 = sourceLayout.y;
        x2 = targetLayout.x;
        y2 = targetLayout.y;
        if (orient === "LR" || orient === "RL") {
          cpx1 = x1 + (x2 - x1) * seriesScope.curvature;
          cpy1 = y1;
          cpx2 = x2 + (x1 - x2) * seriesScope.curvature;
          cpy2 = y2;
        }
        if (orient === "TB" || orient === "BT") {
          cpx1 = x1;
          cpy1 = y1 + (y2 - y1) * seriesScope.curvature;
          cpx2 = x2;
          cpy2 = y2 + (y1 - y2) * seriesScope.curvature;
        }
      }
      return {
        x1,
        y1,
        x2,
        y2,
        cpx1,
        cpy1,
        cpx2,
        cpy2
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeAction.js
var require_treeAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeAction.js"() {
    var echarts = require_echarts();
    var _roamHelper = require_roamHelper2();
    var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
    echarts.registerAction({
      type: "treeExpandAndCollapse",
      event: "treeExpandAndCollapse",
      update: "update"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "tree",
        query: payload
      }, function(seriesModel) {
        var dataIndex = payload.dataIndex;
        var tree = seriesModel.getData().tree;
        var node = tree.getNodeByDataIndex(dataIndex);
        node.isExpand = !node.isExpand;
      });
    });
    echarts.registerAction({
      type: "treeRoam",
      event: "treeRoam",
      // Here we set 'none' instead of 'update', because roam action
      // just need to update the transform matrix without having to recalculate
      // the layout. So don't need to go through the whole update process, such
      // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
      update: "none"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "tree",
        query: payload
      }, function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var res = updateCenterAndZoom(coordSys, payload);
        seriesModel.setCenter && seriesModel.setCenter(res.center);
        seriesModel.setZoom && seriesModel.setZoom(res.zoom);
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/traversalHelper.js
var require_traversalHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/traversalHelper.js"(exports) {
    function eachAfter(root, callback, separation) {
      var nodes = [root];
      var next = [];
      var node;
      while (node = nodes.pop()) {
        next.push(node);
        if (node.isExpand) {
          var children = node.children;
          if (children.length) {
            for (var i = 0; i < children.length; i++) {
              nodes.push(children[i]);
            }
          }
        }
      }
      while (node = next.pop()) {
        callback(node, separation);
      }
    }
    function eachBefore(root, callback) {
      var nodes = [root];
      var node;
      while (node = nodes.pop()) {
        callback(node);
        if (node.isExpand) {
          var children = node.children;
          if (children.length) {
            for (var i = children.length - 1; i >= 0; i--) {
              nodes.push(children[i]);
            }
          }
        }
      }
    }
    exports.eachAfter = eachAfter;
    exports.eachBefore = eachBefore;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeLayout.js
var require_treeLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree/treeLayout.js"(exports, module) {
    var _traversalHelper = require_traversalHelper();
    var eachAfter = _traversalHelper.eachAfter;
    var eachBefore = _traversalHelper.eachBefore;
    var _layoutHelper = require_layoutHelper();
    var init = _layoutHelper.init;
    var firstWalk = _layoutHelper.firstWalk;
    var secondWalk = _layoutHelper.secondWalk;
    var sep = _layoutHelper.separation;
    var radialCoordinate = _layoutHelper.radialCoordinate;
    var getViewRect = _layoutHelper.getViewRect;
    function _default(ecModel, api) {
      ecModel.eachSeriesByType("tree", function(seriesModel) {
        commonLayout(seriesModel, api);
      });
    }
    function commonLayout(seriesModel, api) {
      var layoutInfo = getViewRect(seriesModel, api);
      seriesModel.layoutInfo = layoutInfo;
      var layout = seriesModel.get("layout");
      var width = 0;
      var height = 0;
      var separation = null;
      if (layout === "radial") {
        width = 2 * Math.PI;
        height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
        separation = sep(function(node1, node2) {
          return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
        });
      } else {
        width = layoutInfo.width;
        height = layoutInfo.height;
        separation = sep();
      }
      var virtualRoot = seriesModel.getData().tree.root;
      var realRoot = virtualRoot.children[0];
      if (realRoot) {
        init(virtualRoot);
        eachAfter(realRoot, firstWalk, separation);
        virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
        eachBefore(realRoot, secondWalk);
        var left = realRoot;
        var right = realRoot;
        var bottom = realRoot;
        eachBefore(realRoot, function(node) {
          var x = node.getLayout().x;
          if (x < left.getLayout().x) {
            left = node;
          }
          if (x > right.getLayout().x) {
            right = node;
          }
          if (node.depth > bottom.depth) {
            bottom = node;
          }
        });
        var delta = left === right ? 1 : separation(left, right) / 2;
        var tx = delta - left.getLayout().x;
        var kx = 0;
        var ky = 0;
        var coorX = 0;
        var coorY = 0;
        if (layout === "radial") {
          kx = width / (right.getLayout().x + delta + tx);
          ky = height / (bottom.depth - 1 || 1);
          eachBefore(realRoot, function(node) {
            coorX = (node.getLayout().x + tx) * kx;
            coorY = (node.depth - 1) * ky;
            var finalCoor = radialCoordinate(coorX, coorY);
            node.setLayout({
              x: finalCoor.x,
              y: finalCoor.y,
              rawX: coorX,
              rawY: coorY
            }, true);
          });
        } else {
          var orient = seriesModel.getOrient();
          if (orient === "RL" || orient === "LR") {
            ky = height / (right.getLayout().x + delta + tx);
            kx = width / (bottom.depth - 1 || 1);
            eachBefore(realRoot, function(node) {
              coorY = (node.getLayout().x + tx) * ky;
              coorX = orient === "LR" ? (node.depth - 1) * kx : width - (node.depth - 1) * kx;
              node.setLayout({
                x: coorX,
                y: coorY
              }, true);
            });
          } else if (orient === "TB" || orient === "BT") {
            kx = width / (right.getLayout().x + delta + tx);
            ky = height / (bottom.depth - 1 || 1);
            eachBefore(realRoot, function(node) {
              coorX = (node.getLayout().x + tx) * kx;
              coorY = orient === "TB" ? (node.depth - 1) * ky : height - (node.depth - 1) * ky;
              node.setLayout({
                x: coorX,
                y: coorY
              }, true);
            });
          }
        }
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree.js
var require_tree = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/tree.js"() {
    var echarts = require_echarts();
    require_TreeSeries();
    require_TreeView();
    require_treeAction();
    var visualSymbol = require_symbol2();
    var treeLayout = require_treeLayout();
    echarts.registerVisual(visualSymbol("tree", "circle"));
    echarts.registerLayout(treeLayout);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/treeHelper.js
var require_treeHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/treeHelper.js"(exports) {
    var zrUtil = require_util();
    function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
      if (payload && zrUtil.indexOf(validPayloadTypes, payload.type) >= 0) {
        var root = seriesModel.getData().tree.root;
        var targetNode = payload.targetNode;
        if (typeof targetNode === "string") {
          targetNode = root.getNodeById(targetNode);
        }
        if (targetNode && root.contains(targetNode)) {
          return {
            node: targetNode
          };
        }
        var targetNodeId = payload.targetNodeId;
        if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
          return {
            node: targetNode
          };
        }
      }
    }
    function getPathToRoot(node) {
      var path = [];
      while (node) {
        node = node.parentNode;
        node && path.push(node);
      }
      return path.reverse();
    }
    function aboveViewRoot(viewRoot, node) {
      var viewPath = getPathToRoot(viewRoot);
      return zrUtil.indexOf(viewPath, node) >= 0;
    }
    function wrapTreePathInfo(node, seriesModel) {
      var treePathInfo = [];
      while (node) {
        var nodeDataIndex = node.dataIndex;
        treePathInfo.push({
          name: node.name,
          dataIndex: nodeDataIndex,
          value: seriesModel.getRawValue(nodeDataIndex)
        });
        node = node.parentNode;
      }
      treePathInfo.reverse();
      return treePathInfo;
    }
    exports.retrieveTargetInfo = retrieveTargetInfo;
    exports.getPathToRoot = getPathToRoot;
    exports.aboveViewRoot = aboveViewRoot;
    exports.wrapTreePathInfo = wrapTreePathInfo;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapSeries.js
var require_TreemapSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var Tree = require_Tree();
    var Model = require_Model();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var addCommas = _format.addCommas;
    var _treeHelper = require_treeHelper();
    var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
    var _default = SeriesModel.extend({
      type: "series.treemap",
      layoutMode: "box",
      dependencies: ["grid", "polar"],
      preventUsingHoverLayer: true,
      /**
       * @type {module:echarts/data/Tree~Node}
       */
      _viewRoot: null,
      defaultOption: {
        // Disable progressive rendering
        progressive: 0,
        // center: ['50%', '50%'],          // not supported in ec3.
        // size: ['80%', '80%'],            // deprecated, compatible with ec2.
        left: "center",
        top: "middle",
        right: null,
        bottom: null,
        width: "80%",
        height: "80%",
        sort: true,
        // Can be null or false or true
        // (order by desc default, asc not supported yet (strange effect))
        clipWindow: "origin",
        // Size of clipped window when zooming. 'origin' or 'fullscreen'
        squareRatio: 0.5 * (1 + Math.sqrt(5)),
        // golden ratio
        leafDepth: null,
        // Nodes on depth from root are regarded as leaves.
        // Count from zero (zero represents only view root).
        drillDownIcon: "▶",
        // Use html character temporarily because it is complicated
        // to align specialized icon. ▷▶❒❐▼✚
        zoomToNodeRatio: 0.32 * 0.32,
        // Be effective when using zoomToNode. Specify the proportion of the
        // target node area in the view area.
        roam: true,
        // true, false, 'scale' or 'zoom', 'move'.
        nodeClick: "zoomToNode",
        // Leaf node click behaviour: 'zoomToNode', 'link', false.
        // If leafDepth is set and clicking a node which has children but
        // be on left depth, the behaviour would be changing root. Otherwise
        // use behavious defined above.
        animation: true,
        animationDurationUpdate: 900,
        animationEasing: "quinticInOut",
        breadcrumb: {
          show: true,
          height: 22,
          left: "center",
          top: "bottom",
          // right
          // bottom
          emptyItemWidth: 25,
          // Width of empty node.
          itemStyle: {
            color: "rgba(0,0,0,0.7)",
            //'#5793f3',
            borderColor: "rgba(255,255,255,0.7)",
            borderWidth: 1,
            shadowColor: "rgba(150,150,150,1)",
            shadowBlur: 3,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            textStyle: {
              color: "#fff"
            }
          },
          emphasis: {
            textStyle: {}
          }
        },
        label: {
          show: true,
          // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
          distance: 0,
          padding: 5,
          position: "inside",
          // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...
          // formatter: null,
          color: "#fff",
          ellipsis: true
          // align
          // verticalAlign
        },
        upperLabel: {
          // Label when node is parent.
          show: false,
          position: [0, "50%"],
          height: 20,
          // formatter: null,
          color: "#fff",
          ellipsis: true,
          // align: null,
          verticalAlign: "middle"
        },
        itemStyle: {
          color: null,
          // Can be 'none' if not necessary.
          colorAlpha: null,
          // Can be 'none' if not necessary.
          colorSaturation: null,
          // Can be 'none' if not necessary.
          borderWidth: 0,
          gapWidth: 0,
          borderColor: "#fff",
          borderColorSaturation: null
          // If specified, borderColor will be ineffective, and the
          // border color is evaluated by color of current node and
          // borderColorSaturation.
        },
        emphasis: {
          upperLabel: {
            show: true,
            position: [0, "50%"],
            color: "#fff",
            ellipsis: true,
            verticalAlign: "middle"
          }
        },
        visualDimension: 0,
        // Can be 0, 1, 2, 3.
        visualMin: null,
        visualMax: null,
        color: [],
        // + treemapSeries.color should not be modified. Please only modified
        // level[n].color (if necessary).
        // + Specify color list of each level. level[0].color would be global
        // color list if not specified. (see method `setDefault`).
        // + But set as a empty array to forbid fetch color from global palette
        // when using nodeModel.get('color'), otherwise nodes on deep level
        // will always has color palette set and are not able to inherit color
        // from parent node.
        // + TreemapSeries.color can not be set as 'none', otherwise effect
        // legend color fetching (see seriesColor.js).
        colorAlpha: null,
        // Array. Specify color alpha range of each level, like [0.2, 0.8]
        colorSaturation: null,
        // Array. Specify color saturation of each level, like [0.2, 0.5]
        colorMappingBy: "index",
        // 'value' or 'index' or 'id'.
        visibleMin: 10,
        // If area less than this threshold (unit: pixel^2), node will not
        // be rendered. Only works when sort is 'asc' or 'desc'.
        childrenVisibleMin: null,
        // If area of a node less than this threshold (unit: pixel^2),
        // grandchildren will not show.
        // Why grandchildren? If not grandchildren but children,
        // some siblings show children and some not,
        // the appearance may be mess and not consistent,
        levels: []
        // Each item: {
        //     visibleMin, itemStyle, visualDimension, label
        // }
        // data: {
        //      value: [],
        //      children: [],
        //      link: 'http://xxx.xxx.xxx',
        //      target: 'blank' or 'self'
        // }
      },
      /**
       * @override
       */
      getInitialData: function(option, ecModel) {
        var root = {
          name: option.name,
          children: option.data
        };
        completeTreeValue(root);
        var levels = option.levels || [];
        var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
        var designatedVisualModel = new Model({
          itemStyle: designatedVisualItemStyle
        }, this, ecModel);
        levels = option.levels = setDefault(levels, ecModel);
        var levelModels = zrUtil.map(levels || [], function(levelDefine) {
          return new Model(levelDefine, designatedVisualModel, ecModel);
        }, this);
        var tree = Tree.createTree(root, this, beforeLink);
        function beforeLink(nodeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            var node = tree.getNodeByDataIndex(idx);
            var levelModel = levelModels[node.depth];
            model.parentModel = levelModel || designatedVisualModel;
            return model;
          });
        }
        return tree.data;
      },
      optionUpdated: function() {
        this.resetViewRoot();
      },
      /**
       * @override
       * @param {number} dataIndex
       * @param {boolean} [mutipleSeries=false]
       */
      formatTooltip: function(dataIndex) {
        var data = this.getData();
        var value = this.getRawValue(dataIndex);
        var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value);
        var name2 = data.getName(dataIndex);
        return encodeHTML(name2 + ": " + formattedValue);
      },
      /**
       * Add tree path to tooltip param
       *
       * @override
       * @param {number} dataIndex
       * @return {Object}
       */
      getDataParams: function(dataIndex) {
        var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
        var node = this.getData().tree.getNodeByDataIndex(dataIndex);
        params.treePathInfo = wrapTreePathInfo(node, this);
        return params;
      },
      /**
       * @public
       * @param {Object} layoutInfo {
       *                                x: containerGroup x
       *                                y: containerGroup y
       *                                width: containerGroup width
       *                                height: containerGroup height
       *                            }
       */
      setLayoutInfo: function(layoutInfo) {
        this.layoutInfo = this.layoutInfo || {};
        zrUtil.extend(this.layoutInfo, layoutInfo);
      },
      /**
       * @param  {string} id
       * @return {number} index
       */
      mapIdToIndex: function(id) {
        var idIndexMap = this._idIndexMap;
        if (!idIndexMap) {
          idIndexMap = this._idIndexMap = zrUtil.createHashMap();
          this._idIndexMapCount = 0;
        }
        var index = idIndexMap.get(id);
        if (index == null) {
          idIndexMap.set(id, index = this._idIndexMapCount++);
        }
        return index;
      },
      getViewRoot: function() {
        return this._viewRoot;
      },
      /**
       * @param {module:echarts/data/Tree~Node} [viewRoot]
       */
      resetViewRoot: function(viewRoot) {
        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
        var root = this.getRawData().tree.root;
        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
          this._viewRoot = root;
        }
      }
    });
    function completeTreeValue(dataNode) {
      var sum = 0;
      zrUtil.each(dataNode.children, function(child) {
        completeTreeValue(child);
        var childValue = child.value;
        zrUtil.isArray(childValue) && (childValue = childValue[0]);
        sum += childValue;
      });
      var thisValue = dataNode.value;
      if (zrUtil.isArray(thisValue)) {
        thisValue = thisValue[0];
      }
      if (thisValue == null || isNaN(thisValue)) {
        thisValue = sum;
      }
      if (thisValue < 0) {
        thisValue = 0;
      }
      zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
    }
    function setDefault(levels, ecModel) {
      var globalColorList = ecModel.get("color");
      if (!globalColorList) {
        return;
      }
      levels = levels || [];
      var hasColorDefine;
      zrUtil.each(levels, function(levelDefine) {
        var model = new Model(levelDefine);
        var modelColor = model.get("color");
        if (model.get("itemStyle.color") || modelColor && modelColor !== "none") {
          hasColorDefine = true;
        }
      });
      if (!hasColorDefine) {
        var level0 = levels[0] || (levels[0] = {});
        level0.color = globalColorList.slice();
      }
      return levels;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/Breadcrumb.js
var require_Breadcrumb = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/Breadcrumb.js"(exports, module) {
    var graphic = require_graphic();
    var layout = require_layout();
    var zrUtil = require_util();
    var _treeHelper = require_treeHelper();
    var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
    var TEXT_PADDING = 8;
    var ITEM_GAP = 8;
    var ARRAY_LENGTH = 5;
    function Breadcrumb(containerGroup) {
      this.group = new graphic.Group();
      containerGroup.add(this.group);
    }
    Breadcrumb.prototype = {
      constructor: Breadcrumb,
      render: function(seriesModel, api, targetNode, onSelect) {
        var model = seriesModel.getModel("breadcrumb");
        var thisGroup = this.group;
        thisGroup.removeAll();
        if (!model.get("show") || !targetNode) {
          return;
        }
        var normalStyleModel = model.getModel("itemStyle");
        var textStyleModel = normalStyleModel.getModel("textStyle");
        var layoutParam = {
          pos: {
            left: model.get("left"),
            right: model.get("right"),
            top: model.get("top"),
            bottom: model.get("bottom")
          },
          box: {
            width: api.getWidth(),
            height: api.getHeight()
          },
          emptyItemWidth: model.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(targetNode, layoutParam, textStyleModel);
        this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);
        layout.positionElement(thisGroup, layoutParam.pos, layoutParam.box);
      },
      /**
       * Prepare render list and total width
       * @private
       */
      _prepare: function(targetNode, layoutParam, textStyleModel) {
        for (var node = targetNode; node; node = node.parentNode) {
          var text = node.getModel().get("name");
          var textRect = textStyleModel.getTextRect(text);
          var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
          layoutParam.totalWidth += itemWidth + ITEM_GAP;
          layoutParam.renderList.push({
            node,
            text,
            width: itemWidth
          });
        }
      },
      /**
       * @private
       */
      _renderContent: function(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
        var lastX = 0;
        var emptyItemWidth = layoutParam.emptyItemWidth;
        var height = seriesModel.get("breadcrumb.height");
        var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);
        var totalWidth = layoutParam.totalWidth;
        var renderList = layoutParam.renderList;
        for (var i = renderList.length - 1; i >= 0; i--) {
          var item = renderList[i];
          var itemNode = item.node;
          var itemWidth = item.width;
          var text = item.text;
          if (totalWidth > availableSize.width) {
            totalWidth -= itemWidth - emptyItemWidth;
            itemWidth = emptyItemWidth;
            text = null;
          }
          var el = new graphic.Polygon({
            shape: {
              points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
            },
            style: zrUtil.defaults(normalStyleModel.getItemStyle(), {
              lineJoin: "bevel",
              text,
              textFill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont()
            }),
            z: 10,
            onclick: zrUtil.curry(onSelect, itemNode)
          });
          this.group.add(el);
          packEventData(el, seriesModel, itemNode);
          lastX += itemWidth + ITEM_GAP;
        }
      },
      /**
       * @override
       */
      remove: function() {
        this.group.removeAll();
      }
    };
    function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
      var points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
      !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
      !head && points.push([x, y + itemHeight / 2]);
      return points;
    }
    function packEventData(el, seriesModel, itemNode) {
      el.eventData = {
        componentType: "series",
        componentSubType: "treemap",
        componentIndex: seriesModel.componentIndex,
        seriesIndex: seriesModel.componentIndex,
        seriesName: seriesModel.name,
        seriesType: "treemap",
        selfType: "breadcrumb",
        // Distinguish with click event on treemap node.
        nodeData: {
          dataIndex: itemNode && itemNode.dataIndex,
          name: itemNode && itemNode.name
        },
        treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
      };
    }
    var _default = Breadcrumb;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/animation.js
var require_animation = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/util/animation.js"(exports) {
    var zrUtil = require_util();
    function createWrap() {
      var storage = [];
      var elExistsMap = {};
      var doneCallback;
      return {
        /**
         * Caution: a el can only be added once, otherwise 'done'
         * might not be called. This method checks this (by el.id),
         * suppresses adding and returns false when existing el found.
         *
         * @param {modele:zrender/Element} el
         * @param {Object} target
         * @param {number} [time=500]
         * @param {number} [delay=0]
         * @param {string} [easing='linear']
         * @return {boolean} Whether adding succeeded.
         *
         * @example
         *     add(el, target, time, delay, easing);
         *     add(el, target, time, easing);
         *     add(el, target, time);
         *     add(el, target);
         */
        add: function(el, target, time, delay, easing) {
          if (zrUtil.isString(delay)) {
            easing = delay;
            delay = 0;
          }
          if (elExistsMap[el.id]) {
            return false;
          }
          elExistsMap[el.id] = 1;
          storage.push({
            el,
            target,
            time,
            delay,
            easing
          });
          return true;
        },
        /**
         * Only execute when animation finished. Will not execute when any
         * of 'stop' or 'stopAnimation' called.
         *
         * @param {Function} callback
         */
        done: function(callback) {
          doneCallback = callback;
          return this;
        },
        /**
         * Will stop exist animation firstly.
         */
        start: function() {
          var count = storage.length;
          for (var i = 0, len = storage.length; i < len; i++) {
            var item = storage[i];
            item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
          }
          return this;
          function done() {
            count--;
            if (!count) {
              storage.length = 0;
              elExistsMap = {};
              doneCallback && doneCallback();
            }
          }
        }
      };
    }
    exports.createWrap = createWrap;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapView.js
var require_TreemapView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/TreemapView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var DataDiffer = require_DataDiffer();
    var helper = require_treeHelper();
    var Breadcrumb = require_Breadcrumb();
    var RoamController = require_RoamController();
    var BoundingRect = require_BoundingRect();
    var matrix = require_matrix();
    var animationUtil = require_animation();
    var makeStyleMapper = require_makeStyleMapper();
    var _format = require_format();
    var windowOpen = _format.windowOpen;
    var bind = zrUtil.bind;
    var Group = graphic.Group;
    var Rect = graphic.Rect;
    var each = zrUtil.each;
    var DRAG_THRESHOLD = 3;
    var PATH_LABEL_NOAMAL = ["label"];
    var PATH_LABEL_EMPHASIS = ["emphasis", "label"];
    var PATH_UPPERLABEL_NORMAL = ["upperLabel"];
    var PATH_UPPERLABEL_EMPHASIS = ["emphasis", "upperLabel"];
    var Z_BASE = 10;
    var Z_BG = 1;
    var Z_CONTENT = 2;
    var getItemStyleEmphasis = makeStyleMapper([
      ["fill", "color"],
      // `borderColor` and `borderWidth` has been occupied,
      // so use `stroke` to indicate the stroke of the rect.
      ["stroke", "strokeColor"],
      ["lineWidth", "strokeWidth"],
      ["shadowBlur"],
      ["shadowOffsetX"],
      ["shadowOffsetY"],
      ["shadowColor"]
    ]);
    var getItemStyleNormal = function(model) {
      var itemStyle = getItemStyleEmphasis(model);
      itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
      return itemStyle;
    };
    var _default = echarts.extendChartView({
      type: "treemap",
      /**
       * @override
       */
      init: function(o, api) {
        this._containerGroup;
        this._storage = createStorage();
        this._oldTree;
        this._breadcrumb;
        this._controller;
        this._state = "ready";
      },
      /**
       * @override
       */
      render: function(seriesModel, ecModel, api, payload) {
        var models = ecModel.findComponents({
          mainType: "series",
          subType: "treemap",
          query: payload
        });
        if (zrUtil.indexOf(models, seriesModel) < 0) {
          return;
        }
        this.seriesModel = seriesModel;
        this.api = api;
        this.ecModel = ecModel;
        var types = ["treemapZoomToNode", "treemapRootToNode"];
        var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);
        var payloadType = payload && payload.type;
        var layoutInfo = seriesModel.layoutInfo;
        var isInit = !this._oldTree;
        var thisStorage = this._storage;
        var reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
          rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
          direction: payload.direction
        } : null;
        var containerGroup = this._giveContainerGroup(layoutInfo);
        var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
        !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
        this._resetController(api);
        this._renderBreadcrumb(seriesModel, api, targetInfo);
      },
      /**
       * @private
       */
      _giveContainerGroup: function(layoutInfo) {
        var containerGroup = this._containerGroup;
        if (!containerGroup) {
          containerGroup = this._containerGroup = new Group();
          this._initEvents(containerGroup);
          this.group.add(containerGroup);
        }
        containerGroup.attr("position", [layoutInfo.x, layoutInfo.y]);
        return containerGroup;
      },
      /**
       * @private
       */
      _doRender: function(containerGroup, seriesModel, reRoot) {
        var thisTree = seriesModel.getData().tree;
        var oldTree = this._oldTree;
        var lastsForAnimation = createStorage();
        var thisStorage = createStorage();
        var oldStorage = this._storage;
        var willInvisibleEls = [];
        var doRenderNode = zrUtil.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls);
        dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
        var willDeleteEls = clearStorage(oldStorage);
        this._oldTree = thisTree;
        this._storage = thisStorage;
        return {
          lastsForAnimation,
          willDeleteEls,
          renderFinally
        };
        function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
          if (sameTree) {
            oldViewChildren = thisViewChildren;
            each(thisViewChildren, function(child, index) {
              !child.isRemoved() && processNode(index, index);
            });
          } else {
            new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();
          }
          function getKey(node) {
            return node.getId();
          }
          function processNode(newIndex, oldIndex) {
            var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
            var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
            var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
            group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
          }
        }
        function clearStorage(storage) {
          var willDeleteEls2 = createStorage();
          storage && each(storage, function(store, storageName) {
            var delEls = willDeleteEls2[storageName];
            each(store, function(el) {
              el && (delEls.push(el), el.__tmWillDelete = 1);
            });
          });
          return willDeleteEls2;
        }
        function renderFinally() {
          each(willDeleteEls, function(els) {
            each(els, function(el) {
              el.parent && el.parent.remove(el);
            });
          });
          each(willInvisibleEls, function(el) {
            el.invisible = true;
            el.dirty();
          });
        }
      },
      /**
       * @private
       */
      _doAnimation: function(containerGroup, renderResult, seriesModel, reRoot) {
        if (!seriesModel.get("animation")) {
          return;
        }
        var duration = seriesModel.get("animationDurationUpdate");
        var easing = seriesModel.get("animationEasing");
        var animationWrap = animationUtil.createWrap();
        each(renderResult.willDeleteEls, function(store, storageName) {
          each(store, function(el, rawIndex) {
            if (el.invisible) {
              return;
            }
            var parent = el.parent;
            var target;
            if (reRoot && reRoot.direction === "drillDown") {
              target = parent === reRoot.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: parent.__tmNodeWidth,
                  height: parent.__tmNodeHeight
                },
                style: {
                  opacity: 0
                }
                // Others.
              } : {
                style: {
                  opacity: 0
                }
              };
            } else {
              var targetX = 0;
              var targetY = 0;
              if (!parent.__tmWillDelete) {
                targetX = parent.__tmNodeWidth / 2;
                targetY = parent.__tmNodeHeight / 2;
              }
              target = storageName === "nodeGroup" ? {
                position: [targetX, targetY],
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: targetX,
                  y: targetY,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            target && animationWrap.add(el, target, duration, easing);
          });
        });
        each(this._storage, function(store, storageName) {
          each(store, function(el, rawIndex) {
            var last = renderResult.lastsForAnimation[storageName][rawIndex];
            var target = {};
            if (!last) {
              return;
            }
            if (storageName === "nodeGroup") {
              if (last.old) {
                target.position = el.position.slice();
                el.attr("position", last.old);
              }
            } else {
              if (last.old) {
                target.shape = zrUtil.extend({}, el.shape);
                el.setShape(last.old);
              }
              if (last.fadein) {
                el.setStyle("opacity", 0);
                target.style = {
                  opacity: 1
                };
              } else if (el.style.opacity !== 1) {
                target.style = {
                  opacity: 1
                };
              }
            }
            animationWrap.add(el, target, duration, easing);
          });
        }, this);
        this._state = "animating";
        animationWrap.done(bind(function() {
          this._state = "ready";
          renderResult.renderFinally();
        }, this)).start();
      },
      /**
       * @private
       */
      _resetController: function(api) {
        var controller = this._controller;
        if (!controller) {
          controller = this._controller = new RoamController(api.getZr());
          controller.enable(this.seriesModel.get("roam"));
          controller.on("pan", bind(this._onPan, this));
          controller.on("zoom", bind(this._onZoom, this));
        }
        var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());
        controller.setPointerChecker(function(e, x, y) {
          return rect.contain(x, y);
        });
      },
      /**
       * @private
       */
      _clearController: function() {
        var controller = this._controller;
        if (controller) {
          controller.dispose();
          controller = null;
        }
      },
      /**
       * @private
       */
      _onPan: function(e) {
        if (this._state !== "animating" && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {
          var root = this.seriesModel.getData().tree.root;
          if (!root) {
            return;
          }
          var rootLayout = root.getLayout();
          if (!rootLayout) {
            return;
          }
          this.api.dispatchAction({
            type: "treemapMove",
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rootLayout.x + e.dx,
              y: rootLayout.y + e.dy,
              width: rootLayout.width,
              height: rootLayout.height
            }
          });
        }
      },
      /**
       * @private
       */
      _onZoom: function(e) {
        var mouseX = e.originX;
        var mouseY = e.originY;
        if (this._state !== "animating") {
          var root = this.seriesModel.getData().tree.root;
          if (!root) {
            return;
          }
          var rootLayout = root.getLayout();
          if (!rootLayout) {
            return;
          }
          var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
          var layoutInfo = this.seriesModel.layoutInfo;
          mouseX -= layoutInfo.x;
          mouseY -= layoutInfo.y;
          var m = matrix.create();
          matrix.translate(m, m, [-mouseX, -mouseY]);
          matrix.scale(m, m, [e.scale, e.scale]);
          matrix.translate(m, m, [mouseX, mouseY]);
          rect.applyTransform(m);
          this.api.dispatchAction({
            type: "treemapRender",
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            }
          });
        }
      },
      /**
       * @private
       */
      _initEvents: function(containerGroup) {
        containerGroup.on("click", function(e) {
          if (this._state !== "ready") {
            return;
          }
          var nodeClick = this.seriesModel.get("nodeClick", true);
          if (!nodeClick) {
            return;
          }
          var targetInfo = this.findTarget(e.offsetX, e.offsetY);
          if (!targetInfo) {
            return;
          }
          var node = targetInfo.node;
          if (node.getLayout().isLeafRoot) {
            this._rootToNode(targetInfo);
          } else {
            if (nodeClick === "zoomToNode") {
              this._zoomToNode(targetInfo);
            } else if (nodeClick === "link") {
              var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
              var link = itemModel.get("link", true);
              var linkTarget = itemModel.get("target", true) || "blank";
              link && windowOpen(link, linkTarget);
            }
          }
        }, this);
      },
      /**
       * @private
       */
      _renderBreadcrumb: function(seriesModel, api, targetInfo) {
        if (!targetInfo) {
          targetInfo = seriesModel.get("leafDepth", true) != null ? {
            node: seriesModel.getViewRoot()
            // FIXME
            // better way?
            // Find breadcrumb tail on center of containerGroup.
          } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
          if (!targetInfo) {
            targetInfo = {
              node: seriesModel.getData().tree.root
            };
          }
        }
        (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, bind(onSelect, this));
        function onSelect(node) {
          if (this._state !== "animating") {
            helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({
              node
            }) : this._zoomToNode({
              node
            });
          }
        }
      },
      /**
       * @override
       */
      remove: function() {
        this._clearController();
        this._containerGroup && this._containerGroup.removeAll();
        this._storage = createStorage();
        this._state = "ready";
        this._breadcrumb && this._breadcrumb.remove();
      },
      dispose: function() {
        this._clearController();
      },
      /**
       * @private
       */
      _zoomToNode: function(targetInfo) {
        this.api.dispatchAction({
          type: "treemapZoomToNode",
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        });
      },
      /**
       * @private
       */
      _rootToNode: function(targetInfo) {
        this.api.dispatchAction({
          type: "treemapRootToNode",
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        });
      },
      /**
       * @public
       * @param {number} x Global coord x.
       * @param {number} y Global coord y.
       * @return {Object} info If not found, return undefined;
       * @return {number} info.node Target node.
       * @return {number} info.offsetX x refer to target node.
       * @return {number} info.offsetY y refer to target node.
       */
      findTarget: function(x, y) {
        var targetInfo;
        var viewRoot = this.seriesModel.getViewRoot();
        viewRoot.eachNode({
          attr: "viewChildren",
          order: "preorder"
        }, function(node) {
          var bgEl = this._storage.background[node.getRawIndex()];
          if (bgEl) {
            var point = bgEl.transformCoordToLocal(x, y);
            var shape = bgEl.shape;
            if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
              targetInfo = {
                node,
                offsetX: point[0],
                offsetY: point[1]
              };
            } else {
              return false;
            }
          }
        }, this);
        return targetInfo;
      }
    });
    function createStorage() {
      return {
        nodeGroup: [],
        background: [],
        content: []
      };
    }
    function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
      if (!thisNode) {
        return;
      }
      var thisLayout = thisNode.getLayout();
      var data = seriesModel.getData();
      data.setItemGraphicEl(thisNode.dataIndex, null);
      if (!thisLayout || !thisLayout.isInView) {
        return;
      }
      var thisWidth = thisLayout.width;
      var thisHeight = thisLayout.height;
      var borderWidth = thisLayout.borderWidth;
      var thisInvisible = thisLayout.invisible;
      var thisRawIndex = thisNode.getRawIndex();
      var oldRawIndex = oldNode && oldNode.getRawIndex();
      var thisViewChildren = thisNode.viewChildren;
      var upperHeight = thisLayout.upperHeight;
      var isParent = thisViewChildren && thisViewChildren.length;
      var itemStyleNormalModel = thisNode.getModel("itemStyle");
      var itemStyleEmphasisModel = thisNode.getModel("emphasis.itemStyle");
      var group = giveGraphic("nodeGroup", Group);
      if (!group) {
        return;
      }
      parentGroup.add(group);
      group.attr("position", [thisLayout.x || 0, thisLayout.y || 0]);
      group.__tmNodeWidth = thisWidth;
      group.__tmNodeHeight = thisHeight;
      if (thisLayout.isAboveViewRoot) {
        return group;
      }
      var nodeModel = thisNode.getModel();
      var bg = giveGraphic("background", Rect, depth, Z_BG);
      bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
      if (isParent) {
        if (graphic.isHighDownDispatcher(group)) {
          graphic.setAsHighDownDispatcher(group, false);
        }
        if (bg) {
          graphic.setAsHighDownDispatcher(bg, true);
          data.setItemGraphicEl(thisNode.dataIndex, bg);
        }
      } else {
        var content = giveGraphic("content", Rect, depth, Z_CONTENT);
        content && renderContent(group, content);
        if (bg && graphic.isHighDownDispatcher(bg)) {
          graphic.setAsHighDownDispatcher(bg, false);
        }
        graphic.setAsHighDownDispatcher(group, true);
        data.setItemGraphicEl(thisNode.dataIndex, group);
      }
      return group;
      function renderBackground(group2, bg2, useUpperLabel) {
        bg2.dataIndex = thisNode.dataIndex;
        bg2.seriesIndex = seriesModel.seriesIndex;
        bg2.setShape({
          x: 0,
          y: 0,
          width: thisWidth,
          height: thisHeight
        });
        if (thisInvisible) {
          processInvisible(bg2);
        } else {
          bg2.invisible = false;
          var visualBorderColor = thisNode.getVisual("borderColor", true);
          var emphasisBorderColor = itemStyleEmphasisModel.get("borderColor");
          var normalStyle = getItemStyleNormal(itemStyleNormalModel);
          normalStyle.fill = visualBorderColor;
          var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
          emphasisStyle.fill = emphasisBorderColor;
          if (useUpperLabel) {
            var upperLabelWidth = thisWidth - 2 * borderWidth;
            prepareText(normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight, {
              x: borderWidth,
              y: 0,
              width: upperLabelWidth,
              height: upperHeight
            });
          } else {
            normalStyle.text = emphasisStyle.text = null;
          }
          bg2.setStyle(normalStyle);
          graphic.setElementHoverStyle(bg2, emphasisStyle);
        }
        group2.add(bg2);
      }
      function renderContent(group2, content2) {
        content2.dataIndex = thisNode.dataIndex;
        content2.seriesIndex = seriesModel.seriesIndex;
        var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
        var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
        content2.culling = true;
        content2.setShape({
          x: borderWidth,
          y: borderWidth,
          width: contentWidth,
          height: contentHeight
        });
        if (thisInvisible) {
          processInvisible(content2);
        } else {
          content2.invisible = false;
          var visualColor = thisNode.getVisual("color", true);
          var normalStyle = getItemStyleNormal(itemStyleNormalModel);
          normalStyle.fill = visualColor;
          var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
          prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);
          content2.setStyle(normalStyle);
          graphic.setElementHoverStyle(content2, emphasisStyle);
        }
        group2.add(content2);
      }
      function processInvisible(element) {
        !element.invisible && willInvisibleEls.push(element);
      }
      function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {
        var defaultText = nodeModel.get("name");
        var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
        var emphasisLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS);
        var isShow = normalLabelModel.getShallow("show");
        graphic.setLabelStyle(normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel, {
          defaultText: isShow ? defaultText : null,
          autoColor: visualColor,
          isRectText: true,
          labelFetcher: seriesModel,
          labelDataIndex: thisNode.dataIndex,
          labelProp: upperLabelRect ? "upperLabel" : "label"
        });
        addDrillDownIcon(normalStyle, upperLabelRect, thisLayout);
        addDrillDownIcon(emphasisStyle, upperLabelRect, thisLayout);
        upperLabelRect && (normalStyle.textRect = zrUtil.clone(upperLabelRect));
        normalStyle.truncate = isShow && normalLabelModel.get("ellipsis") ? {
          outerWidth: width,
          outerHeight: height,
          minChar: 2
        } : null;
      }
      function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
        var text = style.text;
        if (!upperLabelRect && thisLayout2.isLeafRoot && text != null) {
          var iconChar = seriesModel.get("drillDownIcon", true);
          style.text = iconChar ? iconChar + " " + text : text;
        }
      }
      function giveGraphic(storageName, Ctor, depth2, z) {
        var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
        var lasts = lastsForAnimation[storageName];
        if (element) {
          oldStorage[storageName][oldRawIndex] = null;
          prepareAnimationWhenHasOld(lasts, element, storageName);
        } else if (!thisInvisible) {
          element = new Ctor({
            z: calculateZ(depth2, z)
          });
          element.__tmDepth = depth2;
          element.__tmStorageName = storageName;
          prepareAnimationWhenNoOld(lasts, element, storageName);
        }
        return thisStorage[storageName][thisRawIndex] = element;
      }
      function prepareAnimationWhenHasOld(lasts, element, storageName) {
        var lastCfg = lasts[thisRawIndex] = {};
        lastCfg.old = storageName === "nodeGroup" ? element.position.slice() : zrUtil.extend({}, element.shape);
      }
      function prepareAnimationWhenNoOld(lasts, element, storageName) {
        var lastCfg = lasts[thisRawIndex] = {};
        var parentNode = thisNode.parentNode;
        if (parentNode && (!reRoot || reRoot.direction === "drillDown")) {
          var parentOldX = 0;
          var parentOldY = 0;
          var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];
          if (!reRoot && parentOldBg && parentOldBg.old) {
            parentOldX = parentOldBg.old.width;
            parentOldY = parentOldBg.old.height;
          }
          lastCfg.old = storageName === "nodeGroup" ? [0, parentOldY] : {
            x: parentOldX,
            y: parentOldY,
            width: 0,
            height: 0
          };
        }
        lastCfg.fadein = storageName !== "nodeGroup";
      }
    }
    function calculateZ(depth, zInLevel) {
      var zb = depth * Z_BASE + zInLevel;
      return (zb - 1) / zb;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapAction.js
var require_treemapAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapAction.js"() {
    var echarts = require_echarts();
    var helper = require_treeHelper();
    var noop = function() {
    };
    var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
    for (i = 0; i < actionTypes.length; i++) {
      echarts.registerAction({
        type: actionTypes[i],
        update: "updateView"
      }, noop);
    }
    var i;
    echarts.registerAction({
      type: "treemapRootToNode",
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "treemap",
        query: payload
      }, handleRootToNode);
      function handleRootToNode(model, index) {
        var types = ["treemapZoomToNode", "treemapRootToNode"];
        var targetInfo = helper.retrieveTargetInfo(payload, types, model);
        if (targetInfo) {
          var originViewRoot = model.getViewRoot();
          if (originViewRoot) {
            payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
          }
          model.resetViewRoot(targetInfo.node);
        }
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/VisualMapping.js
var require_VisualMapping = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/VisualMapping.js"(exports, module) {
    var zrUtil = require_util();
    var zrColor = require_color();
    var _number = require_number();
    var linearMap = _number.linearMap;
    var each = zrUtil.each;
    var isObject = zrUtil.isObject;
    var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
    var VisualMapping = function(option) {
      var mappingMethod = option.mappingMethod;
      var visualType = option.type;
      var thisOption = this.option = zrUtil.clone(option);
      this.type = visualType;
      this.mappingMethod = mappingMethod;
      this._normalizeData = normalizers[mappingMethod];
      var visualHandler = visualHandlers[visualType];
      this.applyVisual = visualHandler.applyVisual;
      this.getColorMapper = visualHandler.getColorMapper;
      this._doMap = visualHandler._doMap[mappingMethod];
      if (mappingMethod === "piecewise") {
        normalizeVisualRange(thisOption);
        preprocessForPiecewise(thisOption);
      } else if (mappingMethod === "category") {
        thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
      } else {
        zrUtil.assert(mappingMethod !== "linear" || thisOption.dataExtent);
        normalizeVisualRange(thisOption);
      }
    };
    VisualMapping.prototype = {
      constructor: VisualMapping,
      mapValueToVisual: function(value) {
        var normalized = this._normalizeData(value);
        return this._doMap(normalized, value);
      },
      getNormalizer: function() {
        return zrUtil.bind(this._normalizeData, this);
      }
    };
    var visualHandlers = VisualMapping.visualHandlers = {
      color: {
        applyVisual: makeApplyVisual("color"),
        /**
         * Create a mapper function
         * @return {Function}
         */
        getColorMapper: function() {
          var thisOption = this.option;
          return zrUtil.bind(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
            !isNormalized && (value = this._normalizeData(value));
            return doMapCategory.call(this, value);
          } : function(value, isNormalized, out) {
            var returnRGBArray = !!out;
            !isNormalized && (value = this._normalizeData(value));
            out = zrColor.fastLerp(value, thisOption.parsedVisual, out);
            return returnRGBArray ? out : zrColor.stringify(out, "rgba");
          }, this);
        },
        _doMap: {
          linear: function(normalized) {
            return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba");
          },
          category: doMapCategory,
          piecewise: function(normalized, value) {
            var result = getSpecifiedVisual.call(this, value);
            if (result == null) {
              result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba");
            }
            return result;
          },
          fixed: doMapFixed
        }
      },
      colorHue: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyHSL(color, value);
      }),
      colorSaturation: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyHSL(color, null, value);
      }),
      colorLightness: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyHSL(color, null, null, value);
      }),
      colorAlpha: makePartialColorVisualHandler(function(color, value) {
        return zrColor.modifyAlpha(color, value);
      }),
      opacity: {
        applyVisual: makeApplyVisual("opacity"),
        _doMap: makeDoMap([0, 1])
      },
      liftZ: {
        applyVisual: makeApplyVisual("liftZ"),
        _doMap: {
          linear: doMapFixed,
          category: doMapFixed,
          piecewise: doMapFixed,
          fixed: doMapFixed
        }
      },
      symbol: {
        applyVisual: function(value, getter, setter) {
          var symbolCfg = this.mapValueToVisual(value);
          if (zrUtil.isString(symbolCfg)) {
            setter("symbol", symbolCfg);
          } else if (isObject(symbolCfg)) {
            for (var name2 in symbolCfg) {
              if (symbolCfg.hasOwnProperty(name2)) {
                setter(name2, symbolCfg[name2]);
              }
            }
          }
        },
        _doMap: {
          linear: doMapToArray,
          category: doMapCategory,
          piecewise: function(normalized, value) {
            var result = getSpecifiedVisual.call(this, value);
            if (result == null) {
              result = doMapToArray.call(this, normalized);
            }
            return result;
          },
          fixed: doMapFixed
        }
      },
      symbolSize: {
        applyVisual: makeApplyVisual("symbolSize"),
        _doMap: makeDoMap([0, 1])
      }
    };
    function preprocessForPiecewise(thisOption) {
      var pieceList = thisOption.pieceList;
      thisOption.hasSpecialVisual = false;
      zrUtil.each(pieceList, function(piece, index) {
        piece.originIndex = index;
        if (piece.visual != null) {
          thisOption.hasSpecialVisual = true;
        }
      });
    }
    function preprocessForSpecifiedCategory(thisOption) {
      var categories = thisOption.categories;
      var visual = thisOption.visual;
      var categoryMap = thisOption.categoryMap = {};
      each(categories, function(cate, index) {
        categoryMap[cate] = index;
      });
      if (!zrUtil.isArray(visual)) {
        var visualArr = [];
        if (zrUtil.isObject(visual)) {
          each(visual, function(v, cate) {
            var index = categoryMap[cate];
            visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
          });
        } else {
          visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
        }
        visual = setVisualToOption(thisOption, visualArr);
      }
      for (var i = categories.length - 1; i >= 0; i--) {
        if (visual[i] == null) {
          delete categoryMap[categories[i]];
          categories.pop();
        }
      }
    }
    function normalizeVisualRange(thisOption, isCategory) {
      var visual = thisOption.visual;
      var visualArr = [];
      if (zrUtil.isObject(visual)) {
        each(visual, function(v) {
          visualArr.push(v);
        });
      } else if (visual != null) {
        visualArr.push(visual);
      }
      var doNotNeedPair = {
        color: 1,
        symbol: 1
      };
      if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
        visualArr[1] = visualArr[0];
      }
      setVisualToOption(thisOption, visualArr);
    }
    function makePartialColorVisualHandler(applyValue) {
      return {
        applyVisual: function(value, getter, setter) {
          value = this.mapValueToVisual(value);
          setter("color", applyValue(getter("color"), value));
        },
        _doMap: makeDoMap([0, 1])
      };
    }
    function doMapToArray(normalized) {
      var visual = this.option.visual;
      return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
    }
    function makeApplyVisual(visualType) {
      return function(value, getter, setter) {
        setter(visualType, this.mapValueToVisual(value));
      };
    }
    function doMapCategory(normalized) {
      var visual = this.option.visual;
      return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
    }
    function doMapFixed() {
      return this.option.visual[0];
    }
    function makeDoMap(sourceExtent) {
      return {
        linear: function(normalized) {
          return linearMap(normalized, sourceExtent, this.option.visual, true);
        },
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = linearMap(normalized, sourceExtent, this.option.visual, true);
          }
          return result;
        },
        fixed: doMapFixed
      };
    }
    function getSpecifiedVisual(value) {
      var thisOption = this.option;
      var pieceList = thisOption.pieceList;
      if (thisOption.hasSpecialVisual) {
        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
        var piece = pieceList[pieceIndex];
        if (piece && piece.visual) {
          return piece.visual[this.type];
        }
      }
    }
    function setVisualToOption(thisOption, visualArr) {
      thisOption.visual = visualArr;
      if (thisOption.type === "color") {
        thisOption.parsedVisual = zrUtil.map(visualArr, function(item) {
          return zrColor.parse(item);
        });
      }
      return visualArr;
    }
    var normalizers = {
      linear: function(value) {
        return linearMap(value, this.option.dataExtent, [0, 1], true);
      },
      piecewise: function(value) {
        var pieceList = this.option.pieceList;
        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
        if (pieceIndex != null) {
          return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
        }
      },
      category: function(value) {
        var index = this.option.categories ? this.option.categoryMap[value] : value;
        return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
      },
      fixed: zrUtil.noop
    };
    VisualMapping.listVisualTypes = function() {
      var visualTypes = [];
      zrUtil.each(visualHandlers, function(handler, key) {
        visualTypes.push(key);
      });
      return visualTypes;
    };
    VisualMapping.addVisualHandler = function(name2, handler) {
      visualHandlers[name2] = handler;
    };
    VisualMapping.isValidType = function(visualType) {
      return visualHandlers.hasOwnProperty(visualType);
    };
    VisualMapping.eachVisual = function(visual, callback, context) {
      if (zrUtil.isObject(visual)) {
        zrUtil.each(visual, callback, context);
      } else {
        callback.call(context, visual);
      }
    };
    VisualMapping.mapVisual = function(visual, callback, context) {
      var isPrimary;
      var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);
      VisualMapping.eachVisual(visual, function(v, key) {
        var newVal = callback.call(context, v, key);
        isPrimary ? newVisual = newVal : newVisual[key] = newVal;
      });
      return newVisual;
    };
    VisualMapping.retrieveVisuals = function(obj) {
      var ret = {};
      var hasVisual;
      obj && each(visualHandlers, function(h, visualType) {
        if (obj.hasOwnProperty(visualType)) {
          ret[visualType] = obj[visualType];
          hasVisual = true;
        }
      });
      return hasVisual ? ret : null;
    };
    VisualMapping.prepareVisualTypes = function(visualTypes) {
      if (isObject(visualTypes)) {
        var types = [];
        each(visualTypes, function(item, type) {
          types.push(type);
        });
        visualTypes = types;
      } else if (zrUtil.isArray(visualTypes)) {
        visualTypes = visualTypes.slice();
      } else {
        return [];
      }
      visualTypes.sort(function(type1, type2) {
        return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
      });
      return visualTypes;
    };
    VisualMapping.dependsOn = function(visualType1, visualType2) {
      return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
    };
    VisualMapping.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
      var possibleI;
      var abs = Infinity;
      for (var i = 0, len = pieceList.length; i < len; i++) {
        var pieceValue = pieceList[i].value;
        if (pieceValue != null) {
          if (pieceValue === value || typeof pieceValue === "string" && pieceValue === value + "") {
            return i;
          }
          findClosestWhenOutside && updatePossible(pieceValue, i);
        }
      }
      for (var i = 0, len = pieceList.length; i < len; i++) {
        var piece = pieceList[i];
        var interval = piece.interval;
        var close = piece.close;
        if (interval) {
          if (interval[0] === -Infinity) {
            if (littleThan(close[1], value, interval[1])) {
              return i;
            }
          } else if (interval[1] === Infinity) {
            if (littleThan(close[0], interval[0], value)) {
              return i;
            }
          } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
            return i;
          }
          findClosestWhenOutside && updatePossible(interval[0], i);
          findClosestWhenOutside && updatePossible(interval[1], i);
        }
      }
      if (findClosestWhenOutside) {
        return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
      }
      function updatePossible(val, index) {
        var newAbs = Math.abs(val - value);
        if (newAbs < abs) {
          abs = newAbs;
          possibleI = index;
        }
      }
    };
    function littleThan(close, a, b) {
      return close ? a <= b : a < b;
    }
    var _default = VisualMapping;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapVisual.js
var require_treemapVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapVisual.js"(exports, module) {
    var VisualMapping = require_VisualMapping();
    var zrColor = require_color();
    var zrUtil = require_util();
    var isArray = zrUtil.isArray;
    var ITEM_STYLE_NORMAL = "itemStyle";
    var _default = {
      seriesType: "treemap",
      reset: function(seriesModel, ecModel, api, payload) {
        var tree = seriesModel.getData().tree;
        var root = tree.root;
        if (root.isRemoved()) {
          return;
        }
        travelTree(
          root,
          // Visual should calculate from tree root but not view root.
          {},
          seriesModel.getViewRoot().getAncestors(),
          seriesModel
        );
      }
    };
    function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
      var nodeModel = node.getModel();
      var nodeLayout = node.getLayout();
      if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
        return;
      }
      var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
      var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
      var borderColor = nodeItemStyleModel.get("borderColor");
      var borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
      var thisNodeColor;
      if (borderColorSaturation != null) {
        thisNodeColor = calculateColor(visuals, node);
        borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
      }
      node.setVisual("borderColor", borderColor);
      var viewChildren = node.viewChildren;
      if (!viewChildren || !viewChildren.length) {
        thisNodeColor = calculateColor(visuals, node);
        node.setVisual("color", thisNodeColor);
      } else {
        var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
        zrUtil.each(viewChildren, function(child, index) {
          if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
            var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
            travelTree(child, childVisual, viewRootAncestors, seriesModel);
          }
        });
      }
    }
    function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
      var visuals = zrUtil.extend({}, designatedVisual);
      var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
      zrUtil.each(["color", "colorAlpha", "colorSaturation"], function(visualName) {
        designatedVisualItemStyle[visualName] = designatedVisual[visualName];
        var val = nodeItemStyleModel.get(visualName);
        designatedVisualItemStyle[visualName] = null;
        val != null && (visuals[visualName] = val);
      });
      return visuals;
    }
    function calculateColor(visuals) {
      var color = getValueVisualDefine(visuals, "color");
      if (color) {
        var colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
        var colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
        if (colorSaturation) {
          color = zrColor.modifyHSL(color, null, null, colorSaturation);
        }
        if (colorAlpha) {
          color = zrColor.modifyAlpha(color, colorAlpha);
        }
        return color;
      }
    }
    function calculateBorderColor(borderColorSaturation, thisNodeColor) {
      return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
    }
    function getValueVisualDefine(visuals, name2) {
      var value = visuals[name2];
      if (value != null && value !== "none") {
        return value;
      }
    }
    function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
      if (!viewChildren || !viewChildren.length) {
        return;
      }
      var rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
      if (!rangeVisual) {
        return;
      }
      var visualMin = nodeModel.get("visualMin");
      var visualMax = nodeModel.get("visualMax");
      var dataExtent = nodeLayout.dataExtent.slice();
      visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
      visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
      var colorMappingBy = nodeModel.get("colorMappingBy");
      var opt = {
        type: rangeVisual.name,
        dataExtent,
        visual: rangeVisual.range
      };
      if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
        opt.mappingMethod = "category";
        opt.loop = true;
      } else {
        opt.mappingMethod = "linear";
      }
      var mapping = new VisualMapping(opt);
      mapping.__drColorMappingBy = colorMappingBy;
      return mapping;
    }
    function getRangeVisual(nodeModel, name2) {
      var range = nodeModel.get(name2);
      return isArray(range) && range.length ? {
        name: name2,
        range
      } : null;
    }
    function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
      var childVisuals = zrUtil.extend({}, visuals);
      if (mapping) {
        var mappingType = mapping.type;
        var colorMappingBy = mappingType === "color" && mapping.__drColorMappingBy;
        var value = colorMappingBy === "index" ? index : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
        childVisuals[mappingType] = mapping.mapValueToVisual(value);
      }
      return childVisuals;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapLayout.js
var require_treemapLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap/treemapLayout.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var MAX_SAFE_INTEGER = _number.MAX_SAFE_INTEGER;
    var layout = require_layout();
    var helper = require_treeHelper();
    var mathMax = Math.max;
    var mathMin = Math.min;
    var retrieveValue = zrUtil.retrieve;
    var each = zrUtil.each;
    var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
    var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
    var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
    var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
    var _default = {
      seriesType: "treemap",
      reset: function(seriesModel, ecModel, api, payload) {
        var ecWidth = api.getWidth();
        var ecHeight = api.getHeight();
        var seriesOption = seriesModel.option;
        var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
        var size = seriesOption.size || [];
        var containerWidth = parsePercent(retrieveValue(layoutInfo.width, size[0]), ecWidth);
        var containerHeight = parsePercent(retrieveValue(layoutInfo.height, size[1]), ecHeight);
        var payloadType = payload && payload.type;
        var types = ["treemapZoomToNode", "treemapRootToNode"];
        var targetInfo = helper.retrieveTargetInfo(payload, types, seriesModel);
        var rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
        var viewRoot = seriesModel.getViewRoot();
        var viewAbovePath = helper.getPathToRoot(viewRoot);
        if (payloadType !== "treemapMove") {
          var rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
          var sort2 = seriesOption.sort;
          if (sort2 && sort2 !== "asc" && sort2 !== "desc") {
            sort2 = "desc";
          }
          var options = {
            squareRatio: seriesOption.squareRatio,
            sort: sort2,
            leafDepth: seriesOption.leafDepth
          };
          viewRoot.hostTree.clearLayouts();
          var viewRootLayout = {
            x: 0,
            y: 0,
            width: rootSize[0],
            height: rootSize[1],
            area: rootSize[0] * rootSize[1]
          };
          viewRoot.setLayout(viewRootLayout);
          squarify(viewRoot, options, false, 0);
          var viewRootLayout = viewRoot.getLayout();
          each(viewAbovePath, function(node, index) {
            var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
            node.setLayout(zrUtil.extend({
              dataExtent: [childValue, childValue],
              borderWidth: 0,
              upperHeight: 0
            }, viewRootLayout));
          });
        }
        var treeRoot = seriesModel.getData().tree.root;
        treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
        seriesModel.setLayoutInfo(layoutInfo);
        prunning(
          treeRoot,
          // Transform to base element coordinate system.
          new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight),
          viewAbovePath,
          viewRoot,
          0
        );
      }
    };
    function squarify(node, options, hideChildren, depth) {
      var width;
      var height;
      if (node.isRemoved()) {
        return;
      }
      var thisLayout = node.getLayout();
      width = thisLayout.width;
      height = thisLayout.height;
      var nodeModel = node.getModel();
      var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
      var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
      var upperLabelHeight = getUpperLabelHeight(nodeModel);
      var upperHeight = Math.max(borderWidth, upperLabelHeight);
      var layoutOffset = borderWidth - halfGapWidth;
      var layoutOffsetUpper = upperHeight - halfGapWidth;
      var nodeModel = node.getModel();
      node.setLayout({
        borderWidth,
        upperHeight,
        upperLabelHeight
      }, true);
      width = mathMax(width - 2 * layoutOffset, 0);
      height = mathMax(height - layoutOffset - layoutOffsetUpper, 0);
      var totalArea = width * height;
      var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
      if (!viewChildren.length) {
        return;
      }
      var rect = {
        x: layoutOffset,
        y: layoutOffsetUpper,
        width,
        height
      };
      var rowFixedLength = mathMin(width, height);
      var best = Infinity;
      var row = [];
      row.area = 0;
      for (var i = 0, len = viewChildren.length; i < len; ) {
        var child = viewChildren[i];
        row.push(child);
        row.area += child.getLayout().area;
        var score = worst(row, rowFixedLength, options.squareRatio);
        if (score <= best) {
          i++;
          best = score;
        } else {
          row.area -= row.pop().getLayout().area;
          position(row, rowFixedLength, rect, halfGapWidth, false);
          rowFixedLength = mathMin(rect.width, rect.height);
          row.length = row.area = 0;
          best = Infinity;
        }
      }
      if (row.length) {
        position(row, rowFixedLength, rect, halfGapWidth, true);
      }
      if (!hideChildren) {
        var childrenVisibleMin = nodeModel.get("childrenVisibleMin");
        if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
          hideChildren = true;
        }
      }
      for (var i = 0, len = viewChildren.length; i < len; i++) {
        squarify(viewChildren[i], options, hideChildren, depth + 1);
      }
    }
    function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
      var viewChildren = node.children || [];
      var orderBy = options.sort;
      orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
      var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
      if (hideChildren && !overLeafDepth) {
        return node.viewChildren = [];
      }
      viewChildren = zrUtil.filter(viewChildren, function(child) {
        return !child.isRemoved();
      });
      sort(viewChildren, orderBy);
      var info = statistic(nodeModel, viewChildren, orderBy);
      if (info.sum === 0) {
        return node.viewChildren = [];
      }
      info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
      if (info.sum === 0) {
        return node.viewChildren = [];
      }
      for (var i = 0, len = viewChildren.length; i < len; i++) {
        var area = viewChildren[i].getValue() / info.sum * totalArea;
        viewChildren[i].setLayout({
          area
        });
      }
      if (overLeafDepth) {
        viewChildren.length && node.setLayout({
          isLeafRoot: true
        }, true);
        viewChildren.length = 0;
      }
      node.viewChildren = viewChildren;
      node.setLayout({
        dataExtent: info.dataExtent
      }, true);
      return viewChildren;
    }
    function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
      if (!orderBy) {
        return sum;
      }
      var visibleMin = nodeModel.get("visibleMin");
      var len = orderedChildren.length;
      var deletePoint = len;
      for (var i = len - 1; i >= 0; i--) {
        var value = orderedChildren[orderBy === "asc" ? len - i - 1 : i].getValue();
        if (value / sum * totalArea < visibleMin) {
          deletePoint = i;
          sum -= value;
        }
      }
      orderBy === "asc" ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
      return sum;
    }
    function sort(viewChildren, orderBy) {
      if (orderBy) {
        viewChildren.sort(function(a, b) {
          var diff = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
          return diff === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
        });
      }
      return viewChildren;
    }
    function statistic(nodeModel, children, orderBy) {
      var sum = 0;
      for (var i = 0, len = children.length; i < len; i++) {
        sum += children[i].getValue();
      }
      var dimension = nodeModel.get("visualDimension");
      var dataExtent;
      if (!children || !children.length) {
        dataExtent = [NaN, NaN];
      } else if (dimension === "value" && orderBy) {
        dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
        orderBy === "asc" && dataExtent.reverse();
      } else {
        var dataExtent = [Infinity, -Infinity];
        each(children, function(child) {
          var value = child.getValue(dimension);
          value < dataExtent[0] && (dataExtent[0] = value);
          value > dataExtent[1] && (dataExtent[1] = value);
        });
      }
      return {
        sum,
        dataExtent
      };
    }
    function worst(row, rowFixedLength, ratio) {
      var areaMax = 0;
      var areaMin = Infinity;
      for (var i = 0, area, len = row.length; i < len; i++) {
        area = row[i].getLayout().area;
        if (area) {
          area < areaMin && (areaMin = area);
          area > areaMax && (areaMax = area);
        }
      }
      var squareArea = row.area * row.area;
      var f = rowFixedLength * rowFixedLength * ratio;
      return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
    }
    function position(row, rowFixedLength, rect, halfGapWidth, flush) {
      var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
      var idx1WhenH = 1 - idx0WhenH;
      var xy = ["x", "y"];
      var wh = ["width", "height"];
      var last = rect[xy[idx0WhenH]];
      var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
      if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
        rowOtherLength = rect[wh[idx1WhenH]];
      }
      for (var i = 0, rowLen = row.length; i < rowLen; i++) {
        var node = row[i];
        var nodeLayout = {};
        var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
        var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0);
        var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
        var modWH = i === rowLen - 1 || remain < step ? remain : step;
        var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);
        nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);
        nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);
        last += modWH;
        node.setLayout(nodeLayout, true);
      }
      rect[xy[idx1WhenH]] += rowOtherLength;
      rect[wh[idx1WhenH]] -= rowOtherLength;
    }
    function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
      var currNode = (targetInfo || {}).node;
      var defaultSize = [containerWidth, containerHeight];
      if (!currNode || currNode === viewRoot) {
        return defaultSize;
      }
      var parent;
      var viewArea = containerWidth * containerHeight;
      var area = viewArea * seriesModel.option.zoomToNodeRatio;
      while (parent = currNode.parentNode) {
        var sum = 0;
        var siblings = parent.children;
        for (var i = 0, len = siblings.length; i < len; i++) {
          sum += siblings[i].getValue();
        }
        var currNodeValue = currNode.getValue();
        if (currNodeValue === 0) {
          return defaultSize;
        }
        area *= sum / currNodeValue;
        var parentModel = parent.getModel();
        var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
        var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel, borderWidth));
        area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
        area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
        currNode = parent;
      }
      area < viewArea && (area = viewArea);
      var scale = Math.pow(area / viewArea, 0.5);
      return [containerWidth * scale, containerHeight * scale];
    }
    function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
      if (rootRect) {
        return {
          x: rootRect.x,
          y: rootRect.y
        };
      }
      var defaultPosition = {
        x: 0,
        y: 0
      };
      if (!targetInfo) {
        return defaultPosition;
      }
      var targetNode = targetInfo.node;
      var layout2 = targetNode.getLayout();
      if (!layout2) {
        return defaultPosition;
      }
      var targetCenter = [layout2.width / 2, layout2.height / 2];
      var node = targetNode;
      while (node) {
        var nodeLayout = node.getLayout();
        targetCenter[0] += nodeLayout.x;
        targetCenter[1] += nodeLayout.y;
        node = node.parentNode;
      }
      return {
        x: layoutInfo.width / 2 - targetCenter[0],
        y: layoutInfo.height / 2 - targetCenter[1]
      };
    }
    function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
      var nodeLayout = node.getLayout();
      var nodeInViewAbovePath = viewAbovePath[depth];
      var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
      if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
        return;
      }
      node.setLayout({
        // isInView means: viewRoot sub tree + viewAbovePath
        isInView: true,
        // invisible only means: outside view clip so that the node can not
        // see but still layout for animation preparation but not render.
        invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
        isAboveViewRoot
      }, true);
      var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
      each(node.viewChildren || [], function(child) {
        prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
      });
    }
    function getUpperLabelHeight(model) {
      return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap.js
var require_treemap = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/treemap.js"() {
    var echarts = require_echarts();
    require_TreemapSeries();
    require_TreemapView();
    require_treemapAction();
    var treemapVisual = require_treemapVisual();
    var treemapLayout = require_treemapLayout();
    echarts.registerVisual(treemapVisual);
    echarts.registerLayout(treemapLayout);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Graph.js
var require_Graph = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/data/Graph.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var _clazz = require_clazz();
    var enableClassCheck = _clazz.enableClassCheck;
    function generateNodeKey(id) {
      return "_EC_" + id;
    }
    var Graph = function(directed) {
      this._directed = directed || false;
      this.nodes = [];
      this.edges = [];
      this._nodesMap = {};
      this._edgesMap = {};
      this.data;
      this.edgeData;
    };
    var graphProto = Graph.prototype;
    graphProto.type = "graph";
    graphProto.isDirected = function() {
      return this._directed;
    };
    graphProto.addNode = function(id, dataIndex) {
      id = id == null ? "" + dataIndex : "" + id;
      var nodesMap = this._nodesMap;
      if (nodesMap[generateNodeKey(id)]) {
        return;
      }
      var node = new Node(id, dataIndex);
      node.hostGraph = this;
      this.nodes.push(node);
      nodesMap[generateNodeKey(id)] = node;
      return node;
    };
    graphProto.getNodeByIndex = function(dataIndex) {
      var rawIdx = this.data.getRawIndex(dataIndex);
      return this.nodes[rawIdx];
    };
    graphProto.getNodeById = function(id) {
      return this._nodesMap[generateNodeKey(id)];
    };
    graphProto.addEdge = function(n1, n2, dataIndex) {
      var nodesMap = this._nodesMap;
      var edgesMap = this._edgesMap;
      if (typeof n1 === "number") {
        n1 = this.nodes[n1];
      }
      if (typeof n2 === "number") {
        n2 = this.nodes[n2];
      }
      if (!Node.isInstance(n1)) {
        n1 = nodesMap[generateNodeKey(n1)];
      }
      if (!Node.isInstance(n2)) {
        n2 = nodesMap[generateNodeKey(n2)];
      }
      if (!n1 || !n2) {
        return;
      }
      var key = n1.id + "-" + n2.id;
      var edge = new Edge(n1, n2, dataIndex);
      edge.hostGraph = this;
      if (this._directed) {
        n1.outEdges.push(edge);
        n2.inEdges.push(edge);
      }
      n1.edges.push(edge);
      if (n1 !== n2) {
        n2.edges.push(edge);
      }
      this.edges.push(edge);
      edgesMap[key] = edge;
      return edge;
    };
    graphProto.getEdgeByIndex = function(dataIndex) {
      var rawIdx = this.edgeData.getRawIndex(dataIndex);
      return this.edges[rawIdx];
    };
    graphProto.getEdge = function(n1, n2) {
      if (Node.isInstance(n1)) {
        n1 = n1.id;
      }
      if (Node.isInstance(n2)) {
        n2 = n2.id;
      }
      var edgesMap = this._edgesMap;
      if (this._directed) {
        return edgesMap[n1 + "-" + n2];
      } else {
        return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
      }
    };
    graphProto.eachNode = function(cb, context) {
      var nodes = this.nodes;
      var len = nodes.length;
      for (var i = 0; i < len; i++) {
        if (nodes[i].dataIndex >= 0) {
          cb.call(context, nodes[i], i);
        }
      }
    };
    graphProto.eachEdge = function(cb, context) {
      var edges = this.edges;
      var len = edges.length;
      for (var i = 0; i < len; i++) {
        if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
          cb.call(context, edges[i], i);
        }
      }
    };
    graphProto.breadthFirstTraverse = function(cb, startNode, direction, context) {
      if (!Node.isInstance(startNode)) {
        startNode = this._nodesMap[generateNodeKey(startNode)];
      }
      if (!startNode) {
        return;
      }
      var edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
      for (var i = 0; i < this.nodes.length; i++) {
        this.nodes[i].__visited = false;
      }
      if (cb.call(context, startNode, null)) {
        return;
      }
      var queue = [startNode];
      while (queue.length) {
        var currentNode = queue.shift();
        var edges = currentNode[edgeType];
        for (var i = 0; i < edges.length; i++) {
          var e = edges[i];
          var otherNode = e.node1 === currentNode ? e.node2 : e.node1;
          if (!otherNode.__visited) {
            if (cb.call(context, otherNode, currentNode)) {
              return;
            }
            queue.push(otherNode);
            otherNode.__visited = true;
          }
        }
      }
    };
    graphProto.update = function() {
      var data = this.data;
      var edgeData = this.edgeData;
      var nodes = this.nodes;
      var edges = this.edges;
      for (var i = 0, len = nodes.length; i < len; i++) {
        nodes[i].dataIndex = -1;
      }
      for (var i = 0, len = data.count(); i < len; i++) {
        nodes[data.getRawIndex(i)].dataIndex = i;
      }
      edgeData.filterSelf(function(idx) {
        var edge = edges[edgeData.getRawIndex(idx)];
        return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
      });
      for (var i = 0, len = edges.length; i < len; i++) {
        edges[i].dataIndex = -1;
      }
      for (var i = 0, len = edgeData.count(); i < len; i++) {
        edges[edgeData.getRawIndex(i)].dataIndex = i;
      }
    };
    graphProto.clone = function() {
      var graph = new Graph(this._directed);
      var nodes = this.nodes;
      var edges = this.edges;
      for (var i = 0; i < nodes.length; i++) {
        graph.addNode(nodes[i].id, nodes[i].dataIndex);
      }
      for (var i = 0; i < edges.length; i++) {
        var e = edges[i];
        graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);
      }
      return graph;
    };
    function Node(id, dataIndex) {
      this.id = id == null ? "" : id;
      this.inEdges = [];
      this.outEdges = [];
      this.edges = [];
      this.hostGraph;
      this.dataIndex = dataIndex == null ? -1 : dataIndex;
    }
    Node.prototype = {
      constructor: Node,
      /**
       * @return {number}
       */
      degree: function() {
        return this.edges.length;
      },
      /**
       * @return {number}
       */
      inDegree: function() {
        return this.inEdges.length;
      },
      /**
      * @return {number}
      */
      outDegree: function() {
        return this.outEdges.length;
      },
      /**
       * @param {string} [path]
       * @return {module:echarts/model/Model}
       */
      getModel: function(path) {
        if (this.dataIndex < 0) {
          return;
        }
        var graph = this.hostGraph;
        var itemModel = graph.data.getItemModel(this.dataIndex);
        return itemModel.getModel(path);
      }
    };
    function Edge(n1, n2, dataIndex) {
      this.node1 = n1;
      this.node2 = n2;
      this.dataIndex = dataIndex == null ? -1 : dataIndex;
    }
    Edge.prototype.getModel = function(path) {
      if (this.dataIndex < 0) {
        return;
      }
      var graph = this.hostGraph;
      var itemModel = graph.edgeData.getItemModel(this.dataIndex);
      return itemModel.getModel(path);
    };
    var createGraphDataProxyMixin = function(hostName, dataName) {
      return {
        /**
         * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
         * @return {number}
         */
        getValue: function(dimension) {
          var data = this[hostName][dataName];
          return data.get(data.getDimension(dimension || "value"), this.dataIndex);
        },
        /**
         * @param {Object|string} key
         * @param {*} [value]
         */
        setVisual: function(key, value) {
          this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
        },
        /**
         * @param {string} key
         * @return {boolean}
         */
        getVisual: function(key, ignoreParent) {
          return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);
        },
        /**
         * @param {Object} layout
         * @return {boolean} [merge=false]
         */
        setLayout: function(layout, merge) {
          this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);
        },
        /**
         * @return {Object}
         */
        getLayout: function() {
          return this[hostName][dataName].getItemLayout(this.dataIndex);
        },
        /**
         * @return {module:zrender/Element}
         */
        getGraphicEl: function() {
          return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
        },
        /**
         * @return {number}
         */
        getRawIndex: function() {
          return this[hostName][dataName].getRawIndex(this.dataIndex);
        }
      };
    };
    zrUtil.mixin(Node, createGraphDataProxyMixin("hostGraph", "data"));
    zrUtil.mixin(Edge, createGraphDataProxyMixin("hostGraph", "edgeData"));
    Graph.Node = Node;
    Graph.Edge = Edge;
    enableClassCheck(Node);
    enableClassCheck(Edge);
    var _default = Graph;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js
var require_createGraphFromNodeEdge = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/createGraphFromNodeEdge.js"(exports, module) {
    var zrUtil = require_util();
    var List = require_List();
    var Graph = require_Graph();
    var linkList = require_linkList();
    var createDimensions = require_createDimensions();
    var CoordinateSystem = require_CoordinateSystem();
    var createListFromArray = require_createListFromArray();
    function _default(nodes, edges, seriesModel, directed, beforeLink) {
      var graph = new Graph(directed);
      for (var i = 0; i < nodes.length; i++) {
        graph.addNode(zrUtil.retrieve(
          // Id, name, dataIndex
          nodes[i].id,
          nodes[i].name,
          i
        ), i);
      }
      var linkNameList = [];
      var validEdges = [];
      var linkCount = 0;
      for (var i = 0; i < edges.length; i++) {
        var link = edges[i];
        var source = link.source;
        var target = link.target;
        if (graph.addEdge(source, target, linkCount)) {
          validEdges.push(link);
          linkNameList.push(zrUtil.retrieve(link.id, source + " > " + target));
          linkCount++;
        }
      }
      var coordSys = seriesModel.get("coordinateSystem");
      var nodeData;
      if (coordSys === "cartesian2d" || coordSys === "polar") {
        nodeData = createListFromArray(nodes, seriesModel);
      } else {
        var coordSysCtor = CoordinateSystem.get(coordSys);
        var coordDimensions = coordSysCtor && coordSysCtor.type !== "view" ? coordSysCtor.dimensions || [] : [];
        if (zrUtil.indexOf(coordDimensions, "value") < 0) {
          coordDimensions.concat(["value"]);
        }
        var dimensionNames = createDimensions(nodes, {
          coordDimensions
        });
        nodeData = new List(dimensionNames, seriesModel);
        nodeData.initData(nodes);
      }
      var edgeData = new List(["value"], seriesModel);
      edgeData.initData(validEdges, linkNameList);
      beforeLink && beforeLink(nodeData, edgeData);
      linkList({
        mainData: nodeData,
        struct: graph,
        structAttr: "graph",
        datas: {
          node: nodeData,
          edge: edgeData
        },
        datasAttr: {
          node: "data",
          edge: "edgeData"
        }
      });
      graph.update();
      return graph;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js
var require_multipleGraphEdgeHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/multipleGraphEdgeHelper.js"(exports) {
    var zrUtil = require_util();
    var KEY_DELIMITER = "-->";
    var getAutoCurvenessParams = function(seriesModel) {
      return seriesModel.get("autoCurveness") || null;
    };
    var createCurveness = function(seriesModel, appendLength) {
      var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
      var length = 20;
      var curvenessList = [];
      if (typeof autoCurvenessParmas === "number") {
        length = autoCurvenessParmas;
      } else if (zrUtil.isArray(autoCurvenessParmas)) {
        seriesModel.__curvenessList = autoCurvenessParmas;
        return;
      }
      if (appendLength > length) {
        length = appendLength;
      }
      var len = length % 2 ? length + 2 : length + 3;
      curvenessList = [];
      for (var i = 0; i < len; i++) {
        curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
      }
      seriesModel.__curvenessList = curvenessList;
    };
    var getKeyOfEdges = function(n1, n2, seriesModel) {
      var source = [n1.id, n1.dataIndex].join(".");
      var target = [n2.id, n2.dataIndex].join(".");
      return [seriesModel.uid, source, target].join(KEY_DELIMITER);
    };
    var getOppositeKey = function(key) {
      var keys = key.split(KEY_DELIMITER);
      return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);
    };
    var getEdgeFromMap = function(edge, seriesModel) {
      var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
      return seriesModel.__edgeMap[key];
    };
    var getTotalLengthBetweenNodes = function(edge, seriesModel) {
      var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
      var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
      return len + lenV;
    };
    var getEdgeMapLengthWithKey = function(key, seriesModel) {
      var edgeMap = seriesModel.__edgeMap;
      return edgeMap[key] ? edgeMap[key].length : 0;
    };
    function initCurvenessList(seriesModel) {
      if (!getAutoCurvenessParams(seriesModel)) {
        return;
      }
      seriesModel.__curvenessList = [];
      seriesModel.__edgeMap = {};
      createCurveness(seriesModel);
    }
    function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
      if (!getAutoCurvenessParams(seriesModel)) {
        return;
      }
      var key = getKeyOfEdges(n1, n2, seriesModel);
      var edgeMap = seriesModel.__edgeMap;
      var oppositeEdges = edgeMap[getOppositeKey(key)];
      if (edgeMap[key] && !oppositeEdges) {
        edgeMap[key].isForward = true;
      } else if (oppositeEdges && edgeMap[key]) {
        oppositeEdges.isForward = true;
        edgeMap[key].isForward = false;
      }
      edgeMap[key] = edgeMap[key] || [];
      edgeMap[key].push(index);
    }
    function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
      var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
      var isArrayParam = zrUtil.isArray(autoCurvenessParams);
      if (!autoCurvenessParams) {
        return null;
      }
      var edgeArray = getEdgeFromMap(edge, seriesModel);
      if (!edgeArray) {
        return null;
      }
      var edgeIndex = -1;
      for (var i = 0; i < edgeArray.length; i++) {
        if (edgeArray[i] === index) {
          edgeIndex = i;
          break;
        }
      }
      var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
      createCurveness(seriesModel, totalLen);
      edge.lineStyle = edge.lineStyle || {};
      var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
      var curvenessList = seriesModel.__curvenessList;
      var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
      if (!edgeArray.isForward) {
        var oppositeKey = getOppositeKey(curKey);
        var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
        var resValue = curvenessList[edgeIndex + len + parityCorrection];
        if (needReverse) {
          if (isArrayParam) {
            if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
              return (len + parityCorrection) % 2 ? resValue : -resValue;
            } else {
              return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
            }
          } else {
            return (len + parityCorrection) % 2 ? resValue : -resValue;
          }
        } else {
          return curvenessList[edgeIndex + len + parityCorrection];
        }
      } else {
        return curvenessList[parityCorrection + edgeIndex];
      }
    }
    exports.initCurvenessList = initCurvenessList;
    exports.createEdgeMapForCurveness = createEdgeMapForCurveness;
    exports.getCurvenessForEdge = getCurvenessForEdge;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphSeries.js
var require_GraphSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphSeries.js"(exports, module) {
    var echarts = require_echarts();
    var List = require_List();
    var zrUtil = require_util();
    var _model = require_model();
    var defaultEmphasis = _model.defaultEmphasis;
    var Model = require_Model();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var createGraphFromNodeEdge = require_createGraphFromNodeEdge();
    var LegendVisualProvider = require_LegendVisualProvider();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var initCurvenessList = _multipleGraphEdgeHelper.initCurvenessList;
    var createEdgeMapForCurveness = _multipleGraphEdgeHelper.createEdgeMapForCurveness;
    var GraphSeries = echarts.extendSeriesModel({
      type: "series.graph",
      init: function(option) {
        GraphSeries.superApply(this, "init", arguments);
        var self2 = this;
        function getCategoriesData() {
          return self2._categoriesData;
        }
        this.legendVisualProvider = new LegendVisualProvider(getCategoriesData, getCategoriesData);
        this.fillDataTextStyle(option.edges || option.links);
        this._updateCategoriesData();
      },
      mergeOption: function(option) {
        GraphSeries.superApply(this, "mergeOption", arguments);
        this.fillDataTextStyle(option.edges || option.links);
        this._updateCategoriesData();
      },
      mergeDefaultAndTheme: function(option) {
        GraphSeries.superApply(this, "mergeDefaultAndTheme", arguments);
        defaultEmphasis(option, ["edgeLabel"], ["show"]);
      },
      getInitialData: function(option, ecModel) {
        var edges = option.edges || option.links || [];
        var nodes = option.data || option.nodes || [];
        var self2 = this;
        if (nodes && edges) {
          initCurvenessList(this);
          var graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
          zrUtil.each(graph.edges, function(edge) {
            createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
          }, this);
          return graph.data;
        }
        function beforeLink(nodeData, edgeData) {
          nodeData.wrapMethod("getItemModel", function(model) {
            var categoriesModels = self2._categoriesModels;
            var categoryIdx = model.getShallow("category");
            var categoryModel = categoriesModels[categoryIdx];
            if (categoryModel) {
              categoryModel.parentModel = model.parentModel;
              model.parentModel = categoryModel;
            }
            return model;
          });
          var edgeLabelModel = self2.getModel("edgeLabel");
          var fakeSeriesModel = new Model({
            label: edgeLabelModel.option
          }, edgeLabelModel.parentModel, ecModel);
          var emphasisEdgeLabelModel = self2.getModel("emphasis.edgeLabel");
          var emphasisFakeSeriesModel = new Model({
            emphasis: {
              label: emphasisEdgeLabelModel.option
            }
          }, emphasisEdgeLabelModel.parentModel, ecModel);
          edgeData.wrapMethod("getItemModel", function(model) {
            model.customizeGetParent(edgeGetParent);
            return model;
          });
          function edgeGetParent(path) {
            path = this.parsePath(path);
            return path && path[0] === "label" ? fakeSeriesModel : path && path[0] === "emphasis" && path[1] === "label" ? emphasisFakeSeriesModel : this.parentModel;
          }
        }
      },
      /**
       * @return {module:echarts/data/Graph}
       */
      getGraph: function() {
        return this.getData().graph;
      },
      /**
       * @return {module:echarts/data/List}
       */
      getEdgeData: function() {
        return this.getGraph().edgeData;
      },
      /**
       * @return {module:echarts/data/List}
       */
      getCategoriesData: function() {
        return this._categoriesData;
      },
      /**
       * @override
       */
      formatTooltip: function(dataIndex, multipleSeries, dataType) {
        if (dataType === "edge") {
          var nodeData = this.getData();
          var params = this.getDataParams(dataIndex, dataType);
          var edge = nodeData.graph.getEdgeByIndex(dataIndex);
          var sourceName = nodeData.getName(edge.node1.dataIndex);
          var targetName = nodeData.getName(edge.node2.dataIndex);
          var html = [];
          sourceName != null && html.push(sourceName);
          targetName != null && html.push(targetName);
          html = encodeHTML(html.join(" > "));
          if (params.value) {
            html += " : " + encodeHTML(params.value);
          }
          return html;
        } else {
          return GraphSeries.superApply(this, "formatTooltip", arguments);
        }
      },
      _updateCategoriesData: function() {
        var categories = zrUtil.map(this.option.categories || [], function(category) {
          return category.value != null ? category : zrUtil.extend({
            value: 0
          }, category);
        });
        var categoriesData = new List(["value"], this);
        categoriesData.initData(categories);
        this._categoriesData = categoriesData;
        this._categoriesModels = categoriesData.mapArray(function(idx) {
          return categoriesData.getItemModel(idx, true);
        });
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      },
      isAnimationEnabled: function() {
        return GraphSeries.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation"));
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "view",
        // Default option for all coordinate systems
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // polarIndex: 0,
        // geoIndex: 0,
        legendHoverLink: true,
        hoverAnimation: true,
        layout: null,
        focusNodeAdjacency: false,
        // Configuration of circular layout
        circular: {
          rotateLabel: false
        },
        // Configuration of force directed layout
        force: {
          initLayout: null,
          // Node repulsion. Can be an array to represent range.
          repulsion: [0, 50],
          gravity: 0.1,
          // Initial friction
          friction: 0.6,
          // Edge length. Can be an array to represent range.
          edgeLength: 30,
          layoutAnimation: true
        },
        left: "center",
        top: "center",
        // right: null,
        // bottom: null,
        // width: '80%',
        // height: '80%',
        symbol: "circle",
        symbolSize: 10,
        edgeSymbol: ["none", "none"],
        edgeSymbolSize: 10,
        edgeLabel: {
          position: "middle",
          distance: 5
        },
        draggable: false,
        roam: false,
        // Default on center of graph
        center: null,
        zoom: 1,
        // Symbol size scale ratio in roam
        nodeScaleRatio: 0.6,
        // cursor: null,
        // categories: [],
        // data: []
        // Or
        // nodes: []
        //
        // links: []
        // Or
        // edges: []
        label: {
          show: false,
          formatter: "{b}"
        },
        itemStyle: {},
        lineStyle: {
          color: "#aaa",
          width: 1,
          opacity: 0.5
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    var _default = GraphSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LinePath.js
var require_LinePath = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LinePath.js"(exports, module) {
    var graphic = require_graphic();
    var vec2 = require_vector();
    var straightLineProto = graphic.Line.prototype;
    var bezierCurveProto = graphic.BezierCurve.prototype;
    function isLine(shape) {
      return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
    }
    var _default = graphic.extendShape({
      type: "ec-line",
      style: {
        stroke: "#000",
        fill: null
      },
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        percent: 1,
        cpx1: null,
        cpy1: null
      },
      buildPath: function(ctx, shape) {
        this[isLine(shape) ? "_buildPathLine" : "_buildPathCurve"](ctx, shape);
      },
      _buildPathLine: straightLineProto.buildPath,
      _buildPathCurve: bezierCurveProto.buildPath,
      pointAt: function(t) {
        return this[isLine(this.shape) ? "_pointAtLine" : "_pointAtCurve"](t);
      },
      _pointAtLine: straightLineProto.pointAt,
      _pointAtCurve: bezierCurveProto.pointAt,
      tangentAt: function(t) {
        var shape = this.shape;
        var p = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : this._tangentAtCurve(t);
        return vec2.normalize(p, p);
      },
      _tangentAtCurve: bezierCurveProto.tangentAt
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Line.js
var require_Line2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Line.js"(exports, module) {
    var zrUtil = require_util();
    var vector = require_vector();
    var symbolUtil = require_symbol();
    var LinePath = require_LinePath();
    var graphic = require_graphic();
    var _number = require_number();
    var round = _number.round;
    var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
    function makeSymbolTypeKey(symbolCategory) {
      return "_" + symbolCategory + "Type";
    }
    function createSymbol(name2, lineData, idx) {
      var symbolType = lineData.getItemVisual(idx, name2);
      if (!symbolType || symbolType === "none") {
        return;
      }
      var color = lineData.getItemVisual(idx, "color");
      var symbolSize = lineData.getItemVisual(idx, name2 + "Size");
      var symbolRotate = lineData.getItemVisual(idx, name2 + "Rotate");
      if (!zrUtil.isArray(symbolSize)) {
        symbolSize = [symbolSize, symbolSize];
      }
      var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
      symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
      symbolPath.name = name2;
      return symbolPath;
    }
    function createLine(points) {
      var line = new LinePath({
        name: "line",
        subPixelOptimize: true
      });
      setLinePoints(line.shape, points);
      return line;
    }
    function setLinePoints(targetShape, points) {
      targetShape.x1 = points[0][0];
      targetShape.y1 = points[0][1];
      targetShape.x2 = points[1][0];
      targetShape.y2 = points[1][1];
      targetShape.percent = 1;
      var cp1 = points[2];
      if (cp1) {
        targetShape.cpx1 = cp1[0];
        targetShape.cpy1 = cp1[1];
      } else {
        targetShape.cpx1 = NaN;
        targetShape.cpy1 = NaN;
      }
    }
    function updateSymbolAndLabelBeforeLineUpdate() {
      var lineGroup = this;
      var symbolFrom = lineGroup.childOfName("fromSymbol");
      var symbolTo = lineGroup.childOfName("toSymbol");
      var label = lineGroup.childOfName("label");
      if (!symbolFrom && !symbolTo && label.ignore) {
        return;
      }
      var invScale = 1;
      var parentNode = this.parent;
      while (parentNode) {
        if (parentNode.scale) {
          invScale /= parentNode.scale[0];
        }
        parentNode = parentNode.parent;
      }
      var line = lineGroup.childOfName("line");
      if (!this.__dirty && !line.__dirty) {
        return;
      }
      var percent = line.shape.percent;
      var fromPos = line.pointAt(0);
      var toPos = line.pointAt(percent);
      var d = vector.sub([], toPos, fromPos);
      vector.normalize(d, d);
      if (symbolFrom) {
        symbolFrom.attr("position", fromPos);
        var specifiedRotation = symbolFrom.__specifiedRotation;
        if (specifiedRotation == null) {
          var tangent = line.tangentAt(0);
          symbolFrom.attr("rotation", Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
        } else {
          symbolFrom.attr("rotation", specifiedRotation);
        }
        symbolFrom.attr("scale", [invScale * percent, invScale * percent]);
      }
      if (symbolTo) {
        symbolTo.attr("position", toPos);
        var specifiedRotation = symbolTo.__specifiedRotation;
        if (specifiedRotation == null) {
          var tangent = line.tangentAt(1);
          symbolTo.attr("rotation", -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
        } else {
          symbolTo.attr("rotation", specifiedRotation);
        }
        symbolTo.attr("scale", [invScale * percent, invScale * percent]);
      }
      if (!label.ignore) {
        label.attr("position", toPos);
        var textPosition;
        var textAlign;
        var textVerticalAlign;
        var textOrigin;
        var distance = label.__labelDistance;
        var distanceX = distance[0] * invScale;
        var distanceY = distance[1] * invScale;
        var halfPercent = percent / 2;
        var tangent = line.tangentAt(halfPercent);
        var n = [tangent[1], -tangent[0]];
        var cp = line.pointAt(halfPercent);
        if (n[1] > 0) {
          n[0] = -n[0];
          n[1] = -n[1];
        }
        var dir = tangent[0] < 0 ? -1 : 1;
        if (label.__position !== "start" && label.__position !== "end") {
          var rotation = -Math.atan2(tangent[1], tangent[0]);
          if (toPos[0] < fromPos[0]) {
            rotation = Math.PI + rotation;
          }
          label.attr("rotation", rotation);
        }
        var dy;
        switch (label.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            dy = -distanceY;
            textVerticalAlign = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            dy = distanceY;
            textVerticalAlign = "top";
            break;
          default:
            dy = 0;
            textVerticalAlign = "middle";
        }
        switch (label.__position) {
          case "end":
            textPosition = [d[0] * distanceX + toPos[0], d[1] * distanceY + toPos[1]];
            textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
            textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            textPosition = [-d[0] * distanceX + fromPos[0], -d[1] * distanceY + fromPos[1]];
            textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
            textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            textPosition = [distanceX * dir + fromPos[0], fromPos[1] + dy];
            textAlign = tangent[0] < 0 ? "right" : "left";
            textOrigin = [-distanceX * dir, -dy];
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            textPosition = [cp[0], cp[1] + dy];
            textAlign = "center";
            textOrigin = [0, -dy];
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            textPosition = [-distanceX * dir + toPos[0], toPos[1] + dy];
            textAlign = tangent[0] >= 0 ? "right" : "left";
            textOrigin = [distanceX * dir, -dy];
            break;
        }
        label.attr({
          style: {
            // Use the user specified text align and baseline first
            textVerticalAlign: label.__verticalAlign || textVerticalAlign,
            textAlign: label.__textAlign || textAlign
          },
          position: textPosition,
          scale: [invScale, invScale],
          origin: textOrigin
        });
      }
    }
    function Line(lineData, idx, seriesScope) {
      graphic.Group.call(this);
      this._createLine(lineData, idx, seriesScope);
    }
    var lineProto = Line.prototype;
    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;
    lineProto._createLine = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var linePoints = lineData.getItemLayout(idx);
      var line = createLine(linePoints);
      line.shape.percent = 0;
      graphic.initProps(line, {
        shape: {
          percent: 1
        }
      }, seriesModel, idx);
      this.add(line);
      var label = new graphic.Text({
        name: "label",
        // FIXME
        // Temporary solution for `focusNodeAdjacency`.
        // line label do not use the opacity of lineStyle.
        lineLabelOriginalOpacity: 1
      });
      this.add(label);
      zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbol = createSymbol(symbolCategory, lineData, idx);
        this.add(symbol);
        this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
      }, this);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    lineProto.updateData = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName("line");
      var linePoints = lineData.getItemLayout(idx);
      var target = {
        shape: {}
      };
      setLinePoints(target.shape, linePoints);
      graphic.updateProps(line, target, seriesModel, idx);
      zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbolType = lineData.getItemVisual(idx, symbolCategory);
        var key = makeSymbolTypeKey(symbolCategory);
        if (this[key] !== symbolType) {
          this.remove(this.childOfName(symbolCategory));
          var symbol = createSymbol(symbolCategory, lineData, idx);
          this.add(symbol);
        }
        this[key] = symbolType;
      }, this);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    lineProto._updateCommonStl = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childOfName("line");
      var lineStyle = seriesScope && seriesScope.lineStyle;
      var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
      var labelModel = seriesScope && seriesScope.labelModel;
      var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
      if (!seriesScope || lineData.hasItemOption) {
        var itemModel = lineData.getItemModel(idx);
        lineStyle = itemModel.getModel("lineStyle").getLineStyle();
        hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
        labelModel = itemModel.getModel("label");
        hoverLabelModel = itemModel.getModel("emphasis.label");
      }
      var visualColor = lineData.getItemVisual(idx, "color");
      var visualOpacity = zrUtil.retrieve3(lineData.getItemVisual(idx, "opacity"), lineStyle.opacity, 1);
      line.useStyle(zrUtil.defaults({
        strokeNoScale: true,
        fill: "none",
        stroke: visualColor,
        opacity: visualOpacity
      }, lineStyle));
      line.hoverStyle = hoverLineStyle;
      zrUtil.each(SYMBOL_CATEGORIES, function(symbolCategory) {
        var symbol = this.childOfName(symbolCategory);
        if (symbol) {
          symbol.setColor(visualColor);
          symbol.setStyle({
            opacity: visualOpacity
          });
        }
      }, this);
      var showLabel = labelModel.getShallow("show");
      var hoverShowLabel = hoverLabelModel.getShallow("show");
      var label = this.childOfName("label");
      var defaultLabelColor;
      var baseText;
      if (showLabel || hoverShowLabel) {
        defaultLabelColor = visualColor || "#000";
        baseText = seriesModel.getFormattedLabel(idx, "normal", lineData.dataType);
        if (baseText == null) {
          var rawVal = seriesModel.getRawValue(idx);
          baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal;
        }
      }
      var normalText = showLabel ? baseText : null;
      var emphasisText = hoverShowLabel ? zrUtil.retrieve2(seriesModel.getFormattedLabel(idx, "emphasis", lineData.dataType), baseText) : null;
      var labelStyle = label.style;
      if (normalText != null || emphasisText != null) {
        graphic.setTextStyle(label.style, labelModel, {
          text: normalText
        }, {
          autoColor: defaultLabelColor
        });
        label.__textAlign = labelStyle.textAlign;
        label.__verticalAlign = labelStyle.textVerticalAlign;
        label.__position = labelModel.get("position") || "middle";
        var distance = labelModel.get("distance");
        if (!zrUtil.isArray(distance)) {
          distance = [distance, distance];
        }
        label.__labelDistance = distance;
      }
      if (emphasisText != null) {
        label.hoverStyle = {
          text: emphasisText,
          textFill: hoverLabelModel.getTextColor(true),
          // For merging hover style to normal style, do not use
          // `hoverLabelModel.getFont()` here.
          fontStyle: hoverLabelModel.getShallow("fontStyle"),
          fontWeight: hoverLabelModel.getShallow("fontWeight"),
          fontSize: hoverLabelModel.getShallow("fontSize"),
          fontFamily: hoverLabelModel.getShallow("fontFamily")
        };
      } else {
        label.hoverStyle = {
          text: null
        };
      }
      label.ignore = !showLabel && !hoverShowLabel;
      graphic.setHoverStyle(this);
    };
    lineProto.highlight = function() {
      this.trigger("emphasis");
    };
    lineProto.downplay = function() {
      this.trigger("normal");
    };
    lineProto.updateLayout = function(lineData, idx) {
      this.setLinePoints(lineData.getItemLayout(idx));
    };
    lineProto.setLinePoints = function(points) {
      var linePath = this.childOfName("line");
      setLinePoints(linePath.shape, points);
      linePath.dirty();
    };
    zrUtil.inherits(Line, graphic.Group);
    var _default = Line;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LineDraw.js
var require_LineDraw = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LineDraw.js"(exports, module) {
    var graphic = require_graphic();
    var LineGroup = require_Line2();
    function LineDraw(ctor) {
      this._ctor = ctor || LineGroup;
      this.group = new graphic.Group();
    }
    var lineDrawProto = LineDraw.prototype;
    lineDrawProto.isPersistent = function() {
      return true;
    };
    lineDrawProto.updateData = function(lineData) {
      var lineDraw = this;
      var group = lineDraw.group;
      var oldLineData = lineDraw._lineData;
      lineDraw._lineData = lineData;
      if (!oldLineData) {
        group.removeAll();
      }
      var seriesScope = makeSeriesScope(lineData);
      lineData.diff(oldLineData).add(function(idx) {
        doAdd(lineDraw, lineData, idx, seriesScope);
      }).update(function(newIdx, oldIdx) {
        doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
      }).remove(function(idx) {
        group.remove(oldLineData.getItemGraphicEl(idx));
      }).execute();
    };
    function doAdd(lineDraw, lineData, idx, seriesScope) {
      var itemLayout = lineData.getItemLayout(idx);
      if (!lineNeedsDraw(itemLayout)) {
        return;
      }
      var el = new lineDraw._ctor(lineData, idx, seriesScope);
      lineData.setItemGraphicEl(idx, el);
      lineDraw.group.add(el);
    }
    function doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
      var itemEl = oldLineData.getItemGraphicEl(oldIdx);
      if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
        lineDraw.group.remove(itemEl);
        return;
      }
      if (!itemEl) {
        itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
      } else {
        itemEl.updateData(newLineData, newIdx, seriesScope);
      }
      newLineData.setItemGraphicEl(newIdx, itemEl);
      lineDraw.group.add(itemEl);
    }
    lineDrawProto.updateLayout = function() {
      var lineData = this._lineData;
      if (!lineData) {
        return;
      }
      lineData.eachItemGraphicEl(function(el, idx) {
        el.updateLayout(lineData, idx);
      }, this);
    };
    lineDrawProto.incrementalPrepareUpdate = function(lineData) {
      this._seriesScope = makeSeriesScope(lineData);
      this._lineData = null;
      this.group.removeAll();
    };
    function isEffectObject(el) {
      return el.animators && el.animators.length > 0;
    }
    lineDrawProto.incrementalUpdate = function(taskParams, lineData) {
      function updateIncrementalAndHover(el2) {
        if (!el2.isGroup && !isEffectObject(el2)) {
          el2.incremental = el2.useHoverLayer = true;
        }
      }
      for (var idx = taskParams.start; idx < taskParams.end; idx++) {
        var itemLayout = lineData.getItemLayout(idx);
        if (lineNeedsDraw(itemLayout)) {
          var el = new this._ctor(lineData, idx, this._seriesScope);
          el.traverse(updateIncrementalAndHover);
          this.group.add(el);
          lineData.setItemGraphicEl(idx, el);
        }
      }
    };
    function makeSeriesScope(lineData) {
      var hostModel = lineData.hostModel;
      return {
        lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
        hoverLineStyle: hostModel.getModel("emphasis.lineStyle").getLineStyle(),
        labelModel: hostModel.getModel("label"),
        hoverLabelModel: hostModel.getModel("emphasis.label")
      };
    }
    lineDrawProto.remove = function() {
      this._clearIncremental();
      this._incremental = null;
      this.group.removeAll();
    };
    lineDrawProto._clearIncremental = function() {
      var incremental = this._incremental;
      if (incremental) {
        incremental.clearDisplaybles();
      }
    };
    function isPointNaN(pt) {
      return isNaN(pt[0]) || isNaN(pt[1]);
    }
    function lineNeedsDraw(pts) {
      return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
    }
    var _default = LineDraw;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphHelper.js
var require_graphHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphHelper.js"(exports) {
    function getNodeGlobalScale(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type !== "view") {
        return 1;
      }
      var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
      var groupScale = coordSys.scale;
      var groupZoom = groupScale && groupScale[0] || 1;
      var roamZoom = coordSys.getZoom();
      var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
      return nodeScale / groupZoom;
    }
    function getSymbolSize(node) {
      var symbolSize = node.getVisual("symbolSize");
      if (symbolSize instanceof Array) {
        symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
      }
      return +symbolSize;
    }
    exports.getNodeGlobalScale = getNodeGlobalScale;
    exports.getSymbolSize = getSymbolSize;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/adjustEdge.js
var require_adjustEdge = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/adjustEdge.js"(exports, module) {
    var curveTool = require_curve();
    var vec2 = require_vector();
    var _graphHelper = require_graphHelper();
    var getSymbolSize = _graphHelper.getSymbolSize;
    var v1 = [];
    var v2 = [];
    var v3 = [];
    var quadraticAt = curveTool.quadraticAt;
    var v2DistSquare = vec2.distSquare;
    var mathAbs = Math.abs;
    function intersectCurveCircle(curvePoints, center, radius) {
      var p0 = curvePoints[0];
      var p1 = curvePoints[1];
      var p2 = curvePoints[2];
      var d = Infinity;
      var t;
      var radiusSquare = radius * radius;
      var interval = 0.1;
      for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
        v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
        v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
        var diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);
        if (diff < d) {
          d = diff;
          t = _t;
        }
      }
      for (var i = 0; i < 32; i++) {
        var next = t + interval;
        v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
        v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
        v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);
        v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);
        var diff = v2DistSquare(v2, center) - radiusSquare;
        if (mathAbs(diff) < 0.01) {
          break;
        }
        var nextDiff = v2DistSquare(v3, center) - radiusSquare;
        interval /= 2;
        if (diff < 0) {
          if (nextDiff >= 0) {
            t = t + interval;
          } else {
            t = t - interval;
          }
        } else {
          if (nextDiff >= 0) {
            t = t - interval;
          } else {
            t = t + interval;
          }
        }
      }
      return t;
    }
    function _default(graph, scale) {
      var tmp0 = [];
      var quadraticSubdivide = curveTool.quadraticSubdivide;
      var pts = [[], [], []];
      var pts2 = [[], []];
      var v = [];
      scale /= 2;
      graph.eachEdge(function(edge, idx) {
        var linePoints = edge.getLayout();
        var fromSymbol = edge.getVisual("fromSymbol");
        var toSymbol = edge.getVisual("toSymbol");
        if (!linePoints.__original) {
          linePoints.__original = [vec2.clone(linePoints[0]), vec2.clone(linePoints[1])];
          if (linePoints[2]) {
            linePoints.__original.push(vec2.clone(linePoints[2]));
          }
        }
        var originalPoints = linePoints.__original;
        if (linePoints[2] != null) {
          vec2.copy(pts[0], originalPoints[0]);
          vec2.copy(pts[1], originalPoints[2]);
          vec2.copy(pts[2], originalPoints[1]);
          if (fromSymbol && fromSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node1);
            var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale);
            quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
            pts[0][0] = tmp0[3];
            pts[1][0] = tmp0[4];
            quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
            pts[0][1] = tmp0[3];
            pts[1][1] = tmp0[4];
          }
          if (toSymbol && toSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node2);
            var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale);
            quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
            pts[1][0] = tmp0[1];
            pts[2][0] = tmp0[2];
            quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
            pts[1][1] = tmp0[1];
            pts[2][1] = tmp0[2];
          }
          vec2.copy(linePoints[0], pts[0]);
          vec2.copy(linePoints[1], pts[2]);
          vec2.copy(linePoints[2], pts[1]);
        } else {
          vec2.copy(pts2[0], originalPoints[0]);
          vec2.copy(pts2[1], originalPoints[1]);
          vec2.sub(v, pts2[1], pts2[0]);
          vec2.normalize(v, v);
          if (fromSymbol && fromSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node1);
            vec2.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);
          }
          if (toSymbol && toSymbol !== "none") {
            var symbolSize = getSymbolSize(edge.node2);
            vec2.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);
          }
          vec2.copy(linePoints[0], pts2[0]);
          vec2.copy(linePoints[1], pts2[1]);
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphView.js
var require_GraphView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/GraphView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var SymbolDraw = require_SymbolDraw();
    var LineDraw = require_LineDraw();
    var RoamController = require_RoamController();
    var roamHelper = require_roamHelper();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var graphic = require_graphic();
    var adjustEdge = require_adjustEdge();
    var _graphHelper = require_graphHelper();
    var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;
    var FOCUS_ADJACENCY = "__focusNodeAdjacency";
    var UNFOCUS_ADJACENCY = "__unfocusNodeAdjacency";
    var nodeOpacityPath = ["itemStyle", "opacity"];
    var lineOpacityPath = ["lineStyle", "opacity"];
    function getItemOpacity(item, opacityPath) {
      var opacity = item.getVisual("opacity");
      return opacity != null ? opacity : item.getModel().get(opacityPath);
    }
    function fadeOutItem(item, opacityPath, opacityRatio) {
      var el = item.getGraphicEl();
      var opacity = getItemOpacity(item, opacityPath);
      if (opacityRatio != null) {
        opacity == null && (opacity = 1);
        opacity *= opacityRatio;
      }
      el.downplay && el.downplay();
      el.traverse(function(child) {
        if (!child.isGroup) {
          var opct = child.lineLabelOriginalOpacity;
          if (opct == null || opacityRatio != null) {
            opct = opacity;
          }
          child.setStyle("opacity", opct);
        }
      });
    }
    function fadeInItem(item, opacityPath) {
      var opacity = getItemOpacity(item, opacityPath);
      var el = item.getGraphicEl();
      el.traverse(function(child) {
        !child.isGroup && child.setStyle("opacity", opacity);
      });
      el.highlight && el.highlight();
    }
    var _default = echarts.extendChartView({
      type: "graph",
      init: function(ecModel, api) {
        var symbolDraw = new SymbolDraw();
        var lineDraw = new LineDraw();
        var group = this.group;
        this._controller = new RoamController(api.getZr());
        this._controllerHost = {
          target: group
        };
        group.add(symbolDraw.group);
        group.add(lineDraw.group);
        this._symbolDraw = symbolDraw;
        this._lineDraw = lineDraw;
        this._firstRender = true;
      },
      render: function(seriesModel, ecModel, api) {
        var graphView = this;
        var coordSys = seriesModel.coordinateSystem;
        this._model = seriesModel;
        var symbolDraw = this._symbolDraw;
        var lineDraw = this._lineDraw;
        var group = this.group;
        if (coordSys.type === "view") {
          var groupNewProp = {
            position: coordSys.position,
            scale: coordSys.scale
          };
          if (this._firstRender) {
            group.attr(groupNewProp);
          } else {
            graphic.updateProps(group, groupNewProp, seriesModel);
          }
        }
        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
        var data = seriesModel.getData();
        symbolDraw.updateData(data);
        var edgeData = seriesModel.getEdgeData();
        lineDraw.updateData(edgeData);
        this._updateNodeAndLinkScale();
        this._updateController(seriesModel, ecModel, api);
        clearTimeout(this._layoutTimeout);
        var forceLayout = seriesModel.forceLayout;
        var layoutAnimation = seriesModel.get("force.layoutAnimation");
        if (forceLayout) {
          this._startForceLayoutIteration(forceLayout, layoutAnimation);
        }
        data.eachItemGraphicEl(function(el, idx) {
          var itemModel = data.getItemModel(idx);
          el.off("drag").off("dragend");
          var draggable = itemModel.get("draggable");
          if (draggable) {
            el.on("drag", function() {
              if (forceLayout) {
                forceLayout.warmUp();
                !this._layouting && this._startForceLayoutIteration(forceLayout, layoutAnimation);
                forceLayout.setFixed(idx);
                data.setItemLayout(idx, el.position);
              }
            }, this).on("dragend", function() {
              if (forceLayout) {
                forceLayout.setUnfixed(idx);
              }
            }, this);
          }
          el.setDraggable(draggable && forceLayout);
          el[FOCUS_ADJACENCY] && el.off("mouseover", el[FOCUS_ADJACENCY]);
          el[UNFOCUS_ADJACENCY] && el.off("mouseout", el[UNFOCUS_ADJACENCY]);
          if (itemModel.get("focusNodeAdjacency")) {
            el.on("mouseover", el[FOCUS_ADJACENCY] = function() {
              graphView._clearTimer();
              api.dispatchAction({
                type: "focusNodeAdjacency",
                seriesId: seriesModel.id,
                dataIndex: el.dataIndex
              });
            });
            el.on("mouseout", el[UNFOCUS_ADJACENCY] = function() {
              graphView._dispatchUnfocus(api);
            });
          }
        }, this);
        data.graph.eachEdge(function(edge) {
          var el = edge.getGraphicEl();
          el[FOCUS_ADJACENCY] && el.off("mouseover", el[FOCUS_ADJACENCY]);
          el[UNFOCUS_ADJACENCY] && el.off("mouseout", el[UNFOCUS_ADJACENCY]);
          if (edge.getModel().get("focusNodeAdjacency")) {
            el.on("mouseover", el[FOCUS_ADJACENCY] = function() {
              graphView._clearTimer();
              api.dispatchAction({
                type: "focusNodeAdjacency",
                seriesId: seriesModel.id,
                edgeDataIndex: edge.dataIndex
              });
            });
            el.on("mouseout", el[UNFOCUS_ADJACENCY] = function() {
              graphView._dispatchUnfocus(api);
            });
          }
        });
        var circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get("circular.rotateLabel");
        var cx = data.getLayout("cx");
        var cy = data.getLayout("cy");
        data.eachItemGraphicEl(function(el, idx) {
          var itemModel = data.getItemModel(idx);
          var labelRotate = itemModel.get("label.rotate") || 0;
          var symbolPath = el.getSymbolPath();
          if (circularRotateLabel) {
            var pos = data.getItemLayout(idx);
            var rad = Math.atan2(pos[1] - cy, pos[0] - cx);
            if (rad < 0) {
              rad = Math.PI * 2 + rad;
            }
            var isLeft = pos[0] < cx;
            if (isLeft) {
              rad = rad - Math.PI;
            }
            var textPosition = isLeft ? "left" : "right";
            graphic.modifyLabelStyle(symbolPath, {
              textRotation: -rad,
              textPosition,
              textOrigin: "center"
            }, {
              textPosition
            });
          } else {
            graphic.modifyLabelStyle(symbolPath, {
              textRotation: labelRotate *= Math.PI / 180
            });
          }
        });
        this._firstRender = false;
      },
      dispose: function() {
        this._controller && this._controller.dispose();
        this._controllerHost = {};
        this._clearTimer();
      },
      _dispatchUnfocus: function(api, opt) {
        var self2 = this;
        this._clearTimer();
        this._unfocusDelayTimer = setTimeout(function() {
          self2._unfocusDelayTimer = null;
          api.dispatchAction({
            type: "unfocusNodeAdjacency",
            seriesId: self2._model.id
          });
        }, 500);
      },
      _clearTimer: function() {
        if (this._unfocusDelayTimer) {
          clearTimeout(this._unfocusDelayTimer);
          this._unfocusDelayTimer = null;
        }
      },
      focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var graph = data.graph;
        var dataIndex = payload.dataIndex;
        var edgeDataIndex = payload.edgeDataIndex;
        var node = graph.getNodeByIndex(dataIndex);
        var edge = graph.getEdgeByIndex(edgeDataIndex);
        if (!node && !edge) {
          return;
        }
        graph.eachNode(function(node2) {
          fadeOutItem(node2, nodeOpacityPath, 0.1);
        });
        graph.eachEdge(function(edge2) {
          fadeOutItem(edge2, lineOpacityPath, 0.1);
        });
        if (node) {
          fadeInItem(node, nodeOpacityPath);
          zrUtil.each(node.edges, function(adjacentEdge) {
            if (adjacentEdge.dataIndex < 0) {
              return;
            }
            fadeInItem(adjacentEdge, lineOpacityPath);
            fadeInItem(adjacentEdge.node1, nodeOpacityPath);
            fadeInItem(adjacentEdge.node2, nodeOpacityPath);
          });
        }
        if (edge) {
          fadeInItem(edge, lineOpacityPath);
          fadeInItem(edge.node1, nodeOpacityPath);
          fadeInItem(edge.node2, nodeOpacityPath);
        }
      },
      unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var graph = seriesModel.getData().graph;
        graph.eachNode(function(node) {
          fadeOutItem(node, nodeOpacityPath);
        });
        graph.eachEdge(function(edge) {
          fadeOutItem(edge, lineOpacityPath);
        });
      },
      _startForceLayoutIteration: function(forceLayout, layoutAnimation) {
        var self2 = this;
        (function step() {
          forceLayout.step(function(stopped) {
            self2.updateLayout(self2._model);
            (self2._layouting = !stopped) && (layoutAnimation ? self2._layoutTimeout = setTimeout(step, 16) : step());
          });
        })();
      },
      _updateController: function(seriesModel, ecModel, api) {
        var controller = this._controller;
        var controllerHost = this._controllerHost;
        var group = this.group;
        controller.setPointerChecker(function(e, x, y) {
          var rect = group.getBoundingRect();
          rect.applyTransform(group.transform);
          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel);
        });
        if (seriesModel.coordinateSystem.type !== "view") {
          controller.disable();
          return;
        }
        controller.enable(seriesModel.get("roam"));
        controllerHost.zoomLimit = seriesModel.get("scaleLimit");
        controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
        controller.off("pan").off("zoom").on("pan", function(e) {
          roamHelper.updateViewOnPan(controllerHost, e.dx, e.dy);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "graphRoam",
            dx: e.dx,
            dy: e.dy
          });
        }).on("zoom", function(e) {
          roamHelper.updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY);
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: "graphRoam",
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          });
          this._updateNodeAndLinkScale();
          adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
          this._lineDraw.updateLayout();
        }, this);
      },
      _updateNodeAndLinkScale: function() {
        var seriesModel = this._model;
        var data = seriesModel.getData();
        var nodeScale = getNodeGlobalScale(seriesModel);
        var invScale = [nodeScale, nodeScale];
        data.eachItemGraphicEl(function(el, idx) {
          el.attr("scale", invScale);
        });
      },
      updateLayout: function(seriesModel) {
        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
        this._symbolDraw.updateLayout();
        this._lineDraw.updateLayout();
      },
      remove: function(ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove();
        this._lineDraw && this._lineDraw.remove();
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/focusNodeAdjacencyAction.js
var require_focusNodeAdjacencyAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/focusNodeAdjacencyAction.js"() {
    var echarts = require_echarts();
    echarts.registerAction({
      type: "focusNodeAdjacency",
      event: "focusNodeAdjacency",
      update: "series:focusNodeAdjacency"
    }, function() {
    });
    echarts.registerAction({
      type: "unfocusNodeAdjacency",
      event: "unfocusNodeAdjacency",
      update: "series:unfocusNodeAdjacency"
    }, function() {
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphAction.js
var require_graphAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/graphAction.js"() {
    var echarts = require_echarts();
    var _roamHelper = require_roamHelper2();
    var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
    require_focusNodeAdjacencyAction();
    var actionInfo = {
      type: "graphRoam",
      event: "graphRoam",
      update: "none"
    };
    echarts.registerAction(actionInfo, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        query: payload
      }, function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var res = updateCenterAndZoom(coordSys, payload);
        seriesModel.setCenter && seriesModel.setCenter(res.center);
        seriesModel.setZoom && seriesModel.setZoom(res.zoom);
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryFilter.js
var require_categoryFilter = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryFilter.js"(exports, module) {
    function _default(ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      ecModel.eachSeriesByType("graph", function(graphSeries) {
        var categoriesData = graphSeries.getCategoriesData();
        var graph = graphSeries.getGraph();
        var data = graph.data;
        var categoryNames = categoriesData.mapArray(categoriesData.getName);
        data.filterSelf(function(idx) {
          var model = data.getItemModel(idx);
          var category = model.getShallow("category");
          if (category != null) {
            if (typeof category === "number") {
              category = categoryNames[category];
            }
            for (var i = 0; i < legendModels.length; i++) {
              if (!legendModels[i].isSelected(category)) {
                return false;
              }
            }
          }
          return true;
        });
      }, this);
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryVisual.js
var require_categoryVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/categoryVisual.js"(exports, module) {
    function _default(ecModel) {
      var paletteScope = {};
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var categoriesData = seriesModel.getCategoriesData();
        var data = seriesModel.getData();
        var categoryNameIdxMap = {};
        categoriesData.each(function(idx) {
          var name2 = categoriesData.getName(idx);
          categoryNameIdxMap["ec-" + name2] = idx;
          var itemModel = categoriesData.getItemModel(idx);
          var color = itemModel.get("itemStyle.color") || seriesModel.getColorFromPalette(name2, paletteScope);
          categoriesData.setItemVisual(idx, "color", color);
          var itemStyleList = ["opacity", "symbol", "symbolSize", "symbolKeepAspect"];
          for (var i = 0; i < itemStyleList.length; i++) {
            var itemStyle = itemModel.getShallow(itemStyleList[i], true);
            if (itemStyle != null) {
              categoriesData.setItemVisual(idx, itemStyleList[i], itemStyle);
            }
          }
        });
        if (categoriesData.count()) {
          data.each(function(idx) {
            var model = data.getItemModel(idx);
            var category = model.getShallow("category");
            if (category != null) {
              if (typeof category === "string") {
                category = categoryNameIdxMap["ec-" + category];
              }
              var itemStyleList = ["color", "opacity", "symbol", "symbolSize", "symbolKeepAspect"];
              for (var i = 0; i < itemStyleList.length; i++) {
                if (data.getItemVisual(idx, itemStyleList[i], true) == null) {
                  data.setItemVisual(idx, itemStyleList[i], categoriesData.getItemVisual(category, itemStyleList[i]));
                }
              }
            }
          });
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/edgeVisual.js
var require_edgeVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/edgeVisual.js"(exports, module) {
    function normalize(a) {
      if (!(a instanceof Array)) {
        a = [a, a];
      }
      return a;
    }
    function _default(ecModel) {
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var graph = seriesModel.getGraph();
        var edgeData = seriesModel.getEdgeData();
        var symbolType = normalize(seriesModel.get("edgeSymbol"));
        var symbolSize = normalize(seriesModel.get("edgeSymbolSize"));
        var colorQuery = "lineStyle.color".split(".");
        var opacityQuery = "lineStyle.opacity".split(".");
        edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
        edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
        edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
        edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
        edgeData.setVisual("color", seriesModel.get(colorQuery));
        edgeData.setVisual("opacity", seriesModel.get(opacityQuery));
        edgeData.each(function(idx) {
          var itemModel = edgeData.getItemModel(idx);
          var edge = graph.getEdgeByIndex(idx);
          var symbolType2 = normalize(itemModel.getShallow("symbol", true));
          var symbolSize2 = normalize(itemModel.getShallow("symbolSize", true));
          var color = itemModel.get(colorQuery);
          var opacity = itemModel.get(opacityQuery);
          switch (color) {
            case "source":
              color = edge.node1.getVisual("color");
              break;
            case "target":
              color = edge.node2.getVisual("color");
              break;
          }
          symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
          symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
          symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
          symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
          edge.setVisual("color", color);
          edge.setVisual("opacity", opacity);
        });
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js
var require_simpleLayoutHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayoutHelper.js"(exports) {
    var vec2 = require_vector();
    var zrUtil = require_util();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
    function simpleLayout(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        return;
      }
      var graph = seriesModel.getGraph();
      graph.eachNode(function(node) {
        var model = node.getModel();
        node.setLayout([+model.get("x"), +model.get("y")]);
      });
      simpleLayoutEdge(graph, seriesModel);
    }
    function simpleLayoutEdge(graph, seriesModel) {
      graph.eachEdge(function(edge, index) {
        var curveness = zrUtil.retrieve3(edge.getModel().get("lineStyle.curveness"), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
        var p1 = vec2.clone(edge.node1.getLayout());
        var p2 = vec2.clone(edge.node2.getLayout());
        var points = [p1, p2];
        if (+curveness) {
          points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
        }
        edge.setLayout(points);
      });
    }
    exports.simpleLayout = simpleLayout;
    exports.simpleLayoutEdge = simpleLayoutEdge;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayout.js
var require_simpleLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/simpleLayout.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var _simpleLayoutHelper = require_simpleLayoutHelper();
    var simpleLayout = _simpleLayoutHelper.simpleLayout;
    var simpleLayoutEdge = _simpleLayoutHelper.simpleLayoutEdge;
    function _default(ecModel, api) {
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var layout = seriesModel.get("layout");
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.type !== "view") {
          var data = seriesModel.getData();
          var dimensions = [];
          each(coordSys.dimensions, function(coordDim) {
            dimensions = dimensions.concat(data.mapDimension(coordDim, true));
          });
          for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
            var value = [];
            var hasValue = false;
            for (var i = 0; i < dimensions.length; i++) {
              var val = data.get(dimensions[i], dataIndex);
              if (!isNaN(val)) {
                hasValue = true;
              }
              value.push(val);
            }
            if (hasValue) {
              data.setItemLayout(dataIndex, coordSys.dataToPoint(value));
            } else {
              data.setItemLayout(dataIndex, [NaN, NaN]);
            }
          }
          simpleLayoutEdge(data.graph, seriesModel);
        } else if (!layout || layout === "none") {
          simpleLayout(seriesModel);
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayoutHelper.js
var require_circularLayoutHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayoutHelper.js"(exports) {
    var vec2 = require_vector();
    var _graphHelper = require_graphHelper();
    var getSymbolSize = _graphHelper.getSymbolSize;
    var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;
    var zrUtil = require_util();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
    var PI = Math.PI;
    var _symbolRadiansHalf = [];
    function circularLayout(seriesModel, basedOn) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        return;
      }
      var rect = coordSys.getBoundingRect();
      var nodeData = seriesModel.getData();
      var graph = nodeData.graph;
      var cx = rect.width / 2 + rect.x;
      var cy = rect.height / 2 + rect.y;
      var r = Math.min(rect.width, rect.height) / 2;
      var count = nodeData.count();
      nodeData.setLayout({
        cx,
        cy
      });
      if (!count) {
        return;
      }
      _layoutNodesBasedOn[basedOn](seriesModel, coordSys, graph, nodeData, r, cx, cy, count);
      graph.eachEdge(function(edge, index) {
        var curveness = zrUtil.retrieve3(edge.getModel().get("lineStyle.curveness"), getCurvenessForEdge(edge, seriesModel, index), 0);
        var p1 = vec2.clone(edge.node1.getLayout());
        var p2 = vec2.clone(edge.node2.getLayout());
        var cp1;
        var x12 = (p1[0] + p2[0]) / 2;
        var y12 = (p1[1] + p2[1]) / 2;
        if (+curveness) {
          curveness *= 3;
          cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
        }
        edge.setLayout([p1, p2, cp1]);
      });
    }
    var _layoutNodesBasedOn = {
      value: function(seriesModel, coordSys, graph, nodeData, r, cx, cy, count) {
        var angle = 0;
        var sum = nodeData.getSum("value");
        var unitAngle = Math.PI * 2 / (sum || count);
        graph.eachNode(function(node) {
          var value = node.getValue("value");
          var radianHalf = unitAngle * (sum ? value : 1) / 2;
          angle += radianHalf;
          node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
          angle += radianHalf;
        });
      },
      symbolSize: function(seriesModel, coordSys, graph, nodeData, r, cx, cy, count) {
        var sumRadian = 0;
        _symbolRadiansHalf.length = count;
        var nodeScale = getNodeGlobalScale(seriesModel);
        graph.eachNode(function(node) {
          var symbolSize = getSymbolSize(node);
          isNaN(symbolSize) && (symbolSize = 2);
          symbolSize < 0 && (symbolSize = 0);
          symbolSize *= nodeScale;
          var symbolRadianHalf = Math.asin(symbolSize / 2 / r);
          isNaN(symbolRadianHalf) && (symbolRadianHalf = PI / 2);
          _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
          sumRadian += symbolRadianHalf * 2;
        });
        var halfRemainRadian = (2 * PI - sumRadian) / count / 2;
        var angle = 0;
        graph.eachNode(function(node) {
          var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
          angle += radianHalf;
          node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
          angle += radianHalf;
        });
      }
    };
    exports.circularLayout = circularLayout;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayout.js
var require_circularLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/circularLayout.js"(exports, module) {
    var _circularLayoutHelper = require_circularLayoutHelper();
    var circularLayout = _circularLayoutHelper.circularLayout;
    function _default(ecModel) {
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        if (seriesModel.get("layout") === "circular") {
          circularLayout(seriesModel, "symbolSize");
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceHelper.js
var require_forceHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceHelper.js"(exports) {
    var vec2 = require_vector();
    var scaleAndAdd = vec2.scaleAndAdd;
    function forceLayout(nodes, edges, opts) {
      var rect = opts.rect;
      var width = rect.width;
      var height = rect.height;
      var center = [rect.x + width / 2, rect.y + height / 2];
      var gravity = opts.gravity == null ? 0.1 : opts.gravity;
      for (var i = 0; i < nodes.length; i++) {
        var n = nodes[i];
        if (!n.p) {
          n.p = vec2.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);
        }
        n.pp = vec2.clone(n.p);
        n.edges = null;
      }
      var initialFriction = opts.friction == null ? 0.6 : opts.friction;
      var friction = initialFriction;
      return {
        warmUp: function() {
          friction = initialFriction * 0.8;
        },
        setFixed: function(idx) {
          nodes[idx].fixed = true;
        },
        setUnfixed: function(idx) {
          nodes[idx].fixed = false;
        },
        /**
         * Some formulas were originally copied from "d3.js"
         * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
         * with some modifications made for this project.
         * See the license statement at the head of this file.
         */
        step: function(cb) {
          var v12 = [];
          var nLen = nodes.length;
          for (var i2 = 0; i2 < edges.length; i2++) {
            var e = edges[i2];
            if (e.ignoreForceLayout) {
              continue;
            }
            var n1 = e.n1;
            var n2 = e.n2;
            vec2.sub(v12, n2.p, n1.p);
            var d = vec2.len(v12) - e.d;
            var w = n2.w / (n1.w + n2.w);
            if (isNaN(w)) {
              w = 0;
            }
            vec2.normalize(v12, v12);
            !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
            !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
          }
          for (var i2 = 0; i2 < nLen; i2++) {
            var n3 = nodes[i2];
            if (!n3.fixed) {
              vec2.sub(v12, center, n3.p);
              scaleAndAdd(n3.p, n3.p, v12, gravity * friction);
            }
          }
          for (var i2 = 0; i2 < nLen; i2++) {
            var n1 = nodes[i2];
            for (var j = i2 + 1; j < nLen; j++) {
              var n2 = nodes[j];
              vec2.sub(v12, n2.p, n1.p);
              var d = vec2.len(v12);
              if (d === 0) {
                vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
                d = 1;
              }
              var repFact = (n1.rep + n2.rep) / d / d;
              !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
              !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
            }
          }
          var v = [];
          for (var i2 = 0; i2 < nLen; i2++) {
            var n3 = nodes[i2];
            if (!n3.fixed) {
              vec2.sub(v, n3.p, n3.pp);
              scaleAndAdd(n3.p, n3.p, v, friction);
              vec2.copy(n3.pp, n3.p);
            }
          }
          friction = friction * 0.992;
          cb && cb(nodes, edges, friction < 0.01);
        }
      };
    }
    exports.forceLayout = forceLayout;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceLayout.js
var require_forceLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/forceLayout.js"(exports, module) {
    var _forceHelper = require_forceHelper();
    var forceLayout = _forceHelper.forceLayout;
    var _simpleLayoutHelper = require_simpleLayoutHelper();
    var simpleLayout = _simpleLayoutHelper.simpleLayout;
    var _circularLayoutHelper = require_circularLayoutHelper();
    var circularLayout = _circularLayoutHelper.circularLayout;
    var _number = require_number();
    var linearMap = _number.linearMap;
    var vec2 = require_vector();
    var zrUtil = require_util();
    var _multipleGraphEdgeHelper = require_multipleGraphEdgeHelper();
    var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
    function _default(ecModel) {
      ecModel.eachSeriesByType("graph", function(graphSeries) {
        var coordSys = graphSeries.coordinateSystem;
        if (coordSys && coordSys.type !== "view") {
          return;
        }
        if (graphSeries.get("layout") === "force") {
          var preservedPoints = graphSeries.preservedPoints || {};
          var graph = graphSeries.getGraph();
          var nodeData = graph.data;
          var edgeData = graph.edgeData;
          var forceModel = graphSeries.getModel("force");
          var initLayout = forceModel.get("initLayout");
          if (graphSeries.preservedPoints) {
            nodeData.each(function(idx) {
              var id = nodeData.getId(idx);
              nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
            });
          } else if (!initLayout || initLayout === "none") {
            simpleLayout(graphSeries);
          } else if (initLayout === "circular") {
            circularLayout(graphSeries, "value");
          }
          var nodeDataExtent = nodeData.getDataExtent("value");
          var edgeDataExtent = edgeData.getDataExtent("value");
          var repulsion = forceModel.get("repulsion");
          var edgeLength = forceModel.get("edgeLength");
          if (!zrUtil.isArray(repulsion)) {
            repulsion = [repulsion, repulsion];
          }
          if (!zrUtil.isArray(edgeLength)) {
            edgeLength = [edgeLength, edgeLength];
          }
          edgeLength = [edgeLength[1], edgeLength[0]];
          var nodes = nodeData.mapArray("value", function(value, idx) {
            var point = nodeData.getItemLayout(idx);
            var rep = linearMap(value, nodeDataExtent, repulsion);
            if (isNaN(rep)) {
              rep = (repulsion[0] + repulsion[1]) / 2;
            }
            return {
              w: rep,
              rep,
              fixed: nodeData.getItemModel(idx).get("fixed"),
              p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
            };
          });
          var edges = edgeData.mapArray("value", function(value, idx) {
            var edge = graph.getEdgeByIndex(idx);
            var d = linearMap(value, edgeDataExtent, edgeLength);
            if (isNaN(d)) {
              d = (edgeLength[0] + edgeLength[1]) / 2;
            }
            var edgeModel = edge.getModel();
            var curveness = zrUtil.retrieve3(edgeModel.get("lineStyle.curveness"), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
            return {
              n1: nodes[edge.node1.dataIndex],
              n2: nodes[edge.node2.dataIndex],
              d,
              curveness,
              ignoreForceLayout: edgeModel.get("ignoreForceLayout")
            };
          });
          var coordSys = graphSeries.coordinateSystem;
          var rect = coordSys.getBoundingRect();
          var forceInstance = forceLayout(nodes, edges, {
            rect,
            gravity: forceModel.get("gravity"),
            friction: forceModel.get("friction")
          });
          var oldStep = forceInstance.step;
          forceInstance.step = function(cb) {
            for (var i = 0, l = nodes.length; i < l; i++) {
              if (nodes[i].fixed) {
                vec2.copy(nodes[i].p, graph.getNodeByIndex(i).getLayout());
              }
            }
            oldStep(function(nodes2, edges2, stopped) {
              for (var i2 = 0, l2 = nodes2.length; i2 < l2; i2++) {
                if (!nodes2[i2].fixed) {
                  graph.getNodeByIndex(i2).setLayout(nodes2[i2].p);
                }
                preservedPoints[nodeData.getId(i2)] = nodes2[i2].p;
              }
              for (var i2 = 0, l2 = edges2.length; i2 < l2; i2++) {
                var e = edges2[i2];
                var edge = graph.getEdgeByIndex(i2);
                var p1 = e.n1.p;
                var p2 = e.n2.p;
                var points = edge.getLayout();
                points = points ? points.slice() : [];
                points[0] = points[0] || [];
                points[1] = points[1] || [];
                vec2.copy(points[0], p1);
                vec2.copy(points[1], p2);
                if (+e.curveness) {
                  points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness];
                }
                edge.setLayout(points);
              }
              cb && cb(stopped);
            });
          };
          graphSeries.forceLayout = forceInstance;
          graphSeries.preservedPoints = preservedPoints;
          forceInstance.step();
        } else {
          graphSeries.forceLayout = null;
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/createView.js
var require_createView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph/createView.js"(exports, module) {
    var View = require_View();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var bbox = require_bbox();
    function getViewRect(seriesModel, api, aspect) {
      var option = seriesModel.getBoxLayoutParams();
      option.aspect = aspect;
      return getLayoutRect(option, {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function _default(ecModel, api) {
      var viewList = [];
      ecModel.eachSeriesByType("graph", function(seriesModel) {
        var coordSysType = seriesModel.get("coordinateSystem");
        if (!coordSysType || coordSysType === "view") {
          var data = seriesModel.getData();
          var positions = data.mapArray(function(idx) {
            var itemModel = data.getItemModel(idx);
            return [+itemModel.get("x"), +itemModel.get("y")];
          });
          var min = [];
          var max = [];
          bbox.fromPoints(positions, min, max);
          if (max[0] - min[0] === 0) {
            max[0] += 1;
            min[0] -= 1;
          }
          if (max[1] - min[1] === 0) {
            max[1] += 1;
            min[1] -= 1;
          }
          var aspect = (max[0] - min[0]) / (max[1] - min[1]);
          var viewRect = getViewRect(seriesModel, api, aspect);
          if (isNaN(aspect)) {
            min = [viewRect.x, viewRect.y];
            max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];
          }
          var bbWidth = max[0] - min[0];
          var bbHeight = max[1] - min[1];
          var viewWidth = viewRect.width;
          var viewHeight = viewRect.height;
          var viewCoordSys = seriesModel.coordinateSystem = new View();
          viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
          viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);
          viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight);
          viewCoordSys.setCenter(seriesModel.get("center"));
          viewCoordSys.setZoom(seriesModel.get("zoom"));
          viewList.push(viewCoordSys);
        }
      });
      return viewList;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph.js
var require_graph = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/graph.js"() {
    var echarts = require_echarts();
    require_GraphSeries();
    require_GraphView();
    require_graphAction();
    var categoryFilter = require_categoryFilter();
    var visualSymbol = require_symbol2();
    var categoryVisual = require_categoryVisual();
    var edgeVisual = require_edgeVisual();
    var simpleLayout = require_simpleLayout();
    var circularLayout = require_circularLayout();
    var forceLayout = require_forceLayout();
    var createView = require_createView();
    echarts.registerProcessor(categoryFilter);
    echarts.registerVisual(visualSymbol("graph", "circle", null));
    echarts.registerVisual(categoryVisual);
    echarts.registerVisual(edgeVisual);
    echarts.registerLayout(simpleLayout);
    echarts.registerLayout(echarts.PRIORITY.VISUAL.POST_CHART_LAYOUT, circularLayout);
    echarts.registerLayout(forceLayout);
    echarts.registerCoordinateSystem("graphView", {
      create: createView
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeSeries.js
var require_GaugeSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeSeries.js"(exports, module) {
    var createListSimply = require_createListSimply();
    var SeriesModel = require_Series();
    var GaugeSeries = SeriesModel.extend({
      type: "series.gauge",
      getInitialData: function(option, ecModel) {
        return createListSimply(this, ["value"]);
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        // 默认全局居中
        center: ["50%", "50%"],
        legendHoverLink: true,
        radius: "75%",
        startAngle: 225,
        endAngle: -45,
        clockwise: true,
        // 最小值
        min: 0,
        // 最大值
        max: 100,
        // 分割段数，默认为10
        splitNumber: 10,
        // 坐标轴线
        axisLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          lineStyle: {
            // 属性lineStyle控制线条样式
            color: [[0.2, "#91c7ae"], [0.8, "#63869e"], [1, "#c23531"]],
            width: 30
          }
        },
        // 分隔线
        splitLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          // 属性length控制线长
          length: 30,
          // 属性lineStyle（详见lineStyle）控制线条样式
          lineStyle: {
            color: "#eee",
            width: 2,
            type: "solid"
          }
        },
        // 坐标轴小标记
        axisTick: {
          // 属性show控制显示与否，默认不显示
          show: true,
          // 每份split细分多少段
          splitNumber: 5,
          // 属性length控制线长
          length: 8,
          // 属性lineStyle控制线条样式
          lineStyle: {
            color: "#eee",
            width: 1,
            type: "solid"
          }
        },
        axisLabel: {
          show: true,
          distance: 5,
          // formatter: null,
          color: "auto"
        },
        pointer: {
          show: true,
          length: "80%",
          width: 8
        },
        itemStyle: {
          color: "auto"
        },
        title: {
          show: true,
          // x, y，单位px
          offsetCenter: [0, "-40%"],
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#333",
          fontSize: 15
        },
        detail: {
          show: true,
          backgroundColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          borderColor: "#ccc",
          width: 100,
          height: null,
          // self-adaption
          padding: [5, 10],
          // x, y，单位px
          offsetCenter: [0, "40%"],
          // formatter: null,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "auto",
          fontSize: 30
        }
      }
    });
    var _default = GaugeSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/PointerPath.js
var require_PointerPath = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/PointerPath.js"(exports, module) {
    var Path = require_Path();
    var _default = Path.extend({
      type: "echartsGaugePointer",
      shape: {
        angle: 0,
        width: 10,
        r: 10,
        x: 0,
        y: 0
      },
      buildPath: function(ctx, shape) {
        var mathCos = Math.cos;
        var mathSin = Math.sin;
        var r = shape.r;
        var width = shape.width;
        var angle = shape.angle;
        var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
        var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);
        angle = shape.angle - Math.PI / 2;
        ctx.moveTo(x, y);
        ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);
        ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);
        ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);
        ctx.lineTo(x, y);
        return;
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeView.js
var require_GaugeView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge/GaugeView.js"(exports, module) {
    var PointerPath = require_PointerPath();
    var graphic = require_graphic();
    var ChartView = require_Chart();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var round = _number.round;
    var linearMap = _number.linearMap;
    function parsePosition(seriesModel, api) {
      var center = seriesModel.get("center");
      var width = api.getWidth();
      var height = api.getHeight();
      var size = Math.min(width, height);
      var cx = parsePercent(center[0], api.getWidth());
      var cy = parsePercent(center[1], api.getHeight());
      var r = parsePercent(seriesModel.get("radius"), size / 2);
      return {
        cx,
        cy,
        r
      };
    }
    function formatLabel(label, labelFormatter) {
      if (labelFormatter) {
        if (typeof labelFormatter === "string") {
          label = labelFormatter.replace("{value}", label != null ? label : "");
        } else if (typeof labelFormatter === "function") {
          label = labelFormatter(label);
        }
      }
      return label;
    }
    var PI2 = Math.PI * 2;
    var GaugeView = ChartView.extend({
      type: "gauge",
      render: function(seriesModel, ecModel, api) {
        this.group.removeAll();
        var colorList = seriesModel.get("axisLine.lineStyle.color");
        var posInfo = parsePosition(seriesModel, api);
        this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
      },
      dispose: function() {
      },
      _renderMain: function(seriesModel, ecModel, api, colorList, posInfo) {
        var group = this.group;
        var axisLineModel = seriesModel.getModel("axisLine");
        var lineStyleModel = axisLineModel.getModel("lineStyle");
        var clockwise = seriesModel.get("clockwise");
        var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
        var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
        var angleRangeSpan = (endAngle - startAngle) % PI2;
        var prevEndAngle = startAngle;
        var axisLineWidth = lineStyleModel.get("width");
        var showAxis = axisLineModel.get("show");
        for (var i = 0; showAxis && i < colorList.length; i++) {
          var percent = Math.min(Math.max(colorList[i][0], 0), 1);
          var endAngle = startAngle + angleRangeSpan * percent;
          var sector = new graphic.Sector({
            shape: {
              startAngle: prevEndAngle,
              endAngle,
              cx: posInfo.cx,
              cy: posInfo.cy,
              clockwise,
              r0: posInfo.r - axisLineWidth,
              r: posInfo.r
            },
            silent: true
          });
          sector.setStyle({
            fill: colorList[i][1]
          });
          sector.setStyle(lineStyleModel.getLineStyle(
            // Because we use sector to simulate arc
            // so the properties for stroking are useless
            ["color", "borderWidth", "borderColor"]
          ));
          group.add(sector);
          prevEndAngle = endAngle;
        }
        var getColor = function(percent2) {
          if (percent2 <= 0) {
            return colorList[0][1];
          }
          for (var i2 = 0; i2 < colorList.length; i2++) {
            if (colorList[i2][0] >= percent2 && (i2 === 0 ? 0 : colorList[i2 - 1][0]) < percent2) {
              return colorList[i2][1];
            }
          }
          return colorList[i2 - 1][1];
        };
        if (!clockwise) {
          var tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
        }
        this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
        this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
        this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);
        this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);
      },
      _renderTicks: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
        var group = this.group;
        var cx = posInfo.cx;
        var cy = posInfo.cy;
        var r = posInfo.r;
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        var splitLineModel = seriesModel.getModel("splitLine");
        var tickModel = seriesModel.getModel("axisTick");
        var labelModel = seriesModel.getModel("axisLabel");
        var splitNumber = seriesModel.get("splitNumber");
        var subSplitNumber = tickModel.get("splitNumber");
        var splitLineLen = parsePercent(splitLineModel.get("length"), r);
        var tickLen = parsePercent(tickModel.get("length"), r);
        var angle = startAngle;
        var step = (endAngle - startAngle) / splitNumber;
        var subStep = step / subSplitNumber;
        var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
        var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
        for (var i = 0; i <= splitNumber; i++) {
          var unitX = Math.cos(angle);
          var unitY = Math.sin(angle);
          if (splitLineModel.get("show")) {
            var splitLine = new graphic.Line({
              shape: {
                x1: unitX * r + cx,
                y1: unitY * r + cy,
                x2: unitX * (r - splitLineLen) + cx,
                y2: unitY * (r - splitLineLen) + cy
              },
              style: splitLineStyle,
              silent: true
            });
            if (splitLineStyle.stroke === "auto") {
              splitLine.setStyle({
                stroke: getColor(i / splitNumber)
              });
            }
            group.add(splitLine);
          }
          if (labelModel.get("show")) {
            var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
            var distance = labelModel.get("distance");
            var autoColor = getColor(i / splitNumber);
            group.add(new graphic.Text({
              style: graphic.setTextStyle({}, labelModel, {
                text: label,
                x: unitX * (r - splitLineLen - distance) + cx,
                y: unitY * (r - splitLineLen - distance) + cy,
                textVerticalAlign: unitY < -0.4 ? "top" : unitY > 0.4 ? "bottom" : "middle",
                textAlign: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
              }, {
                autoColor
              }),
              silent: true
            }));
          }
          if (tickModel.get("show") && i !== splitNumber) {
            for (var j = 0; j <= subSplitNumber; j++) {
              var unitX = Math.cos(angle);
              var unitY = Math.sin(angle);
              var tickLine = new graphic.Line({
                shape: {
                  x1: unitX * r + cx,
                  y1: unitY * r + cy,
                  x2: unitX * (r - tickLen) + cx,
                  y2: unitY * (r - tickLen) + cy
                },
                silent: true,
                style: tickLineStyle
              });
              if (tickLineStyle.stroke === "auto") {
                tickLine.setStyle({
                  stroke: getColor((i + j / subSplitNumber) / splitNumber)
                });
              }
              group.add(tickLine);
              angle += subStep;
            }
            angle -= subStep;
          } else {
            angle += step;
          }
        }
      },
      _renderPointer: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
        var group = this.group;
        var oldData = this._data;
        if (!seriesModel.get("pointer.show")) {
          oldData && oldData.eachItemGraphicEl(function(el) {
            group.remove(el);
          });
          return;
        }
        var valueExtent = [+seriesModel.get("min"), +seriesModel.get("max")];
        var angleExtent = [startAngle, endAngle];
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        data.diff(oldData).add(function(idx) {
          var pointer = new PointerPath({
            shape: {
              angle: startAngle
            }
          });
          graphic.initProps(pointer, {
            shape: {
              angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)
            }
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }).update(function(newIdx, oldIdx) {
          var pointer = oldData.getItemGraphicEl(oldIdx);
          graphic.updateProps(pointer, {
            shape: {
              angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)
            }
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }).remove(function(idx) {
          var pointer = oldData.getItemGraphicEl(idx);
          group.remove(pointer);
        }).execute();
        data.eachItemGraphicEl(function(pointer, idx) {
          var itemModel = data.getItemModel(idx);
          var pointerModel = itemModel.getModel("pointer");
          pointer.setShape({
            x: posInfo.cx,
            y: posInfo.cy,
            width: parsePercent(pointerModel.get("width"), posInfo.r),
            r: parsePercent(pointerModel.get("length"), posInfo.r)
          });
          pointer.useStyle(itemModel.getModel("itemStyle").getItemStyle());
          if (pointer.style.fill === "auto") {
            pointer.setStyle("fill", getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }
          graphic.setHoverStyle(pointer, itemModel.getModel("emphasis.itemStyle").getItemStyle());
        });
        this._data = data;
      },
      _renderTitle: function(seriesModel, ecModel, api, getColor, posInfo) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var titleModel = seriesModel.getModel("title");
        if (titleModel.get("show")) {
          var offsetCenter = titleModel.get("offsetCenter");
          var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
          var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
          var minVal = +seriesModel.get("min");
          var maxVal = +seriesModel.get("max");
          var value = seriesModel.getData().get(valueDim, 0);
          var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
          this.group.add(new graphic.Text({
            silent: true,
            style: graphic.setTextStyle({}, titleModel, {
              x,
              y,
              // FIXME First data name ?
              text: data.getName(0),
              textAlign: "center",
              textVerticalAlign: "middle"
            }, {
              autoColor,
              forceRich: true
            })
          }));
        }
      },
      _renderDetail: function(seriesModel, ecModel, api, getColor, posInfo) {
        var detailModel = seriesModel.getModel("detail");
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        if (detailModel.get("show")) {
          var offsetCenter = detailModel.get("offsetCenter");
          var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
          var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
          var width = parsePercent(detailModel.get("width"), posInfo.r);
          var height = parsePercent(detailModel.get("height"), posInfo.r);
          var data = seriesModel.getData();
          var value = data.get(data.mapDimension("value"), 0);
          var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
          this.group.add(new graphic.Text({
            silent: true,
            style: graphic.setTextStyle({}, detailModel, {
              x,
              y,
              text: formatLabel(
                // FIXME First data name ?
                value,
                detailModel.get("formatter")
              ),
              textWidth: isNaN(width) ? null : width,
              textHeight: isNaN(height) ? null : height,
              textAlign: "center",
              textVerticalAlign: "middle"
            }, {
              autoColor,
              forceRich: true
            })
          }));
        }
      }
    });
    var _default = GaugeView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge.js
var require_gauge = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/gauge.js"() {
    require_GaugeSeries();
    require_GaugeView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelSeries.js
var require_FunnelSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelSeries.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var createListSimply = require_createListSimply();
    var _model = require_model();
    var defaultEmphasis = _model.defaultEmphasis;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForNameBased = _sourceHelper.makeSeriesEncodeForNameBased;
    var LegendVisualProvider = require_LegendVisualProvider();
    var FunnelSeries = echarts.extendSeriesModel({
      type: "series.funnel",
      init: function(option) {
        FunnelSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
        this._defaultLabelLine(option);
      },
      getInitialData: function(option, ecModel) {
        return createListSimply(this, {
          coordDimensions: ["value"],
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForNameBased, this)
        });
      },
      _defaultLabelLine: function(option) {
        defaultEmphasis(option, "labelLine", ["show"]);
        var labelLineNormalOpt = option.labelLine;
        var labelLineEmphasisOpt = option.emphasis.labelLine;
        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
      },
      // Overwrite
      getDataParams: function(dataIndex) {
        var data = this.getData();
        var params = FunnelSeries.superCall(this, "getDataParams", dataIndex);
        var valueDim = data.mapDimension("value");
        var sum = data.getSum(valueDim);
        params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);
        params.$vars.push("percent");
        return params;
      },
      defaultOption: {
        zlevel: 0,
        // 一级层叠
        z: 2,
        // 二级层叠
        legendHoverLink: true,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        // 默认取数据最小最大值
        // min: 0,
        // max: 100,
        minSize: "0%",
        maxSize: "100%",
        sort: "descending",
        // 'ascending', 'descending'
        orient: "vertical",
        gap: 0,
        funnelAlign: "center",
        label: {
          show: true,
          position: "outer"
          // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
        },
        labelLine: {
          show: true,
          length: 20,
          lineStyle: {
            // color: 各异,
            width: 1,
            type: "solid"
          }
        },
        itemStyle: {
          // color: 各异,
          borderColor: "#fff",
          borderWidth: 1
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    var _default = FunnelSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelView.js
var require_FunnelView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/FunnelView.js"(exports, module) {
    var graphic = require_graphic();
    var zrUtil = require_util();
    var ChartView = require_Chart();
    function FunnelPiece(data, idx) {
      graphic.Group.call(this);
      var polygon = new graphic.Polygon();
      var labelLine = new graphic.Polyline();
      var text = new graphic.Text();
      this.add(polygon);
      this.add(labelLine);
      this.add(text);
      this.highDownOnUpdate = function(fromState, toState) {
        if (toState === "emphasis") {
          labelLine.ignore = labelLine.hoverIgnore;
          text.ignore = text.hoverIgnore;
        } else {
          labelLine.ignore = labelLine.normalIgnore;
          text.ignore = text.normalIgnore;
        }
      };
      this.updateData(data, idx, true);
    }
    var funnelPieceProto = FunnelPiece.prototype;
    var opacityAccessPath = ["itemStyle", "opacity"];
    funnelPieceProto.updateData = function(data, idx, firstCreate) {
      var polygon = this.childAt(0);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var opacity = data.getItemModel(idx).get(opacityAccessPath);
      opacity = opacity == null ? 1 : opacity;
      polygon.useStyle({});
      if (firstCreate) {
        polygon.setShape({
          points: layout.points
        });
        polygon.setStyle({
          opacity: 0
        });
        graphic.initProps(polygon, {
          style: {
            opacity
          }
        }, seriesModel, idx);
      } else {
        graphic.updateProps(polygon, {
          style: {
            opacity
          },
          shape: {
            points: layout.points
          }
        }, seriesModel, idx);
      }
      var itemStyleModel = itemModel.getModel("itemStyle");
      var visualColor = data.getItemVisual(idx, "color");
      polygon.setStyle(zrUtil.defaults({
        lineJoin: "round",
        fill: visualColor
      }, itemStyleModel.getItemStyle(["opacity"])));
      polygon.hoverStyle = itemStyleModel.getModel("emphasis").getItemStyle();
      this._updateLabel(data, idx);
      graphic.setHoverStyle(this);
    };
    funnelPieceProto._updateLabel = function(data, idx) {
      var labelLine = this.childAt(1);
      var labelText = this.childAt(2);
      var seriesModel = data.hostModel;
      var itemModel = data.getItemModel(idx);
      var layout = data.getItemLayout(idx);
      var labelLayout = layout.label;
      var visualColor = data.getItemVisual(idx, "color");
      graphic.updateProps(labelLine, {
        shape: {
          points: labelLayout.linePoints || labelLayout.linePoints
        }
      }, seriesModel, idx);
      graphic.updateProps(labelText, {
        style: {
          x: labelLayout.x,
          y: labelLayout.y
        }
      }, seriesModel, idx);
      labelText.attr({
        rotation: labelLayout.rotation,
        origin: [labelLayout.x, labelLayout.y],
        z2: 10
      });
      var labelModel = itemModel.getModel("label");
      var labelHoverModel = itemModel.getModel("emphasis.label");
      var labelLineModel = itemModel.getModel("labelLine");
      var labelLineHoverModel = itemModel.getModel("emphasis.labelLine");
      var visualColor = data.getItemVisual(idx, "color");
      graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
        labelFetcher: data.hostModel,
        labelDataIndex: idx,
        defaultText: data.getName(idx),
        autoColor: visualColor,
        useInsideStyle: !!labelLayout.inside
      }, {
        textAlign: labelLayout.textAlign,
        textVerticalAlign: labelLayout.verticalAlign
      });
      labelText.ignore = labelText.normalIgnore = !labelModel.get("show");
      labelText.hoverIgnore = !labelHoverModel.get("show");
      labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get("show");
      labelLine.hoverIgnore = !labelLineHoverModel.get("show");
      labelLine.setStyle({
        stroke: visualColor
      });
      labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle());
      labelLine.hoverStyle = labelLineHoverModel.getModel("lineStyle").getLineStyle();
    };
    zrUtil.inherits(FunnelPiece, graphic.Group);
    var FunnelView = ChartView.extend({
      type: "funnel",
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        data.diff(oldData).add(function(idx) {
          var funnelPiece = new FunnelPiece(data, idx);
          data.setItemGraphicEl(idx, funnelPiece);
          group.add(funnelPiece);
        }).update(function(newIdx, oldIdx) {
          var piePiece = oldData.getItemGraphicEl(oldIdx);
          piePiece.updateData(data, newIdx);
          group.add(piePiece);
          data.setItemGraphicEl(newIdx, piePiece);
        }).remove(function(idx) {
          var piePiece = oldData.getItemGraphicEl(idx);
          group.remove(piePiece);
        }).execute();
        this._data = data;
      },
      remove: function() {
        this.group.removeAll();
        this._data = null;
      },
      dispose: function() {
      }
    });
    var _default = FunnelView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/funnelLayout.js
var require_funnelLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel/funnelLayout.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var layout = require_layout();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var linearMap = _number.linearMap;
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function getSortedIndices(data, sort) {
      var valueDim = data.mapDimension("value");
      var valueArr = data.mapArray(valueDim, function(val) {
        return val;
      });
      var indices = [];
      var isAscending = sort === "ascending";
      for (var i = 0, len = data.count(); i < len; i++) {
        indices[i] = i;
      }
      if (typeof sort === "function") {
        indices.sort(sort);
      } else if (sort !== "none") {
        indices.sort(function(a, b) {
          return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
        });
      }
      return indices;
    }
    function labelLayout(data) {
      data.each(function(idx) {
        var itemModel = data.getItemModel(idx);
        var labelModel = itemModel.getModel("label");
        var labelPosition = labelModel.get("position");
        var orient = itemModel.get("orient");
        var labelLineModel = itemModel.getModel("labelLine");
        var layout2 = data.getItemLayout(idx);
        var points = layout2.points;
        var isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
        var textAlign;
        var textX;
        var textY;
        var linePoints;
        if (isLabelInside) {
          if (labelPosition === "insideLeft") {
            textX = (points[0][0] + points[3][0]) / 2 + 5;
            textY = (points[0][1] + points[3][1]) / 2;
            textAlign = "left";
          } else if (labelPosition === "insideRight") {
            textX = (points[1][0] + points[2][0]) / 2 - 5;
            textY = (points[1][1] + points[2][1]) / 2;
            textAlign = "right";
          } else {
            textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
            textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
            textAlign = "center";
          }
          linePoints = [[textX, textY], [textX, textY]];
        } else {
          var x1;
          var y1;
          var x2;
          var y2;
          var labelLineLen = labelLineModel.get("length");
          if (labelPosition === "left") {
            x1 = (points[3][0] + points[0][0]) / 2;
            y1 = (points[3][1] + points[0][1]) / 2;
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = "right";
          } else if (labelPosition === "right") {
            x1 = (points[1][0] + points[2][0]) / 2;
            y1 = (points[1][1] + points[2][1]) / 2;
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "left";
          } else if (labelPosition === "top") {
            x1 = (points[3][0] + points[0][0]) / 2;
            y1 = (points[3][1] + points[0][1]) / 2;
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = "center";
          } else if (labelPosition === "bottom") {
            x1 = (points[1][0] + points[2][0]) / 2;
            y1 = (points[1][1] + points[2][1]) / 2;
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else if (labelPosition === "rightTop") {
            x1 = orient === "horizontal" ? points[3][0] : points[1][0];
            y1 = orient === "horizontal" ? points[3][1] : points[1][1];
            if (orient === "horizontal") {
              y2 = y1 - labelLineLen;
              textY = y2 - 5;
              textAlign = "center";
            } else {
              x2 = x1 + labelLineLen;
              textX = x2 + 5;
              textAlign = "top";
            }
          } else if (labelPosition === "rightBottom") {
            x1 = points[2][0];
            y1 = points[2][1];
            if (orient === "horizontal") {
              y2 = y1 + labelLineLen;
              textY = y2 + 5;
              textAlign = "center";
            } else {
              x2 = x1 + labelLineLen;
              textX = x2 + 5;
              textAlign = "bottom";
            }
          } else if (labelPosition === "leftTop") {
            x1 = points[0][0];
            y1 = orient === "horizontal" ? points[0][1] : points[1][1];
            if (orient === "horizontal") {
              y2 = y1 - labelLineLen;
              textY = y2 - 5;
              textAlign = "center";
            } else {
              x2 = x1 - labelLineLen;
              textX = x2 - 5;
              textAlign = "right";
            }
          } else if (labelPosition === "leftBottom") {
            x1 = orient === "horizontal" ? points[1][0] : points[3][0];
            y1 = orient === "horizontal" ? points[1][1] : points[2][1];
            if (orient === "horizontal") {
              y2 = y1 + labelLineLen;
              textY = y2 + 5;
              textAlign = "center";
            } else {
              x2 = x1 - labelLineLen;
              textX = x2 - 5;
              textAlign = "right";
            }
          } else {
            x1 = (points[1][0] + points[2][0]) / 2;
            y1 = (points[1][1] + points[2][1]) / 2;
            if (orient === "horizontal") {
              y2 = y1 + labelLineLen;
              textY = y2 + 5;
              textAlign = "center";
            } else {
              x2 = x1 + labelLineLen;
              textX = x2 + 5;
              textAlign = "left";
            }
          }
          if (orient === "horizontal") {
            x2 = x1;
            textX = x2;
          } else {
            y2 = y1;
            textY = y2;
          }
          linePoints = [[x1, y1], [x2, y2]];
        }
        layout2.label = {
          linePoints,
          x: textX,
          y: textY,
          verticalAlign: "middle",
          textAlign,
          inside: isLabelInside
        };
      });
    }
    function _default(ecModel, api, payload) {
      ecModel.eachSeriesByType("funnel", function(seriesModel) {
        var data = seriesModel.getData();
        var valueDim = data.mapDimension("value");
        var sort = seriesModel.get("sort");
        var viewRect = getViewRect(seriesModel, api);
        var indices = getSortedIndices(data, sort);
        var orient = seriesModel.get("orient");
        var viewWidth = viewRect.width;
        var viewHeight = viewRect.height;
        var x = viewRect.x;
        var y = viewRect.y;
        var sizeExtent = orient === "horizontal" ? [parsePercent(seriesModel.get("minSize"), viewHeight), parsePercent(seriesModel.get("maxSize"), viewHeight)] : [parsePercent(seriesModel.get("minSize"), viewWidth), parsePercent(seriesModel.get("maxSize"), viewWidth)];
        var dataExtent = data.getDataExtent(valueDim);
        var min = seriesModel.get("min");
        var max = seriesModel.get("max");
        if (min == null) {
          min = Math.min(dataExtent[0], 0);
        }
        if (max == null) {
          max = dataExtent[1];
        }
        var funnelAlign = seriesModel.get("funnelAlign");
        var gap = seriesModel.get("gap");
        var viewSize = orient === "horizontal" ? viewWidth : viewHeight;
        var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
        var getLinePoints = function(idx2, offset) {
          if (orient === "horizontal") {
            var val = data.get(valueDim, idx2) || 0;
            var itemHeight = linearMap(val, [min, max], sizeExtent, true);
            var y0;
            switch (funnelAlign) {
              case "top":
                y0 = y;
                break;
              case "center":
                y0 = y + (viewHeight - itemHeight) / 2;
                break;
              case "bottom":
                y0 = y + (viewHeight - itemHeight);
                break;
            }
            return [[offset, y0], [offset, y0 + itemHeight]];
          }
          var val = data.get(valueDim, idx2) || 0;
          var itemWidth = linearMap(val, [min, max], sizeExtent, true);
          var x0;
          switch (funnelAlign) {
            case "left":
              x0 = x;
              break;
            case "center":
              x0 = x + (viewWidth - itemWidth) / 2;
              break;
            case "right":
              x0 = x + viewWidth - itemWidth;
              break;
          }
          return [[x0, offset], [x0 + itemWidth, offset]];
        };
        if (sort === "ascending") {
          itemSize = -itemSize;
          gap = -gap;
          if (orient === "horizontal") {
            x += viewWidth;
          } else {
            y += viewHeight;
          }
          indices = indices.reverse();
        }
        for (var i = 0; i < indices.length; i++) {
          var idx = indices[i];
          var nextIdx = indices[i + 1];
          var itemModel = data.getItemModel(idx);
          if (orient === "horizontal") {
            var width = itemModel.get("itemStyle.width");
            if (width == null) {
              width = itemSize;
            } else {
              width = parsePercent(width, viewWidth);
              if (sort === "ascending") {
                width = -width;
              }
            }
            var start = getLinePoints(idx, x);
            var end = getLinePoints(nextIdx, x + width);
            x += width + gap;
            data.setItemLayout(idx, {
              points: start.concat(end.slice().reverse())
            });
          } else {
            var height = itemModel.get("itemStyle.height");
            if (height == null) {
              height = itemSize;
            } else {
              height = parsePercent(height, viewHeight);
              if (sort === "ascending") {
                height = -height;
              }
            }
            var start = orient === "horizontal" ? getLinePoints(idx, x) : getLinePoints(idx, y);
            var end = orient === "horizontal" ? getLinePoints(nextIdx, x + width) : getLinePoints(nextIdx, y + height);
            y += height + gap;
            data.setItemLayout(idx, {
              points: start.concat(end.slice().reverse())
            });
          }
        }
        labelLayout(data);
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel.js
var require_funnel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/funnel.js"() {
    var echarts = require_echarts();
    require_FunnelSeries();
    require_FunnelView();
    var dataColor = require_dataColor();
    var funnelLayout = require_funnelLayout();
    var dataFilter = require_dataFilter();
    echarts.registerVisual(dataColor("funnel"));
    echarts.registerLayout(funnelLayout);
    echarts.registerProcessor(dataFilter("funnel"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js
var require_parallelPreprocessor = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelPreprocessor.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    function _default(option) {
      createParallelIfNeeded(option);
      mergeAxisOptionFromParallel(option);
    }
    function createParallelIfNeeded(option) {
      if (option.parallel) {
        return;
      }
      var hasParallelSeries = false;
      zrUtil.each(option.series, function(seriesOpt) {
        if (seriesOpt && seriesOpt.type === "parallel") {
          hasParallelSeries = true;
        }
      });
      if (hasParallelSeries) {
        option.parallel = [{}];
      }
    }
    function mergeAxisOptionFromParallel(option) {
      var axes = modelUtil.normalizeToArray(option.parallelAxis);
      zrUtil.each(axes, function(axisOption) {
        if (!zrUtil.isObject(axisOption)) {
          return;
        }
        var parallelIndex = axisOption.parallelIndex || 0;
        var parallelOption = modelUtil.normalizeToArray(option.parallel)[parallelIndex];
        if (parallelOption && parallelOption.parallelAxisDefault) {
          zrUtil.merge(axisOption, parallelOption.parallelAxisDefault, false);
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelAxis.js
var require_ParallelAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var ParallelAxis = function(dim, scale, coordExtent, axisType, axisIndex) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.axisIndex = axisIndex;
    };
    ParallelAxis.prototype = {
      constructor: ParallelAxis,
      /**
       * Axis model
       * @param {module:echarts/coord/parallel/AxisModel}
       */
      model: null,
      /**
       * @override
       */
      isHorizontal: function() {
        return this.coordinateSystem.getModel().get("layout") !== "horizontal";
      }
    };
    zrUtil.inherits(ParallelAxis, Axis);
    var _default = ParallelAxis;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/sliderMove.js
var require_sliderMove = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/sliderMove.js"(exports, module) {
    function _default(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
      delta = delta || 0;
      var extentSpan = extent[1] - extent[0];
      if (minSpan != null) {
        minSpan = restrict(minSpan, [0, extentSpan]);
      }
      if (maxSpan != null) {
        maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
      }
      if (handleIndex === "all") {
        var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
        handleSpan = restrict(handleSpan, [0, extentSpan]);
        minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
        handleIndex = 0;
      }
      handleEnds[0] = restrict(handleEnds[0], extent);
      handleEnds[1] = restrict(handleEnds[1], extent);
      var originalDistSign = getSpanSign(handleEnds, handleIndex);
      handleEnds[handleIndex] += delta;
      var extentMinSpan = minSpan || 0;
      var realExtent = extent.slice();
      originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
      handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
      var currDistSign = getSpanSign(handleEnds, handleIndex);
      if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
      }
      var currDistSign = getSpanSign(handleEnds, handleIndex);
      if (maxSpan != null && currDistSign.span > maxSpan) {
        handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
      }
      return handleEnds;
    }
    function getSpanSign(handleEnds, handleIndex) {
      var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
      return {
        span: Math.abs(dist),
        sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
      };
    }
    function restrict(value, extend) {
      return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/Parallel.js
var require_Parallel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/Parallel.js"(exports, module) {
    var zrUtil = require_util();
    var matrix = require_matrix();
    var layoutUtil = require_layout();
    var axisHelper = require_axisHelper();
    var ParallelAxis = require_ParallelAxis();
    var graphic = require_graphic();
    var numberUtil = require_number();
    var sliderMove = require_sliderMove();
    var each = zrUtil.each;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathFloor = Math.floor;
    var mathCeil = Math.ceil;
    var round = numberUtil.round;
    var PI = Math.PI;
    function Parallel(parallelModel, ecModel, api) {
      this._axesMap = zrUtil.createHashMap();
      this._axesLayout = {};
      this.dimensions = parallelModel.dimensions;
      this._rect;
      this._model = parallelModel;
      this._init(parallelModel, ecModel, api);
    }
    Parallel.prototype = {
      type: "parallel",
      constructor: Parallel,
      /**
       * Initialize cartesian coordinate systems
       * @private
       */
      _init: function(parallelModel, ecModel, api) {
        var dimensions = parallelModel.dimensions;
        var parallelAxisIndex = parallelModel.parallelAxisIndex;
        each(dimensions, function(dim, idx) {
          var axisIndex = parallelAxisIndex[idx];
          var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
          var axis = this._axesMap.set(dim, new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisIndex));
          var isCategory = axis.type === "category";
          axis.onBand = isCategory && axisModel.get("boundaryGap");
          axis.inverse = axisModel.get("inverse");
          axisModel.axis = axis;
          axis.model = axisModel;
          axis.coordinateSystem = axisModel.coordinateSystem = this;
        }, this);
      },
      /**
       * Update axis scale after data processed
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      update: function(ecModel, api) {
        this._updateAxesFromSeries(this._model, ecModel);
      },
      /**
       * @override
       */
      containPoint: function(point) {
        var layoutInfo = this._makeLayoutInfo();
        var axisBase = layoutInfo.axisBase;
        var layoutBase = layoutInfo.layoutBase;
        var pixelDimIndex = layoutInfo.pixelDimIndex;
        var pAxis = point[1 - pixelDimIndex];
        var pLayout = point[pixelDimIndex];
        return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
      },
      getModel: function() {
        return this._model;
      },
      /**
       * Update properties from series
       * @private
       */
      _updateAxesFromSeries: function(parallelModel, ecModel) {
        ecModel.eachSeries(function(seriesModel) {
          if (!parallelModel.contains(seriesModel, ecModel)) {
            return;
          }
          var data = seriesModel.getData();
          each(this.dimensions, function(dim) {
            var axis = this._axesMap.get(dim);
            axis.scale.unionExtentFromData(data, data.mapDimension(dim));
            axisHelper.niceScaleExtent(axis.scale, axis.model);
          }, this);
        }, this);
      },
      /**
       * Resize the parallel coordinate system.
       * @param {module:echarts/coord/parallel/ParallelModel} parallelModel
       * @param {module:echarts/ExtensionAPI} api
       */
      resize: function(parallelModel, api) {
        this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
        this._layoutAxes();
      },
      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getRect: function() {
        return this._rect;
      },
      /**
       * @private
       */
      _makeLayoutInfo: function() {
        var parallelModel = this._model;
        var rect = this._rect;
        var xy = ["x", "y"];
        var wh = ["width", "height"];
        var layout = parallelModel.get("layout");
        var pixelDimIndex = layout === "horizontal" ? 0 : 1;
        var layoutLength = rect[wh[pixelDimIndex]];
        var layoutExtent = [0, layoutLength];
        var axisCount = this.dimensions.length;
        var axisExpandWidth = restrict(parallelModel.get("axisExpandWidth"), layoutExtent);
        var axisExpandCount = restrict(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
        var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
        var axisExpandWindow = parallelModel.get("axisExpandWindow");
        var winSize;
        if (!axisExpandWindow) {
          winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
          var axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor(axisCount / 2);
          axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
          axisExpandWindow[1] = axisExpandWindow[0] + winSize;
        } else {
          winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
          axisExpandWindow[1] = axisExpandWindow[0] + winSize;
        }
        var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
        axisCollapseWidth < 3 && (axisCollapseWidth = 0);
        var winInnerIndices = [mathFloor(round(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
        var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
        return {
          layout,
          pixelDimIndex,
          layoutBase: rect[xy[pixelDimIndex]],
          layoutLength,
          axisBase: rect[xy[1 - pixelDimIndex]],
          axisLength: rect[wh[1 - pixelDimIndex]],
          axisExpandable,
          axisExpandWidth,
          axisCollapseWidth,
          axisExpandWindow,
          axisCount,
          winInnerIndices,
          axisExpandWindow0Pos
        };
      },
      /**
       * @private
       */
      _layoutAxes: function() {
        var rect = this._rect;
        var axes = this._axesMap;
        var dimensions = this.dimensions;
        var layoutInfo = this._makeLayoutInfo();
        var layout = layoutInfo.layout;
        axes.each(function(axis) {
          var axisExtent = [0, layoutInfo.axisLength];
          var idx = axis.inverse ? 1 : 0;
          axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
        });
        each(dimensions, function(dim, idx) {
          var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
          var positionTable = {
            horizontal: {
              x: posInfo.position,
              y: layoutInfo.axisLength
            },
            vertical: {
              x: 0,
              y: posInfo.position
            }
          };
          var rotationTable = {
            horizontal: PI / 2,
            vertical: 0
          };
          var position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y];
          var rotation = rotationTable[layout];
          var transform = matrix.create();
          matrix.rotate(transform, transform, rotation);
          matrix.translate(transform, transform, position);
          this._axesLayout[dim] = {
            position,
            rotation,
            transform,
            axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
            axisLabelShow: posInfo.axisLabelShow,
            nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
            tickDirection: 1,
            labelDirection: 1
          };
        }, this);
      },
      /**
       * Get axis by dim.
       * @param {string} dim
       * @return {module:echarts/coord/parallel/ParallelAxis} [description]
       */
      getAxis: function(dim) {
        return this._axesMap.get(dim);
      },
      /**
       * Convert a dim value of a single item of series data to Point.
       * @param {*} value
       * @param {string} dim
       * @return {Array}
       */
      dataToPoint: function(value, dim) {
        return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
      },
      /**
       * Travel data for one time, get activeState of each data item.
       * @param {module:echarts/data/List} data
       * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'
       *                            {number} dataIndex
       * @param {number} [start=0] the start dataIndex that travel from.
       * @param {number} [end=data.count()] the next dataIndex of the last dataIndex will be travel.
       */
      eachActiveState: function(data, callback, start, end) {
        start == null && (start = 0);
        end == null && (end = data.count());
        var axesMap = this._axesMap;
        var dimensions = this.dimensions;
        var dataDimensions = [];
        var axisModels = [];
        zrUtil.each(dimensions, function(axisDim) {
          dataDimensions.push(data.mapDimension(axisDim));
          axisModels.push(axesMap.get(axisDim).model);
        });
        var hasActiveSet = this.hasAxisBrushed();
        for (var dataIndex = start; dataIndex < end; dataIndex++) {
          var activeState;
          if (!hasActiveSet) {
            activeState = "normal";
          } else {
            activeState = "active";
            var values = data.getValues(dataDimensions, dataIndex);
            for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
              var state = axisModels[j].getActiveState(values[j]);
              if (state === "inactive") {
                activeState = "inactive";
                break;
              }
            }
          }
          callback(activeState, dataIndex);
        }
      },
      /**
       * Whether has any activeSet.
       * @return {boolean}
       */
      hasAxisBrushed: function() {
        var dimensions = this.dimensions;
        var axesMap = this._axesMap;
        var hasActiveSet = false;
        for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
          if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
            hasActiveSet = true;
          }
        }
        return hasActiveSet;
      },
      /**
       * Convert coords of each axis to Point.
       *  Return point. For example: [10, 20]
       * @param {Array.<number>} coords
       * @param {string} dim
       * @return {Array.<number>}
       */
      axisCoordToPoint: function(coord, dim) {
        var axisLayout = this._axesLayout[dim];
        return graphic.applyTransform([coord, 0], axisLayout.transform);
      },
      /**
       * Get axis layout.
       */
      getAxisLayout: function(dim) {
        return zrUtil.clone(this._axesLayout[dim]);
      },
      /**
       * @param {Array.<number>} point
       * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
       */
      getSlidedAxisExpandWindow: function(point) {
        var layoutInfo = this._makeLayoutInfo();
        var pixelDimIndex = layoutInfo.pixelDimIndex;
        var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
        var winSize = axisExpandWindow[1] - axisExpandWindow[0];
        var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
        if (!this.containPoint(point)) {
          return {
            behavior: "none",
            axisExpandWindow
          };
        }
        var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
        var delta;
        var behavior = "slide";
        var axisCollapseWidth = layoutInfo.axisCollapseWidth;
        var triggerArea = this._model.get("axisExpandSlideTriggerArea");
        var useJump = triggerArea[0] != null;
        if (axisCollapseWidth) {
          if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
            behavior = "jump";
            delta = pointCoord - winSize * triggerArea[2];
          } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
            behavior = "jump";
            delta = pointCoord - winSize * (1 - triggerArea[2]);
          } else {
            (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
          }
          delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
          delta ? sliderMove(delta, axisExpandWindow, extent, "all") : behavior = "none";
        } else {
          var winSize = axisExpandWindow[1] - axisExpandWindow[0];
          var pos = extent[1] * pointCoord / winSize;
          axisExpandWindow = [mathMax(0, pos - winSize / 2)];
          axisExpandWindow[1] = mathMin(extent[1], axisExpandWindow[0] + winSize);
          axisExpandWindow[0] = axisExpandWindow[1] - winSize;
        }
        return {
          axisExpandWindow,
          behavior
        };
      }
    };
    function restrict(len, extent) {
      return mathMin(mathMax(len, extent[0]), extent[1]);
    }
    function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
      var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
      return {
        position: step * axisIndex,
        axisNameAvailableWidth: step,
        axisLabelShow: true
      };
    }
    function layoutAxisWithExpand(axisIndex, layoutInfo) {
      var layoutLength = layoutInfo.layoutLength;
      var axisExpandWidth = layoutInfo.axisExpandWidth;
      var axisCount = layoutInfo.axisCount;
      var axisCollapseWidth = layoutInfo.axisCollapseWidth;
      var winInnerIndices = layoutInfo.winInnerIndices;
      var position;
      var axisNameAvailableWidth = axisCollapseWidth;
      var axisLabelShow = false;
      var nameTruncateMaxWidth;
      if (axisIndex < winInnerIndices[0]) {
        position = axisIndex * axisCollapseWidth;
        nameTruncateMaxWidth = axisCollapseWidth;
      } else if (axisIndex <= winInnerIndices[1]) {
        position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
        axisNameAvailableWidth = axisExpandWidth;
        axisLabelShow = true;
      } else {
        position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
        nameTruncateMaxWidth = axisCollapseWidth;
      }
      return {
        position,
        axisNameAvailableWidth,
        axisLabelShow,
        nameTruncateMaxWidth
      };
    }
    var _default = Parallel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelCreator.js
var require_parallelCreator = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/parallelCreator.js"() {
    var Parallel = require_Parallel();
    var CoordinateSystem = require_CoordinateSystem();
    function create(ecModel, api) {
      var coordSysList = [];
      ecModel.eachComponent("parallel", function(parallelModel, idx) {
        var coordSys = new Parallel(parallelModel, ecModel, api);
        coordSys.name = "parallel_" + idx;
        coordSys.resize(parallelModel, api);
        parallelModel.coordinateSystem = coordSys;
        coordSys.model = parallelModel;
        coordSysList.push(coordSys);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === "parallel") {
          var parallelModel = ecModel.queryComponents({
            mainType: "parallel",
            index: seriesModel.get("parallelIndex"),
            id: seriesModel.get("parallelId")
          })[0];
          seriesModel.coordinateSystem = parallelModel.coordinateSystem;
        }
      });
      return coordSysList;
    }
    CoordinateSystem.register("parallel", {
      create
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/AxisModel.js
var require_AxisModel2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/AxisModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var makeStyleMapper = require_makeStyleMapper();
    var axisModelCreator = require_axisModelCreator();
    var numberUtil = require_number();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var AxisModel = ComponentModel.extend({
      type: "baseParallelAxis",
      /**
       * @type {module:echarts/coord/parallel/Axis}
       */
      axis: null,
      /**
       * @type {Array.<Array.<number>}
       * @readOnly
       */
      activeIntervals: [],
      /**
       * @return {Object}
       */
      getAreaSelectStyle: function() {
        return makeStyleMapper([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle"));
      },
      /**
       * The code of this feature is put on AxisModel but not ParallelAxis,
       * because axisModel can be alive after echarts updating but instance of
       * ParallelAxis having been disposed. this._activeInterval should be kept
       * when action dispatched (i.e. legend click).
       *
       * @param {Array.<Array<number>>} intervals interval.length === 0
       *                                          means set all active.
       * @public
       */
      setActiveIntervals: function(intervals) {
        var activeIntervals = this.activeIntervals = zrUtil.clone(intervals);
        if (activeIntervals) {
          for (var i = activeIntervals.length - 1; i >= 0; i--) {
            numberUtil.asc(activeIntervals[i]);
          }
        }
      },
      /**
       * @param {number|string} [value] When attempting to detect 'no activeIntervals set',
       *                         value can not be input.
       * @return {string} 'normal': no activeIntervals set,
       *                  'active',
       *                  'inactive'.
       * @public
       */
      getActiveState: function(value) {
        var activeIntervals = this.activeIntervals;
        if (!activeIntervals.length) {
          return "normal";
        }
        if (value == null || isNaN(value)) {
          return "inactive";
        }
        if (activeIntervals.length === 1) {
          var interval = activeIntervals[0];
          if (interval[0] <= value && value <= interval[1]) {
            return "active";
          }
        } else {
          for (var i = 0, len = activeIntervals.length; i < len; i++) {
            if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
              return "active";
            }
          }
        }
        return "inactive";
      }
    });
    var defaultOption = {
      type: "value",
      /**
       * @type {Array.<number>}
       */
      dim: null,
      // 0, 1, 2, ...
      // parallelIndex: null,
      areaSelectStyle: {
        width: 20,
        borderWidth: 1,
        borderColor: "rgba(160,197,232)",
        color: "rgba(160,197,232)",
        opacity: 0.3
      },
      realtime: true,
      // Whether realtime update view when select.
      z: 10
    };
    zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
    function getAxisType(axisName, option) {
      return option.type || (option.data ? "category" : "value");
    }
    axisModelCreator("parallel", AxisModel, getAxisType, defaultOption);
    var _default = AxisModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelModel.js
var require_ParallelModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/parallel/ParallelModel.js"(exports, module) {
    var zrUtil = require_util();
    var Component = require_Component();
    require_AxisModel2();
    var _default = Component.extend({
      type: "parallel",
      dependencies: ["parallelAxis"],
      /**
       * @type {module:echarts/coord/parallel/Parallel}
       */
      coordinateSystem: null,
      /**
       * Each item like: 'dim0', 'dim1', 'dim2', ...
       * @type {Array.<string>}
       * @readOnly
       */
      dimensions: null,
      /**
       * Coresponding to dimensions.
       * @type {Array.<number>}
       * @readOnly
       */
      parallelAxisIndex: null,
      layoutMode: "box",
      defaultOption: {
        zlevel: 0,
        z: 0,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        layout: "horizontal",
        // 'horizontal' or 'vertical'
        // FIXME
        // naming?
        axisExpandable: false,
        axisExpandCenter: null,
        axisExpandCount: 0,
        axisExpandWidth: 50,
        // FIXME '10%' ?
        axisExpandRate: 17,
        axisExpandDebounce: 50,
        // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
        // Do not doc to user until necessary.
        axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
        axisExpandTriggerOn: "click",
        // 'mousemove' or 'click'
        parallelAxisDefault: null
      },
      /**
       * @override
       */
      init: function() {
        Component.prototype.init.apply(this, arguments);
        this.mergeOption({});
      },
      /**
       * @override
       */
      mergeOption: function(newOption) {
        var thisOption = this.option;
        newOption && zrUtil.merge(thisOption, newOption, true);
        this._initDimensions();
      },
      /**
       * Whether series or axis is in this coordinate system.
       * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model
       * @param {module:echarts/model/Global} ecModel
       */
      contains: function(model, ecModel) {
        var parallelIndex = model.get("parallelIndex");
        return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
      },
      setAxisExpand: function(opt) {
        zrUtil.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(name2) {
          if (opt.hasOwnProperty(name2)) {
            this.option[name2] = opt[name2];
          }
        }, this);
      },
      /**
       * @private
       */
      _initDimensions: function() {
        var dimensions = this.dimensions = [];
        var parallelAxisIndex = this.parallelAxisIndex = [];
        var axisModels = zrUtil.filter(this.dependentModels.parallelAxis, function(axisModel) {
          return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
        }, this);
        zrUtil.each(axisModels, function(axisModel) {
          dimensions.push("dim" + axisModel.get("dim"));
          parallelAxisIndex.push(axisModel.componentIndex);
        });
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/parallelAxisAction.js
var require_parallelAxisAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/parallelAxisAction.js"() {
    var echarts = require_echarts();
    var actionInfo = {
      type: "axisAreaSelect",
      event: "axisAreaSelected"
      // update: 'updateVisual'
    };
    echarts.registerAction(actionInfo, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "parallelAxis",
        query: payload
      }, function(parallelAxisModel) {
        parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
      });
    });
    echarts.registerAction("parallelAxisExpand", function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "parallel",
        query: payload
      }, function(parallelModel) {
        parallelModel.setAxisExpand(payload);
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushController.js
var require_BrushController = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushController.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var Eventful = require_Eventful();
    var graphic = require_graphic();
    var interactionMutex = require_interactionMutex();
    var DataDiffer = require_DataDiffer();
    var curry = zrUtil.curry;
    var each = zrUtil.each;
    var map = zrUtil.map;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var mathPow = Math.pow;
    var COVER_Z = 1e4;
    var UNSELECT_THRESHOLD = 6;
    var MIN_RESIZE_LINE_WIDTH = 6;
    var MUTEX_RESOURCE_KEY = "globalPan";
    var DIRECTION_MAP = {
      w: [0, 0],
      e: [0, 1],
      n: [1, 0],
      s: [1, 1]
    };
    var CURSOR_MAP = {
      w: "ew",
      e: "ew",
      n: "ns",
      s: "ns",
      ne: "nesw",
      sw: "nesw",
      nw: "nwse",
      se: "nwse"
    };
    var DEFAULT_BRUSH_OPT = {
      brushStyle: {
        lineWidth: 2,
        stroke: "rgba(0,0,0,0.3)",
        fill: "rgba(0,0,0,0.1)"
      },
      transformable: true,
      brushMode: "single",
      removeOnClick: false
    };
    var baseUID = 0;
    function BrushController(zr) {
      Eventful.call(this);
      this._zr = zr;
      this.group = new graphic.Group();
      this._brushType;
      this._brushOption;
      this._panels;
      this._track = [];
      this._dragging;
      this._covers = [];
      this._creatingCover;
      this._creatingPanel;
      this._enableGlobalPan;
      this._uid = "brushController_" + baseUID++;
      this._handlers = {};
      each(pointerHandlers, function(handler, eventName) {
        this._handlers[eventName] = zrUtil.bind(handler, this);
      }, this);
    }
    BrushController.prototype = {
      constructor: BrushController,
      /**
       * If set to null/undefined/false, select disabled.
       * @param {Object} brushOption
       * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
       *                          If passing false/null/undefined, disable brush.
       *                          If passing 'auto', determined by panel.defaultBrushType.
       *                              ('auto' can not be used in global panel)
       * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
       * @param {boolean} [brushOption.transformable=true]
       * @param {boolean} [brushOption.removeOnClick=false]
       * @param {Object} [brushOption.brushStyle]
       * @param {number} [brushOption.brushStyle.width]
       * @param {number} [brushOption.brushStyle.lineWidth]
       * @param {string} [brushOption.brushStyle.stroke]
       * @param {string} [brushOption.brushStyle.fill]
       * @param {number} [brushOption.z]
       */
      enableBrush: function(brushOption) {
        this._brushType && doDisableBrush(this);
        brushOption.brushType && doEnableBrush(this, brushOption);
        return this;
      },
      /**
       * @param {Array.<Object>} panelOpts If not pass, it is global brush.
       *        Each items: {
       *            panelId, // mandatory.
       *            clipPath, // mandatory. function.
       *            isTargetByCursor, // mandatory. function.
       *            defaultBrushType, // optional, only used when brushType is 'auto'.
       *            getLinearBrushOtherExtent, // optional. function.
       *        }
       */
      setPanels: function(panelOpts) {
        if (panelOpts && panelOpts.length) {
          var panels = this._panels = {};
          zrUtil.each(panelOpts, function(panelOpts2) {
            panels[panelOpts2.panelId] = zrUtil.clone(panelOpts2);
          });
        } else {
          this._panels = null;
        }
        return this;
      },
      /**
       * @param {Object} [opt]
       * @return {boolean} [opt.enableGlobalPan=false]
       */
      mount: function(opt) {
        opt = opt || {};
        this._enableGlobalPan = opt.enableGlobalPan;
        var thisGroup = this.group;
        this._zr.add(thisGroup);
        thisGroup.attr({
          position: opt.position || [0, 0],
          rotation: opt.rotation || 0,
          scale: opt.scale || [1, 1]
        });
        this._transform = thisGroup.getLocalTransform();
        return this;
      },
      eachCover: function(cb, context) {
        each(this._covers, cb, context);
      },
      /**
       * Update covers.
       * @param {Array.<Object>} brushOptionList Like:
       *        [
       *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
       *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
       *            ...
       *        ]
       *        `brushType` is required in each cover info. (can not be 'auto')
       *        `id` is not mandatory.
       *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
       *        If brushOptionList is null/undefined, all covers removed.
       */
      updateCovers: function(brushOptionList) {
        brushOptionList = zrUtil.map(brushOptionList, function(brushOption) {
          return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
        });
        var tmpIdPrefix = "\0-brush-index-";
        var oldCovers = this._covers;
        var newCovers = this._covers = [];
        var controller = this;
        var creatingCover = this._creatingCover;
        new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
        return this;
        function getKey(brushOption, index) {
          return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + "-" + brushOption.brushType;
        }
        function oldGetKey(cover, index) {
          return getKey(cover.__brushOption, index);
        }
        function addOrUpdate(newIndex, oldIndex) {
          var newBrushOption = brushOptionList[newIndex];
          if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
            newCovers[newIndex] = oldCovers[oldIndex];
          } else {
            var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
            updateCoverAfterCreation(controller, cover);
          }
        }
        function remove(oldIndex) {
          if (oldCovers[oldIndex] !== creatingCover) {
            controller.group.remove(oldCovers[oldIndex]);
          }
        }
      },
      unmount: function() {
        this.enableBrush(false);
        clearCovers(this);
        this._zr.remove(this.group);
        return this;
      },
      dispose: function() {
        this.unmount();
        this.off();
      }
    };
    zrUtil.mixin(BrushController, Eventful);
    function doEnableBrush(controller, brushOption) {
      var zr = controller._zr;
      if (!controller._enableGlobalPan) {
        interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
      }
      mountHandlers(zr, controller._handlers);
      controller._brushType = brushOption.brushType;
      controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
    }
    function doDisableBrush(controller) {
      var zr = controller._zr;
      interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
      unmountHandlers(zr, controller._handlers);
      controller._brushType = controller._brushOption = null;
    }
    function mountHandlers(zr, handlers) {
      each(handlers, function(handler, eventName) {
        zr.on(eventName, handler);
      });
    }
    function unmountHandlers(zr, handlers) {
      each(handlers, function(handler, eventName) {
        zr.off(eventName, handler);
      });
    }
    function createCover(controller, brushOption) {
      var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
      cover.__brushOption = brushOption;
      updateZ(cover, brushOption);
      controller.group.add(cover);
      return cover;
    }
    function endCreating(controller, creatingCover) {
      var coverRenderer = getCoverRenderer(creatingCover);
      if (coverRenderer.endCreating) {
        coverRenderer.endCreating(controller, creatingCover);
        updateZ(creatingCover, creatingCover.__brushOption);
      }
      return creatingCover;
    }
    function updateCoverShape(controller, cover) {
      var brushOption = cover.__brushOption;
      getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
    }
    function updateZ(cover, brushOption) {
      var z = brushOption.z;
      z == null && (z = COVER_Z);
      cover.traverse(function(el) {
        el.z = z;
        el.z2 = z;
      });
    }
    function updateCoverAfterCreation(controller, cover) {
      getCoverRenderer(cover).updateCommon(controller, cover);
      updateCoverShape(controller, cover);
    }
    function getCoverRenderer(cover) {
      return coverRenderers[cover.__brushOption.brushType];
    }
    function getPanelByPoint(controller, e, localCursorPoint) {
      var panels = controller._panels;
      if (!panels) {
        return true;
      }
      var panel;
      var transform = controller._transform;
      each(panels, function(pn) {
        pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);
      });
      return panel;
    }
    function getPanelByCover(controller, cover) {
      var panels = controller._panels;
      if (!panels) {
        return true;
      }
      var panelId = cover.__brushOption.panelId;
      return panelId != null ? panels[panelId] : true;
    }
    function clearCovers(controller) {
      var covers = controller._covers;
      var originalLength = covers.length;
      each(covers, function(cover) {
        controller.group.remove(cover);
      }, controller);
      covers.length = 0;
      return !!originalLength;
    }
    function trigger(controller, opt) {
      var areas = map(controller._covers, function(cover) {
        var brushOption = cover.__brushOption;
        var range = zrUtil.clone(brushOption.range);
        return {
          brushType: brushOption.brushType,
          panelId: brushOption.panelId,
          range
        };
      });
      controller.trigger("brush", areas, {
        isEnd: !!opt.isEnd,
        removeOnClick: !!opt.removeOnClick
      });
    }
    function shouldShowCover(controller) {
      var track = controller._track;
      if (!track.length) {
        return false;
      }
      var p2 = track[track.length - 1];
      var p1 = track[0];
      var dx = p2[0] - p1[0];
      var dy = p2[1] - p1[1];
      var dist = mathPow(dx * dx + dy * dy, 0.5);
      return dist > UNSELECT_THRESHOLD;
    }
    function getTrackEnds(track) {
      var tail = track.length - 1;
      tail < 0 && (tail = 0);
      return [track[0], track[tail]];
    }
    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
      var cover = new graphic.Group();
      cover.add(new graphic.Rect({
        name: "main",
        style: makeStyle(brushOption),
        silent: true,
        draggable: true,
        cursor: "move",
        drift: curry(doDrift, controller, cover, "nswe"),
        ondragend: curry(trigger, controller, {
          isEnd: true
        })
      }));
      each(edgeNames, function(name2) {
        cover.add(new graphic.Rect({
          name: name2,
          style: {
            opacity: 0
          },
          draggable: true,
          silent: true,
          invisible: true,
          drift: curry(doDrift, controller, cover, name2),
          ondragend: curry(trigger, controller, {
            isEnd: true
          })
        }));
      });
      return cover;
    }
    function updateBaseRect(controller, cover, localRange, brushOption) {
      var lineWidth = brushOption.brushStyle.lineWidth || 0;
      var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
      var x = localRange[0][0];
      var y = localRange[1][0];
      var xa = x - lineWidth / 2;
      var ya = y - lineWidth / 2;
      var x2 = localRange[0][1];
      var y2 = localRange[1][1];
      var x2a = x2 - handleSize + lineWidth / 2;
      var y2a = y2 - handleSize + lineWidth / 2;
      var width = x2 - x;
      var height = y2 - y;
      var widtha = width + lineWidth;
      var heighta = height + lineWidth;
      updateRectShape(controller, cover, "main", x, y, width, height);
      if (brushOption.transformable) {
        updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
        updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
        updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
        updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
        updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
        updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
        updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
        updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
      }
    }
    function updateCommon(controller, cover) {
      var brushOption = cover.__brushOption;
      var transformable = brushOption.transformable;
      var mainEl = cover.childAt(0);
      mainEl.useStyle(makeStyle(brushOption));
      mainEl.attr({
        silent: !transformable,
        cursor: transformable ? "move" : "default"
      });
      each(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function(name2) {
        var el = cover.childOfName(name2);
        var globalDir = getGlobalDirection(controller, name2);
        el && el.attr({
          silent: !transformable,
          invisible: !transformable,
          cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
        });
      });
    }
    function updateRectShape(controller, cover, name2, x, y, w, h) {
      var el = cover.childOfName(name2);
      el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
    }
    function makeStyle(brushOption) {
      return zrUtil.defaults({
        strokeNoScale: true
      }, brushOption.brushStyle);
    }
    function formatRectRange(x, y, x2, y2) {
      var min = [mathMin(x, x2), mathMin(y, y2)];
      var max = [mathMax(x, x2), mathMax(y, y2)];
      return [
        [min[0], max[0]],
        // x range
        [min[1], max[1]]
        // y range
      ];
    }
    function getTransform(controller) {
      return graphic.getTransform(controller.group);
    }
    function getGlobalDirection(controller, localDirection) {
      if (localDirection.length > 1) {
        localDirection = localDirection.split("");
        var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
        (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
        return globalDir.join("");
      } else {
        var map2 = {
          w: "left",
          e: "right",
          n: "top",
          s: "bottom"
        };
        var inverseMap = {
          left: "w",
          right: "e",
          top: "n",
          bottom: "s"
        };
        var globalDir = graphic.transformDirection(map2[localDirection], getTransform(controller));
        return inverseMap[globalDir];
      }
    }
    function driftRect(toRectRange, fromRectRange, controller, cover, name2, dx, dy, e) {
      var brushOption = cover.__brushOption;
      var rectRange = toRectRange(brushOption.range);
      var localDelta = toLocalDelta(controller, dx, dy);
      each(name2.split(""), function(namePart) {
        var ind = DIRECTION_MAP[namePart];
        rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
      });
      brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
      updateCoverAfterCreation(controller, cover);
      trigger(controller, {
        isEnd: false
      });
    }
    function driftPolygon(controller, cover, dx, dy, e) {
      var range = cover.__brushOption.range;
      var localDelta = toLocalDelta(controller, dx, dy);
      each(range, function(point) {
        point[0] += localDelta[0];
        point[1] += localDelta[1];
      });
      updateCoverAfterCreation(controller, cover);
      trigger(controller, {
        isEnd: false
      });
    }
    function toLocalDelta(controller, dx, dy) {
      var thisGroup = controller.group;
      var localD = thisGroup.transformCoordToLocal(dx, dy);
      var localZero = thisGroup.transformCoordToLocal(0, 0);
      return [localD[0] - localZero[0], localD[1] - localZero[1]];
    }
    function clipByPanel(controller, cover, data) {
      var panel = getPanelByCover(controller, cover);
      return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);
    }
    function pointsToRect(points) {
      var xmin = mathMin(points[0][0], points[1][0]);
      var ymin = mathMin(points[0][1], points[1][1]);
      var xmax = mathMax(points[0][0], points[1][0]);
      var ymax = mathMax(points[0][1], points[1][1]);
      return {
        x: xmin,
        y: ymin,
        width: xmax - xmin,
        height: ymax - ymin
      };
    }
    function resetCursor(controller, e, localCursorPoint) {
      if (
        // Check active
        !controller._brushType || isOutsideZrArea(controller, e)
      ) {
        return;
      }
      var zr = controller._zr;
      var covers = controller._covers;
      var currPanel = getPanelByPoint(controller, e, localCursorPoint);
      if (!controller._dragging) {
        for (var i = 0; i < covers.length; i++) {
          var brushOption = covers[i].__brushOption;
          if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
            return;
          }
        }
      }
      currPanel && zr.setCursorStyle("crosshair");
    }
    function preventDefault(e) {
      var rawE = e.event;
      rawE.preventDefault && rawE.preventDefault();
    }
    function mainShapeContain(cover, x, y) {
      return cover.childOfName("main").contain(x, y);
    }
    function updateCoverByMouse(controller, e, localCursorPoint, isEnd) {
      var creatingCover = controller._creatingCover;
      var panel = controller._creatingPanel;
      var thisBrushOption = controller._brushOption;
      var eventParams;
      controller._track.push(localCursorPoint.slice());
      if (shouldShowCover(controller) || creatingCover) {
        if (panel && !creatingCover) {
          thisBrushOption.brushMode === "single" && clearCovers(controller);
          var brushOption = zrUtil.clone(thisBrushOption);
          brushOption.brushType = determineBrushType(brushOption.brushType, panel);
          brushOption.panelId = panel === true ? null : panel.panelId;
          creatingCover = controller._creatingCover = createCover(controller, brushOption);
          controller._covers.push(creatingCover);
        }
        if (creatingCover) {
          var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
          var coverBrushOption = creatingCover.__brushOption;
          coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
          if (isEnd) {
            endCreating(controller, creatingCover);
            coverRenderer.updateCommon(controller, creatingCover);
          }
          updateCoverShape(controller, creatingCover);
          eventParams = {
            isEnd
          };
        }
      } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
        if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
          eventParams = {
            isEnd,
            removeOnClick: true
          };
        }
      }
      return eventParams;
    }
    function determineBrushType(brushType, panel) {
      if (brushType === "auto") {
        return panel.defaultBrushType;
      }
      return brushType;
    }
    var pointerHandlers = {
      mousedown: function(e) {
        if (this._dragging) {
          handleDragEnd(this, e);
        } else if (!e.target || !e.target.draggable) {
          preventDefault(e);
          var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
          this._creatingCover = null;
          var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);
          if (panel) {
            this._dragging = true;
            this._track = [localCursorPoint.slice()];
          }
        }
      },
      mousemove: function(e) {
        var x = e.offsetX;
        var y = e.offsetY;
        var localCursorPoint = this.group.transformCoordToLocal(x, y);
        resetCursor(this, e, localCursorPoint);
        if (this._dragging) {
          preventDefault(e);
          var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);
          eventParams && trigger(this, eventParams);
        }
      },
      mouseup: function(e) {
        handleDragEnd(this, e);
      }
    };
    function handleDragEnd(controller, e) {
      if (controller._dragging) {
        preventDefault(e);
        var x = e.offsetX;
        var y = e.offsetY;
        var localCursorPoint = controller.group.transformCoordToLocal(x, y);
        var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);
        controller._dragging = false;
        controller._track = [];
        controller._creatingCover = null;
        eventParams && trigger(controller, eventParams);
      }
    }
    function isOutsideZrArea(controller, x, y) {
      var zr = controller._zr;
      return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
    }
    var coverRenderers = {
      lineX: getLineRenderer(0),
      lineY: getLineRenderer(1),
      rect: {
        createCover: function(controller, brushOption) {
          return createBaseRectCover(curry(driftRect, function(range) {
            return range;
          }, function(range) {
            return range;
          }), controller, brushOption, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]);
        },
        getCreatingRange: function(localTrack) {
          var ends = getTrackEnds(localTrack);
          return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
        },
        updateCoverShape: function(controller, cover, localRange, brushOption) {
          updateBaseRect(controller, cover, localRange, brushOption);
        },
        updateCommon,
        contain: mainShapeContain
      },
      polygon: {
        createCover: function(controller, brushOption) {
          var cover = new graphic.Group();
          cover.add(new graphic.Polyline({
            name: "main",
            style: makeStyle(brushOption),
            silent: true
          }));
          return cover;
        },
        getCreatingRange: function(localTrack) {
          return localTrack;
        },
        endCreating: function(controller, cover) {
          cover.remove(cover.childAt(0));
          cover.add(new graphic.Polygon({
            name: "main",
            draggable: true,
            drift: curry(driftPolygon, controller, cover),
            ondragend: curry(trigger, controller, {
              isEnd: true
            })
          }));
        },
        updateCoverShape: function(controller, cover, localRange, brushOption) {
          cover.childAt(0).setShape({
            points: clipByPanel(controller, cover, localRange)
          });
        },
        updateCommon,
        contain: mainShapeContain
      }
    };
    function getLineRenderer(xyIndex) {
      return {
        createCover: function(controller, brushOption) {
          return createBaseRectCover(curry(driftRect, function(range) {
            var rectRange = [range, [0, 100]];
            xyIndex && rectRange.reverse();
            return rectRange;
          }, function(rectRange) {
            return rectRange[xyIndex];
          }), controller, brushOption, [["w", "e"], ["n", "s"]][xyIndex]);
        },
        getCreatingRange: function(localTrack) {
          var ends = getTrackEnds(localTrack);
          var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
          var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);
          return [min, max];
        },
        updateCoverShape: function(controller, cover, localRange, brushOption) {
          var otherExtent;
          var panel = getPanelByCover(controller, cover);
          if (panel !== true && panel.getLinearBrushOtherExtent) {
            otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
          } else {
            var zr = controller._zr;
            otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
          }
          var rectRange = [localRange, otherExtent];
          xyIndex && rectRange.reverse();
          updateBaseRect(controller, cover, rectRange, brushOption);
        },
        updateCommon,
        contain: mainShapeContain
      };
    }
    var _default = BrushController;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/brushHelper.js
var require_brushHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/brushHelper.js"(exports) {
    var BoundingRect = require_BoundingRect();
    var _cursorHelper = require_cursorHelper();
    var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
    var graphicUtil = require_graphic();
    function makeRectPanelClipPath(rect) {
      rect = normalizeRect(rect);
      return function(localPoints, transform) {
        return graphicUtil.clipPointsByRect(localPoints, rect);
      };
    }
    function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
      rect = normalizeRect(rect);
      return function(xyIndex) {
        var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
        var brushWidth = idx ? rect.width : rect.height;
        var base = idx ? rect.x : rect.y;
        return [base, base + (brushWidth || 0)];
      };
    }
    function makeRectIsTargetByCursor(rect, api, targetModel) {
      rect = normalizeRect(rect);
      return function(e, localCursorPoint, transform) {
        return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel);
      };
    }
    function normalizeRect(rect) {
      return BoundingRect.create(rect);
    }
    exports.makeRectPanelClipPath = makeRectPanelClipPath;
    exports.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;
    exports.makeRectIsTargetByCursor = makeRectIsTargetByCursor;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/ParallelAxisView.js
var require_ParallelAxisView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/ParallelAxisView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var AxisBuilder = require_AxisBuilder();
    var BrushController = require_BrushController();
    var brushHelper = require_brushHelper();
    var graphic = require_graphic();
    var elementList = ["axisLine", "axisTickLabel", "axisName"];
    var AxisView = echarts.extendComponentView({
      type: "parallelAxis",
      /**
       * @override
       */
      init: function(ecModel, api) {
        AxisView.superApply(this, "init", arguments);
        (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil.bind(this._onBrush, this));
      },
      /**
       * @override
       */
      render: function(axisModel, ecModel, api, payload) {
        if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
          return;
        }
        this.axisModel = axisModel;
        this.api = api;
        this.group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic.Group();
        this.group.add(this._axisGroup);
        if (!axisModel.get("show")) {
          return;
        }
        var coordSysModel = getCoordSysModel(axisModel, ecModel);
        var coordSys = coordSysModel.coordinateSystem;
        var areaSelectStyle = axisModel.getAreaSelectStyle();
        var areaWidth = areaSelectStyle.width;
        var dim = axisModel.axis.dim;
        var axisLayout = coordSys.getAxisLayout(dim);
        var builderOpt = zrUtil.extend({
          strokeContainThreshold: areaWidth
        }, axisLayout);
        var axisBuilder = new AxisBuilder(axisModel, builderOpt);
        zrUtil.each(elementList, axisBuilder.add, axisBuilder);
        this._axisGroup.add(axisBuilder.getGroup());
        this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
        var animationModel = payload && payload.animation === false ? null : axisModel;
        graphic.groupTransition(oldAxisGroup, this._axisGroup, animationModel);
      },
      // /**
      //  * @override
      //  */
      // updateVisual: function (axisModel, ecModel, api, payload) {
      //     this._brushController && this._brushController
      //         .updateCovers(getCoverInfoList(axisModel));
      // },
      _refreshBrushController: function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
        var extent = axisModel.axis.getExtent();
        var extentLen = extent[1] - extent[0];
        var extra = Math.min(30, Math.abs(extentLen) * 0.1);
        var rect = graphic.BoundingRect.create({
          x: extent[0],
          y: -areaWidth / 2,
          width: extentLen,
          height: areaWidth
        });
        rect.x -= extra;
        rect.width += 2 * extra;
        this._brushController.mount({
          enableGlobalPan: true,
          rotation: builderOpt.rotation,
          position: builderOpt.position
        }).setPanels([{
          panelId: "pl",
          clipPath: brushHelper.makeRectPanelClipPath(rect),
          isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, coordSysModel),
          getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect, 0)
        }]).enableBrush({
          brushType: "lineX",
          brushStyle: areaSelectStyle,
          removeOnClick: true
        }).updateCovers(getCoverInfoList(axisModel));
      },
      _onBrush: function(coverInfoList, opt) {
        var axisModel = this.axisModel;
        var axis = axisModel.axis;
        var intervals = zrUtil.map(coverInfoList, function(coverInfo) {
          return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)];
        });
        if (!axisModel.option.realtime === opt.isEnd || opt.removeOnClick) {
          this.api.dispatchAction({
            type: "axisAreaSelect",
            parallelAxisId: axisModel.id,
            intervals
          });
        }
      },
      /**
       * @override
       */
      dispose: function() {
        this._brushController.dispose();
      }
    });
    function fromAxisAreaSelect(axisModel, ecModel, payload) {
      return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
        mainType: "parallelAxis",
        query: payload
      })[0] === axisModel;
    }
    function getCoverInfoList(axisModel) {
      var axis = axisModel.axis;
      return zrUtil.map(axisModel.activeIntervals, function(interval) {
        return {
          brushType: "lineX",
          panelId: "pl",
          range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
        };
      });
    }
    function getCoordSysModel(axisModel, ecModel) {
      return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
    }
    var _default = AxisView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallelAxis.js
var require_parallelAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallelAxis.js"() {
    require_parallelCreator();
    require_parallelAxisAction();
    require_ParallelAxisView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallel.js
var require_parallel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/parallel.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var throttleUtil = require_throttle();
    var parallelPreprocessor = require_parallelPreprocessor();
    require_parallelCreator();
    require_ParallelModel();
    require_parallelAxis();
    var CLICK_THRESHOLD = 5;
    echarts.extendComponentView({
      type: "parallel",
      render: function(parallelModel, ecModel, api) {
        this._model = parallelModel;
        this._api = api;
        if (!this._handlers) {
          this._handlers = {};
          zrUtil.each(handlers, function(handler, eventName) {
            api.getZr().on(eventName, this._handlers[eventName] = zrUtil.bind(handler, this));
          }, this);
        }
        throttleUtil.createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
      },
      dispose: function(ecModel, api) {
        zrUtil.each(this._handlers, function(handler, eventName) {
          api.getZr().off(eventName, handler);
        });
        this._handlers = null;
      },
      /**
       * @param {Object} [opt] If null, cancle the last action triggering for debounce.
       */
      _throttledDispatchExpand: function(opt) {
        this._dispatchExpand(opt);
      },
      _dispatchExpand: function(opt) {
        opt && this._api.dispatchAction(zrUtil.extend({
          type: "parallelAxisExpand"
        }, opt));
      }
    });
    var handlers = {
      mousedown: function(e) {
        if (checkTrigger(this, "click")) {
          this._mouseDownPoint = [e.offsetX, e.offsetY];
        }
      },
      mouseup: function(e) {
        var mouseDownPoint = this._mouseDownPoint;
        if (checkTrigger(this, "click") && mouseDownPoint) {
          var point = [e.offsetX, e.offsetY];
          var dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
          if (dist > CLICK_THRESHOLD) {
            return;
          }
          var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
          result.behavior !== "none" && this._dispatchExpand({
            axisExpandWindow: result.axisExpandWindow
          });
        }
        this._mouseDownPoint = null;
      },
      mousemove: function(e) {
        if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
          return;
        }
        var model = this._model;
        var result = model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
        var behavior = result.behavior;
        behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
        this._throttledDispatchExpand(behavior === "none" ? null : {
          axisExpandWindow: result.axisExpandWindow,
          // Jumping uses animation, and sliding suppresses animation.
          animation: behavior === "jump" ? null : false
        });
      }
    };
    function checkTrigger(view, triggerOn) {
      var model = view._model;
      return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
    }
    echarts.registerPreprocessor(parallelPreprocessor);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelSeries.js
var require_ParallelSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelSeries.js"(exports, module) {
    var _util = require_util();
    var each = _util.each;
    var createHashMap = _util.createHashMap;
    var SeriesModel = require_Series();
    var createListFromArray = require_createListFromArray();
    var _default = SeriesModel.extend({
      type: "series.parallel",
      dependencies: ["parallel"],
      visualColorAccessPath: "lineStyle.color",
      getInitialData: function(option, ecModel) {
        var source = this.getSource();
        setEncodeAndDimensions(source, this);
        return createListFromArray(source, this);
      },
      /**
       * User can get data raw indices on 'axisAreaSelected' event received.
       *
       * @public
       * @param {string} activeState 'active' or 'inactive' or 'normal'
       * @return {Array.<number>} Raw indices
       */
      getRawIndicesByActiveState: function(activeState) {
        var coordSys = this.coordinateSystem;
        var data = this.getData();
        var indices = [];
        coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
          if (activeState === theActiveState) {
            indices.push(data.getRawIndex(dataIndex));
          }
        });
        return indices;
      },
      defaultOption: {
        zlevel: 0,
        // 一级层叠
        z: 2,
        // 二级层叠
        coordinateSystem: "parallel",
        parallelIndex: 0,
        label: {
          show: false
        },
        inactiveOpacity: 0.05,
        activeOpacity: 1,
        lineStyle: {
          width: 1,
          opacity: 0.45,
          type: "solid"
        },
        emphasis: {
          label: {
            show: false
          }
        },
        progressive: 500,
        smooth: false,
        // true | false | number
        animationEasing: "linear"
      }
    });
    function setEncodeAndDimensions(source, seriesModel) {
      if (source.encodeDefine) {
        return;
      }
      var parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
      if (!parallelModel) {
        return;
      }
      var encodeDefine = source.encodeDefine = createHashMap();
      each(parallelModel.dimensions, function(axisDim) {
        var dataDimIndex = convertDimNameToNumber(axisDim);
        encodeDefine.set(axisDim, dataDimIndex);
      });
    }
    function convertDimNameToNumber(dimName) {
      return +dimName.replace("dim", "");
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelView.js
var require_ParallelView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/ParallelView.js"(exports, module) {
    var graphic = require_graphic();
    var ChartView = require_Chart();
    var DEFAULT_SMOOTH = 0.3;
    var ParallelView = ChartView.extend({
      type: "parallel",
      init: function() {
        this._dataGroup = new graphic.Group();
        this.group.add(this._dataGroup);
        this._data;
        this._initialized;
      },
      /**
       * @override
       */
      render: function(seriesModel, ecModel, api, payload) {
        var dataGroup = this._dataGroup;
        var data = seriesModel.getData();
        var oldData = this._data;
        var coordSys = seriesModel.coordinateSystem;
        var dimensions = coordSys.dimensions;
        var seriesScope = makeSeriesScope(seriesModel);
        data.diff(oldData).add(add).update(update).remove(remove).execute();
        function add(newDataIndex) {
          var line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
          updateElCommon(line, data, newDataIndex, seriesScope);
        }
        function update(newDataIndex, oldDataIndex) {
          var line = oldData.getItemGraphicEl(oldDataIndex);
          var points = createLinePoints(data, newDataIndex, dimensions, coordSys);
          data.setItemGraphicEl(newDataIndex, line);
          var animationModel = payload && payload.animation === false ? null : seriesModel;
          graphic.updateProps(line, {
            shape: {
              points
            }
          }, animationModel, newDataIndex);
          updateElCommon(line, data, newDataIndex, seriesScope);
        }
        function remove(oldDataIndex) {
          var line = oldData.getItemGraphicEl(oldDataIndex);
          dataGroup.remove(line);
        }
        if (!this._initialized) {
          this._initialized = true;
          var clipPath = createGridClipShape(coordSys, seriesModel, function() {
            setTimeout(function() {
              dataGroup.removeClipPath();
            });
          });
          dataGroup.setClipPath(clipPath);
        }
        this._data = data;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this._initialized = true;
        this._data = null;
        this._dataGroup.removeAll();
      },
      incrementalRender: function(taskParams, seriesModel, ecModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var dimensions = coordSys.dimensions;
        var seriesScope = makeSeriesScope(seriesModel);
        for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
          var line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
          line.incremental = true;
          updateElCommon(line, data, dataIndex, seriesScope);
        }
      },
      dispose: function() {
      },
      // _renderForProgressive: function (seriesModel) {
      //     var dataGroup = this._dataGroup;
      //     var data = seriesModel.getData();
      //     var oldData = this._data;
      //     var coordSys = seriesModel.coordinateSystem;
      //     var dimensions = coordSys.dimensions;
      //     var option = seriesModel.option;
      //     var progressive = option.progressive;
      //     var smooth = option.smooth ? SMOOTH : null;
      //     // In progressive animation is disabled, so use simple data diff,
      //     // which effects performance less.
      //     // (Typically performance for data with length 7000+ like:
      //     // simpleDiff: 60ms, addEl: 184ms,
      //     // in RMBP 2.4GHz intel i7, OSX 10.9 chrome 50.0.2661.102 (64-bit))
      //     if (simpleDiff(oldData, data, dimensions)) {
      //         dataGroup.removeAll();
      //         data.each(function (dataIndex) {
      //             addEl(data, dataGroup, dataIndex, dimensions, coordSys);
      //         });
      //     }
      //     updateElCommon(data, progressive, smooth);
      //     // Consider switch between progressive and not.
      //     data.__plProgressive = true;
      //     this._data = data;
      // },
      /**
       * @override
       */
      remove: function() {
        this._dataGroup && this._dataGroup.removeAll();
        this._data = null;
      }
    });
    function createGridClipShape(coordSys, seriesModel, cb) {
      var parallelModel = coordSys.model;
      var rect = coordSys.getRect();
      var rectEl = new graphic.Rect({
        shape: {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        }
      });
      var dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
      rectEl.setShape(dim, 0);
      graphic.initProps(rectEl, {
        shape: {
          width: rect.width,
          height: rect.height
        }
      }, seriesModel, cb);
      return rectEl;
    }
    function createLinePoints(data, dataIndex, dimensions, coordSys) {
      var points = [];
      for (var i = 0; i < dimensions.length; i++) {
        var dimName = dimensions[i];
        var value = data.get(data.mapDimension(dimName), dataIndex);
        if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
          points.push(coordSys.dataToPoint(value, dimName));
        }
      }
      return points;
    }
    function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
      var points = createLinePoints(data, dataIndex, dimensions, coordSys);
      var line = new graphic.Polyline({
        shape: {
          points
        },
        silent: true,
        z2: 10
      });
      dataGroup.add(line);
      data.setItemGraphicEl(dataIndex, line);
      return line;
    }
    function makeSeriesScope(seriesModel) {
      var smooth = seriesModel.get("smooth", true);
      smooth === true && (smooth = DEFAULT_SMOOTH);
      return {
        lineStyle: seriesModel.getModel("lineStyle").getLineStyle(),
        smooth: smooth != null ? smooth : DEFAULT_SMOOTH
      };
    }
    function updateElCommon(el, data, dataIndex, seriesScope) {
      var lineStyle = seriesScope.lineStyle;
      if (data.hasItemOption) {
        var lineStyleModel = data.getItemModel(dataIndex).getModel("lineStyle");
        lineStyle = lineStyleModel.getLineStyle();
      }
      el.useStyle(lineStyle);
      var elStyle = el.style;
      elStyle.fill = null;
      elStyle.stroke = data.getItemVisual(dataIndex, "color");
      elStyle.opacity = data.getItemVisual(dataIndex, "opacity");
      seriesScope.smooth && (el.shape.smooth = seriesScope.smooth);
    }
    function isEmptyValue(val, axisType) {
      return axisType === "category" ? val == null : val == null || isNaN(val);
    }
    var _default = ParallelView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/parallelVisual.js
var require_parallelVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel/parallelVisual.js"(exports, module) {
    var opacityAccessPath = ["lineStyle", "normal", "opacity"];
    var _default = {
      seriesType: "parallel",
      reset: function(seriesModel, ecModel, api) {
        var itemStyleModel = seriesModel.getModel("itemStyle");
        var lineStyleModel = seriesModel.getModel("lineStyle");
        var globalColors = ecModel.get("color");
        var color = lineStyleModel.get("color") || itemStyleModel.get("color") || globalColors[seriesModel.seriesIndex % globalColors.length];
        var inactiveOpacity = seriesModel.get("inactiveOpacity");
        var activeOpacity = seriesModel.get("activeOpacity");
        var lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
        var coordSys = seriesModel.coordinateSystem;
        var data = seriesModel.getData();
        var opacityMap = {
          normal: lineStyle.opacity,
          active: activeOpacity,
          inactive: inactiveOpacity
        };
        data.setVisual("color", color);
        function progress(params, data2) {
          coordSys.eachActiveState(data2, function(activeState, dataIndex) {
            var opacity = opacityMap[activeState];
            if (activeState === "normal" && data2.hasItemOption) {
              var itemOpacity = data2.getItemModel(dataIndex).get(opacityAccessPath, true);
              itemOpacity != null && (opacity = itemOpacity);
            }
            data2.setItemVisual(dataIndex, "opacity", opacity);
          }, params.start, params.end);
        }
        return {
          progress
        };
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel.js
var require_parallel2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/parallel.js"() {
    var echarts = require_echarts();
    require_parallel();
    require_ParallelSeries();
    require_ParallelView();
    var parallelVisual = require_parallelVisual();
    echarts.registerVisual(parallelVisual);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeySeries.js
var require_SankeySeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeySeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createGraphFromNodeEdge = require_createGraphFromNodeEdge();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var Model = require_Model();
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var SankeySeries = SeriesModel.extend({
      type: "series.sankey",
      layoutInfo: null,
      levelModels: null,
      /**
       * Init a graph data structure from data in option series
       *
       * @param  {Object} option  the object used to config echarts view
       * @return {module:echarts/data/List} storage initial data
       */
      getInitialData: function(option, ecModel) {
        var links = option.edges || option.links;
        var nodes = option.data || option.nodes;
        var levels = option.levels;
        var levelModels = this.levelModels = {};
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].depth != null && levels[i].depth >= 0) {
            levelModels[levels[i].depth] = new Model(levels[i], this, ecModel);
          } else {
          }
        }
        if (nodes && links) {
          var graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);
          return graph.data;
        }
        function beforeLink(nodeData, edgeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            model.customizeGetParent(function(path) {
              var parentModel = this.parentModel;
              var nodeDepth = parentModel.getData().getItemLayout(idx).depth;
              var levelModel = parentModel.levelModels[nodeDepth];
              return levelModel || this.parentModel;
            });
            return model;
          });
          edgeData.wrapMethod("getItemModel", function(model, idx) {
            model.customizeGetParent(function(path) {
              var parentModel = this.parentModel;
              var edge = parentModel.getGraph().getEdgeByIndex(idx);
              var depth = edge.node1.getLayout().depth;
              var levelModel = parentModel.levelModels[depth];
              return levelModel || this.parentModel;
            });
            return model;
          });
        }
      },
      setNodePosition: function(dataIndex, localPosition) {
        var dataItem = this.option.data[dataIndex];
        dataItem.localX = localPosition[0];
        dataItem.localY = localPosition[1];
      },
      /**
       * Return the graphic data structure
       *
       * @return {module:echarts/data/Graph} graphic data structure
       */
      getGraph: function() {
        return this.getData().graph;
      },
      /**
       * Get edge data of graphic data structure
       *
       * @return {module:echarts/data/List} data structure of list
       */
      getEdgeData: function() {
        return this.getGraph().edgeData;
      },
      /**
       * @override
       */
      formatTooltip: function(dataIndex, multipleSeries, dataType) {
        if (dataType === "edge") {
          var params = this.getDataParams(dataIndex, dataType);
          var rawDataOpt = params.data;
          var html = rawDataOpt.source + " -- " + rawDataOpt.target;
          if (params.value) {
            html += " : " + params.value;
          }
          return encodeHTML(html);
        } else if (dataType === "node") {
          var node = this.getGraph().getNodeByIndex(dataIndex);
          var value = node.getLayout().value;
          var name2 = this.getDataParams(dataIndex, dataType).data.name;
          if (value) {
            var html = name2 + " : " + value;
          }
          return encodeHTML(html);
        }
        return SankeySeries.superCall(this, "formatTooltip", dataIndex, multipleSeries);
      },
      optionUpdated: function() {
        var option = this.option;
        if (option.focusNodeAdjacency === true) {
          option.focusNodeAdjacency = "allEdges";
        }
      },
      // Override Series.getDataParams()
      getDataParams: function(dataIndex, dataType) {
        var params = SankeySeries.superCall(this, "getDataParams", dataIndex, dataType);
        if (params.value == null && dataType === "node") {
          var node = this.getGraph().getNodeByIndex(dataIndex);
          var nodeValue = node.getLayout().value;
          params.value = nodeValue;
        }
        return params;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "view",
        layout: null,
        // The position of the whole view
        left: "5%",
        top: "5%",
        right: "20%",
        bottom: "5%",
        // Value can be 'vertical'
        orient: "horizontal",
        // The dx of the node
        nodeWidth: 20,
        // The vertical distance between two nodes
        nodeGap: 8,
        // Control if the node can move or not
        draggable: true,
        // Value can be 'inEdges', 'outEdges', 'allEdges', true (the same as 'allEdges').
        focusNodeAdjacency: false,
        // The number of iterations to change the position of the node
        layoutIterations: 32,
        label: {
          show: true,
          position: "right",
          color: "#000",
          fontSize: 12
        },
        levels: [],
        // Value can be 'left' or 'right'
        nodeAlign: "justify",
        itemStyle: {
          borderWidth: 1,
          borderColor: "#333"
        },
        lineStyle: {
          color: "#314656",
          opacity: 0.2,
          curveness: 0.5
        },
        emphasis: {
          label: {
            show: true
          },
          lineStyle: {
            opacity: 0.5
          }
        },
        animationEasing: "linear",
        animationDuration: 1e3
      }
    });
    var _default = SankeySeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeyView.js
var require_SankeyView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/SankeyView.js"(exports, module) {
    var graphic = require_graphic();
    var echarts = require_echarts();
    var zrUtil = require_util();
    var nodeOpacityPath = ["itemStyle", "opacity"];
    var hoverNodeOpacityPath = ["emphasis", "itemStyle", "opacity"];
    var lineOpacityPath = ["lineStyle", "opacity"];
    var hoverLineOpacityPath = ["emphasis", "lineStyle", "opacity"];
    function getItemOpacity(item, opacityPath) {
      return item.getVisual("opacity") || item.getModel().get(opacityPath);
    }
    function fadeOutItem(item, opacityPath, opacityRatio) {
      var el = item.getGraphicEl();
      var opacity = getItemOpacity(item, opacityPath);
      if (opacityRatio != null) {
        opacity == null && (opacity = 1);
        opacity *= opacityRatio;
      }
      el.downplay && el.downplay();
      el.traverse(function(child) {
        if (child.type !== "group") {
          child.setStyle("opacity", opacity);
        }
      });
    }
    function fadeInItem(item, opacityPath) {
      var opacity = getItemOpacity(item, opacityPath);
      var el = item.getGraphicEl();
      el.traverse(function(child) {
        if (child.type !== "group") {
          child.setStyle("opacity", opacity);
        }
      });
      el.highlight && el.highlight();
    }
    var SankeyShape = graphic.extendShape({
      shape: {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0,
        cpx1: 0,
        cpy1: 0,
        cpx2: 0,
        cpy2: 0,
        extent: 0,
        orient: ""
      },
      buildPath: function(ctx, shape) {
        var extent = shape.extent;
        ctx.moveTo(shape.x1, shape.y1);
        ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
        if (shape.orient === "vertical") {
          ctx.lineTo(shape.x2 + extent, shape.y2);
          ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);
        } else {
          ctx.lineTo(shape.x2, shape.y2 + extent);
          ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);
        }
        ctx.closePath();
      },
      highlight: function() {
        this.trigger("emphasis");
      },
      downplay: function() {
        this.trigger("normal");
      }
    });
    var _default = echarts.extendChartView({
      type: "sankey",
      /**
       * @private
       * @type {module:echarts/chart/sankey/SankeySeries}
       */
      _model: null,
      /**
       * @private
       * @type {boolean}
       */
      _focusAdjacencyDisabled: false,
      render: function(seriesModel, ecModel, api) {
        var sankeyView = this;
        var graph = seriesModel.getGraph();
        var group = this.group;
        var layoutInfo = seriesModel.layoutInfo;
        var width = layoutInfo.width;
        var height = layoutInfo.height;
        var nodeData = seriesModel.getData();
        var edgeData = seriesModel.getData("edge");
        var orient = seriesModel.get("orient");
        this._model = seriesModel;
        group.removeAll();
        group.attr("position", [layoutInfo.x, layoutInfo.y]);
        graph.eachEdge(function(edge) {
          var curve = new SankeyShape();
          curve.dataIndex = edge.dataIndex;
          curve.seriesIndex = seriesModel.seriesIndex;
          curve.dataType = "edge";
          var lineStyleModel = edge.getModel("lineStyle");
          var curvature = lineStyleModel.get("curveness");
          var n1Layout = edge.node1.getLayout();
          var node1Model = edge.node1.getModel();
          var dragX1 = node1Model.get("localX");
          var dragY1 = node1Model.get("localY");
          var n2Layout = edge.node2.getLayout();
          var node2Model = edge.node2.getModel();
          var dragX2 = node2Model.get("localX");
          var dragY2 = node2Model.get("localY");
          var edgeLayout = edge.getLayout();
          var x1;
          var y1;
          var x2;
          var y2;
          var cpx1;
          var cpy1;
          var cpx2;
          var cpy2;
          curve.shape.extent = Math.max(1, edgeLayout.dy);
          curve.shape.orient = orient;
          if (orient === "vertical") {
            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
            x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
            y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
            cpx1 = x1;
            cpy1 = y1 * (1 - curvature) + y2 * curvature;
            cpx2 = x2;
            cpy2 = y1 * curvature + y2 * (1 - curvature);
          } else {
            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
            x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
            y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
            cpx1 = x1 * (1 - curvature) + x2 * curvature;
            cpy1 = y1;
            cpx2 = x1 * curvature + x2 * (1 - curvature);
            cpy2 = y2;
          }
          curve.setShape({
            x1,
            y1,
            x2,
            y2,
            cpx1,
            cpy1,
            cpx2,
            cpy2
          });
          curve.setStyle(lineStyleModel.getItemStyle());
          switch (curve.style.fill) {
            case "source":
              curve.style.fill = edge.node1.getVisual("color");
              break;
            case "target":
              curve.style.fill = edge.node2.getVisual("color");
              break;
          }
          graphic.setHoverStyle(curve, edge.getModel("emphasis.lineStyle").getItemStyle());
          group.add(curve);
          edgeData.setItemGraphicEl(edge.dataIndex, curve);
        });
        graph.eachNode(function(node) {
          var layout = node.getLayout();
          var itemModel = node.getModel();
          var dragX = itemModel.get("localX");
          var dragY = itemModel.get("localY");
          var labelModel = itemModel.getModel("label");
          var labelHoverModel = itemModel.getModel("emphasis.label");
          var rect = new graphic.Rect({
            shape: {
              x: dragX != null ? dragX * width : layout.x,
              y: dragY != null ? dragY * height : layout.y,
              width: layout.dx,
              height: layout.dy
            },
            style: itemModel.getModel("itemStyle").getItemStyle()
          });
          var hoverStyle = node.getModel("emphasis.itemStyle").getItemStyle();
          graphic.setLabelStyle(rect.style, hoverStyle, labelModel, labelHoverModel, {
            labelFetcher: seriesModel,
            labelDataIndex: node.dataIndex,
            defaultText: node.id,
            isRectText: true
          });
          rect.setStyle("fill", node.getVisual("color"));
          graphic.setHoverStyle(rect, hoverStyle);
          group.add(rect);
          nodeData.setItemGraphicEl(node.dataIndex, rect);
          rect.dataType = "node";
        });
        nodeData.eachItemGraphicEl(function(el, dataIndex) {
          var itemModel = nodeData.getItemModel(dataIndex);
          if (itemModel.get("draggable")) {
            el.drift = function(dx, dy) {
              sankeyView._focusAdjacencyDisabled = true;
              this.shape.x += dx;
              this.shape.y += dy;
              this.dirty();
              api.dispatchAction({
                type: "dragNode",
                seriesId: seriesModel.id,
                dataIndex: nodeData.getRawIndex(dataIndex),
                localX: this.shape.x / width,
                localY: this.shape.y / height
              });
            };
            el.ondragend = function() {
              sankeyView._focusAdjacencyDisabled = false;
            };
            el.draggable = true;
            el.cursor = "move";
          }
          el.highlight = function() {
            this.trigger("emphasis");
          };
          el.downplay = function() {
            this.trigger("normal");
          };
          el.focusNodeAdjHandler && el.off("mouseover", el.focusNodeAdjHandler);
          el.unfocusNodeAdjHandler && el.off("mouseout", el.unfocusNodeAdjHandler);
          if (itemModel.get("focusNodeAdjacency")) {
            el.on("mouseover", el.focusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._clearTimer();
                api.dispatchAction({
                  type: "focusNodeAdjacency",
                  seriesId: seriesModel.id,
                  dataIndex: el.dataIndex
                });
              }
            });
            el.on("mouseout", el.unfocusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._dispatchUnfocus(api);
              }
            });
          }
        });
        edgeData.eachItemGraphicEl(function(el, dataIndex) {
          var edgeModel = edgeData.getItemModel(dataIndex);
          el.focusNodeAdjHandler && el.off("mouseover", el.focusNodeAdjHandler);
          el.unfocusNodeAdjHandler && el.off("mouseout", el.unfocusNodeAdjHandler);
          if (edgeModel.get("focusNodeAdjacency")) {
            el.on("mouseover", el.focusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._clearTimer();
                api.dispatchAction({
                  type: "focusNodeAdjacency",
                  seriesId: seriesModel.id,
                  edgeDataIndex: el.dataIndex
                });
              }
            });
            el.on("mouseout", el.unfocusNodeAdjHandler = function() {
              if (!sankeyView._focusAdjacencyDisabled) {
                sankeyView._dispatchUnfocus(api);
              }
            });
          }
        });
        if (!this._data && seriesModel.get("animation")) {
          group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function() {
            group.removeClipPath();
          }));
        }
        this._data = seriesModel.getData();
      },
      dispose: function() {
        this._clearTimer();
      },
      _dispatchUnfocus: function(api) {
        var self2 = this;
        this._clearTimer();
        this._unfocusDelayTimer = setTimeout(function() {
          self2._unfocusDelayTimer = null;
          api.dispatchAction({
            type: "unfocusNodeAdjacency",
            seriesId: self2._model.id
          });
        }, 500);
      },
      _clearTimer: function() {
        if (this._unfocusDelayTimer) {
          clearTimeout(this._unfocusDelayTimer);
          this._unfocusDelayTimer = null;
        }
      },
      focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var data = seriesModel.getData();
        var graph = data.graph;
        var dataIndex = payload.dataIndex;
        var itemModel = data.getItemModel(dataIndex);
        var edgeDataIndex = payload.edgeDataIndex;
        if (dataIndex == null && edgeDataIndex == null) {
          return;
        }
        var node = graph.getNodeByIndex(dataIndex);
        var edge = graph.getEdgeByIndex(edgeDataIndex);
        graph.eachNode(function(node2) {
          fadeOutItem(node2, nodeOpacityPath, 0.1);
        });
        graph.eachEdge(function(edge2) {
          fadeOutItem(edge2, lineOpacityPath, 0.1);
        });
        if (node) {
          fadeInItem(node, hoverNodeOpacityPath);
          var focusNodeAdj = itemModel.get("focusNodeAdjacency");
          if (focusNodeAdj === "outEdges") {
            zrUtil.each(node.outEdges, function(edge2) {
              if (edge2.dataIndex < 0) {
                return;
              }
              fadeInItem(edge2, hoverLineOpacityPath);
              fadeInItem(edge2.node2, hoverNodeOpacityPath);
            });
          } else if (focusNodeAdj === "inEdges") {
            zrUtil.each(node.inEdges, function(edge2) {
              if (edge2.dataIndex < 0) {
                return;
              }
              fadeInItem(edge2, hoverLineOpacityPath);
              fadeInItem(edge2.node1, hoverNodeOpacityPath);
            });
          } else if (focusNodeAdj === "allEdges") {
            zrUtil.each(node.edges, function(edge2) {
              if (edge2.dataIndex < 0) {
                return;
              }
              fadeInItem(edge2, hoverLineOpacityPath);
              edge2.node1 !== node && fadeInItem(edge2.node1, hoverNodeOpacityPath);
              edge2.node2 !== node && fadeInItem(edge2.node2, hoverNodeOpacityPath);
            });
          }
        }
        if (edge) {
          fadeInItem(edge, hoverLineOpacityPath);
          fadeInItem(edge.node1, hoverNodeOpacityPath);
          fadeInItem(edge.node2, hoverNodeOpacityPath);
        }
      },
      unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
        var graph = seriesModel.getGraph();
        graph.eachNode(function(node) {
          fadeOutItem(node, nodeOpacityPath);
        });
        graph.eachEdge(function(edge) {
          fadeOutItem(edge, lineOpacityPath);
        });
      }
    });
    function createGridClipShape(rect, seriesModel, cb) {
      var rectEl = new graphic.Rect({
        shape: {
          x: rect.x - 10,
          y: rect.y - 10,
          width: 0,
          height: rect.height + 20
        }
      });
      graphic.initProps(rectEl, {
        shape: {
          width: rect.width + 20
        }
      }, seriesModel, cb);
      return rectEl;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyAction.js
var require_sankeyAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyAction.js"() {
    var echarts = require_echarts();
    require_focusNodeAdjacencyAction();
    echarts.registerAction({
      type: "dragNode",
      event: "dragnode",
      // here can only use 'update' now, other value is not support in echarts.
      update: "update"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sankey",
        query: payload
      }, function(seriesModel) {
        seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyLayout.js
var require_sankeyLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyLayout.js"(exports, module) {
    var layout = require_layout();
    var zrUtil = require_util();
    var _model = require_model();
    var groupData = _model.groupData;
    function _default(ecModel, api, payload) {
      ecModel.eachSeriesByType("sankey", function(seriesModel) {
        var nodeWidth = seriesModel.get("nodeWidth");
        var nodeGap = seriesModel.get("nodeGap");
        var layoutInfo = getViewRect(seriesModel, api);
        seriesModel.layoutInfo = layoutInfo;
        var width = layoutInfo.width;
        var height = layoutInfo.height;
        var graph = seriesModel.getGraph();
        var nodes = graph.nodes;
        var edges = graph.edges;
        computeNodeValues(nodes);
        var filteredNodes = zrUtil.filter(nodes, function(node) {
          return node.getLayout().value === 0;
        });
        var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
        var orient = seriesModel.get("orient");
        var nodeAlign = seriesModel.get("nodeAlign");
        layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
      });
    }
    function getViewRect(seriesModel, api) {
      return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    }
    function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
      computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
      computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
      computeEdgeDepths(nodes, orient);
    }
    function computeNodeValues(nodes) {
      zrUtil.each(nodes, function(node) {
        var value1 = sum(node.outEdges, getEdgeValue);
        var value2 = sum(node.inEdges, getEdgeValue);
        var nodeRawValue = node.getValue() || 0;
        var value = Math.max(value1, value2, nodeRawValue);
        node.setLayout({
          value
        }, true);
      });
    }
    function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
      var remainEdges = [];
      var indegreeArr = [];
      var zeroIndegrees = [];
      var nextTargetNode = [];
      var x = 0;
      var kx = 0;
      for (var i = 0; i < edges.length; i++) {
        remainEdges[i] = 1;
      }
      for (i = 0; i < nodes.length; i++) {
        indegreeArr[i] = nodes[i].inEdges.length;
        if (indegreeArr[i] === 0) {
          zeroIndegrees.push(nodes[i]);
        }
      }
      var maxNodeDepth = -1;
      while (zeroIndegrees.length) {
        for (var idx = 0; idx < zeroIndegrees.length; idx++) {
          var node = zeroIndegrees[idx];
          var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
          var isItemDepth = item.depth != null && item.depth >= 0;
          if (isItemDepth && item.depth > maxNodeDepth) {
            maxNodeDepth = item.depth;
          }
          node.setLayout({
            depth: isItemDepth ? item.depth : x
          }, true);
          orient === "vertical" ? node.setLayout({
            dy: nodeWidth
          }, true) : node.setLayout({
            dx: nodeWidth
          }, true);
          for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
            var edge = node.outEdges[edgeIdx];
            var indexEdge = edges.indexOf(edge);
            remainEdges[indexEdge] = 0;
            var targetNode = edge.node2;
            var nodeIndex = nodes.indexOf(targetNode);
            if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
              nextTargetNode.push(targetNode);
            }
          }
        }
        ++x;
        zeroIndegrees = nextTargetNode;
        nextTargetNode = [];
      }
      for (i = 0; i < remainEdges.length; i++) {
        if (remainEdges[i] === 1) {
          throw new Error("Sankey is a DAG, the original data has cycle!");
        }
      }
      var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
      if (nodeAlign && nodeAlign !== "left") {
        adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
      }
      var kx = orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
      scaleNodeBreadths(nodes, kx, orient);
    }
    function isNodeDepth(node) {
      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
      return item.depth != null && item.depth >= 0;
    }
    function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
      if (nodeAlign === "right") {
        var nextSourceNode = [];
        var remainNodes = nodes;
        var nodeHeight = 0;
        while (remainNodes.length) {
          for (var i = 0; i < remainNodes.length; i++) {
            var node = remainNodes[i];
            node.setLayout({
              skNodeHeight: nodeHeight
            }, true);
            for (var j = 0; j < node.inEdges.length; j++) {
              var edge = node.inEdges[j];
              if (nextSourceNode.indexOf(edge.node1) < 0) {
                nextSourceNode.push(edge.node1);
              }
            }
          }
          remainNodes = nextSourceNode;
          nextSourceNode = [];
          ++nodeHeight;
        }
        zrUtil.each(nodes, function(node2) {
          if (!isNodeDepth(node2)) {
            node2.setLayout({
              depth: Math.max(0, maxDepth - node2.getLayout().skNodeHeight)
            }, true);
          }
        });
      } else if (nodeAlign === "justify") {
        moveSinksRight(nodes, maxDepth);
      }
    }
    function moveSinksRight(nodes, maxDepth) {
      zrUtil.each(nodes, function(node) {
        if (!isNodeDepth(node) && !node.outEdges.length) {
          node.setLayout({
            depth: maxDepth
          }, true);
        }
      });
    }
    function scaleNodeBreadths(nodes, kx, orient) {
      zrUtil.each(nodes, function(node) {
        var nodeDepth = node.getLayout().depth * kx;
        orient === "vertical" ? node.setLayout({
          y: nodeDepth
        }, true) : node.setLayout({
          x: nodeDepth
        }, true);
      });
    }
    function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
      var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
      initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
      for (var alpha = 1; iterations > 0; iterations--) {
        alpha *= 0.99;
        relaxRightToLeft(nodesByBreadth, alpha, orient);
        resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
        relaxLeftToRight(nodesByBreadth, alpha, orient);
        resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
      }
    }
    function prepareNodesByBreadth(nodes, orient) {
      var nodesByBreadth = [];
      var keyAttr = orient === "vertical" ? "y" : "x";
      var groupResult = groupData(nodes, function(node) {
        return node.getLayout()[keyAttr];
      });
      groupResult.keys.sort(function(a, b) {
        return a - b;
      });
      zrUtil.each(groupResult.keys, function(key) {
        nodesByBreadth.push(groupResult.buckets.get(key));
      });
      return nodesByBreadth;
    }
    function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
      var minKy = Infinity;
      zrUtil.each(nodesByBreadth, function(nodes) {
        var n = nodes.length;
        var sum2 = 0;
        zrUtil.each(nodes, function(node) {
          sum2 += node.getLayout().value;
        });
        var ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
        if (ky < minKy) {
          minKy = ky;
        }
      });
      zrUtil.each(nodesByBreadth, function(nodes) {
        zrUtil.each(nodes, function(node, i) {
          var nodeDy = node.getLayout().value * minKy;
          if (orient === "vertical") {
            node.setLayout({
              x: i
            }, true);
            node.setLayout({
              dx: nodeDy
            }, true);
          } else {
            node.setLayout({
              y: i
            }, true);
            node.setLayout({
              dy: nodeDy
            }, true);
          }
        });
      });
      zrUtil.each(edges, function(edge) {
        var edgeDy = +edge.getValue() * minKy;
        edge.setLayout({
          dy: edgeDy
        }, true);
      });
    }
    function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
      var keyAttr = orient === "vertical" ? "x" : "y";
      zrUtil.each(nodesByBreadth, function(nodes) {
        nodes.sort(function(a, b) {
          return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
        });
        var nodeX;
        var node;
        var dy;
        var y0 = 0;
        var n = nodes.length;
        var nodeDyAttr = orient === "vertical" ? "dx" : "dy";
        for (var i = 0; i < n; i++) {
          node = nodes[i];
          dy = y0 - node.getLayout()[keyAttr];
          if (dy > 0) {
            nodeX = node.getLayout()[keyAttr] + dy;
            orient === "vertical" ? node.setLayout({
              x: nodeX
            }, true) : node.setLayout({
              y: nodeX
            }, true);
          }
          y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
        }
        var viewWidth = orient === "vertical" ? width : height;
        dy = y0 - nodeGap - viewWidth;
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] - dy;
          orient === "vertical" ? node.setLayout({
            x: nodeX
          }, true) : node.setLayout({
            y: nodeX
          }, true);
          y0 = nodeX;
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
            if (dy > 0) {
              nodeX = node.getLayout()[keyAttr] - dy;
              orient === "vertical" ? node.setLayout({
                x: nodeX
              }, true) : node.setLayout({
                y: nodeX
              }, true);
            }
            y0 = node.getLayout()[keyAttr];
          }
        }
      });
    }
    function relaxRightToLeft(nodesByBreadth, alpha, orient) {
      zrUtil.each(nodesByBreadth.slice().reverse(), function(nodes) {
        zrUtil.each(nodes, function(node) {
          if (node.outEdges.length) {
            var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue, orient);
            if (isNaN(y)) {
              var len = node.outEdges.length;
              y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;
            }
            if (orient === "vertical") {
              var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
              node.setLayout({
                x: nodeX
              }, true);
            } else {
              var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
              node.setLayout({
                y: nodeY
              }, true);
            }
          }
        });
      });
    }
    function weightedTarget(edge, orient) {
      return center(edge.node2, orient) * edge.getValue();
    }
    function centerTarget(edge, orient) {
      return center(edge.node2, orient);
    }
    function weightedSource(edge, orient) {
      return center(edge.node1, orient) * edge.getValue();
    }
    function centerSource(edge, orient) {
      return center(edge.node1, orient);
    }
    function center(node, orient) {
      return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
    }
    function getEdgeValue(edge) {
      return edge.getValue();
    }
    function sum(array, cb, orient) {
      var sum2 = 0;
      var len = array.length;
      var i = -1;
      while (++i < len) {
        var value = +cb.call(array, array[i], orient);
        if (!isNaN(value)) {
          sum2 += value;
        }
      }
      return sum2;
    }
    function relaxLeftToRight(nodesByBreadth, alpha, orient) {
      zrUtil.each(nodesByBreadth, function(nodes) {
        zrUtil.each(nodes, function(node) {
          if (node.inEdges.length) {
            var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue, orient);
            if (isNaN(y)) {
              var len = node.inEdges.length;
              y = len ? sum(node.inEdges, centerSource, orient) / len : 0;
            }
            if (orient === "vertical") {
              var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;
              node.setLayout({
                x: nodeX
              }, true);
            } else {
              var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;
              node.setLayout({
                y: nodeY
              }, true);
            }
          }
        });
      });
    }
    function computeEdgeDepths(nodes, orient) {
      var keyAttr = orient === "vertical" ? "x" : "y";
      zrUtil.each(nodes, function(node) {
        node.outEdges.sort(function(a, b) {
          return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
        });
        node.inEdges.sort(function(a, b) {
          return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
        });
      });
      zrUtil.each(nodes, function(node) {
        var sy = 0;
        var ty = 0;
        zrUtil.each(node.outEdges, function(edge) {
          edge.setLayout({
            sy
          }, true);
          sy += edge.getLayout().dy;
        });
        zrUtil.each(node.inEdges, function(edge) {
          edge.setLayout({
            ty
          }, true);
          ty += edge.getLayout().dy;
        });
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyVisual.js
var require_sankeyVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey/sankeyVisual.js"(exports, module) {
    var VisualMapping = require_VisualMapping();
    var zrUtil = require_util();
    function _default(ecModel, payload) {
      ecModel.eachSeriesByType("sankey", function(seriesModel) {
        var graph = seriesModel.getGraph();
        var nodes = graph.nodes;
        if (nodes.length) {
          var minValue = Infinity;
          var maxValue = -Infinity;
          zrUtil.each(nodes, function(node) {
            var nodeValue = node.getLayout().value;
            if (nodeValue < minValue) {
              minValue = nodeValue;
            }
            if (nodeValue > maxValue) {
              maxValue = nodeValue;
            }
          });
          zrUtil.each(nodes, function(node) {
            var mapping = new VisualMapping({
              type: "color",
              mappingMethod: "linear",
              dataExtent: [minValue, maxValue],
              visual: seriesModel.get("color")
            });
            var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
            var customColor = node.getModel().get("itemStyle.color");
            customColor != null ? node.setVisual("color", customColor) : node.setVisual("color", mapValueToColor);
          });
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey.js
var require_sankey = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sankey.js"() {
    var echarts = require_echarts();
    require_SankeySeries();
    require_SankeyView();
    require_sankeyAction();
    var sankeyLayout = require_sankeyLayout();
    var sankeyVisual = require_sankeyVisual();
    echarts.registerLayout(sankeyLayout);
    echarts.registerVisual(sankeyVisual);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js
var require_whiskerBoxCommon = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/whiskerBoxCommon.js"(exports) {
    var createListSimply = require_createListSimply();
    var zrUtil = require_util();
    var _dimensionHelper = require_dimensionHelper();
    var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
    var _sourceHelper = require_sourceHelper();
    var makeSeriesEncodeForAxisCoordSys = _sourceHelper.makeSeriesEncodeForAxisCoordSys;
    var seriesModelMixin = {
      /**
       * @private
       * @type {string}
       */
      _baseAxisDim: null,
      /**
       * @override
       */
      getInitialData: function(option, ecModel) {
        var ordinalMeta;
        var xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
        var yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
        var xAxisType = xAxisModel.get("type");
        var yAxisType = yAxisModel.get("type");
        var addOrdinal;
        if (xAxisType === "category") {
          option.layout = "horizontal";
          ordinalMeta = xAxisModel.getOrdinalMeta();
          addOrdinal = true;
        } else if (yAxisType === "category") {
          option.layout = "vertical";
          ordinalMeta = yAxisModel.getOrdinalMeta();
          addOrdinal = true;
        } else {
          option.layout = option.layout || "horizontal";
        }
        var coordDims = ["x", "y"];
        var baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
        var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
        var otherAxisDim = coordDims[1 - baseAxisDimIndex];
        var axisModels = [xAxisModel, yAxisModel];
        var baseAxisType = axisModels[baseAxisDimIndex].get("type");
        var otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
        var data = option.data;
        if (data && addOrdinal) {
          var newOptionData = [];
          zrUtil.each(data, function(item, index) {
            var newItem;
            if (item.value && zrUtil.isArray(item.value)) {
              newItem = item.value.slice();
              item.value.unshift(index);
            } else if (zrUtil.isArray(item)) {
              newItem = item.slice();
              item.unshift(index);
            } else {
              newItem = item;
            }
            newOptionData.push(newItem);
          });
          option.data = newOptionData;
        }
        var defaultValueDimensions = this.defaultValueDimensions;
        var coordDimensions = [{
          name: baseAxisDim,
          type: getDimensionTypeByAxis(baseAxisType),
          ordinalMeta,
          otherDims: {
            tooltip: false,
            itemName: 0
          },
          dimsDef: ["base"]
        }, {
          name: otherAxisDim,
          type: getDimensionTypeByAxis(otherAxisType),
          dimsDef: defaultValueDimensions.slice()
        }];
        return createListSimply(this, {
          coordDimensions,
          dimensionsCount: defaultValueDimensions.length + 1,
          encodeDefaulter: zrUtil.curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
        });
      },
      /**
       * If horizontal, base axis is x, otherwise y.
       * @override
       */
      getBaseAxis: function() {
        var dim = this._baseAxisDim;
        return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
      }
    };
    exports.seriesModelMixin = seriesModelMixin;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js
var require_BoxplotSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var _whiskerBoxCommon = require_whiskerBoxCommon();
    var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
    var BoxplotSeries = SeriesModel.extend({
      type: "series.boxplot",
      dependencies: ["xAxis", "yAxis", "grid"],
      // TODO
      // box width represents group size, so dimension should have 'size'.
      /**
       * @see <https://en.wikipedia.org/wiki/Box_plot>
       * The meanings of 'min' and 'max' depend on user,
       * and echarts do not need to know it.
       * @readOnly
       */
      defaultValueDimensions: [{
        name: "min",
        defaultTooltip: true
      }, {
        name: "Q1",
        defaultTooltip: true
      }, {
        name: "median",
        defaultTooltip: true
      }, {
        name: "Q3",
        defaultTooltip: true
      }, {
        name: "max",
        defaultTooltip: true
      }],
      /**
       * @type {Array.<string>}
       * @readOnly
       */
      dimensions: null,
      /**
       * @override
       */
      defaultOption: {
        zlevel: 0,
        // 一级层叠
        z: 2,
        // 二级层叠
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        hoverAnimation: true,
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        layout: null,
        // 'horizontal' or 'vertical'
        boxWidth: [7, 50],
        // [min, max] can be percent of band width.
        itemStyle: {
          color: "#fff",
          borderWidth: 1
        },
        emphasis: {
          itemStyle: {
            borderWidth: 2,
            shadowBlur: 5,
            shadowOffsetX: 2,
            shadowOffsetY: 2,
            shadowColor: "rgba(0,0,0,0.4)"
          }
        },
        animationEasing: "elasticOut",
        animationDuration: 800
      }
    });
    zrUtil.mixin(BoxplotSeries, seriesModelMixin, true);
    var _default = BoxplotSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotView.js
var require_BoxplotView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/BoxplotView.js"(exports, module) {
    var zrUtil = require_util();
    var ChartView = require_Chart();
    var graphic = require_graphic();
    var Path = require_Path();
    var NORMAL_ITEM_STYLE_PATH = ["itemStyle"];
    var EMPHASIS_ITEM_STYLE_PATH = ["emphasis", "itemStyle"];
    var BoxplotView = ChartView.extend({
      type: "boxplot",
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var group = this.group;
        var oldData = this._data;
        if (!this._data) {
          group.removeAll();
        }
        var constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
        data.diff(oldData).add(function(newIdx) {
          if (data.hasValue(newIdx)) {
            var itemLayout = data.getItemLayout(newIdx);
            var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
            data.setItemGraphicEl(newIdx, symbolEl);
            group.add(symbolEl);
          }
        }).update(function(newIdx, oldIdx) {
          var symbolEl = oldData.getItemGraphicEl(oldIdx);
          if (!data.hasValue(newIdx)) {
            group.remove(symbolEl);
            return;
          }
          var itemLayout = data.getItemLayout(newIdx);
          if (!symbolEl) {
            symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
          } else {
            updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
          }
          group.add(symbolEl);
          data.setItemGraphicEl(newIdx, symbolEl);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && group.remove(el);
        }).execute();
        this._data = data;
      },
      remove: function(ecModel) {
        var group = this.group;
        var data = this._data;
        this._data = null;
        data && data.eachItemGraphicEl(function(el) {
          el && group.remove(el);
        });
      },
      dispose: zrUtil.noop
    });
    var BoxPath = Path.extend({
      type: "boxplotBoxPath",
      shape: {},
      buildPath: function(ctx, shape) {
        var ends = shape.points;
        var i = 0;
        ctx.moveTo(ends[i][0], ends[i][1]);
        i++;
        for (; i < 4; i++) {
          ctx.lineTo(ends[i][0], ends[i][1]);
        }
        ctx.closePath();
        for (; i < ends.length; i++) {
          ctx.moveTo(ends[i][0], ends[i][1]);
          i++;
          ctx.lineTo(ends[i][0], ends[i][1]);
        }
      }
    });
    function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
      var ends = itemLayout.ends;
      var el = new BoxPath({
        shape: {
          points: isInit ? transInit(ends, constDim, itemLayout) : ends
        }
      });
      updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
      return el;
    }
    function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
      var seriesModel = data.hostModel;
      var updateMethod = graphic[isInit ? "initProps" : "updateProps"];
      updateMethod(el, {
        shape: {
          points: itemLayout.ends
        }
      }, seriesModel, dataIndex);
      var itemModel = data.getItemModel(dataIndex);
      var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
      var borderColor = data.getItemVisual(dataIndex, "color");
      var itemStyle = normalItemStyleModel.getItemStyle(["borderColor"]);
      itemStyle.stroke = borderColor;
      itemStyle.strokeNoScale = true;
      el.useStyle(itemStyle);
      el.z2 = 100;
      var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
      graphic.setHoverStyle(el, hoverStyle);
    }
    function transInit(points, dim, itemLayout) {
      return zrUtil.map(points, function(point) {
        point = point.slice();
        point[dim] = itemLayout.initBaseline;
        return point;
      });
    }
    var _default = BoxplotView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotVisual.js
var require_boxplotVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotVisual.js"(exports, module) {
    var borderColorQuery = ["itemStyle", "borderColor"];
    function _default(ecModel, api) {
      var globalColors = ecModel.get("color");
      ecModel.eachRawSeriesByType("boxplot", function(seriesModel) {
        var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];
        var data = seriesModel.getData();
        data.setVisual({
          legendSymbol: "roundRect",
          // Use name 'color' but not 'borderColor' for legend usage and
          // visual coding from other component like dataRange.
          color: seriesModel.get(borderColorQuery) || defaulColor
        });
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          data.each(function(idx) {
            var itemModel = data.getItemModel(idx);
            data.setItemVisual(idx, {
              color: itemModel.get(borderColorQuery, true)
            });
          });
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotLayout.js
var require_boxplotLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot/boxplotLayout.js"(exports, module) {
    var zrUtil = require_util();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var each = zrUtil.each;
    function _default(ecModel) {
      var groupResult = groupSeriesByAxis(ecModel);
      each(groupResult, function(groupItem) {
        var seriesModels = groupItem.seriesModels;
        if (!seriesModels.length) {
          return;
        }
        calculateBase(groupItem);
        each(seriesModels, function(seriesModel, idx) {
          layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
        });
      });
    }
    function groupSeriesByAxis(ecModel) {
      var result = [];
      var axisList = [];
      ecModel.eachSeriesByType("boxplot", function(seriesModel) {
        var baseAxis = seriesModel.getBaseAxis();
        var idx = zrUtil.indexOf(axisList, baseAxis);
        if (idx < 0) {
          idx = axisList.length;
          axisList[idx] = baseAxis;
          result[idx] = {
            axis: baseAxis,
            seriesModels: []
          };
        }
        result[idx].seriesModels.push(seriesModel);
      });
      return result;
    }
    function calculateBase(groupItem) {
      var extent;
      var baseAxis = groupItem.axis;
      var seriesModels = groupItem.seriesModels;
      var seriesCount = seriesModels.length;
      var boxWidthList = groupItem.boxWidthList = [];
      var boxOffsetList = groupItem.boxOffsetList = [];
      var boundList = [];
      var bandWidth;
      if (baseAxis.type === "category") {
        bandWidth = baseAxis.getBandWidth();
      } else {
        var maxDataCount = 0;
        each(seriesModels, function(seriesModel) {
          maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
        });
        extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;
      }
      each(seriesModels, function(seriesModel) {
        var boxWidthBound = seriesModel.get("boxWidth");
        if (!zrUtil.isArray(boxWidthBound)) {
          boxWidthBound = [boxWidthBound, boxWidthBound];
        }
        boundList.push([parsePercent(boxWidthBound[0], bandWidth) || 0, parsePercent(boxWidthBound[1], bandWidth) || 0]);
      });
      var availableWidth = bandWidth * 0.8 - 2;
      var boxGap = availableWidth / seriesCount * 0.3;
      var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
      var base = boxWidth / 2 - availableWidth / 2;
      each(seriesModels, function(seriesModel, idx) {
        boxOffsetList.push(base);
        base += boxGap + boxWidth;
        boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
      });
    }
    function layoutSingleSeries(seriesModel, offset, boxWidth) {
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var halfWidth = boxWidth / 2;
      var cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
      var vDimIdx = 1 - cDimIdx;
      var coordDims = ["x", "y"];
      var cDim = data.mapDimension(coordDims[cDimIdx]);
      var vDims = data.mapDimension(coordDims[vDimIdx], true);
      if (cDim == null || vDims.length < 5) {
        return;
      }
      for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
        var axisDimVal = data.get(cDim, dataIndex);
        var median = getPoint(axisDimVal, vDims[2], dataIndex);
        var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
        var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
        var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
        var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
        var ends = [];
        addBodyEnd(ends, end2, 0);
        addBodyEnd(ends, end4, 1);
        ends.push(end1, end2, end5, end4);
        layEndLine(ends, end1);
        layEndLine(ends, end5);
        layEndLine(ends, median);
        data.setItemLayout(dataIndex, {
          initBaseline: median[vDimIdx],
          ends
        });
      }
      function getPoint(axisDimVal2, dimIdx, dataIndex2) {
        var val = data.get(dimIdx, dataIndex2);
        var p = [];
        p[cDimIdx] = axisDimVal2;
        p[vDimIdx] = val;
        var point;
        if (isNaN(axisDimVal2) || isNaN(val)) {
          point = [NaN, NaN];
        } else {
          point = coordSys.dataToPoint(p);
          point[cDimIdx] += offset;
        }
        return point;
      }
      function addBodyEnd(ends2, point, start) {
        var point1 = point.slice();
        var point2 = point.slice();
        point1[cDimIdx] += halfWidth;
        point2[cDimIdx] -= halfWidth;
        start ? ends2.push(point1, point2) : ends2.push(point2, point1);
      }
      function layEndLine(ends2, endCenter) {
        var from = endCenter.slice();
        var to = endCenter.slice();
        from[cDimIdx] -= halfWidth;
        to[cDimIdx] += halfWidth;
        ends2.push(from, to);
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot.js
var require_boxplot = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/boxplot.js"() {
    var echarts = require_echarts();
    require_BoxplotSeries();
    require_BoxplotView();
    var boxplotVisual = require_boxplotVisual();
    var boxplotLayout = require_boxplotLayout();
    echarts.registerVisual(boxplotVisual);
    echarts.registerLayout(boxplotLayout);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js
var require_CandlestickSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var _whiskerBoxCommon = require_whiskerBoxCommon();
    var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
    var CandlestickSeries = SeriesModel.extend({
      type: "series.candlestick",
      dependencies: ["xAxis", "yAxis", "grid"],
      /**
       * @readOnly
       */
      defaultValueDimensions: [{
        name: "open",
        defaultTooltip: true
      }, {
        name: "close",
        defaultTooltip: true
      }, {
        name: "lowest",
        defaultTooltip: true
      }, {
        name: "highest",
        defaultTooltip: true
      }],
      /**
       * @type {Array.<string>}
       * @readOnly
       */
      dimensions: null,
      /**
       * @override
       */
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "cartesian2d",
        legendHoverLink: true,
        hoverAnimation: true,
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        layout: null,
        // 'horizontal' or 'vertical'
        clip: true,
        itemStyle: {
          color: "#c23531",
          // 阳线 positive
          color0: "#314656",
          // 阴线 negative     '#c23531', '#314656'
          borderWidth: 1,
          // FIXME
          // ec2中使用的是lineStyle.color 和 lineStyle.color0
          borderColor: "#c23531",
          borderColor0: "#314656"
        },
        emphasis: {
          itemStyle: {
            borderWidth: 2
          }
        },
        barMaxWidth: null,
        barMinWidth: null,
        barWidth: null,
        large: true,
        largeThreshold: 600,
        progressive: 3e3,
        progressiveThreshold: 1e4,
        progressiveChunkMode: "mod",
        animationUpdate: false,
        animationEasing: "linear",
        animationDuration: 300
      },
      /**
       * Get dimension for shadow in dataZoom
       * @return {string} dimension name
       */
      getShadowDim: function() {
        return "open";
      },
      brushSelector: function(dataIndex, data, selectors) {
        var itemLayout = data.getItemLayout(dataIndex);
        return itemLayout && selectors.rect(itemLayout.brushRect);
      }
    });
    zrUtil.mixin(CandlestickSeries, seriesModelMixin, true);
    var _default = CandlestickSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickView.js
var require_CandlestickView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/CandlestickView.js"(exports, module) {
    var zrUtil = require_util();
    var ChartView = require_Chart();
    var graphic = require_graphic();
    var Path = require_Path();
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var NORMAL_ITEM_STYLE_PATH = ["itemStyle"];
    var EMPHASIS_ITEM_STYLE_PATH = ["emphasis", "itemStyle"];
    var SKIP_PROPS = ["color", "color0", "borderColor", "borderColor0"];
    var CandlestickView = ChartView.extend({
      type: "candlestick",
      render: function(seriesModel, ecModel, api) {
        this.group.removeClipPath();
        this._updateDrawMode(seriesModel);
        this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this._clear();
        this._updateDrawMode(seriesModel);
      },
      incrementalRender: function(params, seriesModel, ecModel, api) {
        this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
      },
      _updateDrawMode: function(seriesModel) {
        var isLargeDraw = seriesModel.pipelineContext.large;
        if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw;
          this._clear();
        }
      },
      _renderNormal: function(seriesModel) {
        var data = seriesModel.getData();
        var oldData = this._data;
        var group = this.group;
        var isSimpleBox = data.getLayout("isSimpleBox");
        var needsClip = seriesModel.get("clip", true);
        var coord = seriesModel.coordinateSystem;
        var clipArea = coord.getArea && coord.getArea();
        if (!this._data) {
          group.removeAll();
        }
        data.diff(oldData).add(function(newIdx) {
          if (data.hasValue(newIdx)) {
            var el;
            var itemLayout = data.getItemLayout(newIdx);
            if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
              return;
            }
            el = createNormalBox(itemLayout, newIdx, true);
            graphic.initProps(el, {
              shape: {
                points: itemLayout.ends
              }
            }, seriesModel, newIdx);
            setBoxCommon(el, data, newIdx, isSimpleBox);
            group.add(el);
            data.setItemGraphicEl(newIdx, el);
          }
        }).update(function(newIdx, oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          if (!data.hasValue(newIdx)) {
            group.remove(el);
            return;
          }
          var itemLayout = data.getItemLayout(newIdx);
          if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
            group.remove(el);
            return;
          }
          if (!el) {
            el = createNormalBox(itemLayout, newIdx);
          } else {
            graphic.updateProps(el, {
              shape: {
                points: itemLayout.ends
              }
            }, seriesModel, newIdx);
          }
          setBoxCommon(el, data, newIdx, isSimpleBox);
          group.add(el);
          data.setItemGraphicEl(newIdx, el);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && group.remove(el);
        }).execute();
        this._data = data;
      },
      _renderLarge: function(seriesModel) {
        this._clear();
        createLarge(seriesModel, this.group);
        var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
        if (clipPath) {
          this.group.setClipPath(clipPath);
        } else {
          this.group.removeClipPath();
        }
      },
      _incrementalRenderNormal: function(params, seriesModel) {
        var data = seriesModel.getData();
        var isSimpleBox = data.getLayout("isSimpleBox");
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var el;
          var itemLayout = data.getItemLayout(dataIndex);
          el = createNormalBox(itemLayout, dataIndex);
          setBoxCommon(el, data, dataIndex, isSimpleBox);
          el.incremental = true;
          this.group.add(el);
        }
      },
      _incrementalRenderLarge: function(params, seriesModel) {
        createLarge(seriesModel, this.group, true);
      },
      remove: function(ecModel) {
        this._clear();
      },
      _clear: function() {
        this.group.removeAll();
        this._data = null;
      },
      dispose: zrUtil.noop
    });
    var NormalBoxPath = Path.extend({
      type: "normalCandlestickBox",
      shape: {},
      buildPath: function(ctx, shape) {
        var ends = shape.points;
        if (this.__simpleBox) {
          ctx.moveTo(ends[4][0], ends[4][1]);
          ctx.lineTo(ends[6][0], ends[6][1]);
        } else {
          ctx.moveTo(ends[0][0], ends[0][1]);
          ctx.lineTo(ends[1][0], ends[1][1]);
          ctx.lineTo(ends[2][0], ends[2][1]);
          ctx.lineTo(ends[3][0], ends[3][1]);
          ctx.closePath();
          ctx.moveTo(ends[4][0], ends[4][1]);
          ctx.lineTo(ends[5][0], ends[5][1]);
          ctx.moveTo(ends[6][0], ends[6][1]);
          ctx.lineTo(ends[7][0], ends[7][1]);
        }
      }
    });
    function createNormalBox(itemLayout, dataIndex, isInit) {
      var ends = itemLayout.ends;
      return new NormalBoxPath({
        shape: {
          points: isInit ? transInit(ends, itemLayout) : ends
        },
        z2: 100
      });
    }
    function isNormalBoxClipped(clipArea, itemLayout) {
      var clipped = true;
      for (var i = 0; i < itemLayout.ends.length; i++) {
        if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
          clipped = false;
          break;
        }
      }
      return clipped;
    }
    function setBoxCommon(el, data, dataIndex, isSimpleBox) {
      var itemModel = data.getItemModel(dataIndex);
      var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
      var color = data.getItemVisual(dataIndex, "color");
      var borderColor = data.getItemVisual(dataIndex, "borderColor") || color;
      var itemStyle = normalItemStyleModel.getItemStyle(SKIP_PROPS);
      el.useStyle(itemStyle);
      el.style.strokeNoScale = true;
      el.style.fill = color;
      el.style.stroke = borderColor;
      el.__simpleBox = isSimpleBox;
      var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
      graphic.setHoverStyle(el, hoverStyle);
    }
    function transInit(points, itemLayout) {
      return zrUtil.map(points, function(point) {
        point = point.slice();
        point[1] = itemLayout.initBaseline;
        return point;
      });
    }
    var LargeBoxPath = Path.extend({
      type: "largeCandlestickBox",
      shape: {},
      buildPath: function(ctx, shape) {
        var points = shape.points;
        for (var i = 0; i < points.length; ) {
          if (this.__sign === points[i++]) {
            var x = points[i++];
            ctx.moveTo(x, points[i++]);
            ctx.lineTo(x, points[i++]);
          } else {
            i += 3;
          }
        }
      }
    });
    function createLarge(seriesModel, group, incremental) {
      var data = seriesModel.getData();
      var largePoints = data.getLayout("largePoints");
      var elP = new LargeBoxPath({
        shape: {
          points: largePoints
        },
        __sign: 1
      });
      group.add(elP);
      var elN = new LargeBoxPath({
        shape: {
          points: largePoints
        },
        __sign: -1
      });
      group.add(elN);
      setLargeStyle(1, elP, seriesModel, data);
      setLargeStyle(-1, elN, seriesModel, data);
      if (incremental) {
        elP.incremental = true;
        elN.incremental = true;
      }
    }
    function setLargeStyle(sign, el, seriesModel, data) {
      var suffix = sign > 0 ? "P" : "N";
      var borderColor = data.getVisual("borderColor" + suffix) || data.getVisual("color" + suffix);
      var itemStyle = seriesModel.getModel(NORMAL_ITEM_STYLE_PATH).getItemStyle(SKIP_PROPS);
      el.useStyle(itemStyle);
      el.style.fill = null;
      el.style.stroke = borderColor;
    }
    var _default = CandlestickView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/preprocessor.js
var require_preprocessor = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      if (!option || !zrUtil.isArray(option.series)) {
        return;
      }
      zrUtil.each(option.series, function(seriesItem) {
        if (zrUtil.isObject(seriesItem) && seriesItem.type === "k") {
          seriesItem.type = "candlestick";
        }
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickVisual.js
var require_candlestickVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickVisual.js"(exports, module) {
    var createRenderPlanner = require_createRenderPlanner();
    var positiveBorderColorQuery = ["itemStyle", "borderColor"];
    var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
    var positiveColorQuery = ["itemStyle", "color"];
    var negativeColorQuery = ["itemStyle", "color0"];
    var _default = {
      seriesType: "candlestick",
      plan: createRenderPlanner(),
      // For legend.
      performRawSeries: true,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        data.setVisual({
          legendSymbol: "roundRect",
          colorP: getColor(1, seriesModel),
          colorN: getColor(-1, seriesModel),
          borderColorP: getBorderColor(1, seriesModel),
          borderColorN: getBorderColor(-1, seriesModel)
        });
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        var isLargeRender = seriesModel.pipelineContext.large;
        return !isLargeRender && {
          progress
        };
        function progress(params, data2) {
          var dataIndex;
          while ((dataIndex = params.next()) != null) {
            var itemModel = data2.getItemModel(dataIndex);
            var sign = data2.getItemLayout(dataIndex).sign;
            data2.setItemVisual(dataIndex, {
              color: getColor(sign, itemModel),
              borderColor: getBorderColor(sign, itemModel)
            });
          }
        }
        function getColor(sign, model) {
          return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
        }
        function getBorderColor(sign, model) {
          return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
        }
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickLayout.js
var require_candlestickLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick/candlestickLayout.js"(exports, module) {
    var _graphic = require_graphic();
    var subPixelOptimize = _graphic.subPixelOptimize;
    var createRenderPlanner = require_createRenderPlanner();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _util = require_util();
    var retrieve2 = _util.retrieve2;
    var LargeArr = typeof Float32Array !== "undefined" ? Float32Array : Array;
    var _default = {
      seriesType: "candlestick",
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var data = seriesModel.getData();
        var candleWidth = calculateCandleWidth(seriesModel, data);
        var cDimIdx = 0;
        var vDimIdx = 1;
        var coordDims = ["x", "y"];
        var cDim = data.mapDimension(coordDims[cDimIdx]);
        var vDims = data.mapDimension(coordDims[vDimIdx], true);
        var openDim = vDims[0];
        var closeDim = vDims[1];
        var lowestDim = vDims[2];
        var highestDim = vDims[3];
        data.setLayout({
          candleWidth,
          // The value is experimented visually.
          isSimpleBox: candleWidth <= 1.3
        });
        if (cDim == null || vDims.length < 4) {
          return;
        }
        return {
          progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
        };
        function normalProgress(params, data2) {
          var dataIndex;
          while ((dataIndex = params.next()) != null) {
            var axisDimVal = data2.get(cDim, dataIndex);
            var openVal = data2.get(openDim, dataIndex);
            var closeVal = data2.get(closeDim, dataIndex);
            var lowestVal = data2.get(lowestDim, dataIndex);
            var highestVal = data2.get(highestDim, dataIndex);
            var ocLow = Math.min(openVal, closeVal);
            var ocHigh = Math.max(openVal, closeVal);
            var ocLowPoint = getPoint(ocLow, axisDimVal);
            var ocHighPoint = getPoint(ocHigh, axisDimVal);
            var lowestPoint = getPoint(lowestVal, axisDimVal);
            var highestPoint = getPoint(highestVal, axisDimVal);
            var ends = [];
            addBodyEnd(ends, ocHighPoint, 0);
            addBodyEnd(ends, ocLowPoint, 1);
            ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
            data2.setItemLayout(dataIndex, {
              sign: getSign(data2, dataIndex, openVal, closeVal, closeDim),
              initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
              // open point.
              ends,
              brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
            });
          }
          function getPoint(val, axisDimVal2) {
            var p = [];
            p[cDimIdx] = axisDimVal2;
            p[vDimIdx] = val;
            return isNaN(axisDimVal2) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
          }
          function addBodyEnd(ends2, point, start) {
            var point1 = point.slice();
            var point2 = point.slice();
            point1[cDimIdx] = subPixelOptimize(point1[cDimIdx] + candleWidth / 2, 1, false);
            point2[cDimIdx] = subPixelOptimize(point2[cDimIdx] - candleWidth / 2, 1, true);
            start ? ends2.push(point1, point2) : ends2.push(point2, point1);
          }
          function makeBrushRect(lowestVal2, highestVal2, axisDimVal2) {
            var pmin = getPoint(lowestVal2, axisDimVal2);
            var pmax = getPoint(highestVal2, axisDimVal2);
            pmin[cDimIdx] -= candleWidth / 2;
            pmax[cDimIdx] -= candleWidth / 2;
            return {
              x: pmin[0],
              y: pmin[1],
              width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
              height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
            };
          }
          function subPixelOptimizePoint(point) {
            point[cDimIdx] = subPixelOptimize(point[cDimIdx], 1);
            return point;
          }
        }
        function largeProgress(params, data2) {
          var points = new LargeArr(params.count * 4);
          var offset = 0;
          var point;
          var tmpIn = [];
          var tmpOut = [];
          var dataIndex;
          while ((dataIndex = params.next()) != null) {
            var axisDimVal = data2.get(cDim, dataIndex);
            var openVal = data2.get(openDim, dataIndex);
            var closeVal = data2.get(closeDim, dataIndex);
            var lowestVal = data2.get(lowestDim, dataIndex);
            var highestVal = data2.get(highestDim, dataIndex);
            if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
              points[offset++] = NaN;
              offset += 3;
              continue;
            }
            points[offset++] = getSign(data2, dataIndex, openVal, closeVal, closeDim);
            tmpIn[cDimIdx] = axisDimVal;
            tmpIn[vDimIdx] = lowestVal;
            point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            points[offset++] = point ? point[0] : NaN;
            points[offset++] = point ? point[1] : NaN;
            tmpIn[vDimIdx] = highestVal;
            point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            points[offset++] = point ? point[1] : NaN;
          }
          data2.setLayout("largePoints", points);
        }
      }
    };
    function getSign(data, dataIndex, openVal, closeVal, closeDim) {
      var sign;
      if (openVal > closeVal) {
        sign = -1;
      } else if (openVal < closeVal) {
        sign = 1;
      } else {
        sign = dataIndex > 0 ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : (
          // No record of previous, set to be positive
          1
        );
      }
      return sign;
    }
    function calculateCandleWidth(seriesModel, data) {
      var baseAxis = seriesModel.getBaseAxis();
      var extent;
      var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
      var barMaxWidth = parsePercent(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
      var barMinWidth = parsePercent(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
      var barWidth = seriesModel.get("barWidth");
      return barWidth != null ? parsePercent(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick.js
var require_candlestick = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/candlestick.js"() {
    var echarts = require_echarts();
    require_CandlestickSeries();
    require_CandlestickView();
    var preprocessor = require_preprocessor();
    var candlestickVisual = require_candlestickVisual();
    var candlestickLayout = require_candlestickLayout();
    echarts.registerPreprocessor(preprocessor);
    echarts.registerVisual(candlestickVisual);
    echarts.registerLayout(candlestickLayout);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js
var require_EffectScatterSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterSeries.js"(exports, module) {
    var createListFromArray = require_createListFromArray();
    var SeriesModel = require_Series();
    var _default = SeriesModel.extend({
      type: "series.effectScatter",
      dependencies: ["grid", "polar"],
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          useEncodeDefaulter: true
        });
      },
      brushSelector: "point",
      defaultOption: {
        coordinateSystem: "cartesian2d",
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        effectType: "ripple",
        progressive: 0,
        // When to show the effect, option: 'render'|'emphasis'
        showEffectOn: "render",
        // Ripple effect config
        rippleEffect: {
          period: 4,
          // Scale of ripple
          scale: 2.5,
          // Brush type can be fill or stroke
          brushType: "fill"
        },
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Polar coordinate system
        // polarIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,
        // symbol: null,        // 图形类型
        symbolSize: 10
        // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
        // symbolRotate: null,  // 图形旋转控制
        // large: false,
        // Available when large is true
        // largeThreshold: 2000,
        // itemStyle: {
        //     opacity: 1
        // }
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectSymbol.js
var require_EffectSymbol = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectSymbol.js"(exports, module) {
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var _graphic = require_graphic();
    var Group = _graphic.Group;
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var SymbolClz = require_Symbol();
    var EFFECT_RIPPLE_NUMBER = 3;
    function normalizeSymbolSize(symbolSize) {
      if (!zrUtil.isArray(symbolSize)) {
        symbolSize = [+symbolSize, +symbolSize];
      }
      return symbolSize;
    }
    function updateRipplePath(rippleGroup, effectCfg) {
      var color = effectCfg.rippleEffectColor || effectCfg.color;
      rippleGroup.eachChild(function(ripplePath) {
        ripplePath.attr({
          z: effectCfg.z,
          zlevel: effectCfg.zlevel,
          style: {
            stroke: effectCfg.brushType === "stroke" ? color : null,
            fill: effectCfg.brushType === "fill" ? color : null
          }
        });
      });
    }
    function EffectSymbol(data, idx) {
      Group.call(this);
      var symbol = new SymbolClz(data, idx);
      var rippleGroup = new Group();
      this.add(symbol);
      this.add(rippleGroup);
      rippleGroup.beforeUpdate = function() {
        this.attr(symbol.getScale());
      };
      this.updateData(data, idx);
    }
    var effectSymbolProto = EffectSymbol.prototype;
    effectSymbolProto.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    };
    effectSymbolProto.startEffectAnimation = function(effectCfg) {
      var symbolType = effectCfg.symbolType;
      var color = effectCfg.color;
      var rippleGroup = this.childAt(1);
      for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {
        var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color);
        ripplePath.attr({
          style: {
            strokeNoScale: true
          },
          z2: 99,
          silent: true,
          scale: [0.5, 0.5]
        });
        var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset;
        ripplePath.animate("", true).when(effectCfg.period, {
          scale: [effectCfg.rippleScale / 2, effectCfg.rippleScale / 2]
        }).delay(delay).start();
        ripplePath.animateStyle(true).when(effectCfg.period, {
          opacity: 0
        }).delay(delay).start();
        rippleGroup.add(ripplePath);
      }
      updateRipplePath(rippleGroup, effectCfg);
    };
    effectSymbolProto.updateEffectAnimation = function(effectCfg) {
      var oldEffectCfg = this._effectCfg;
      var rippleGroup = this.childAt(1);
      var DIFFICULT_PROPS = ["symbolType", "period", "rippleScale"];
      for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
        var propName = DIFFICULT_PROPS[i];
        if (oldEffectCfg[propName] !== effectCfg[propName]) {
          this.stopEffectAnimation();
          this.startEffectAnimation(effectCfg);
          return;
        }
      }
      updateRipplePath(rippleGroup, effectCfg);
    };
    effectSymbolProto.highlight = function() {
      this.trigger("emphasis");
    };
    effectSymbolProto.downplay = function() {
      this.trigger("normal");
    };
    effectSymbolProto.updateData = function(data, idx) {
      var seriesModel = data.hostModel;
      this.childAt(0).updateData(data, idx);
      var rippleGroup = this.childAt(1);
      var itemModel = data.getItemModel(idx);
      var symbolType = data.getItemVisual(idx, "symbol");
      var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
      var color = data.getItemVisual(idx, "color");
      rippleGroup.attr("scale", symbolSize);
      rippleGroup.traverse(function(ripplePath) {
        ripplePath.attr({
          fill: color
        });
      });
      var symbolOffset = itemModel.getShallow("symbolOffset");
      if (symbolOffset) {
        var pos = rippleGroup.position;
        pos[0] = parsePercent(symbolOffset[0], symbolSize[0]);
        pos[1] = parsePercent(symbolOffset[1], symbolSize[1]);
      }
      var symbolRotate = data.getItemVisual(idx, "symbolRotate");
      rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
      var effectCfg = {};
      effectCfg.showEffectOn = seriesModel.get("showEffectOn");
      effectCfg.rippleScale = itemModel.get("rippleEffect.scale");
      effectCfg.brushType = itemModel.get("rippleEffect.brushType");
      effectCfg.period = itemModel.get("rippleEffect.period") * 1e3;
      effectCfg.effectOffset = idx / data.count();
      effectCfg.z = itemModel.getShallow("z") || 0;
      effectCfg.zlevel = itemModel.getShallow("zlevel") || 0;
      effectCfg.symbolType = symbolType;
      effectCfg.color = color;
      effectCfg.rippleEffectColor = itemModel.get("rippleEffect.color");
      this.off("mouseover").off("mouseout").off("emphasis").off("normal");
      if (effectCfg.showEffectOn === "render") {
        this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
        this._effectCfg = effectCfg;
      } else {
        this._effectCfg = null;
        this.stopEffectAnimation();
        var symbol = this.childAt(0);
        var onEmphasis = function() {
          symbol.highlight();
          if (effectCfg.showEffectOn !== "render") {
            this.startEffectAnimation(effectCfg);
          }
        };
        var onNormal = function() {
          symbol.downplay();
          if (effectCfg.showEffectOn !== "render") {
            this.stopEffectAnimation();
          }
        };
        this.on("mouseover", onEmphasis, this).on("mouseout", onNormal, this).on("emphasis", onEmphasis, this).on("normal", onNormal, this);
      }
      this._effectCfg = effectCfg;
    };
    effectSymbolProto.fadeOut = function(cb) {
      this.off("mouseover").off("mouseout").off("emphasis").off("normal");
      cb && cb();
    };
    zrUtil.inherits(EffectSymbol, Group);
    var _default = EffectSymbol;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js
var require_EffectScatterView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter/EffectScatterView.js"(exports, module) {
    var echarts = require_echarts();
    var SymbolDraw = require_SymbolDraw();
    var EffectSymbol = require_EffectSymbol();
    var matrix = require_matrix();
    var pointsLayout = require_points();
    var _default = echarts.extendChartView({
      type: "effectScatter",
      init: function() {
        this._symbolDraw = new SymbolDraw(EffectSymbol);
      },
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var effectSymbolDraw = this._symbolDraw;
        effectSymbolDraw.updateData(data);
        this.group.add(effectSymbolDraw.group);
      },
      updateTransform: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        this.group.dirty();
        var res = pointsLayout().reset(seriesModel);
        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count()
          }, data);
        }
        this._symbolDraw.updateLayout(data);
      },
      _updateGroupTransform: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.getRoamTransform) {
          this.group.transform = matrix.clone(coordSys.getRoamTransform());
          this.group.decomposeTransform();
        }
      },
      remove: function(ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove(api);
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter.js
var require_effectScatter = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/effectScatter.js"() {
    var echarts = require_echarts();
    require_EffectScatterSeries();
    require_EffectScatterView();
    var visualSymbol = require_symbol2();
    var layoutPoints = require_points();
    echarts.registerVisual(visualSymbol("effectScatter", "circle"));
    echarts.registerLayout(layoutPoints("effectScatter"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesSeries.js
var require_LinesSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesSeries.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var SeriesModel = require_Series();
    var List = require_List();
    var _util = require_util();
    var concatArray = _util.concatArray;
    var mergeAll = _util.mergeAll;
    var map = _util.map;
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var CoordinateSystem = require_CoordinateSystem();
    var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
    var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
    function compatEc2(seriesOpt) {
      var data = seriesOpt.data;
      if (data && data[0] && data[0][0] && data[0][0].coord) {
        seriesOpt.data = map(data, function(itemOpt) {
          var coords = [itemOpt[0].coord, itemOpt[1].coord];
          var target = {
            coords
          };
          if (itemOpt[0].name) {
            target.fromName = itemOpt[0].name;
          }
          if (itemOpt[1].name) {
            target.toName = itemOpt[1].name;
          }
          return mergeAll([target, itemOpt[0], itemOpt[1]]);
        });
      }
    }
    var LinesSeries = SeriesModel.extend({
      type: "series.lines",
      dependencies: ["grid", "polar"],
      visualColorAccessPath: "lineStyle.color",
      init: function(option) {
        option.data = option.data || [];
        compatEc2(option);
        var result = this._processFlatCoordsArray(option.data);
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
        if (result.flatCoords) {
          option.data = new Float32Array(result.count);
        }
        LinesSeries.superApply(this, "init", arguments);
      },
      mergeOption: function(option) {
        compatEc2(option);
        if (option.data) {
          var result = this._processFlatCoordsArray(option.data);
          this._flatCoords = result.flatCoords;
          this._flatCoordsOffset = result.flatCoordsOffset;
          if (result.flatCoords) {
            option.data = new Float32Array(result.count);
          }
        }
        LinesSeries.superApply(this, "mergeOption", arguments);
      },
      appendData: function(params) {
        var result = this._processFlatCoordsArray(params.data);
        if (result.flatCoords) {
          if (!this._flatCoords) {
            this._flatCoords = result.flatCoords;
            this._flatCoordsOffset = result.flatCoordsOffset;
          } else {
            this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
            this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
          }
          params.data = new Float32Array(result.count);
        }
        this.getRawData().appendData(params.data);
      },
      _getCoordsFromItemModel: function(idx) {
        var itemModel = this.getData().getItemModel(idx);
        var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
        return coords;
      },
      getLineCoordsCount: function(idx) {
        if (this._flatCoordsOffset) {
          return this._flatCoordsOffset[idx * 2 + 1];
        } else {
          return this._getCoordsFromItemModel(idx).length;
        }
      },
      getLineCoords: function(idx, out) {
        if (this._flatCoordsOffset) {
          var offset = this._flatCoordsOffset[idx * 2];
          var len = this._flatCoordsOffset[idx * 2 + 1];
          for (var i = 0; i < len; i++) {
            out[i] = out[i] || [];
            out[i][0] = this._flatCoords[offset + i * 2];
            out[i][1] = this._flatCoords[offset + i * 2 + 1];
          }
          return len;
        } else {
          var coords = this._getCoordsFromItemModel(idx);
          for (var i = 0; i < coords.length; i++) {
            out[i] = out[i] || [];
            out[i][0] = coords[i][0];
            out[i][1] = coords[i][1];
          }
          return coords.length;
        }
      },
      _processFlatCoordsArray: function(data) {
        var startOffset = 0;
        if (this._flatCoords) {
          startOffset = this._flatCoords.length;
        }
        if (typeof data[0] === "number") {
          var len = data.length;
          var coordsOffsetAndLenStorage = new Uint32Arr(len);
          var coordsStorage = new Float64Arr(len);
          var coordsCursor = 0;
          var offsetCursor = 0;
          var dataCount = 0;
          for (var i = 0; i < len; ) {
            dataCount++;
            var count = data[i++];
            coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
            coordsOffsetAndLenStorage[offsetCursor++] = count;
            for (var k = 0; k < count; k++) {
              var x = data[i++];
              var y = data[i++];
              coordsStorage[coordsCursor++] = x;
              coordsStorage[coordsCursor++] = y;
              if (i > len) {
              }
            }
          }
          return {
            flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
            flatCoords: coordsStorage,
            count: dataCount
          };
        }
        return {
          flatCoordsOffset: null,
          flatCoords: null,
          count: data.length
        };
      },
      getInitialData: function(option, ecModel) {
        var lineData = new List(["value"], this);
        lineData.hasItemOption = false;
        lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
          if (dataItem instanceof Array) {
            return NaN;
          } else {
            lineData.hasItemOption = true;
            var value = dataItem.value;
            if (value != null) {
              return value instanceof Array ? value[dimIndex] : value;
            }
          }
        });
        return lineData;
      },
      formatTooltip: function(dataIndex) {
        var data = this.getData();
        var itemModel = data.getItemModel(dataIndex);
        var name2 = itemModel.get("name");
        if (name2) {
          return name2;
        }
        var fromName = itemModel.get("fromName");
        var toName = itemModel.get("toName");
        var html = [];
        fromName != null && html.push(fromName);
        toName != null && html.push(toName);
        return encodeHTML(html.join(" > "));
      },
      preventIncremental: function() {
        return !!this.get("effect.show");
      },
      getProgressive: function() {
        var progressive = this.option.progressive;
        if (progressive == null) {
          return this.option.large ? 1e4 : this.get("progressive");
        }
        return progressive;
      },
      getProgressiveThreshold: function() {
        var progressiveThreshold = this.option.progressiveThreshold;
        if (progressiveThreshold == null) {
          return this.option.large ? 2e4 : this.get("progressiveThreshold");
        }
        return progressiveThreshold;
      },
      defaultOption: {
        coordinateSystem: "geo",
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        hoverAnimation: true,
        // Cartesian coordinate system
        xAxisIndex: 0,
        yAxisIndex: 0,
        symbol: ["none", "none"],
        symbolSize: [10, 10],
        // Geo coordinate system
        geoIndex: 0,
        effect: {
          show: false,
          period: 4,
          // Animation delay. support callback
          // delay: 0,
          // If move with constant speed px/sec
          // period will be ignored if this property is > 0,
          constantSpeed: 0,
          symbol: "circle",
          symbolSize: 3,
          loop: true,
          // Length of trail, 0 - 1
          trailLength: 0.2
          // Same with lineStyle.color
          // color
        },
        large: false,
        // Available when large is true
        largeThreshold: 2e3,
        // If lines are polyline
        // polyline not support curveness, label, animation
        polyline: false,
        // If clip the overflow.
        // Available when coordinateSystem is cartesian or polar.
        clip: true,
        label: {
          show: false,
          position: "end"
          // distance: 5,
          // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
        },
        lineStyle: {
          opacity: 0.5
        }
      }
    });
    var _default = LinesSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectLine.js
var require_EffectLine = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectLine.js"(exports, module) {
    var graphic = require_graphic();
    var Line = require_Line2();
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var vec2 = require_vector();
    var curveUtil = require_curve();
    function EffectLine(lineData, idx, seriesScope) {
      graphic.Group.call(this);
      this.add(this.createLine(lineData, idx, seriesScope));
      this._updateEffectSymbol(lineData, idx);
    }
    var effectLineProto = EffectLine.prototype;
    effectLineProto.createLine = function(lineData, idx, seriesScope) {
      return new Line(lineData, idx, seriesScope);
    };
    effectLineProto._updateEffectSymbol = function(lineData, idx) {
      var itemModel = lineData.getItemModel(idx);
      var effectModel = itemModel.getModel("effect");
      var size = effectModel.get("symbolSize");
      var symbolType = effectModel.get("symbol");
      if (!zrUtil.isArray(size)) {
        size = [size, size];
      }
      var color = effectModel.get("color") || lineData.getItemVisual(idx, "color");
      var symbol = this.childAt(1);
      if (this._symbolType !== symbolType) {
        this.remove(symbol);
        symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
        symbol.z2 = 100;
        symbol.culling = true;
        this.add(symbol);
      }
      if (!symbol) {
        return;
      }
      symbol.setStyle("shadowColor", color);
      symbol.setStyle(effectModel.getItemStyle(["color"]));
      symbol.attr("scale", size);
      symbol.setColor(color);
      symbol.attr("scale", size);
      this._symbolType = symbolType;
      this._symbolScale = size;
      this._updateEffectAnimation(lineData, effectModel, idx);
    };
    effectLineProto._updateEffectAnimation = function(lineData, effectModel, idx) {
      var symbol = this.childAt(1);
      if (!symbol) {
        return;
      }
      var self2 = this;
      var points = lineData.getItemLayout(idx);
      var period = effectModel.get("period") * 1e3;
      var loop = effectModel.get("loop");
      var constantSpeed = effectModel.get("constantSpeed");
      var delayExpr = zrUtil.retrieve(effectModel.get("delay"), function(idx2) {
        return idx2 / lineData.count() * period / 3;
      });
      var isDelayFunc = typeof delayExpr === "function";
      symbol.ignore = true;
      this.updateAnimationPoints(symbol, points);
      if (constantSpeed > 0) {
        period = this.getLineLength(symbol) / constantSpeed * 1e3;
      }
      if (period !== this._period || loop !== this._loop) {
        symbol.stopAnimation();
        var delay = delayExpr;
        if (isDelayFunc) {
          delay = delayExpr(idx);
        }
        if (symbol.__t > 0) {
          delay = -period * symbol.__t;
        }
        symbol.__t = 0;
        var animator = symbol.animate("", loop).when(period, {
          __t: 1
        }).delay(delay).during(function() {
          self2.updateSymbolPosition(symbol);
        });
        if (!loop) {
          animator.done(function() {
            self2.remove(symbol);
          });
        }
        animator.start();
      }
      this._period = period;
      this._loop = loop;
    };
    effectLineProto.getLineLength = function(symbol) {
      return vec2.dist(symbol.__p1, symbol.__cp1) + vec2.dist(symbol.__cp1, symbol.__p2);
    };
    effectLineProto.updateAnimationPoints = function(symbol, points) {
      symbol.__p1 = points[0];
      symbol.__p2 = points[1];
      symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2];
    };
    effectLineProto.updateData = function(lineData, idx, seriesScope) {
      this.childAt(0).updateData(lineData, idx, seriesScope);
      this._updateEffectSymbol(lineData, idx);
    };
    effectLineProto.updateSymbolPosition = function(symbol) {
      var p1 = symbol.__p1;
      var p2 = symbol.__p2;
      var cp1 = symbol.__cp1;
      var t = symbol.__t;
      var pos = symbol.position;
      var lastPos = [pos[0], pos[1]];
      var quadraticAt = curveUtil.quadraticAt;
      var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
      pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
      pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
      var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
      var ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
      symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
      if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
        if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
          var scaleY = vec2.dist(lastPos, pos) * 1.05;
          symbol.attr("scale", [symbol.scale[0], scaleY]);
          if (t === 1) {
            pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
            pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
          }
        } else if (symbol.__lastT === 1) {
          var scaleY = 2 * vec2.dist(p1, pos);
          symbol.attr("scale", [symbol.scale[0], scaleY]);
        } else {
          symbol.attr("scale", this._symbolScale);
        }
      }
      symbol.__lastT = symbol.__t;
      symbol.ignore = false;
    };
    effectLineProto.updateLayout = function(lineData, idx) {
      this.childAt(0).updateLayout(lineData, idx);
      var effectModel = lineData.getItemModel(idx).getModel("effect");
      this._updateEffectAnimation(lineData, effectModel, idx);
    };
    zrUtil.inherits(EffectLine, graphic.Group);
    var _default = EffectLine;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Polyline.js
var require_Polyline2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/Polyline.js"(exports, module) {
    var graphic = require_graphic();
    var zrUtil = require_util();
    function Polyline(lineData, idx, seriesScope) {
      graphic.Group.call(this);
      this._createPolyline(lineData, idx, seriesScope);
    }
    var polylineProto = Polyline.prototype;
    polylineProto._createPolyline = function(lineData, idx, seriesScope) {
      var points = lineData.getItemLayout(idx);
      var line = new graphic.Polyline({
        shape: {
          points
        }
      });
      this.add(line);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    polylineProto.updateData = function(lineData, idx, seriesScope) {
      var seriesModel = lineData.hostModel;
      var line = this.childAt(0);
      var target = {
        shape: {
          points: lineData.getItemLayout(idx)
        }
      };
      graphic.updateProps(line, target, seriesModel, idx);
      this._updateCommonStl(lineData, idx, seriesScope);
    };
    polylineProto._updateCommonStl = function(lineData, idx, seriesScope) {
      var line = this.childAt(0);
      var itemModel = lineData.getItemModel(idx);
      var visualColor = lineData.getItemVisual(idx, "color");
      var lineStyle = seriesScope && seriesScope.lineStyle;
      var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
      if (!seriesScope || lineData.hasItemOption) {
        lineStyle = itemModel.getModel("lineStyle").getLineStyle();
        hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
      }
      line.useStyle(zrUtil.defaults({
        strokeNoScale: true,
        fill: "none",
        stroke: visualColor
      }, lineStyle));
      line.hoverStyle = hoverLineStyle;
      graphic.setHoverStyle(this);
    };
    polylineProto.updateLayout = function(lineData, idx) {
      var polyline = this.childAt(0);
      polyline.setShape("points", lineData.getItemLayout(idx));
    };
    zrUtil.inherits(Polyline, graphic.Group);
    var _default = Polyline;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectPolyline.js
var require_EffectPolyline = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/EffectPolyline.js"(exports, module) {
    var Polyline = require_Polyline2();
    var zrUtil = require_util();
    var EffectLine = require_EffectLine();
    var vec2 = require_vector();
    function EffectPolyline(lineData, idx, seriesScope) {
      EffectLine.call(this, lineData, idx, seriesScope);
      this._lastFrame = 0;
      this._lastFramePercent = 0;
    }
    var effectPolylineProto = EffectPolyline.prototype;
    effectPolylineProto.createLine = function(lineData, idx, seriesScope) {
      return new Polyline(lineData, idx, seriesScope);
    };
    effectPolylineProto.updateAnimationPoints = function(symbol, points) {
      this._points = points;
      var accLenArr = [0];
      var len = 0;
      for (var i = 1; i < points.length; i++) {
        var p1 = points[i - 1];
        var p2 = points[i];
        len += vec2.dist(p1, p2);
        accLenArr.push(len);
      }
      if (len === 0) {
        return;
      }
      for (var i = 0; i < accLenArr.length; i++) {
        accLenArr[i] /= len;
      }
      this._offsets = accLenArr;
      this._length = len;
    };
    effectPolylineProto.getLineLength = function(symbol) {
      return this._length;
    };
    effectPolylineProto.updateSymbolPosition = function(symbol) {
      var t = symbol.__t;
      var points = this._points;
      var offsets = this._offsets;
      var len = points.length;
      if (!offsets) {
        return;
      }
      var lastFrame = this._lastFrame;
      var frame;
      if (t < this._lastFramePercent) {
        var start = Math.min(lastFrame + 1, len - 1);
        for (frame = start; frame >= 0; frame--) {
          if (offsets[frame] <= t) {
            break;
          }
        }
        frame = Math.min(frame, len - 2);
      } else {
        for (var frame = lastFrame; frame < len; frame++) {
          if (offsets[frame] > t) {
            break;
          }
        }
        frame = Math.min(frame - 1, len - 2);
      }
      vec2.lerp(symbol.position, points[frame], points[frame + 1], (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]));
      var tx = points[frame + 1][0] - points[frame][0];
      var ty = points[frame + 1][1] - points[frame][1];
      symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
      this._lastFrame = frame;
      this._lastFramePercent = t;
      symbol.ignore = false;
    };
    zrUtil.inherits(EffectPolyline, EffectLine);
    var _default = EffectPolyline;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeLineDraw.js
var require_LargeLineDraw = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/helper/LargeLineDraw.js"(exports, module) {
    var graphic = require_graphic();
    var IncrementalDisplayable = require_IncrementalDisplayable();
    var lineContain = require_line();
    var quadraticContain = require_quadratic();
    var LargeLineShape = graphic.extendShape({
      shape: {
        polyline: false,
        curveness: 0,
        segs: []
      },
      buildPath: function(path, shape) {
        var segs = shape.segs;
        var curveness = shape.curveness;
        if (shape.polyline) {
          for (var i = 0; i < segs.length; ) {
            var count = segs[i++];
            if (count > 0) {
              path.moveTo(segs[i++], segs[i++]);
              for (var k = 1; k < count; k++) {
                path.lineTo(segs[i++], segs[i++]);
              }
            }
          }
        } else {
          for (var i = 0; i < segs.length; ) {
            var x0 = segs[i++];
            var y0 = segs[i++];
            var x1 = segs[i++];
            var y1 = segs[i++];
            path.moveTo(x0, y0);
            if (curveness > 0) {
              var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
              var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
              path.quadraticCurveTo(x2, y2, x1, y1);
            } else {
              path.lineTo(x1, y1);
            }
          }
        }
      },
      findDataIndex: function(x, y) {
        var shape = this.shape;
        var segs = shape.segs;
        var curveness = shape.curveness;
        if (shape.polyline) {
          var dataIndex = 0;
          for (var i = 0; i < segs.length; ) {
            var count = segs[i++];
            if (count > 0) {
              var x0 = segs[i++];
              var y0 = segs[i++];
              for (var k = 1; k < count; k++) {
                var x1 = segs[i++];
                var y1 = segs[i++];
                if (lineContain.containStroke(x0, y0, x1, y1)) {
                  return dataIndex;
                }
              }
            }
            dataIndex++;
          }
        } else {
          var dataIndex = 0;
          for (var i = 0; i < segs.length; ) {
            var x0 = segs[i++];
            var y0 = segs[i++];
            var x1 = segs[i++];
            var y1 = segs[i++];
            if (curveness > 0) {
              var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
              var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
              if (quadraticContain.containStroke(x0, y0, x2, y2, x1, y1)) {
                return dataIndex;
              }
            } else {
              if (lineContain.containStroke(x0, y0, x1, y1)) {
                return dataIndex;
              }
            }
            dataIndex++;
          }
        }
        return -1;
      }
    });
    function LargeLineDraw() {
      this.group = new graphic.Group();
    }
    var largeLineProto = LargeLineDraw.prototype;
    largeLineProto.isPersistent = function() {
      return !this._incremental;
    };
    largeLineProto.updateData = function(data) {
      this.group.removeAll();
      var lineEl = new LargeLineShape({
        rectHover: true,
        cursor: "default"
      });
      lineEl.setShape({
        segs: data.getLayout("linesPoints")
      });
      this._setCommon(lineEl, data);
      this.group.add(lineEl);
      this._incremental = null;
    };
    largeLineProto.incrementalPrepareUpdate = function(data) {
      this.group.removeAll();
      this._clearIncremental();
      if (data.count() > 5e5) {
        if (!this._incremental) {
          this._incremental = new IncrementalDisplayable({
            silent: true
          });
        }
        this.group.add(this._incremental);
      } else {
        this._incremental = null;
      }
    };
    largeLineProto.incrementalUpdate = function(taskParams, data) {
      var lineEl = new LargeLineShape();
      lineEl.setShape({
        segs: data.getLayout("linesPoints")
      });
      this._setCommon(lineEl, data, !!this._incremental);
      if (!this._incremental) {
        lineEl.rectHover = true;
        lineEl.cursor = "default";
        lineEl.__startIndex = taskParams.start;
        this.group.add(lineEl);
      } else {
        this._incremental.addDisplayable(lineEl, true);
      }
    };
    largeLineProto.remove = function() {
      this._clearIncremental();
      this._incremental = null;
      this.group.removeAll();
    };
    largeLineProto._setCommon = function(lineEl, data, isIncremental) {
      var hostModel = data.hostModel;
      lineEl.setShape({
        polyline: hostModel.get("polyline"),
        curveness: hostModel.get("lineStyle.curveness")
      });
      lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
      lineEl.style.strokeNoScale = true;
      var visualColor = data.getVisual("color");
      if (visualColor) {
        lineEl.setStyle("stroke", visualColor);
      }
      lineEl.setStyle("fill");
      if (!isIncremental) {
        lineEl.seriesIndex = hostModel.seriesIndex;
        lineEl.on("mousemove", function(e) {
          lineEl.dataIndex = null;
          var dataIndex = lineEl.findDataIndex(e.offsetX, e.offsetY);
          if (dataIndex > 0) {
            lineEl.dataIndex = dataIndex + lineEl.__startIndex;
          }
        });
      }
    };
    largeLineProto._clearIncremental = function() {
      var incremental = this._incremental;
      if (incremental) {
        incremental.clearDisplaybles();
      }
    };
    var _default = LargeLineDraw;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesLayout.js
var require_linesLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesLayout.js"(exports, module) {
    var createRenderPlanner = require_createRenderPlanner();
    var _default = {
      seriesType: "lines",
      plan: createRenderPlanner(),
      reset: function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        var isPolyline = seriesModel.get("polyline");
        var isLarge = seriesModel.pipelineContext.large;
        function progress(params, lineData) {
          var lineCoords = [];
          if (isLarge) {
            var points;
            var segCount = params.end - params.start;
            if (isPolyline) {
              var totalCoordsCount = 0;
              for (var i = params.start; i < params.end; i++) {
                totalCoordsCount += seriesModel.getLineCoordsCount(i);
              }
              points = new Float32Array(segCount + totalCoordsCount * 2);
            } else {
              points = new Float32Array(segCount * 4);
            }
            var offset = 0;
            var pt = [];
            for (var i = params.start; i < params.end; i++) {
              var len = seriesModel.getLineCoords(i, lineCoords);
              if (isPolyline) {
                points[offset++] = len;
              }
              for (var k = 0; k < len; k++) {
                pt = coordSys.dataToPoint(lineCoords[k], false, pt);
                points[offset++] = pt[0];
                points[offset++] = pt[1];
              }
            }
            lineData.setLayout("linesPoints", points);
          } else {
            for (var i = params.start; i < params.end; i++) {
              var itemModel = lineData.getItemModel(i);
              var len = seriesModel.getLineCoords(i, lineCoords);
              var pts = [];
              if (isPolyline) {
                for (var j = 0; j < len; j++) {
                  pts.push(coordSys.dataToPoint(lineCoords[j]));
                }
              } else {
                pts[0] = coordSys.dataToPoint(lineCoords[0]);
                pts[1] = coordSys.dataToPoint(lineCoords[1]);
                var curveness = itemModel.get("lineStyle.curveness");
                if (+curveness) {
                  pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
                }
              }
              lineData.setItemLayout(i, pts);
            }
          }
        }
        return {
          progress
        };
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesView.js
var require_LinesView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/LinesView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var LineDraw = require_LineDraw();
    var EffectLine = require_EffectLine();
    var Line = require_Line2();
    var Polyline = require_Polyline2();
    var EffectPolyline = require_EffectPolyline();
    var LargeLineDraw = require_LargeLineDraw();
    var linesLayout = require_linesLayout();
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var _default = echarts.extendChartView({
      type: "lines",
      init: function() {
      },
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var lineDraw = this._updateLineDraw(data, seriesModel);
        var zlevel = seriesModel.get("zlevel");
        var trailLength = seriesModel.get("effect.trailLength");
        var zr = api.getZr();
        var isSvg = zr.painter.getType() === "svg";
        if (!isSvg) {
          zr.painter.getLayer(zlevel).clear(true);
        }
        if (this._lastZlevel != null && !isSvg) {
          zr.configLayer(this._lastZlevel, {
            motionBlur: false
          });
        }
        if (this._showEffect(seriesModel) && trailLength) {
          if (!isSvg) {
            zr.configLayer(zlevel, {
              motionBlur: true,
              lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
            });
          }
        }
        lineDraw.updateData(data);
        var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
        if (clipPath) {
          this.group.setClipPath(clipPath);
        } else {
          this.group.removeClipPath();
        }
        this._lastZlevel = zlevel;
        this._finished = true;
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var lineDraw = this._updateLineDraw(data, seriesModel);
        lineDraw.incrementalPrepareUpdate(data);
        this._clearLayer(api);
        this._finished = false;
      },
      incrementalRender: function(taskParams, seriesModel, ecModel) {
        this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
        this._finished = taskParams.end === seriesModel.getData().count();
      },
      updateTransform: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var pipelineContext = seriesModel.pipelineContext;
        if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
          return {
            update: true
          };
        } else {
          var res = linesLayout.reset(seriesModel);
          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count()
            }, data);
          }
          this._lineDraw.updateLayout();
          this._clearLayer(api);
        }
      },
      _updateLineDraw: function(data, seriesModel) {
        var lineDraw = this._lineDraw;
        var hasEffect = this._showEffect(seriesModel);
        var isPolyline = !!seriesModel.get("polyline");
        var pipelineContext = seriesModel.pipelineContext;
        var isLargeDraw = pipelineContext.large;
        if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
          if (lineDraw) {
            lineDraw.remove();
          }
          lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw() : new LineDraw(isPolyline ? hasEffect ? EffectPolyline : Polyline : hasEffect ? EffectLine : Line);
          this._hasEffet = hasEffect;
          this._isPolyline = isPolyline;
          this._isLargeDraw = isLargeDraw;
          this.group.removeAll();
        }
        this.group.add(lineDraw.group);
        return lineDraw;
      },
      _showEffect: function(seriesModel) {
        return !!seriesModel.get("effect.show");
      },
      _clearLayer: function(api) {
        var zr = api.getZr();
        var isSvg = zr.painter.getType() === "svg";
        if (!isSvg && this._lastZlevel != null) {
          zr.painter.getLayer(this._lastZlevel).clear(true);
        }
      },
      remove: function(ecModel, api) {
        this._lineDraw && this._lineDraw.remove();
        this._lineDraw = null;
        this._clearLayer(api);
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesVisual.js
var require_linesVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines/linesVisual.js"(exports, module) {
    function normalize(a) {
      if (!(a instanceof Array)) {
        a = [a, a];
      }
      return a;
    }
    var opacityQuery = "lineStyle.opacity".split(".");
    var _default = {
      seriesType: "lines",
      reset: function(seriesModel, ecModel, api) {
        var symbolType = normalize(seriesModel.get("symbol"));
        var symbolSize = normalize(seriesModel.get("symbolSize"));
        var data = seriesModel.getData();
        data.setVisual("fromSymbol", symbolType && symbolType[0]);
        data.setVisual("toSymbol", symbolType && symbolType[1]);
        data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
        data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
        data.setVisual("opacity", seriesModel.get(opacityQuery));
        function dataEach(data2, idx) {
          var itemModel = data2.getItemModel(idx);
          var symbolType2 = normalize(itemModel.getShallow("symbol", true));
          var symbolSize2 = normalize(itemModel.getShallow("symbolSize", true));
          var opacity = itemModel.get(opacityQuery);
          symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
          symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
          symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
          symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
          data2.setItemVisual(idx, "opacity", opacity);
        }
        return {
          dataEach: data.hasItemOption ? dataEach : null
        };
      }
    };
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines.js
var require_lines = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/lines.js"() {
    var echarts = require_echarts();
    require_LinesSeries();
    require_LinesView();
    var linesLayout = require_linesLayout();
    var linesVisual = require_linesVisual();
    echarts.registerLayout(linesLayout);
    echarts.registerVisual(linesVisual);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js
var require_HeatmapSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createListFromArray = require_createListFromArray();
    var CoordinateSystem = require_CoordinateSystem();
    var _default = SeriesModel.extend({
      type: "series.heatmap",
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this, {
          generateCoord: "value"
        });
      },
      preventIncremental: function() {
        var coordSysCreator = CoordinateSystem.get(this.get("coordinateSystem"));
        if (coordSysCreator && coordSysCreator.dimensions) {
          return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
        }
      },
      defaultOption: {
        // Cartesian2D or geo
        coordinateSystem: "cartesian2d",
        zlevel: 0,
        z: 2,
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Geo coordinate system
        geoIndex: 0,
        blurSize: 30,
        pointSize: 20,
        maxOpacity: 1,
        minOpacity: 0
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js
var require_HeatmapLayer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapLayer.js"(exports, module) {
    var zrUtil = require_util();
    var GRADIENT_LEVELS = 256;
    function Heatmap() {
      var canvas = zrUtil.createCanvas();
      this.canvas = canvas;
      this.blurSize = 30;
      this.pointSize = 20;
      this.maxOpacity = 1;
      this.minOpacity = 0;
      this._gradientPixels = {};
    }
    Heatmap.prototype = {
      /**
       * Renders Heatmap and returns the rendered canvas
       * @param {Array} data array of data, each has x, y, value
       * @param {number} width canvas width
       * @param {number} height canvas height
       */
      update: function(data, width, height, normalize, colorFunc, isInRange) {
        var brush = this._getBrush();
        var gradientInRange = this._getGradient(data, colorFunc, "inRange");
        var gradientOutOfRange = this._getGradient(data, colorFunc, "outOfRange");
        var r = this.pointSize + this.blurSize;
        var canvas = this.canvas;
        var ctx = canvas.getContext("2d");
        var len = data.length;
        canvas.width = width;
        canvas.height = height;
        for (var i = 0; i < len; ++i) {
          var p = data[i];
          var x = p[0];
          var y = p[1];
          var value = p[2];
          var alpha = normalize(value);
          ctx.globalAlpha = alpha;
          ctx.drawImage(brush, x - r, y - r);
        }
        if (!canvas.width || !canvas.height) {
          return canvas;
        }
        var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var pixels = imageData.data;
        var offset = 0;
        var pixelLen = pixels.length;
        var minOpacity = this.minOpacity;
        var maxOpacity = this.maxOpacity;
        var diffOpacity = maxOpacity - minOpacity;
        while (offset < pixelLen) {
          var alpha = pixels[offset + 3] / 256;
          var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
          if (alpha > 0) {
            var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
            alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
            pixels[offset++] = gradient[gradientOffset];
            pixels[offset++] = gradient[gradientOffset + 1];
            pixels[offset++] = gradient[gradientOffset + 2];
            pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
          } else {
            offset += 4;
          }
        }
        ctx.putImageData(imageData, 0, 0);
        return canvas;
      },
      /**
       * get canvas of a black circle brush used for canvas to draw later
       * @private
       * @returns {Object} circle brush canvas
       */
      _getBrush: function() {
        var brushCanvas = this._brushCanvas || (this._brushCanvas = zrUtil.createCanvas());
        var r = this.pointSize + this.blurSize;
        var d = r * 2;
        brushCanvas.width = d;
        brushCanvas.height = d;
        var ctx = brushCanvas.getContext("2d");
        ctx.clearRect(0, 0, d, d);
        ctx.shadowOffsetX = d;
        ctx.shadowBlur = this.blurSize;
        ctx.shadowColor = "#000";
        ctx.beginPath();
        ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
        return brushCanvas;
      },
      /**
       * get gradient color map
       * @private
       */
      _getGradient: function(data, colorFunc, state) {
        var gradientPixels = this._gradientPixels;
        var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
        var color = [0, 0, 0, 0];
        var off = 0;
        for (var i = 0; i < 256; i++) {
          colorFunc[state](i / 255, true, color);
          pixelsSingleState[off++] = color[0];
          pixelsSingleState[off++] = color[1];
          pixelsSingleState[off++] = color[2];
          pixelsSingleState[off++] = color[3];
        }
        return pixelsSingleState;
      }
    };
    var _default = Heatmap;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapView.js
var require_HeatmapView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap/HeatmapView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var graphic = require_graphic();
    var HeatmapLayer = require_HeatmapLayer();
    var zrUtil = require_util();
    function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
      var dataSpan = dataExtent[1] - dataExtent[0];
      pieceList = zrUtil.map(pieceList, function(piece) {
        return {
          interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
        };
      });
      var len = pieceList.length;
      var lastIndex = 0;
      return function(val) {
        for (var i = lastIndex; i < len; i++) {
          var interval = pieceList[i].interval;
          if (interval[0] <= val && val <= interval[1]) {
            lastIndex = i;
            break;
          }
        }
        if (i === len) {
          for (var i = lastIndex - 1; i >= 0; i--) {
            var interval = pieceList[i].interval;
            if (interval[0] <= val && val <= interval[1]) {
              lastIndex = i;
              break;
            }
          }
        }
        return i >= 0 && i < len && selected[i];
      };
    }
    function getIsInContinuousRange(dataExtent, range) {
      var dataSpan = dataExtent[1] - dataExtent[0];
      range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
      return function(val) {
        return val >= range[0] && val <= range[1];
      };
    }
    function isGeoCoordSys(coordSys) {
      var dimensions = coordSys.dimensions;
      return dimensions[0] === "lng" && dimensions[1] === "lat";
    }
    var _default = echarts.extendChartView({
      type: "heatmap",
      render: function(seriesModel, ecModel, api) {
        var visualMapOfThisSeries;
        ecModel.eachComponent("visualMap", function(visualMap) {
          visualMap.eachTargetSeries(function(targetSeries) {
            if (targetSeries === seriesModel) {
              visualMapOfThisSeries = visualMap;
            }
          });
        });
        this.group.removeAll();
        this._incrementalDisplayable = null;
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys.type === "cartesian2d" || coordSys.type === "calendar") {
          this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
        } else if (isGeoCoordSys(coordSys)) {
          this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
        }
      },
      incrementalPrepareRender: function(seriesModel, ecModel, api) {
        this.group.removeAll();
      },
      incrementalRender: function(params, seriesModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys) {
          this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
        }
      },
      _renderOnCartesianAndCalendar: function(seriesModel, api, start, end, incremental) {
        var coordSys = seriesModel.coordinateSystem;
        var width;
        var height;
        if (coordSys.type === "cartesian2d") {
          var xAxis = coordSys.getAxis("x");
          var yAxis = coordSys.getAxis("y");
          width = xAxis.getBandWidth();
          height = yAxis.getBandWidth();
        }
        var group = this.group;
        var data = seriesModel.getData();
        var itemStyleQuery = "itemStyle";
        var hoverItemStyleQuery = "emphasis.itemStyle";
        var labelQuery = "label";
        var hoverLabelQuery = "emphasis.label";
        var style = seriesModel.getModel(itemStyleQuery).getItemStyle(["color"]);
        var hoverStl = seriesModel.getModel(hoverItemStyleQuery).getItemStyle();
        var labelModel = seriesModel.getModel(labelQuery);
        var hoverLabelModel = seriesModel.getModel(hoverLabelQuery);
        var coordSysType = coordSys.type;
        var dataDims = coordSysType === "cartesian2d" ? [data.mapDimension("x"), data.mapDimension("y"), data.mapDimension("value")] : [data.mapDimension("time"), data.mapDimension("value")];
        for (var idx = start; idx < end; idx++) {
          var rect;
          if (coordSysType === "cartesian2d") {
            if (isNaN(data.get(dataDims[2], idx))) {
              continue;
            }
            var point = coordSys.dataToPoint([data.get(dataDims[0], idx), data.get(dataDims[1], idx)]);
            rect = new graphic.Rect({
              shape: {
                x: Math.floor(Math.round(point[0]) - width / 2),
                y: Math.floor(Math.round(point[1]) - height / 2),
                width: Math.ceil(width),
                height: Math.ceil(height)
              },
              style: {
                fill: data.getItemVisual(idx, "color"),
                opacity: data.getItemVisual(idx, "opacity")
              }
            });
          } else {
            if (isNaN(data.get(dataDims[1], idx))) {
              continue;
            }
            rect = new graphic.Rect({
              z2: 1,
              shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
              style: {
                fill: data.getItemVisual(idx, "color"),
                opacity: data.getItemVisual(idx, "opacity")
              }
            });
          }
          var itemModel = data.getItemModel(idx);
          if (data.hasItemOption) {
            style = itemModel.getModel(itemStyleQuery).getItemStyle(["color"]);
            hoverStl = itemModel.getModel(hoverItemStyleQuery).getItemStyle();
            labelModel = itemModel.getModel(labelQuery);
            hoverLabelModel = itemModel.getModel(hoverLabelQuery);
          }
          var rawValue = seriesModel.getRawValue(idx);
          var defaultText = "-";
          if (rawValue && rawValue[2] != null) {
            defaultText = rawValue[2];
          }
          graphic.setLabelStyle(style, hoverStl, labelModel, hoverLabelModel, {
            labelFetcher: seriesModel,
            labelDataIndex: idx,
            defaultText,
            isRectText: true
          });
          rect.setStyle(style);
          graphic.setHoverStyle(rect, data.hasItemOption ? hoverStl : zrUtil.extend({}, hoverStl));
          rect.incremental = incremental;
          if (incremental) {
            rect.useHoverLayer = true;
          }
          group.add(rect);
          data.setItemGraphicEl(idx, rect);
        }
      },
      _renderOnGeo: function(geo, seriesModel, visualMapModel, api) {
        var inRangeVisuals = visualMapModel.targetVisuals.inRange;
        var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
        var data = seriesModel.getData();
        var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer();
        hmLayer.blurSize = seriesModel.get("blurSize");
        hmLayer.pointSize = seriesModel.get("pointSize");
        hmLayer.minOpacity = seriesModel.get("minOpacity");
        hmLayer.maxOpacity = seriesModel.get("maxOpacity");
        var rect = geo.getViewRect().clone();
        var roamTransform = geo.getRoamTransform();
        rect.applyTransform(roamTransform);
        var x = Math.max(rect.x, 0);
        var y = Math.max(rect.y, 0);
        var x2 = Math.min(rect.width + rect.x, api.getWidth());
        var y2 = Math.min(rect.height + rect.y, api.getHeight());
        var width = x2 - x;
        var height = y2 - y;
        var dims = [data.mapDimension("lng"), data.mapDimension("lat"), data.mapDimension("value")];
        var points = data.mapArray(dims, function(lng, lat, value) {
          var pt = geo.dataToPoint([lng, lat]);
          pt[0] -= x;
          pt[1] -= y;
          pt.push(value);
          return pt;
        });
        var dataExtent = visualMapModel.getExtent();
        var isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
        hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
          inRange: inRangeVisuals.color.getColorMapper(),
          outOfRange: outOfRangeVisuals.color.getColorMapper()
        }, isInRange);
        var img = new graphic.Image({
          style: {
            width,
            height,
            x,
            y,
            image: hmLayer.canvas
          },
          silent: true
        });
        this.group.add(img);
      },
      dispose: function() {
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap.js
var require_heatmap = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/heatmap.js"() {
    require_HeatmapSeries();
    require_HeatmapView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarSeries.js
var require_PictorialBarSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarSeries.js"(exports, module) {
    var BaseBarSeries = require_BaseBarSeries();
    var PictorialBarSeries = BaseBarSeries.extend({
      type: "series.pictorialBar",
      dependencies: ["grid"],
      defaultOption: {
        symbol: "circle",
        // Customized bar shape
        symbolSize: null,
        // Can be ['100%', '100%'], null means auto.
        symbolRotate: null,
        symbolPosition: null,
        // 'start' or 'end' or 'center', null means auto.
        symbolOffset: null,
        symbolMargin: null,
        // start margin and end margin. Can be a number or a percent string.
        // Auto margin by default.
        symbolRepeat: false,
        // false/null/undefined, means no repeat.
        // Can be true, means auto calculate repeat times and cut by data.
        // Can be a number, specifies repeat times, and do not cut by data.
        // Can be 'fixed', means auto calculate repeat times but do not cut by data.
        symbolRepeatDirection: "end",
        // 'end' means from 'start' to 'end'.
        symbolClip: false,
        symbolBoundingData: null,
        // Can be 60 or -40 or [-40, 60]
        symbolPatternSize: 400,
        // 400 * 400 px
        barGap: "-100%",
        // In most case, overlap is needed.
        // z can be set in data item, which is z2 actually.
        // Disable progressive
        progressive: 0,
        hoverAnimation: false
        // Open only when needed.
      },
      getInitialData: function(option) {
        option.stack = null;
        return PictorialBarSeries.superApply(this, "getInitialData", arguments);
      }
    });
    var _default = PictorialBarSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarView.js
var require_PictorialBarView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/bar/PictorialBarView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var isNumeric = _number.isNumeric;
    var _helper = require_helper4();
    var setLabel = _helper.setLabel;
    var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
    var LAYOUT_ATTRS = [{
      xy: "x",
      wh: "width",
      index: 0,
      posDesc: ["left", "right"]
    }, {
      xy: "y",
      wh: "height",
      index: 1,
      posDesc: ["top", "bottom"]
    }];
    var pathForLineWidth = new graphic.Circle();
    var BarView = echarts.extendChartView({
      type: "pictorialBar",
      render: function(seriesModel, ecModel, api) {
        var group = this.group;
        var data = seriesModel.getData();
        var oldData = this._data;
        var cartesian = seriesModel.coordinateSystem;
        var baseAxis = cartesian.getBaseAxis();
        var isHorizontal = !!baseAxis.isHorizontal();
        var coordSysRect = cartesian.grid.getRect();
        var opt = {
          ecSize: {
            width: api.getWidth(),
            height: api.getHeight()
          },
          seriesModel,
          coordSys: cartesian,
          coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
          isHorizontal,
          valueDim: LAYOUT_ATTRS[+isHorizontal],
          categoryDim: LAYOUT_ATTRS[1 - isHorizontal]
        };
        data.diff(oldData).add(function(dataIndex) {
          if (!data.hasValue(dataIndex)) {
            return;
          }
          var itemModel = getItemModel(data, dataIndex);
          var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
          var bar = createBar(data, opt, symbolMeta);
          data.setItemGraphicEl(dataIndex, bar);
          group.add(bar);
          updateCommon(bar, opt, symbolMeta);
        }).update(function(newIndex, oldIndex) {
          var bar = oldData.getItemGraphicEl(oldIndex);
          if (!data.hasValue(newIndex)) {
            group.remove(bar);
            return;
          }
          var itemModel = getItemModel(data, newIndex);
          var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
          var pictorialShapeStr = getShapeStr(data, symbolMeta);
          if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
            group.remove(bar);
            data.setItemGraphicEl(newIndex, null);
            bar = null;
          }
          if (bar) {
            updateBar(bar, opt, symbolMeta);
          } else {
            bar = createBar(data, opt, symbolMeta, true);
          }
          data.setItemGraphicEl(newIndex, bar);
          bar.__pictorialSymbolMeta = symbolMeta;
          group.add(bar);
          updateCommon(bar, opt, symbolMeta);
        }).remove(function(dataIndex) {
          var bar = oldData.getItemGraphicEl(dataIndex);
          bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
        }).execute();
        this._data = data;
        return this.group;
      },
      dispose: zrUtil.noop,
      remove: function(ecModel, api) {
        var group = this.group;
        var data = this._data;
        if (ecModel.get("animation")) {
          if (data) {
            data.eachItemGraphicEl(function(bar) {
              removeBar(data, bar.dataIndex, ecModel, bar);
            });
          }
        } else {
          group.removeAll();
        }
      }
    });
    function getSymbolMeta(data, dataIndex, itemModel, opt) {
      var layout = data.getItemLayout(dataIndex);
      var symbolRepeat = itemModel.get("symbolRepeat");
      var symbolClip = itemModel.get("symbolClip");
      var symbolPosition = itemModel.get("symbolPosition") || "start";
      var symbolRotate = itemModel.get("symbolRotate");
      var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
      var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
      var isAnimationEnabled2 = itemModel.isAnimationEnabled();
      var symbolMeta = {
        dataIndex,
        layout,
        itemModel,
        symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
        color: data.getItemVisual(dataIndex, "color"),
        symbolClip,
        symbolRepeat,
        symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
        symbolPatternSize,
        rotation,
        animationModel: isAnimationEnabled2 ? itemModel : null,
        hoverAnimation: isAnimationEnabled2 && itemModel.get("hoverAnimation"),
        z2: itemModel.getShallow("z", true) || 0
      };
      prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta);
      prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
      prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
      var symbolSize = symbolMeta.symbolSize;
      var symbolOffset = itemModel.get("symbolOffset");
      if (zrUtil.isArray(symbolOffset)) {
        symbolOffset = [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])];
      }
      prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
      return symbolMeta;
    }
    function prepareBarLength(itemModel, symbolRepeat, layout, opt, output) {
      var valueDim = opt.valueDim;
      var symbolBoundingData = itemModel.get("symbolBoundingData");
      var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
      var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));
      var pxSignIdx = 1 - +(layout[valueDim.wh] <= 0);
      var boundingLength;
      if (zrUtil.isArray(symbolBoundingData)) {
        var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];
        symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
        boundingLength = symbolBoundingExtent[pxSignIdx];
      } else if (symbolBoundingData != null) {
        boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;
      } else if (symbolRepeat) {
        boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
      } else {
        boundingLength = layout[valueDim.wh];
      }
      output.boundingLength = boundingLength;
      if (symbolRepeat) {
        output.repeatCutLength = layout[valueDim.wh];
      }
      output.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;
    }
    function convertToCoordOnAxis(axis, value) {
      return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
    }
    function prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, output) {
      var valueDim = opt.valueDim;
      var categoryDim = opt.categoryDim;
      var categorySize = Math.abs(layout[categoryDim.wh]);
      var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
      if (zrUtil.isArray(symbolSize)) {
        symbolSize = symbolSize.slice();
      } else {
        if (symbolSize == null) {
          symbolSize = "100%";
        }
        symbolSize = [symbolSize, symbolSize];
      }
      symbolSize[categoryDim.index] = parsePercent(symbolSize[categoryDim.index], categorySize);
      symbolSize[valueDim.index] = parsePercent(symbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
      output.symbolSize = symbolSize;
      var symbolScale = output.symbolScale = [symbolSize[0] / symbolPatternSize, symbolSize[1] / symbolPatternSize];
      symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
    }
    function prepareLineWidth(itemModel, symbolScale, rotation, opt, output) {
      var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
      if (valueLineWidth) {
        pathForLineWidth.attr({
          scale: symbolScale.slice(),
          rotation
        });
        pathForLineWidth.updateTransform();
        valueLineWidth /= pathForLineWidth.getLineScale();
        valueLineWidth *= symbolScale[opt.valueDim.index];
      }
      output.valueLineWidth = valueLineWidth;
    }
    function prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, output) {
      var categoryDim = opt.categoryDim;
      var valueDim = opt.valueDim;
      var pxSign = output.pxSign;
      var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
      var pathLen = unitLength;
      if (symbolRepeat) {
        var absBoundingLength = Math.abs(boundingLength);
        var symbolMargin = zrUtil.retrieve(itemModel.get("symbolMargin"), "15%") + "";
        var hasEndGap = false;
        if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
          hasEndGap = true;
          symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
        }
        symbolMargin = parsePercent(symbolMargin, symbolSize[valueDim.index]);
        var uLenWithMargin = Math.max(unitLength + symbolMargin * 2, 0);
        var endFix = hasEndGap ? 0 : symbolMargin * 2;
        var repeatSpecified = isNumeric(symbolRepeat);
        var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
        var mDiff = absBoundingLength - repeatTimes * unitLength;
        symbolMargin = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);
        uLenWithMargin = unitLength + symbolMargin * 2;
        endFix = hasEndGap ? 0 : symbolMargin * 2;
        if (!repeatSpecified && symbolRepeat !== "fixed") {
          repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
        }
        pathLen = repeatTimes * uLenWithMargin - endFix;
        output.repeatTimes = repeatTimes;
        output.symbolMargin = symbolMargin;
      }
      var sizeFix = pxSign * (pathLen / 2);
      var pathPosition = output.pathPosition = [];
      pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2;
      pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
      if (symbolOffset) {
        pathPosition[0] += symbolOffset[0];
        pathPosition[1] += symbolOffset[1];
      }
      var bundlePosition = output.bundlePosition = [];
      bundlePosition[categoryDim.index] = layout[categoryDim.xy];
      bundlePosition[valueDim.index] = layout[valueDim.xy];
      var barRectShape = output.barRectShape = zrUtil.extend({}, layout);
      barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
      barRectShape[categoryDim.wh] = layout[categoryDim.wh];
      var clipShape = output.clipShape = {};
      clipShape[categoryDim.xy] = -layout[categoryDim.xy];
      clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
      clipShape[valueDim.xy] = 0;
      clipShape[valueDim.wh] = layout[valueDim.wh];
    }
    function createPath(symbolMeta) {
      var symbolPatternSize = symbolMeta.symbolPatternSize;
      var path = createSymbol(
        // Consider texture img, make a big size.
        symbolMeta.symbolType,
        -symbolPatternSize / 2,
        -symbolPatternSize / 2,
        symbolPatternSize,
        symbolPatternSize,
        symbolMeta.color
      );
      path.attr({
        culling: true
      });
      path.type !== "image" && path.setStyle({
        strokeNoScale: true
      });
      return path;
    }
    function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
      var bundle = bar.__pictorialBundle;
      var symbolSize = symbolMeta.symbolSize;
      var valueLineWidth = symbolMeta.valueLineWidth;
      var pathPosition = symbolMeta.pathPosition;
      var valueDim = opt.valueDim;
      var repeatTimes = symbolMeta.repeatTimes || 0;
      var index = 0;
      var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
      eachPath(bar, function(path2) {
        path2.__pictorialAnimationIndex = index;
        path2.__pictorialRepeatTimes = repeatTimes;
        if (index < repeatTimes) {
          updateAttr(path2, null, makeTarget(index), symbolMeta, isUpdate);
        } else {
          updateAttr(path2, null, {
            scale: [0, 0]
          }, symbolMeta, isUpdate, function() {
            bundle.remove(path2);
          });
        }
        updateHoverAnimation(path2, symbolMeta);
        index++;
      });
      for (; index < repeatTimes; index++) {
        var path = createPath(symbolMeta);
        path.__pictorialAnimationIndex = index;
        path.__pictorialRepeatTimes = repeatTimes;
        bundle.add(path);
        var target = makeTarget(index);
        updateAttr(path, {
          position: target.position,
          scale: [0, 0]
        }, {
          scale: target.scale,
          rotation: target.rotation
        }, symbolMeta, isUpdate);
        path.on("mouseover", onMouseOver).on("mouseout", onMouseOut);
        updateHoverAnimation(path, symbolMeta);
      }
      function makeTarget(index2) {
        var position = pathPosition.slice();
        var pxSign = symbolMeta.pxSign;
        var i = index2;
        if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
          i = repeatTimes - 1 - index2;
        }
        position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
        return {
          position,
          scale: symbolMeta.symbolScale.slice(),
          rotation: symbolMeta.rotation
        };
      }
      function onMouseOver() {
        eachPath(bar, function(path2) {
          path2.trigger("emphasis");
        });
      }
      function onMouseOut() {
        eachPath(bar, function(path2) {
          path2.trigger("normal");
        });
      }
    }
    function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
      var bundle = bar.__pictorialBundle;
      var mainPath = bar.__pictorialMainPath;
      if (!mainPath) {
        mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
        bundle.add(mainPath);
        updateAttr(mainPath, {
          position: symbolMeta.pathPosition.slice(),
          scale: [0, 0],
          rotation: symbolMeta.rotation
        }, {
          scale: symbolMeta.symbolScale.slice()
        }, symbolMeta, isUpdate);
        mainPath.on("mouseover", onMouseOver).on("mouseout", onMouseOut);
      } else {
        updateAttr(mainPath, null, {
          position: symbolMeta.pathPosition.slice(),
          scale: symbolMeta.symbolScale.slice(),
          rotation: symbolMeta.rotation
        }, symbolMeta, isUpdate);
      }
      updateHoverAnimation(mainPath, symbolMeta);
      function onMouseOver() {
        this.trigger("emphasis");
      }
      function onMouseOut() {
        this.trigger("normal");
      }
    }
    function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
      var rectShape = zrUtil.extend({}, symbolMeta.barRectShape);
      var barRect = bar.__pictorialBarRect;
      if (!barRect) {
        barRect = bar.__pictorialBarRect = new graphic.Rect({
          z2: 2,
          shape: rectShape,
          silent: true,
          style: {
            stroke: "transparent",
            fill: "transparent",
            lineWidth: 0
          }
        });
        bar.add(barRect);
      } else {
        updateAttr(barRect, null, {
          shape: rectShape
        }, symbolMeta, isUpdate);
      }
    }
    function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
      if (symbolMeta.symbolClip) {
        var clipPath = bar.__pictorialClipPath;
        var clipShape = zrUtil.extend({}, symbolMeta.clipShape);
        var valueDim = opt.valueDim;
        var animationModel = symbolMeta.animationModel;
        var dataIndex = symbolMeta.dataIndex;
        if (clipPath) {
          graphic.updateProps(clipPath, {
            shape: clipShape
          }, animationModel, dataIndex);
        } else {
          clipShape[valueDim.wh] = 0;
          clipPath = new graphic.Rect({
            shape: clipShape
          });
          bar.__pictorialBundle.setClipPath(clipPath);
          bar.__pictorialClipPath = clipPath;
          var target = {};
          target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
          graphic[isUpdate ? "updateProps" : "initProps"](clipPath, {
            shape: target
          }, animationModel, dataIndex);
        }
      }
    }
    function getItemModel(data, dataIndex) {
      var itemModel = data.getItemModel(dataIndex);
      itemModel.getAnimationDelayParams = getAnimationDelayParams;
      itemModel.isAnimationEnabled = isAnimationEnabled;
      return itemModel;
    }
    function getAnimationDelayParams(path) {
      return {
        index: path.__pictorialAnimationIndex,
        count: path.__pictorialRepeatTimes
      };
    }
    function isAnimationEnabled() {
      return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
    }
    function updateHoverAnimation(path, symbolMeta) {
      path.off("emphasis").off("normal");
      var scale = symbolMeta.symbolScale.slice();
      symbolMeta.hoverAnimation && path.on("emphasis", function() {
        this.animateTo({
          scale: [scale[0] * 1.1, scale[1] * 1.1]
        }, 400, "elasticOut");
      }).on("normal", function() {
        this.animateTo({
          scale: scale.slice()
        }, 400, "elasticOut");
      });
    }
    function createBar(data, opt, symbolMeta, isUpdate) {
      var bar = new graphic.Group();
      var bundle = new graphic.Group();
      bar.add(bundle);
      bar.__pictorialBundle = bundle;
      bundle.attr("position", symbolMeta.bundlePosition.slice());
      if (symbolMeta.symbolRepeat) {
        createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
      } else {
        createOrUpdateSingleSymbol(bar, opt, symbolMeta);
      }
      createOrUpdateBarRect(bar, symbolMeta, isUpdate);
      createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
      bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
      bar.__pictorialSymbolMeta = symbolMeta;
      return bar;
    }
    function updateBar(bar, opt, symbolMeta) {
      var animationModel = symbolMeta.animationModel;
      var dataIndex = symbolMeta.dataIndex;
      var bundle = bar.__pictorialBundle;
      graphic.updateProps(bundle, {
        position: symbolMeta.bundlePosition.slice()
      }, animationModel, dataIndex);
      if (symbolMeta.symbolRepeat) {
        createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
      } else {
        createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
      }
      createOrUpdateBarRect(bar, symbolMeta, true);
      createOrUpdateClip(bar, opt, symbolMeta, true);
    }
    function removeBar(data, dataIndex, animationModel, bar) {
      var labelRect = bar.__pictorialBarRect;
      labelRect && (labelRect.style.text = null);
      var pathes = [];
      eachPath(bar, function(path) {
        pathes.push(path);
      });
      bar.__pictorialMainPath && pathes.push(bar.__pictorialMainPath);
      bar.__pictorialClipPath && (animationModel = null);
      zrUtil.each(pathes, function(path) {
        graphic.updateProps(path, {
          scale: [0, 0]
        }, animationModel, dataIndex, function() {
          bar.parent && bar.parent.remove(bar);
        });
      });
      data.setItemGraphicEl(dataIndex, null);
    }
    function getShapeStr(data, symbolMeta) {
      return [data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none", !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(":");
    }
    function eachPath(bar, cb, context) {
      zrUtil.each(bar.__pictorialBundle.children(), function(el) {
        el !== bar.__pictorialBarRect && cb.call(context, el);
      });
    }
    function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
      immediateAttrs && el.attr(immediateAttrs);
      if (symbolMeta.symbolClip && !isUpdate) {
        animationAttrs && el.attr(animationAttrs);
      } else {
        animationAttrs && graphic[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
      }
    }
    function updateCommon(bar, opt, symbolMeta) {
      var color = symbolMeta.color;
      var dataIndex = symbolMeta.dataIndex;
      var itemModel = symbolMeta.itemModel;
      var normalStyle = itemModel.getModel("itemStyle").getItemStyle(["color"]);
      var hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
      var cursorStyle = itemModel.getShallow("cursor");
      eachPath(bar, function(path) {
        path.setColor(color);
        path.setStyle(zrUtil.defaults({
          fill: color,
          opacity: symbolMeta.opacity
        }, normalStyle));
        graphic.setHoverStyle(path, hoverStyle);
        cursorStyle && (path.cursor = cursorStyle);
        path.z2 = symbolMeta.z2;
      });
      var barRectHoverStyle = {};
      var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
      var barRect = bar.__pictorialBarRect;
      setLabel(barRect.style, barRectHoverStyle, itemModel, color, opt.seriesModel, dataIndex, barPositionOutside);
      graphic.setHoverStyle(barRect, barRectHoverStyle);
    }
    function toIntTimes(times) {
      var roundedTimes = Math.round(times);
      return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
    }
    var _default = BarView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pictorialBar.js
var require_pictorialBar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/pictorialBar.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_Grid();
    require_PictorialBarSeries();
    require_PictorialBarView();
    var _barGrid = require_barGrid();
    var layout = _barGrid.layout;
    var visualSymbol = require_symbol2();
    require_gridSimple();
    echarts.registerLayout(zrUtil.curry(layout, "pictorialBar"));
    echarts.registerVisual(visualSymbol("pictorialBar", "roundRect"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/SingleAxis.js
var require_SingleAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/SingleAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var SingleAxis = function(dim, scale, coordExtent, axisType, position) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.position = position || "bottom";
      this.orient = null;
    };
    SingleAxis.prototype = {
      constructor: SingleAxis,
      /**
       * Axis model
       * @type {module:echarts/coord/single/AxisModel}
       */
      model: null,
      /**
       * Judge the orient of the axis.
       * @return {boolean}
       */
      isHorizontal: function() {
        var position = this.position;
        return position === "top" || position === "bottom";
      },
      /**
       * @override
       */
      pointToData: function(point, clamp) {
        return this.coordinateSystem.pointToData(point, clamp)[0];
      },
      /**
       * Convert the local coord(processed by dataToCoord())
       * to global coord(concrete pixel coord).
       * designated by module:echarts/coord/single/Single.
       * @type {Function}
       */
      toGlobalCoord: null,
      /**
       * Convert the global coord to local coord.
       * designated by module:echarts/coord/single/Single.
       * @type {Function}
       */
      toLocalCoord: null
    };
    zrUtil.inherits(SingleAxis, Axis);
    var _default = SingleAxis;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/Single.js
var require_Single = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/Single.js"(exports, module) {
    var SingleAxis = require_SingleAxis();
    var axisHelper = require_axisHelper();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var _util = require_util();
    var each = _util.each;
    function Single(axisModel, ecModel, api) {
      this.dimension = "single";
      this.dimensions = ["single"];
      this._axis = null;
      this._rect;
      this._init(axisModel, ecModel, api);
      this.model = axisModel;
    }
    Single.prototype = {
      type: "singleAxis",
      axisPointerEnabled: true,
      constructor: Single,
      /**
       * Initialize single coordinate system.
       *
       * @param  {module:echarts/coord/single/AxisModel} axisModel
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       * @private
       */
      _init: function(axisModel, ecModel, api) {
        var dim = this.dimension;
        var axis = new SingleAxis(dim, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
        var isCategory = axis.type === "category";
        axis.onBand = isCategory && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axis.orient = axisModel.get("orient");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.coordinateSystem = this;
        this._axis = axis;
      },
      /**
       * Update axis scale after data processed
       * @param  {module:echarts/model/Global} ecModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      update: function(ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.coordinateSystem === this) {
            var data = seriesModel.getData();
            each(data.mapDimension(this.dimension, true), function(dim) {
              this._axis.scale.unionExtentFromData(data, dim);
            }, this);
            axisHelper.niceScaleExtent(this._axis.scale, this._axis.model);
          }
        }, this);
      },
      /**
       * Resize the single coordinate system.
       *
       * @param  {module:echarts/coord/single/AxisModel} axisModel
       * @param  {module:echarts/ExtensionAPI} api
       */
      resize: function(axisModel, api) {
        this._rect = getLayoutRect({
          left: axisModel.get("left"),
          top: axisModel.get("top"),
          right: axisModel.get("right"),
          bottom: axisModel.get("bottom"),
          width: axisModel.get("width"),
          height: axisModel.get("height")
        }, {
          width: api.getWidth(),
          height: api.getHeight()
        });
        this._adjustAxis();
      },
      /**
       * @return {module:zrender/core/BoundingRect}
       */
      getRect: function() {
        return this._rect;
      },
      /**
       * @private
       */
      _adjustAxis: function() {
        var rect = this._rect;
        var axis = this._axis;
        var isHorizontal = axis.isHorizontal();
        var extent = isHorizontal ? [0, rect.width] : [0, rect.height];
        var idx = axis.reverse ? 1 : 0;
        axis.setExtent(extent[idx], extent[1 - idx]);
        this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
      },
      /**
       * @param  {module:echarts/coord/single/SingleAxis} axis
       * @param  {number} coordBase
       */
      _updateAxisTransform: function(axis, coordBase) {
        var axisExtent = axis.getExtent();
        var extentSum = axisExtent[0] + axisExtent[1];
        var isHorizontal = axis.isHorizontal();
        axis.toGlobalCoord = isHorizontal ? function(coord) {
          return coord + coordBase;
        } : function(coord) {
          return extentSum - coord + coordBase;
        };
        axis.toLocalCoord = isHorizontal ? function(coord) {
          return coord - coordBase;
        } : function(coord) {
          return extentSum - coord + coordBase;
        };
      },
      /**
       * Get axis.
       *
       * @return {module:echarts/coord/single/SingleAxis}
       */
      getAxis: function() {
        return this._axis;
      },
      /**
       * Get axis, add it just for draw tooltip.
       *
       * @return {[type]} [description]
       */
      getBaseAxis: function() {
        return this._axis;
      },
      /**
       * @return {Array.<module:echarts/coord/Axis>}
       */
      getAxes: function() {
        return [this._axis];
      },
      /**
       * @return {Object} {baseAxes: [], otherAxes: []}
       */
      getTooltipAxes: function() {
        return {
          baseAxes: [this.getAxis()]
        };
      },
      /**
       * If contain point.
       *
       * @param  {Array.<number>} point
       * @return {boolean}
       */
      containPoint: function(point) {
        var rect = this.getRect();
        var axis = this.getAxis();
        var orient = axis.orient;
        if (orient === "horizontal") {
          return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
        } else {
          return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
        }
      },
      /**
       * @param {Array.<number>} point
       * @return {Array.<number>}
       */
      pointToData: function(point) {
        var axis = this.getAxis();
        return [axis.coordToData(axis.toLocalCoord(point[axis.orient === "horizontal" ? 0 : 1]))];
      },
      /**
       * Convert the series data to concrete point.
       *
       * @param  {number|Array.<number>} val
       * @return {Array.<number>}
       */
      dataToPoint: function(val) {
        var axis = this.getAxis();
        var rect = this.getRect();
        var pt = [];
        var idx = axis.orient === "horizontal" ? 0 : 1;
        if (val instanceof Array) {
          val = val[0];
        }
        pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
        pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
        return pt;
      }
    };
    var _default = Single;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleCreator.js
var require_singleCreator = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleCreator.js"() {
    var Single = require_Single();
    var CoordinateSystem = require_CoordinateSystem();
    function create(ecModel, api) {
      var singles = [];
      ecModel.eachComponent("singleAxis", function(axisModel, idx) {
        var single = new Single(axisModel, ecModel, api);
        single.name = "single_" + idx;
        single.resize(axisModel, api);
        axisModel.coordinateSystem = single;
        singles.push(single);
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === "singleAxis") {
          var singleAxisModel = ecModel.queryComponents({
            mainType: "singleAxis",
            index: seriesModel.get("singleAxisIndex"),
            id: seriesModel.get("singleAxisId")
          })[0];
          seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
        }
      });
      return singles;
    }
    CoordinateSystem.register("single", {
      create,
      dimensions: Single.prototype.dimensions
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleAxisHelper.js
var require_singleAxisHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/singleAxisHelper.js"(exports) {
    var zrUtil = require_util();
    function layout(axisModel, opt) {
      opt = opt || {};
      var single = axisModel.coordinateSystem;
      var axis = axisModel.axis;
      var layout2 = {};
      var axisPosition = axis.position;
      var orient = axis.orient;
      var rect = single.getRect();
      var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
      var positionMap = {
        horizontal: {
          top: rectBound[2],
          bottom: rectBound[3]
        },
        vertical: {
          left: rectBound[0],
          right: rectBound[1]
        }
      };
      layout2.position = [orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0], orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]];
      var r = {
        horizontal: 0,
        vertical: 1
      };
      layout2.rotation = Math.PI / 2 * r[orient];
      var directionMap = {
        top: -1,
        bottom: 1,
        right: 1,
        left: -1
      };
      layout2.labelDirection = layout2.tickDirection = layout2.nameDirection = directionMap[axisPosition];
      if (axisModel.get("axisTick.inside")) {
        layout2.tickDirection = -layout2.tickDirection;
      }
      if (zrUtil.retrieve(opt.labelInside, axisModel.get("axisLabel.inside"))) {
        layout2.labelDirection = -layout2.labelDirection;
      }
      var labelRotation = opt.rotate;
      labelRotation == null && (labelRotation = axisModel.get("axisLabel.rotate"));
      layout2.labelRotation = axisPosition === "top" ? -labelRotation : labelRotation;
      layout2.z2 = 1;
      return layout2;
    }
    exports.layout = layout;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/SingleAxisView.js
var require_SingleAxisView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/SingleAxisView.js"(exports, module) {
    var zrUtil = require_util();
    var AxisBuilder = require_AxisBuilder();
    var graphic = require_graphic();
    var singleAxisHelper = require_singleAxisHelper();
    var AxisView = require_AxisView();
    var _axisSplitHelper = require_axisSplitHelper();
    var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
    var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var selfBuilderAttrs = ["splitArea", "splitLine"];
    var SingleAxisView = AxisView.extend({
      type: "singleAxis",
      axisPointerClass: "SingleAxisPointer",
      render: function(axisModel, ecModel, api, payload) {
        var group = this.group;
        group.removeAll();
        var oldAxisGroup = this._axisGroup;
        this._axisGroup = new graphic.Group();
        var layout = singleAxisHelper.layout(axisModel);
        var axisBuilder = new AxisBuilder(axisModel, layout);
        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        group.add(this._axisGroup);
        group.add(axisBuilder.getGroup());
        zrUtil.each(selfBuilderAttrs, function(name2) {
          if (axisModel.get(name2 + ".show")) {
            this["_" + name2](axisModel);
          }
        }, this);
        graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
        SingleAxisView.superCall(this, "render", axisModel, ecModel, api, payload);
      },
      remove: function() {
        rectCoordAxisHandleRemove(this);
      },
      _splitLine: function(axisModel) {
        var axis = axisModel.axis;
        if (axis.scale.isBlank()) {
          return;
        }
        var splitLineModel = axisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineWidth = lineStyleModel.get("width");
        var lineColors = lineStyleModel.get("color");
        lineColors = lineColors instanceof Array ? lineColors : [lineColors];
        var gridRect = axisModel.coordinateSystem.getRect();
        var isHorizontal = axis.isHorizontal();
        var splitLines = [];
        var lineCount = 0;
        var ticksCoords = axis.getTicksCoords({
          tickModel: splitLineModel
        });
        var p1 = [];
        var p2 = [];
        for (var i = 0; i < ticksCoords.length; ++i) {
          var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          var colorIndex = lineCount++ % lineColors.length;
          splitLines[colorIndex] = splitLines[colorIndex] || [];
          splitLines[colorIndex].push(new graphic.Line({
            subPixelOptimize: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: {
              lineWidth
            },
            silent: true
          }));
        }
        for (var i = 0; i < splitLines.length; ++i) {
          this.group.add(graphic.mergePath(splitLines[i], {
            style: {
              stroke: lineColors[i % lineColors.length],
              lineDash: lineStyleModel.getLineDash(lineWidth),
              lineWidth
            },
            silent: true
          }));
        }
      },
      _splitArea: function(axisModel) {
        rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, axisModel);
      }
    });
    var _default = SingleAxisView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/AxisModel.js
var require_AxisModel3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/AxisModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var axisModelCreator = require_axisModelCreator();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var AxisModel = ComponentModel.extend({
      type: "singleAxis",
      layoutMode: "box",
      /**
       * @type {module:echarts/coord/single/SingleAxis}
       */
      axis: null,
      /**
       * @type {module:echarts/coord/single/Single}
       */
      coordinateSystem: null,
      /**
       * @override
       */
      getCoordSysModel: function() {
        return this;
      }
    });
    var defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: true,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: true
      },
      axisTick: {
        show: true,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: true,
        interval: "auto"
      },
      splitLine: {
        show: true,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    };
    function getAxisType(axisName, option) {
      return option.type || (option.data ? "category" : "value");
    }
    zrUtil.merge(AxisModel.prototype, axisModelCommonMixin);
    axisModelCreator("single", AxisModel, getAxisType, defaultOption);
    var _default = AxisModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js
var require_findPointFromSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    function _default(finder, ecModel) {
      var point = [];
      var seriesIndex = finder.seriesIndex;
      var seriesModel;
      if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
        return {
          point: []
        };
      }
      var data = seriesModel.getData();
      var dataIndex = modelUtil.queryDataIndex(data, finder);
      if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {
        return {
          point: []
        };
      }
      var el = data.getItemGraphicEl(dataIndex);
      var coordSys = seriesModel.coordinateSystem;
      if (seriesModel.getTooltipPosition) {
        point = seriesModel.getTooltipPosition(dataIndex) || [];
      } else if (coordSys && coordSys.dataToPoint) {
        point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }), dataIndex, true)) || [];
      } else if (el) {
        var rect = el.getBoundingRect().clone();
        rect.applyTransform(el.transform);
        point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
      }
      return {
        point,
        el
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/axisTrigger.js
var require_axisTrigger = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/axisTrigger.js"(exports, module) {
    var zrUtil = require_util();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var modelHelper = require_modelHelper();
    var findPointFromSeries = require_findPointFromSeries();
    var each = zrUtil.each;
    var curry = zrUtil.curry;
    var inner = makeInner();
    function _default(payload, ecModel, api) {
      var currTrigger = payload.currTrigger;
      var point = [payload.x, payload.y];
      var finder = payload;
      var dispatchAction = payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
      var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
      if (!coordSysAxesInfo) {
        return;
      }
      if (illegalPoint(point)) {
        point = findPointFromSeries({
          seriesIndex: finder.seriesIndex,
          // Do not use dataIndexInside from other ec instance.
          // FIXME: auto detect it?
          dataIndex: finder.dataIndex
        }, ecModel).point;
      }
      var isIllegalPoint = illegalPoint(point);
      var inputAxesInfo = finder.axesInfo;
      var axesInfo = coordSysAxesInfo.axesInfo;
      var shouldHide = currTrigger === "leave" || illegalPoint(point);
      var outputFinder = {};
      var showValueMap = {};
      var dataByCoordSys = {
        list: [],
        map: {}
      };
      var updaters = {
        showPointer: curry(showPointer, showValueMap),
        showTooltip: curry(showTooltip, dataByCoordSys)
      };
      each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
        var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
        each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
          var axis = axisInfo.axis;
          var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
          if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
            var val = inputAxisInfo && inputAxisInfo.value;
            if (val == null && !isIllegalPoint) {
              val = axis.pointToData(point);
            }
            val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
          }
        });
      });
      var linkTriggers = {};
      each(axesInfo, function(tarAxisInfo, tarKey) {
        var linkGroup = tarAxisInfo.linkGroup;
        if (linkGroup && !showValueMap[tarKey]) {
          each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
            var srcValItem = showValueMap[srcKey];
            if (srcAxisInfo !== tarAxisInfo && srcValItem) {
              var val = srcValItem.value;
              linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
              linkTriggers[tarAxisInfo.key] = val;
            }
          });
        }
      });
      each(linkTriggers, function(val, tarKey) {
        processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
      });
      updateModelActually(showValueMap, axesInfo, outputFinder);
      dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
      dispatchHighDownActually(axesInfo, dispatchAction, api);
      return outputFinder;
    }
    function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
      var axis = axisInfo.axis;
      if (axis.scale.isBlank() || !axis.containData(newValue)) {
        return;
      }
      if (!axisInfo.involveSeries) {
        updaters.showPointer(axisInfo, newValue);
        return;
      }
      var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
      var payloadBatch = payloadInfo.payloadBatch;
      var snapToValue = payloadInfo.snapToValue;
      if (payloadBatch[0] && outputFinder.seriesIndex == null) {
        zrUtil.extend(outputFinder, payloadBatch[0]);
      }
      if (!dontSnap && axisInfo.snap) {
        if (axis.containData(snapToValue) && snapToValue != null) {
          newValue = snapToValue;
        }
      }
      updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);
      updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
    }
    function buildPayloadsBySeries(value, axisInfo) {
      var axis = axisInfo.axis;
      var dim = axis.dim;
      var snapToValue = value;
      var payloadBatch = [];
      var minDist = Number.MAX_VALUE;
      var minDiff = -1;
      each(axisInfo.seriesModels, function(series, idx) {
        var dataDim = series.getData().mapDimension(dim, true);
        var seriesNestestValue;
        var dataIndices;
        if (series.getAxisTooltipData) {
          var result = series.getAxisTooltipData(dataDim, value, axis);
          dataIndices = result.dataIndices;
          seriesNestestValue = result.nestestValue;
        } else {
          dataIndices = series.getData().indicesOfNearest(
            dataDim[0],
            value,
            // Add a threshold to avoid find the wrong dataIndex
            // when data length is not same.
            // false,
            axis.type === "category" ? 0.5 : null
          );
          if (!dataIndices.length) {
            return;
          }
          seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
        }
        if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
          return;
        }
        var diff = value - seriesNestestValue;
        var dist = Math.abs(diff);
        if (dist <= minDist) {
          if (dist < minDist || diff >= 0 && minDiff < 0) {
            minDist = dist;
            minDiff = diff;
            snapToValue = seriesNestestValue;
            payloadBatch.length = 0;
          }
          each(dataIndices, function(dataIndex) {
            payloadBatch.push({
              seriesIndex: series.seriesIndex,
              dataIndexInside: dataIndex,
              dataIndex: series.getData().getRawIndex(dataIndex)
            });
          });
        }
      });
      return {
        payloadBatch,
        snapToValue
      };
    }
    function showPointer(showValueMap, axisInfo, value, payloadBatch) {
      showValueMap[axisInfo.key] = {
        value,
        payloadBatch
      };
    }
    function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
      var payloadBatch = payloadInfo.payloadBatch;
      var axis = axisInfo.axis;
      var axisModel = axis.model;
      var axisPointerModel = axisInfo.axisPointerModel;
      if (!axisInfo.triggerTooltip || !payloadBatch.length) {
        return;
      }
      var coordSysModel = axisInfo.coordSys.model;
      var coordSysKey = modelHelper.makeKey(coordSysModel);
      var coordSysItem = dataByCoordSys.map[coordSysKey];
      if (!coordSysItem) {
        coordSysItem = dataByCoordSys.map[coordSysKey] = {
          coordSysId: coordSysModel.id,
          coordSysIndex: coordSysModel.componentIndex,
          coordSysType: coordSysModel.type,
          coordSysMainType: coordSysModel.mainType,
          dataByAxis: []
        };
        dataByCoordSys.list.push(coordSysItem);
      }
      coordSysItem.dataByAxis.push({
        axisDim: axis.dim,
        axisIndex: axisModel.componentIndex,
        axisType: axisModel.type,
        axisId: axisModel.id,
        value,
        // Caustion: viewHelper.getValueLabel is actually on "view stage", which
        // depends that all models have been updated. So it should not be performed
        // here. Considering axisPointerModel used here is volatile, which is hard
        // to be retrieve in TooltipView, we prepare parameters here.
        valueLabelOpt: {
          precision: axisPointerModel.get("label.precision"),
          formatter: axisPointerModel.get("label.formatter")
        },
        seriesDataIndices: payloadBatch.slice()
      });
    }
    function updateModelActually(showValueMap, axesInfo, outputFinder) {
      var outputAxesInfo = outputFinder.axesInfo = [];
      each(axesInfo, function(axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        var valItem = showValueMap[key];
        if (valItem) {
          !axisInfo.useHandle && (option.status = "show");
          option.value = valItem.value;
          option.seriesDataIndices = (valItem.payloadBatch || []).slice();
        } else {
          !axisInfo.useHandle && (option.status = "hide");
        }
        option.status === "show" && outputAxesInfo.push({
          axisDim: axisInfo.axis.dim,
          axisIndex: axisInfo.axis.model.componentIndex,
          value: option.value
        });
      });
    }
    function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
      if (illegalPoint(point) || !dataByCoordSys.list.length) {
        dispatchAction({
          type: "hideTip"
        });
        return;
      }
      var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
      dispatchAction({
        type: "showTip",
        escapeConnect: true,
        x: point[0],
        y: point[1],
        tooltipOption: payload.tooltipOption,
        position: payload.position,
        dataIndexInside: sampleItem.dataIndexInside,
        dataIndex: sampleItem.dataIndex,
        seriesIndex: sampleItem.seriesIndex,
        dataByCoordSys: dataByCoordSys.list
      });
    }
    function dispatchHighDownActually(axesInfo, dispatchAction, api) {
      var zr = api.getZr();
      var highDownKey = "axisPointerLastHighlights";
      var lastHighlights = inner(zr)[highDownKey] || {};
      var newHighlights = inner(zr)[highDownKey] = {};
      each(axesInfo, function(axisInfo, key) {
        var option = axisInfo.axisPointerModel.option;
        option.status === "show" && each(option.seriesDataIndices, function(batchItem) {
          var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
          newHighlights[key2] = batchItem;
        });
      });
      var toHighlight = [];
      var toDownplay = [];
      zrUtil.each(lastHighlights, function(batchItem, key) {
        !newHighlights[key] && toDownplay.push(batchItem);
      });
      zrUtil.each(newHighlights, function(batchItem, key) {
        !lastHighlights[key] && toHighlight.push(batchItem);
      });
      toDownplay.length && api.dispatchAction({
        type: "downplay",
        escapeConnect: true,
        batch: toDownplay
      });
      toHighlight.length && api.dispatchAction({
        type: "highlight",
        escapeConnect: true,
        batch: toHighlight
      });
    }
    function findInputAxisInfo(inputAxesInfo, axisInfo) {
      for (var i = 0; i < (inputAxesInfo || []).length; i++) {
        var inputAxisInfo = inputAxesInfo[i];
        if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
          return inputAxisInfo;
        }
      }
    }
    function makeMapperParam(axisInfo) {
      var axisModel = axisInfo.axis.model;
      var item = {};
      var dim = item.axisDim = axisInfo.axis.dim;
      item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
      item.axisName = item[dim + "AxisName"] = axisModel.name;
      item.axisId = item[dim + "AxisId"] = axisModel.id;
      return item;
    }
    function illegalPoint(point) {
      return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js
var require_AxisPointerModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerModel.js"(exports, module) {
    var echarts = require_echarts();
    var AxisPointerModel = echarts.extendComponentModel({
      type: "axisPointer",
      coordSysAxesInfo: null,
      defaultOption: {
        // 'auto' means that show when triggered by tooltip or handle.
        show: "auto",
        // 'click' | 'mousemove' | 'none'
        triggerOn: null,
        // set default in AxisPonterView.js
        zlevel: 0,
        z: 50,
        type: "line",
        // 'line' 'shadow' 'cross' 'none'.
        // axispointer triggered by tootip determine snap automatically,
        // see `modelHelper`.
        snap: false,
        triggerTooltip: true,
        value: null,
        status: null,
        // Init value depends on whether handle is used.
        // [group0, group1, ...]
        // Each group can be: {
        //      mapper: function () {},
        //      singleTooltip: 'multiple',  // 'multiple' or 'single'
        //      xAxisId: ...,
        //      yAxisName: ...,
        //      angleAxisIndex: ...
        // }
        // mapper: can be ignored.
        //      input: {axisInfo, value}
        //      output: {axisInfo, value}
        link: [],
        // Do not set 'auto' here, otherwise global animation: false
        // will not effect at this axispointer.
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: {
          color: "#aaa",
          width: 1,
          type: "solid"
        },
        shadowStyle: {
          color: "rgba(150,150,150,0.3)"
        },
        label: {
          show: true,
          formatter: null,
          // string | Function
          precision: "auto",
          // Or a number like 0, 1, 2 ...
          margin: 3,
          color: "#fff",
          padding: [5, 7, 5, 7],
          backgroundColor: "auto",
          // default: axis line color
          borderColor: null,
          borderWidth: 0,
          shadowBlur: 3,
          shadowColor: "#aaa"
          // Considering applicability, common style should
          // better not have shadowOffset.
          // shadowOffsetX: 0,
          // shadowOffsetY: 2
        },
        handle: {
          show: false,
          /* eslint-disable */
          icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
          // jshint ignore:line
          /* eslint-enable */
          size: 45,
          // handle margin is from symbol center to axis, which is stable when circular move.
          margin: 50,
          // color: '#1b8bbd'
          // color: '#2f4554'
          color: "#333",
          shadowBlur: 3,
          shadowColor: "#aaa",
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          // For mobile performance
          throttle: 40
        }
      }
    });
    var _default = AxisPointerModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/globalListener.js
var require_globalListener = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/globalListener.js"(exports) {
    var zrUtil = require_util();
    var env = require_env();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    var each = zrUtil.each;
    function register(key, api, handler) {
      if (env.node) {
        return;
      }
      var zr = api.getZr();
      inner(zr).records || (inner(zr).records = {});
      initGlobalListeners(zr, api);
      var record = inner(zr).records[key] || (inner(zr).records[key] = {});
      record.handler = handler;
    }
    function initGlobalListeners(zr, api) {
      if (inner(zr).initialized) {
        return;
      }
      inner(zr).initialized = true;
      useHandler("click", zrUtil.curry(doEnter, "click"));
      useHandler("mousemove", zrUtil.curry(doEnter, "mousemove"));
      useHandler("globalout", onLeave);
      function useHandler(eventType, cb) {
        zr.on(eventType, function(e) {
          var dis = makeDispatchAction(api);
          each(inner(zr).records, function(record) {
            record && cb(record, e, dis.dispatchAction);
          });
          dispatchTooltipFinally(dis.pendings, api);
        });
      }
    }
    function dispatchTooltipFinally(pendings, api) {
      var showLen = pendings.showTip.length;
      var hideLen = pendings.hideTip.length;
      var actuallyPayload;
      if (showLen) {
        actuallyPayload = pendings.showTip[showLen - 1];
      } else if (hideLen) {
        actuallyPayload = pendings.hideTip[hideLen - 1];
      }
      if (actuallyPayload) {
        actuallyPayload.dispatchAction = null;
        api.dispatchAction(actuallyPayload);
      }
    }
    function onLeave(record, e, dispatchAction) {
      record.handler("leave", null, dispatchAction);
    }
    function doEnter(currTrigger, record, e, dispatchAction) {
      record.handler(currTrigger, e, dispatchAction);
    }
    function makeDispatchAction(api) {
      var pendings = {
        showTip: [],
        hideTip: []
      };
      var dispatchAction = function(payload) {
        var pendingList = pendings[payload.type];
        if (pendingList) {
          pendingList.push(payload);
        } else {
          payload.dispatchAction = dispatchAction;
          api.dispatchAction(payload);
        }
      };
      return {
        dispatchAction,
        pendings
      };
    }
    function unregister(key, api) {
      if (env.node) {
        return;
      }
      var zr = api.getZr();
      var record = (inner(zr).records || {})[key];
      if (record) {
        inner(zr).records[key] = null;
      }
    }
    exports.register = register;
    exports.unregister = unregister;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerView.js
var require_AxisPointerView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/AxisPointerView.js"(exports, module) {
    var echarts = require_echarts();
    var globalListener = require_globalListener();
    var AxisPointerView = echarts.extendComponentView({
      type: "axisPointer",
      render: function(globalAxisPointerModel, ecModel, api) {
        var globalTooltipModel = ecModel.getComponent("tooltip");
        var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
        globalListener.register("axisPointer", api, function(currTrigger, e, dispatchAction) {
          if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
            dispatchAction({
              type: "updateAxisPointer",
              currTrigger,
              x: e && e.offsetX,
              y: e && e.offsetY
            });
          }
        });
      },
      /**
       * @override
       */
      remove: function(ecModel, api) {
        globalListener.unregister(api.getZr(), "axisPointer");
        AxisPointerView.superApply(this._model, "remove", arguments);
      },
      /**
       * @override
       */
      dispose: function(ecModel, api) {
        globalListener.unregister("axisPointer", api);
        AxisPointerView.superApply(this._model, "dispose", arguments);
      }
    });
    var _default = AxisPointerView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js
var require_BaseAxisPointer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/BaseAxisPointer.js"(exports, module) {
    var zrUtil = require_util();
    var clazzUtil = require_clazz();
    var graphic = require_graphic();
    var axisPointerModelHelper = require_modelHelper();
    var eventTool = require_event();
    var throttleUtil = require_throttle();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    var clone = zrUtil.clone;
    var bind = zrUtil.bind;
    function BaseAxisPointer() {
    }
    BaseAxisPointer.prototype = {
      /**
       * @private
       */
      _group: null,
      /**
       * @private
       */
      _lastGraphicKey: null,
      /**
       * @private
       */
      _handle: null,
      /**
       * @private
       */
      _dragging: false,
      /**
       * @private
       */
      _lastValue: null,
      /**
       * @private
       */
      _lastStatus: null,
      /**
       * @private
       */
      _payloadInfo: null,
      /**
       * In px, arbitrary value. Do not set too small,
       * no animation is ok for most cases.
       * @protected
       */
      animationThreshold: 15,
      /**
       * @implement
       */
      render: function(axisModel, axisPointerModel, api, forceRender) {
        var value = axisPointerModel.get("value");
        var status = axisPointerModel.get("status");
        this._axisModel = axisModel;
        this._axisPointerModel = axisPointerModel;
        this._api = api;
        if (!forceRender && this._lastValue === value && this._lastStatus === status) {
          return;
        }
        this._lastValue = value;
        this._lastStatus = status;
        var group = this._group;
        var handle = this._handle;
        if (!status || status === "hide") {
          group && group.hide();
          handle && handle.hide();
          return;
        }
        group && group.show();
        handle && handle.show();
        var elOption = {};
        this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
        var graphicKey = elOption.graphicKey;
        if (graphicKey !== this._lastGraphicKey) {
          this.clear(api);
        }
        this._lastGraphicKey = graphicKey;
        var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
        if (!group) {
          group = this._group = new graphic.Group();
          this.createPointerEl(group, elOption, axisModel, axisPointerModel);
          this.createLabelEl(group, elOption, axisModel, axisPointerModel);
          api.getZr().add(group);
        } else {
          var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
          this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
          this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
        }
        updateMandatoryProps(group, axisPointerModel, true);
        this._renderHandle(value);
      },
      /**
       * @implement
       */
      remove: function(api) {
        this.clear(api);
      },
      /**
       * @implement
       */
      dispose: function(api) {
        this.clear(api);
      },
      /**
       * @protected
       */
      determineAnimation: function(axisModel, axisPointerModel) {
        var animation = axisPointerModel.get("animation");
        var axis = axisModel.axis;
        var isCategoryAxis = axis.type === "category";
        var useSnap = axisPointerModel.get("snap");
        if (!useSnap && !isCategoryAxis) {
          return false;
        }
        if (animation === "auto" || animation == null) {
          var animationThreshold = this.animationThreshold;
          if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
            return true;
          }
          if (useSnap) {
            var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
            var axisExtent = axis.getExtent();
            return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
          }
          return false;
        }
        return animation === true;
      },
      /**
       * add {pointer, label, graphicKey} to elOption
       * @protected
       */
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
      },
      /**
       * @protected
       */
      createPointerEl: function(group, elOption, axisModel, axisPointerModel) {
        var pointerOption = elOption.pointer;
        if (pointerOption) {
          var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
          group.add(pointerEl);
        }
      },
      /**
       * @protected
       */
      createLabelEl: function(group, elOption, axisModel, axisPointerModel) {
        if (elOption.label) {
          var labelEl = inner(group).labelEl = new graphic.Rect(clone(elOption.label));
          group.add(labelEl);
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      },
      /**
       * @protected
       */
      updatePointerEl: function(group, elOption, updateProps2) {
        var pointerEl = inner(group).pointerEl;
        if (pointerEl && elOption.pointer) {
          pointerEl.setStyle(elOption.pointer.style);
          updateProps2(pointerEl, {
            shape: elOption.pointer.shape
          });
        }
      },
      /**
       * @protected
       */
      updateLabelEl: function(group, elOption, updateProps2, axisPointerModel) {
        var labelEl = inner(group).labelEl;
        if (labelEl) {
          labelEl.setStyle(elOption.label.style);
          updateProps2(labelEl, {
            // Consider text length change in vertical axis, animation should
            // be used on shape, otherwise the effect will be weird.
            shape: elOption.label.shape,
            position: elOption.label.position
          });
          updateLabelShowHide(labelEl, axisPointerModel);
        }
      },
      /**
       * @private
       */
      _renderHandle: function(value) {
        if (this._dragging || !this.updateHandleTransform) {
          return;
        }
        var axisPointerModel = this._axisPointerModel;
        var zr = this._api.getZr();
        var handle = this._handle;
        var handleModel = axisPointerModel.getModel("handle");
        var status = axisPointerModel.get("status");
        if (!handleModel.get("show") || !status || status === "hide") {
          handle && zr.remove(handle);
          this._handle = null;
          return;
        }
        var isInit;
        if (!this._handle) {
          isInit = true;
          handle = this._handle = graphic.createIcon(handleModel.get("icon"), {
            cursor: "move",
            draggable: true,
            onmousemove: function(e) {
              eventTool.stop(e.event);
            },
            onmousedown: bind(this._onHandleDragMove, this, 0, 0),
            drift: bind(this._onHandleDragMove, this),
            ondragend: bind(this._onHandleDragEnd, this)
          });
          zr.add(handle);
        }
        updateMandatoryProps(handle, axisPointerModel, false);
        var includeStyles = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
        handle.setStyle(handleModel.getItemStyle(null, includeStyles));
        var handleSize = handleModel.get("size");
        if (!zrUtil.isArray(handleSize)) {
          handleSize = [handleSize, handleSize];
        }
        handle.attr("scale", [handleSize[0] / 2, handleSize[1] / 2]);
        throttleUtil.createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
        this._moveHandleToValue(value, isInit);
      },
      /**
       * @private
       */
      _moveHandleToValue: function(value, isInit) {
        updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
      },
      /**
       * @private
       */
      _onHandleDragMove: function(dx, dy) {
        var handle = this._handle;
        if (!handle) {
          return;
        }
        this._dragging = true;
        var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
        this._payloadInfo = trans;
        handle.stopAnimation();
        handle.attr(getHandleTransProps(trans));
        inner(handle).lastProp = null;
        this._doDispatchAxisPointer();
      },
      /**
       * Throttled method.
       * @private
       */
      _doDispatchAxisPointer: function() {
        var handle = this._handle;
        if (!handle) {
          return;
        }
        var payloadInfo = this._payloadInfo;
        var axisModel = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: payloadInfo.cursorPoint[0],
          y: payloadInfo.cursorPoint[1],
          tooltipOption: payloadInfo.tooltipOption,
          axesInfo: [{
            axisDim: axisModel.axis.dim,
            axisIndex: axisModel.componentIndex
          }]
        });
      },
      /**
       * @private
       */
      _onHandleDragEnd: function(moveAnimation) {
        this._dragging = false;
        var handle = this._handle;
        if (!handle) {
          return;
        }
        var value = this._axisPointerModel.get("value");
        this._moveHandleToValue(value);
        this._api.dispatchAction({
          type: "hideTip"
        });
      },
      /**
       * Should be implemenented by sub-class if support `handle`.
       * @protected
       * @param {number} value
       * @param {module:echarts/model/Model} axisModel
       * @param {module:echarts/model/Model} axisPointerModel
       * @return {Object} {position: [x, y], rotation: 0}
       */
      getHandleTransform: null,
      /**
       * * Should be implemenented by sub-class if support `handle`.
       * @protected
       * @param {Object} transform {position, rotation}
       * @param {Array.<number>} delta [dx, dy]
       * @param {module:echarts/model/Model} axisModel
       * @param {module:echarts/model/Model} axisPointerModel
       * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
       */
      updateHandleTransform: null,
      /**
       * @private
       */
      clear: function(api) {
        this._lastValue = null;
        this._lastStatus = null;
        var zr = api.getZr();
        var group = this._group;
        var handle = this._handle;
        if (zr && group) {
          this._lastGraphicKey = null;
          group && zr.remove(group);
          handle && zr.remove(handle);
          this._group = null;
          this._handle = null;
          this._payloadInfo = null;
        }
      },
      /**
       * @protected
       */
      doClear: function() {
      },
      /**
       * @protected
       * @param {Array.<number>} xy
       * @param {Array.<number>} wh
       * @param {number} [xDimIndex=0] or 1
       */
      buildLabel: function(xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0;
        return {
          x: xy[xDimIndex],
          y: xy[1 - xDimIndex],
          width: wh[xDimIndex],
          height: wh[1 - xDimIndex]
        };
      }
    };
    BaseAxisPointer.prototype.constructor = BaseAxisPointer;
    function updateProps(animationModel, moveAnimation, el, props) {
      if (!propsEqual(inner(el).lastProp, props)) {
        inner(el).lastProp = props;
        moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
      }
    }
    function propsEqual(lastProps, newProps) {
      if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
        var equals = true;
        zrUtil.each(newProps, function(item, key) {
          equals = equals && propsEqual(lastProps[key], item);
        });
        return !!equals;
      } else {
        return lastProps === newProps;
      }
    }
    function updateLabelShowHide(labelEl, axisPointerModel) {
      labelEl[axisPointerModel.get("label.show") ? "show" : "hide"]();
    }
    function getHandleTransProps(trans) {
      return {
        position: trans.position.slice(),
        rotation: trans.rotation || 0
      };
    }
    function updateMandatoryProps(group, axisPointerModel, silent) {
      var z = axisPointerModel.get("z");
      var zlevel = axisPointerModel.get("zlevel");
      group && group.traverse(function(el) {
        if (el.type !== "group") {
          z != null && (el.z = z);
          zlevel != null && (el.zlevel = zlevel);
          el.silent = silent;
        }
      });
    }
    clazzUtil.enableClassExtend(BaseAxisPointer);
    var _default = BaseAxisPointer;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/viewHelper.js
var require_viewHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/viewHelper.js"(exports) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var textContain = require_text();
    var formatUtil = require_format();
    var matrix = require_matrix();
    var axisHelper = require_axisHelper();
    var AxisBuilder = require_AxisBuilder();
    function buildElStyle(axisPointerModel) {
      var axisPointerType = axisPointerModel.get("type");
      var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
      var style;
      if (axisPointerType === "line") {
        style = styleModel.getLineStyle();
        style.fill = null;
      } else if (axisPointerType === "shadow") {
        style = styleModel.getAreaStyle();
        style.stroke = null;
      }
      return style;
    }
    function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
      var value = axisPointerModel.get("value");
      var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
        precision: axisPointerModel.get("label.precision"),
        formatter: axisPointerModel.get("label.formatter")
      });
      var labelModel = axisPointerModel.getModel("label");
      var paddings = formatUtil.normalizeCssArray(labelModel.get("padding") || 0);
      var font = labelModel.getFont();
      var textRect = textContain.getBoundingRect(text, font);
      var position = labelPos.position;
      var width = textRect.width + paddings[1] + paddings[3];
      var height = textRect.height + paddings[0] + paddings[2];
      var align = labelPos.align;
      align === "right" && (position[0] -= width);
      align === "center" && (position[0] -= width / 2);
      var verticalAlign = labelPos.verticalAlign;
      verticalAlign === "bottom" && (position[1] -= height);
      verticalAlign === "middle" && (position[1] -= height / 2);
      confineInContainer(position, width, height, api);
      var bgColor = labelModel.get("backgroundColor");
      if (!bgColor || bgColor === "auto") {
        bgColor = axisModel.get("axisLine.lineStyle.color");
      }
      elOption.label = {
        shape: {
          x: 0,
          y: 0,
          width,
          height,
          r: labelModel.get("borderRadius")
        },
        position: position.slice(),
        // TODO: rich
        style: {
          text,
          textFont: font,
          textFill: labelModel.getTextColor(),
          textPosition: "inside",
          textPadding: paddings,
          fill: bgColor,
          stroke: labelModel.get("borderColor") || "transparent",
          lineWidth: labelModel.get("borderWidth") || 0,
          shadowBlur: labelModel.get("shadowBlur"),
          shadowColor: labelModel.get("shadowColor"),
          shadowOffsetX: labelModel.get("shadowOffsetX"),
          shadowOffsetY: labelModel.get("shadowOffsetY")
        },
        // Lable should be over axisPointer.
        z2: 10
      };
    }
    function confineInContainer(position, width, height, api) {
      var viewWidth = api.getWidth();
      var viewHeight = api.getHeight();
      position[0] = Math.min(position[0] + width, viewWidth) - width;
      position[1] = Math.min(position[1] + height, viewHeight) - height;
      position[0] = Math.max(position[0], 0);
      position[1] = Math.max(position[1], 0);
    }
    function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
      value = axis.scale.parse(value);
      var text = axis.scale.getLabel(
        // If `precision` is set, width can be fixed (like '12.00500'), which
        // helps to debounce when when moving label.
        value,
        {
          precision: opt.precision
        }
      );
      var formatter = opt.formatter;
      if (formatter) {
        var params = {
          value: axisHelper.getAxisRawValue(axis, value),
          axisDimension: axis.dim,
          axisIndex: axis.index,
          seriesData: []
        };
        zrUtil.each(seriesDataIndices, function(idxItem) {
          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          var dataIndex = idxItem.dataIndexInside;
          var dataParams = series && series.getDataParams(dataIndex);
          dataParams && params.seriesData.push(dataParams);
        });
        if (zrUtil.isString(formatter)) {
          text = formatter.replace("{value}", text);
        } else if (zrUtil.isFunction(formatter)) {
          text = formatter(params);
        }
      }
      return text;
    }
    function getTransformedPosition(axis, value, layoutInfo) {
      var transform = matrix.create();
      matrix.rotate(transform, transform, layoutInfo.rotation);
      matrix.translate(transform, transform, layoutInfo.position);
      return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
    }
    function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
      var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
      layoutInfo.labelMargin = axisPointerModel.get("label.margin");
      buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
        position: getTransformedPosition(axisModel.axis, value, layoutInfo),
        align: textLayout.textAlign,
        verticalAlign: textLayout.textVerticalAlign
      });
    }
    function makeLineShape(p1, p2, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x1: p1[xDimIndex],
        y1: p1[1 - xDimIndex],
        x2: p2[xDimIndex],
        y2: p2[1 - xDimIndex]
      };
    }
    function makeRectShape(xy, wh, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x: xy[xDimIndex],
        y: xy[1 - xDimIndex],
        width: wh[xDimIndex],
        height: wh[1 - xDimIndex]
      };
    }
    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
      return {
        cx,
        cy,
        r0,
        r,
        startAngle,
        endAngle,
        clockwise: true
      };
    }
    exports.buildElStyle = buildElStyle;
    exports.buildLabelElOption = buildLabelElOption;
    exports.getValueLabel = getValueLabel;
    exports.getTransformedPosition = getTransformedPosition;
    exports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
    exports.makeLineShape = makeLineShape;
    exports.makeRectShape = makeRectShape;
    exports.makeSectorShape = makeSectorShape;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js
var require_CartesianAxisPointer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/CartesianAxisPointer.js"(exports, module) {
    var BaseAxisPointer = require_BaseAxisPointer();
    var viewHelper = require_viewHelper();
    var cartesianAxisHelper = require_cartesianAxisHelper();
    var AxisView = require_AxisView();
    var CartesianAxisPointer = BaseAxisPointer.extend({
      /**
       * @override
       */
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisPointerType = axisPointerModel.get("type");
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = viewHelper.buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
        viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
      },
      /**
       * @override
       */
      getHandleTransform: function(value, axisModel, axisPointerModel) {
        var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
          labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get("handle.margin");
        return {
          position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
      },
      /**
       * @override
       */
      updateHandleTransform: function(transform, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var grid = axis.grid;
        var axisExtent = axis.getGlobalExtent(true);
        var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
        var dimIndex = axis.dim === "x" ? 0 : 1;
        var currPosition = transform.position;
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex];
        var tooltipOptions = [{
          verticalAlign: "middle"
        }, {
          align: "center"
        }];
        return {
          position: currPosition,
          rotation: transform.rotation,
          cursorPoint,
          tooltipOption: tooltipOptions[dimIndex]
        };
      }
    });
    function getCartesian(grid, axis) {
      var opt = {};
      opt[axis.dim + "AxisIndex"] = axis.index;
      return grid.getCartesian(opt);
    }
    var pointerShapeBuilder = {
      line: function(axis, pixelValue, otherExtent) {
        var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
        return {
          type: "Line",
          subPixelOptimize: true,
          shape: targetShape
        };
      },
      shadow: function(axis, pixelValue, otherExtent) {
        var bandWidth = Math.max(1, axis.getBandWidth());
        var span = otherExtent[1] - otherExtent[0];
        return {
          type: "Rect",
          shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
        };
      }
    };
    function getAxisDimIndex(axis) {
      return axis.dim === "x" ? 0 : 1;
    }
    AxisView.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer);
    var _default = CartesianAxisPointer;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer.js
var require_axisPointer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var axisPointerModelHelper = require_modelHelper();
    var axisTrigger = require_axisTrigger();
    require_AxisPointerModel();
    require_AxisPointerView();
    require_CartesianAxisPointer();
    echarts.registerPreprocessor(function(option) {
      if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
        var link = option.axisPointer.link;
        if (link && !zrUtil.isArray(link)) {
          option.axisPointer.link = [link];
        }
      }
    });
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
      ecModel.getComponent("axisPointer").coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
    });
    echarts.registerAction({
      type: "updateAxisPointer",
      event: "updateAxisPointer",
      update: ":updateAxisPointer"
    }, axisTrigger);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js
var require_SingleAxisPointer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/SingleAxisPointer.js"(exports, module) {
    var BaseAxisPointer = require_BaseAxisPointer();
    var viewHelper = require_viewHelper();
    var singleAxisHelper = require_singleAxisHelper();
    var AxisView = require_AxisView();
    var XY = ["x", "y"];
    var WH = ["width", "height"];
    var SingleAxisPointer = BaseAxisPointer.extend({
      /**
       * @override
       */
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        var coordSys = axis.coordinateSystem;
        var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
        var pixelValue = coordSys.dataToPoint(value)[0];
        var axisPointerType = axisPointerModel.get("type");
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = viewHelper.buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var layoutInfo = singleAxisHelper.layout(axisModel);
        viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
      },
      /**
       * @override
       */
      getHandleTransform: function(value, axisModel, axisPointerModel) {
        var layoutInfo = singleAxisHelper.layout(axisModel, {
          labelInside: false
        });
        layoutInfo.labelMargin = axisPointerModel.get("handle.margin");
        return {
          position: viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo),
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        };
      },
      /**
       * @override
       */
      updateHandleTransform: function(transform, delta, axisModel, axisPointerModel) {
        var axis = axisModel.axis;
        var coordSys = axis.coordinateSystem;
        var dimIndex = getPointDimIndex(axis);
        var axisExtent = getGlobalExtent(coordSys, dimIndex);
        var currPosition = transform.position;
        currPosition[dimIndex] += delta[dimIndex];
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
        var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
        var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
        var cursorPoint = [cursorOtherValue, cursorOtherValue];
        cursorPoint[dimIndex] = currPosition[dimIndex];
        return {
          position: currPosition,
          rotation: transform.rotation,
          cursorPoint,
          tooltipOption: {
            verticalAlign: "middle"
          }
        };
      }
    });
    var pointerShapeBuilder = {
      line: function(axis, pixelValue, otherExtent) {
        var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
        return {
          type: "Line",
          subPixelOptimize: true,
          shape: targetShape
        };
      },
      shadow: function(axis, pixelValue, otherExtent) {
        var bandWidth = axis.getBandWidth();
        var span = otherExtent[1] - otherExtent[0];
        return {
          type: "Rect",
          shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
        };
      }
    };
    function getPointDimIndex(axis) {
      return axis.isHorizontal() ? 0 : 1;
    }
    function getGlobalExtent(coordSys, dimIndex) {
      var rect = coordSys.getRect();
      return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];
    }
    AxisView.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer);
    var _default = SingleAxisPointer;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/singleAxis.js
var require_singleAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/singleAxis.js"() {
    var echarts = require_echarts();
    require_singleCreator();
    require_SingleAxisView();
    require_AxisModel3();
    require_axisPointer();
    require_SingleAxisPointer();
    echarts.extendComponentView({
      type: "single"
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js
var require_ThemeRiverSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverSeries.js"(exports, module) {
    var SeriesModel = require_Series();
    var createDimensions = require_createDimensions();
    var _dimensionHelper = require_dimensionHelper();
    var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
    var List = require_List();
    var zrUtil = require_util();
    var _model = require_model();
    var groupData = _model.groupData;
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var LegendVisualProvider = require_LegendVisualProvider();
    var DATA_NAME_INDEX = 2;
    var ThemeRiverSeries = SeriesModel.extend({
      type: "series.themeRiver",
      dependencies: ["singleAxis"],
      /**
       * @readOnly
       * @type {module:zrender/core/util#HashMap}
       */
      nameMap: null,
      /**
       * @override
       */
      init: function(option) {
        ThemeRiverSeries.superApply(this, "init", arguments);
        this.legendVisualProvider = new LegendVisualProvider(zrUtil.bind(this.getData, this), zrUtil.bind(this.getRawData, this));
      },
      /**
       * If there is no value of a certain point in the time for some event,set it value to 0.
       *
       * @param {Array} data  initial data in the option
       * @return {Array}
       */
      fixData: function(data) {
        var rawDataLength = data.length;
        var timeValueKeys = {};
        var groupResult = groupData(data, function(item) {
          if (!timeValueKeys.hasOwnProperty(item[0])) {
            timeValueKeys[item[0]] = -1;
          }
          return item[2];
        });
        var layData = [];
        groupResult.buckets.each(function(items, key) {
          layData.push({
            name: key,
            dataList: items
          });
        });
        var layerNum = layData.length;
        for (var k = 0; k < layerNum; ++k) {
          var name2 = layData[k].name;
          for (var j = 0; j < layData[k].dataList.length; ++j) {
            var timeValue = layData[k].dataList[j][0];
            timeValueKeys[timeValue] = k;
          }
          for (var timeValue in timeValueKeys) {
            if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
              timeValueKeys[timeValue] = k;
              data[rawDataLength] = [];
              data[rawDataLength][0] = timeValue;
              data[rawDataLength][1] = 0;
              data[rawDataLength][2] = name2;
              rawDataLength++;
            }
          }
        }
        return data;
      },
      /**
       * @override
       * @param  {Object} option  the initial option that user gived
       * @param  {module:echarts/model/Model} ecModel  the model object for themeRiver option
       * @return {module:echarts/data/List}
       */
      getInitialData: function(option, ecModel) {
        var singleAxisModel = ecModel.queryComponents({
          mainType: "singleAxis",
          index: this.get("singleAxisIndex"),
          id: this.get("singleAxisId")
        })[0];
        var axisType = singleAxisModel.get("type");
        var filterData = zrUtil.filter(option.data, function(dataItem) {
          return dataItem[2] !== void 0;
        });
        var data = this.fixData(filterData || []);
        var nameList = [];
        var nameMap = this.nameMap = zrUtil.createHashMap();
        var count = 0;
        for (var i = 0; i < data.length; ++i) {
          nameList.push(data[i][DATA_NAME_INDEX]);
          if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
            nameMap.set(data[i][DATA_NAME_INDEX], count);
            count++;
          }
        }
        var dimensionsInfo = createDimensions(data, {
          coordDimensions: ["single"],
          dimensionsDefine: [{
            name: "time",
            type: getDimensionTypeByAxis(axisType)
          }, {
            name: "value",
            type: "float"
          }, {
            name: "name",
            type: "ordinal"
          }],
          encodeDefine: {
            single: 0,
            value: 1,
            itemName: 2
          }
        });
        var list = new List(dimensionsInfo, this);
        list.initData(data);
        return list;
      },
      /**
       * The raw data is divided into multiple layers and each layer
       *     has same name.
       *
       * @return {Array.<Array.<number>>}
       */
      getLayerSeries: function() {
        var data = this.getData();
        var lenCount = data.count();
        var indexArr = [];
        for (var i = 0; i < lenCount; ++i) {
          indexArr[i] = i;
        }
        var timeDim = data.mapDimension("single");
        var groupResult = groupData(indexArr, function(index) {
          return data.get("name", index);
        });
        var layerSeries = [];
        groupResult.buckets.each(function(items, key) {
          items.sort(function(index1, index2) {
            return data.get(timeDim, index1) - data.get(timeDim, index2);
          });
          layerSeries.push({
            name: key,
            indices: items
          });
        });
        return layerSeries;
      },
      /**
       * Get data indices for show tooltip content
        * @param {Array.<string>|string} dim  single coordinate dimension
       * @param {number} value axis value
       * @param {module:echarts/coord/single/SingleAxis} baseAxis  single Axis used
       *     the themeRiver.
       * @return {Object} {dataIndices, nestestValue}
       */
      getAxisTooltipData: function(dim, value, baseAxis) {
        if (!zrUtil.isArray(dim)) {
          dim = dim ? [dim] : [];
        }
        var data = this.getData();
        var layerSeries = this.getLayerSeries();
        var indices = [];
        var layerNum = layerSeries.length;
        var nestestValue;
        for (var i = 0; i < layerNum; ++i) {
          var minDist = Number.MAX_VALUE;
          var nearestIdx = -1;
          var pointNum = layerSeries[i].indices.length;
          for (var j = 0; j < pointNum; ++j) {
            var theValue = data.get(dim[0], layerSeries[i].indices[j]);
            var dist = Math.abs(theValue - value);
            if (dist <= minDist) {
              nestestValue = theValue;
              minDist = dist;
              nearestIdx = layerSeries[i].indices[j];
            }
          }
          indices.push(nearestIdx);
        }
        return {
          dataIndices: indices,
          nestestValue
        };
      },
      /**
       * @override
       * @param {number} dataIndex  index of data
       */
      formatTooltip: function(dataIndex) {
        var data = this.getData();
        var htmlName = data.getName(dataIndex);
        var htmlValue = data.get(data.mapDimension("value"), dataIndex);
        if (isNaN(htmlValue) || htmlValue == null) {
          htmlValue = "-";
        }
        return encodeHTML(htmlName + " : " + htmlValue);
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        coordinateSystem: "singleAxis",
        // gap in axis's orthogonal orientation
        boundaryGap: ["10%", "10%"],
        // legendHoverLink: true,
        singleAxisIndex: 0,
        animationEasing: "linear",
        label: {
          margin: 4,
          show: true,
          position: "left",
          color: "#000",
          fontSize: 11
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    var _default = ThemeRiverSeries;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js
var require_ThemeRiverView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/ThemeRiverView.js"(exports, module) {
    var echarts = require_echarts();
    var _poly = require_poly2();
    var Polygon = _poly.Polygon;
    var graphic = require_graphic();
    var _util = require_util();
    var bind = _util.bind;
    var extend = _util.extend;
    var DataDiffer = require_DataDiffer();
    var _default = echarts.extendChartView({
      type: "themeRiver",
      init: function() {
        this._layers = [];
      },
      render: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var group = this.group;
        var layerSeries = seriesModel.getLayerSeries();
        var layoutInfo = data.getLayout("layoutInfo");
        var rect = layoutInfo.rect;
        var boundaryGap = layoutInfo.boundaryGap;
        group.attr("position", [0, rect.y + boundaryGap[0]]);
        function keyGetter(item) {
          return item.name;
        }
        var dataDiffer = new DataDiffer(this._layersSeries || [], layerSeries, keyGetter, keyGetter);
        var newLayersGroups = {};
        dataDiffer.add(bind(process, this, "add")).update(bind(process, this, "update")).remove(bind(process, this, "remove")).execute();
        function process(status, idx, oldIdx) {
          var oldLayersGroups = this._layers;
          if (status === "remove") {
            group.remove(oldLayersGroups[idx]);
            return;
          }
          var points0 = [];
          var points1 = [];
          var color;
          var indices = layerSeries[idx].indices;
          for (var j = 0; j < indices.length; j++) {
            var layout = data.getItemLayout(indices[j]);
            var x = layout.x;
            var y0 = layout.y0;
            var y = layout.y;
            points0.push([x, y0]);
            points1.push([x, y0 + y]);
            color = data.getItemVisual(indices[j], "color");
          }
          var polygon;
          var text;
          var textLayout = data.getItemLayout(indices[0]);
          var itemModel = data.getItemModel(indices[j - 1]);
          var labelModel = itemModel.getModel("label");
          var margin = labelModel.get("margin");
          if (status === "add") {
            var layerGroup = newLayersGroups[idx] = new graphic.Group();
            polygon = new Polygon({
              shape: {
                points: points0,
                stackedOnPoints: points1,
                smooth: 0.4,
                stackedOnSmooth: 0.4,
                smoothConstraint: false
              },
              z2: 0
            });
            text = new graphic.Text({
              style: {
                x: textLayout.x - margin,
                y: textLayout.y0 + textLayout.y / 2
              }
            });
            layerGroup.add(polygon);
            layerGroup.add(text);
            group.add(layerGroup);
            polygon.setClipPath(createGridClipShape(polygon.getBoundingRect(), seriesModel, function() {
              polygon.removeClipPath();
            }));
          } else {
            var layerGroup = oldLayersGroups[oldIdx];
            polygon = layerGroup.childAt(0);
            text = layerGroup.childAt(1);
            group.add(layerGroup);
            newLayersGroups[idx] = layerGroup;
            graphic.updateProps(polygon, {
              shape: {
                points: points0,
                stackedOnPoints: points1
              }
            }, seriesModel);
            graphic.updateProps(text, {
              style: {
                x: textLayout.x - margin,
                y: textLayout.y0 + textLayout.y / 2
              }
            }, seriesModel);
          }
          var hoverItemStyleModel = itemModel.getModel("emphasis.itemStyle");
          var itemStyleModel = itemModel.getModel("itemStyle");
          graphic.setTextStyle(text.style, labelModel, {
            text: labelModel.get("show") ? seriesModel.getFormattedLabel(indices[j - 1], "normal") || data.getName(indices[j - 1]) : null,
            textVerticalAlign: "middle"
          });
          polygon.setStyle(extend({
            fill: color
          }, itemStyleModel.getItemStyle(["color"])));
          graphic.setHoverStyle(polygon, hoverItemStyleModel.getItemStyle());
        }
        this._layersSeries = layerSeries;
        this._layers = newLayersGroups;
      },
      dispose: function() {
      }
    });
    function createGridClipShape(rect, seriesModel, cb) {
      var rectEl = new graphic.Rect({
        shape: {
          x: rect.x - 10,
          y: rect.y - 10,
          width: 0,
          height: rect.height + 20
        }
      });
      graphic.initProps(rectEl, {
        shape: {
          width: rect.width + 20,
          height: rect.height + 20
        }
      }, seriesModel, cb);
      return rectEl;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js
var require_themeRiverLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverLayout.js"(exports, module) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    function _default(ecModel, api) {
      ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
        var data = seriesModel.getData();
        var single = seriesModel.coordinateSystem;
        var layoutInfo = {};
        var rect = single.getRect();
        layoutInfo.rect = rect;
        var boundaryGap = seriesModel.get("boundaryGap");
        var axis = single.getAxis();
        layoutInfo.boundaryGap = boundaryGap;
        if (axis.orient === "horizontal") {
          boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.height);
          boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.height);
          var height = rect.height - boundaryGap[0] - boundaryGap[1];
          themeRiverLayout(data, seriesModel, height);
        } else {
          boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.width);
          boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.width);
          var width = rect.width - boundaryGap[0] - boundaryGap[1];
          themeRiverLayout(data, seriesModel, width);
        }
        data.setLayout("layoutInfo", layoutInfo);
      });
    }
    function themeRiverLayout(data, seriesModel, height) {
      if (!data.count()) {
        return;
      }
      var coordSys = seriesModel.coordinateSystem;
      var layerSeries = seriesModel.getLayerSeries();
      var timeDim = data.mapDimension("single");
      var valueDim = data.mapDimension("value");
      var layerPoints = zrUtil.map(layerSeries, function(singleLayer) {
        return zrUtil.map(singleLayer.indices, function(idx) {
          var pt = coordSys.dataToPoint(data.get(timeDim, idx));
          pt[1] = data.get(valueDim, idx);
          return pt;
        });
      });
      var base = computeBaseline(layerPoints);
      var baseLine = base.y0;
      var ky = height / base.max;
      var n = layerSeries.length;
      var m = layerSeries[0].indices.length;
      var baseY0;
      for (var j = 0; j < m; ++j) {
        baseY0 = baseLine[j] * ky;
        data.setItemLayout(layerSeries[0].indices[j], {
          layerIndex: 0,
          x: layerPoints[0][j][0],
          y0: baseY0,
          y: layerPoints[0][j][1] * ky
        });
        for (var i = 1; i < n; ++i) {
          baseY0 += layerPoints[i - 1][j][1] * ky;
          data.setItemLayout(layerSeries[i].indices[j], {
            layerIndex: i,
            x: layerPoints[i][j][0],
            y0: baseY0,
            y: layerPoints[i][j][1] * ky
          });
        }
      }
    }
    function computeBaseline(data) {
      var layerNum = data.length;
      var pointNum = data[0].length;
      var sums = [];
      var y0 = [];
      var max = 0;
      var temp;
      var base = {};
      for (var i = 0; i < pointNum; ++i) {
        for (var j = 0, temp = 0; j < layerNum; ++j) {
          temp += data[j][i][1];
        }
        if (temp > max) {
          max = temp;
        }
        sums.push(temp);
      }
      for (var k = 0; k < pointNum; ++k) {
        y0[k] = (max - sums[k]) / 2;
      }
      max = 0;
      for (var l = 0; l < pointNum; ++l) {
        var sum = sums[l] + y0[l];
        if (sum > max) {
          max = sum;
        }
      }
      base.y0 = y0;
      base.max = max;
      return base;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverVisual.js
var require_themeRiverVisual = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver/themeRiverVisual.js"(exports, module) {
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    function _default(ecModel) {
      ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
        var data = seriesModel.getData();
        var rawData = seriesModel.getRawData();
        var colorList = seriesModel.get("color");
        var idxMap = createHashMap();
        data.each(function(idx) {
          idxMap.set(data.getRawIndex(idx), idx);
        });
        rawData.each(function(rawIndex) {
          var name2 = rawData.getName(rawIndex);
          var color = colorList[(seriesModel.nameMap.get(name2) - 1) % colorList.length];
          rawData.setItemVisual(rawIndex, "color", color);
          var idx = idxMap.get(rawIndex);
          if (idx != null) {
            data.setItemVisual(idx, "color", color);
          }
        });
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver.js
var require_themeRiver = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/themeRiver.js"() {
    var echarts = require_echarts();
    require_singleAxis();
    require_ThemeRiverSeries();
    require_ThemeRiverView();
    var themeRiverLayout = require_themeRiverLayout();
    var themeRiverVisual = require_themeRiverVisual();
    var dataFilter = require_dataFilter();
    echarts.registerLayout(themeRiverLayout);
    echarts.registerVisual(themeRiverVisual);
    echarts.registerProcessor(dataFilter("themeRiver"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstSeries.js
var require_SunburstSeries = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstSeries.js"(exports, module) {
    var zrUtil = require_util();
    var SeriesModel = require_Series();
    var Tree = require_Tree();
    var Model = require_Model();
    var _treeHelper = require_treeHelper();
    var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
    var _default = SeriesModel.extend({
      type: "series.sunburst",
      /**
       * @type {module:echarts/data/Tree~Node}
       */
      _viewRoot: null,
      getInitialData: function(option, ecModel) {
        var root = {
          name: option.name,
          children: option.data
        };
        completeTreeValue(root);
        var levelModels = zrUtil.map(option.levels || [], function(levelDefine) {
          return new Model(levelDefine, this, ecModel);
        }, this);
        var tree = Tree.createTree(root, this, beforeLink);
        function beforeLink(nodeData) {
          nodeData.wrapMethod("getItemModel", function(model, idx) {
            var node = tree.getNodeByDataIndex(idx);
            var levelModel = levelModels[node.depth];
            levelModel && (model.parentModel = levelModel);
            return model;
          });
        }
        return tree.data;
      },
      optionUpdated: function() {
        this.resetViewRoot();
      },
      /*
       * @override
       */
      getDataParams: function(dataIndex) {
        var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
        var node = this.getData().tree.getNodeByDataIndex(dataIndex);
        params.treePathInfo = wrapTreePathInfo(node, this);
        return params;
      },
      defaultOption: {
        zlevel: 0,
        z: 2,
        // 默认全局居中
        center: ["50%", "50%"],
        radius: [0, "75%"],
        // 默认顺时针
        clockwise: true,
        startAngle: 90,
        // 最小角度改为0
        minAngle: 0,
        percentPrecision: 2,
        // If still show when all data zero.
        stillShowZeroSum: true,
        // Policy of highlighting pieces when hover on one
        // Valid values: 'none' (for not downplay others), 'descendant',
        // 'ancestor', 'self'
        highlightPolicy: "descendant",
        // 'rootToNode', 'link', or false
        nodeClick: "rootToNode",
        renderLabelForZeroData: false,
        label: {
          // could be: 'radial', 'tangential', or 'none'
          rotate: "radial",
          show: true,
          opacity: 1,
          // 'left' is for inner side of inside, and 'right' is for outter
          // side for inside
          align: "center",
          position: "inside",
          distance: 5,
          silent: true
        },
        itemStyle: {
          borderWidth: 1,
          borderColor: "white",
          borderType: "solid",
          shadowBlur: 0,
          shadowColor: "rgba(0, 0, 0, 0.2)",
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        },
        highlight: {
          itemStyle: {
            opacity: 1
          }
        },
        downplay: {
          itemStyle: {
            opacity: 0.5
          },
          label: {
            opacity: 0.6
          }
        },
        // Animation type canbe expansion, scale
        animationType: "expansion",
        animationDuration: 1e3,
        animationDurationUpdate: 500,
        animationEasing: "cubicOut",
        data: [],
        levels: [],
        /**
         * Sort order.
         *
         * Valid values: 'desc', 'asc', null, or callback function.
         * 'desc' and 'asc' for descend and ascendant order;
         * null for not sorting;
         * example of callback function:
         * function(nodeA, nodeB) {
         *     return nodeA.getValue() - nodeB.getValue();
         * }
         */
        sort: "desc"
      },
      getViewRoot: function() {
        return this._viewRoot;
      },
      /**
       * @param {module:echarts/data/Tree~Node} [viewRoot]
       */
      resetViewRoot: function(viewRoot) {
        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
        var root = this.getRawData().tree.root;
        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
          this._viewRoot = root;
        }
      }
    });
    function completeTreeValue(dataNode) {
      var sum = 0;
      zrUtil.each(dataNode.children, function(child) {
        completeTreeValue(child);
        var childValue = child.value;
        zrUtil.isArray(childValue) && (childValue = childValue[0]);
        sum += childValue;
      });
      var thisValue = dataNode.value;
      if (zrUtil.isArray(thisValue)) {
        thisValue = thisValue[0];
      }
      if (thisValue == null || isNaN(thisValue)) {
        thisValue = sum;
      }
      if (thisValue < 0) {
        thisValue = 0;
      }
      zrUtil.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstPiece.js
var require_SunburstPiece = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstPiece.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var NodeHighlightPolicy = {
      NONE: "none",
      // not downplay others
      DESCENDANT: "descendant",
      ANCESTOR: "ancestor",
      SELF: "self"
    };
    var DEFAULT_SECTOR_Z = 2;
    var DEFAULT_TEXT_Z = 4;
    function SunburstPiece(node, seriesModel, ecModel) {
      graphic.Group.call(this);
      var sector = new graphic.Sector({
        z2: DEFAULT_SECTOR_Z
      });
      sector.seriesIndex = seriesModel.seriesIndex;
      var text = new graphic.Text({
        z2: DEFAULT_TEXT_Z,
        silent: node.getModel("label").get("silent")
      });
      this.add(sector);
      this.add(text);
      this.updateData(true, node, "normal", seriesModel, ecModel);
      function onEmphasis() {
        text.ignore = text.hoverIgnore;
      }
      function onNormal() {
        text.ignore = text.normalIgnore;
      }
      this.on("emphasis", onEmphasis).on("normal", onNormal).on("mouseover", onEmphasis).on("mouseout", onNormal);
    }
    var SunburstPieceProto = SunburstPiece.prototype;
    SunburstPieceProto.updateData = function(firstCreate, node, state, seriesModel, ecModel) {
      this.node = node;
      node.piece = this;
      seriesModel = seriesModel || this._seriesModel;
      ecModel = ecModel || this._ecModel;
      var sector = this.childAt(0);
      sector.dataIndex = node.dataIndex;
      var itemModel = node.getModel();
      var layout = node.getLayout();
      var sectorShape = zrUtil.extend({}, layout);
      sectorShape.label = null;
      var visualColor = getNodeColor(node, seriesModel, ecModel);
      fillDefaultColor(node, seriesModel, visualColor);
      var normalStyle = itemModel.getModel("itemStyle").getItemStyle();
      var style;
      if (state === "normal") {
        style = normalStyle;
      } else {
        var stateStyle = itemModel.getModel(state + ".itemStyle").getItemStyle();
        style = zrUtil.merge(stateStyle, normalStyle);
      }
      style = zrUtil.defaults({
        lineJoin: "bevel",
        fill: style.fill || visualColor
      }, style);
      if (firstCreate) {
        sector.setShape(sectorShape);
        sector.shape.r = layout.r0;
        graphic.updateProps(sector, {
          shape: {
            r: layout.r
          }
        }, seriesModel, node.dataIndex);
        sector.useStyle(style);
      } else if (typeof style.fill === "object" && style.fill.type || typeof sector.style.fill === "object" && sector.style.fill.type) {
        graphic.updateProps(sector, {
          shape: sectorShape
        }, seriesModel);
        sector.useStyle(style);
      } else {
        graphic.updateProps(sector, {
          shape: sectorShape,
          style
        }, seriesModel);
      }
      this._updateLabel(seriesModel, visualColor, state);
      var cursorStyle = itemModel.getShallow("cursor");
      cursorStyle && sector.attr("cursor", cursorStyle);
      if (firstCreate) {
        var highlightPolicy = seriesModel.getShallow("highlightPolicy");
        this._initEvents(sector, node, seriesModel, highlightPolicy);
      }
      this._seriesModel = seriesModel || this._seriesModel;
      this._ecModel = ecModel || this._ecModel;
      graphic.setHoverStyle(this);
    };
    SunburstPieceProto.onEmphasis = function(highlightPolicy) {
      var that = this;
      this.node.hostTree.root.eachNode(function(n) {
        if (n.piece) {
          if (that.node === n) {
            n.piece.updateData(false, n, "emphasis");
          } else if (isNodeHighlighted(n, that.node, highlightPolicy)) {
            n.piece.childAt(0).trigger("highlight");
          } else if (highlightPolicy !== NodeHighlightPolicy.NONE) {
            n.piece.childAt(0).trigger("downplay");
          }
        }
      });
    };
    SunburstPieceProto.onNormal = function() {
      this.node.hostTree.root.eachNode(function(n) {
        if (n.piece) {
          n.piece.updateData(false, n, "normal");
        }
      });
    };
    SunburstPieceProto.onHighlight = function() {
      this.updateData(false, this.node, "highlight");
    };
    SunburstPieceProto.onDownplay = function() {
      this.updateData(false, this.node, "downplay");
    };
    SunburstPieceProto._updateLabel = function(seriesModel, visualColor, state) {
      var itemModel = this.node.getModel();
      var normalModel = itemModel.getModel("label");
      var labelModel = state === "normal" || state === "emphasis" ? normalModel : itemModel.getModel(state + ".label");
      var labelHoverModel = itemModel.getModel("emphasis.label");
      var labelFormatter = labelModel.get("formatter");
      var labelState = labelFormatter ? state : "normal";
      var text = zrUtil.retrieve(seriesModel.getFormattedLabel(this.node.dataIndex, labelState, null, null, "label"), this.node.name);
      if (getLabelAttr("show") === false) {
        text = "";
      }
      var layout = this.node.getLayout();
      var labelMinAngle = labelModel.get("minAngle");
      if (labelMinAngle == null) {
        labelMinAngle = normalModel.get("minAngle");
      }
      labelMinAngle = labelMinAngle / 180 * Math.PI;
      var angle = layout.endAngle - layout.startAngle;
      if (labelMinAngle != null && Math.abs(angle) < labelMinAngle) {
        text = "";
      }
      var label = this.childAt(1);
      graphic.setLabelStyle(label.style, label.hoverStyle || {}, normalModel, labelHoverModel, {
        defaultText: labelModel.getShallow("show") ? text : null,
        autoColor: visualColor,
        useInsideStyle: true
      });
      var midAngle = (layout.startAngle + layout.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var r;
      var labelPosition = getLabelAttr("position");
      var labelPadding = getLabelAttr("distance") || 0;
      var textAlign = getLabelAttr("align");
      if (labelPosition === "outside") {
        r = layout.r + labelPadding;
        textAlign = midAngle > Math.PI / 2 ? "right" : "left";
      } else {
        if (!textAlign || textAlign === "center") {
          r = (layout.r + layout.r0) / 2;
          textAlign = "center";
        } else if (textAlign === "left") {
          r = layout.r0 + labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "right";
          }
        } else if (textAlign === "right") {
          r = layout.r - labelPadding;
          if (midAngle > Math.PI / 2) {
            textAlign = "left";
          }
        }
      }
      label.attr("style", {
        text,
        textAlign,
        textVerticalAlign: getLabelAttr("verticalAlign") || "middle",
        opacity: getLabelAttr("opacity")
      });
      var textX = r * dx + layout.cx;
      var textY = r * dy + layout.cy;
      label.attr("position", [textX, textY]);
      var rotateType = getLabelAttr("rotate");
      var rotate = 0;
      if (rotateType === "radial") {
        rotate = -midAngle;
        if (rotate < -Math.PI / 2) {
          rotate += Math.PI;
        }
      } else if (rotateType === "tangential") {
        rotate = Math.PI / 2 - midAngle;
        if (rotate > Math.PI / 2) {
          rotate -= Math.PI;
        } else if (rotate < -Math.PI / 2) {
          rotate += Math.PI;
        }
      } else if (typeof rotateType === "number") {
        rotate = rotateType * Math.PI / 180;
      }
      label.attr("rotation", rotate);
      function getLabelAttr(name2) {
        var stateAttr = labelModel.get(name2);
        if (stateAttr == null) {
          return normalModel.get(name2);
        } else {
          return stateAttr;
        }
      }
    };
    SunburstPieceProto._initEvents = function(sector, node, seriesModel, highlightPolicy) {
      sector.off("mouseover").off("mouseout").off("emphasis").off("normal");
      var that = this;
      var onEmphasis = function() {
        that.onEmphasis(highlightPolicy);
      };
      var onNormal = function() {
        that.onNormal();
      };
      var onDownplay = function() {
        that.onDownplay();
      };
      var onHighlight = function() {
        that.onHighlight();
      };
      if (seriesModel.isAnimationEnabled()) {
        sector.on("mouseover", onEmphasis).on("mouseout", onNormal).on("emphasis", onEmphasis).on("normal", onNormal).on("downplay", onDownplay).on("highlight", onHighlight);
      }
    };
    zrUtil.inherits(SunburstPiece, graphic.Group);
    var _default = SunburstPiece;
    function getNodeColor(node, seriesModel, ecModel) {
      var visualColor = node.getVisual("color");
      var visualMetaList = node.getVisual("visualMeta");
      if (!visualMetaList || visualMetaList.length === 0) {
        visualColor = null;
      }
      var color = node.getModel("itemStyle").get("color");
      if (color) {
        return color;
      } else if (visualColor) {
        return visualColor;
      } else if (node.depth === 0) {
        return ecModel.option.color[0];
      } else {
        var length = ecModel.option.color.length;
        color = ecModel.option.color[getRootId(node) % length];
      }
      return color;
    }
    function getRootId(node) {
      var ancestor = node;
      while (ancestor.depth > 1) {
        ancestor = ancestor.parentNode;
      }
      var virtualRoot = node.getAncestors()[0];
      return zrUtil.indexOf(virtualRoot.children, ancestor);
    }
    function isNodeHighlighted(node, activeNode, policy) {
      if (policy === NodeHighlightPolicy.NONE) {
        return false;
      } else if (policy === NodeHighlightPolicy.SELF) {
        return node === activeNode;
      } else if (policy === NodeHighlightPolicy.ANCESTOR) {
        return node === activeNode || node.isAncestorOf(activeNode);
      } else {
        return node === activeNode || node.isDescendantOf(activeNode);
      }
    }
    function fillDefaultColor(node, seriesModel, color) {
      var data = seriesModel.getData();
      data.setItemVisual(node.dataIndex, "color", color);
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstView.js
var require_SunburstView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/SunburstView.js"(exports, module) {
    var zrUtil = require_util();
    var ChartView = require_Chart();
    var SunburstPiece = require_SunburstPiece();
    var DataDiffer = require_DataDiffer();
    var _format = require_format();
    var windowOpen = _format.windowOpen;
    var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
    var SunburstView = ChartView.extend({
      type: "sunburst",
      init: function() {
      },
      render: function(seriesModel, ecModel, api, payload) {
        var that = this;
        this.seriesModel = seriesModel;
        this.api = api;
        this.ecModel = ecModel;
        var data = seriesModel.getData();
        var virtualRoot = data.tree.root;
        var newRoot = seriesModel.getViewRoot();
        var group = this.group;
        var renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
        var newChildren = [];
        newRoot.eachNode(function(node) {
          newChildren.push(node);
        });
        var oldChildren = this._oldChildren || [];
        dualTravel(newChildren, oldChildren);
        renderRollUp(virtualRoot, newRoot);
        if (payload && payload.highlight && payload.highlight.piece) {
          var highlightPolicy = seriesModel.getShallow("highlightPolicy");
          payload.highlight.piece.onEmphasis(highlightPolicy);
        } else if (payload && payload.unhighlight) {
          var piece = this.virtualPiece;
          if (!piece && virtualRoot.children.length) {
            piece = virtualRoot.children[0].piece;
          }
          if (piece) {
            piece.onNormal();
          }
        }
        this._initEvents();
        this._oldChildren = newChildren;
        function dualTravel(newChildren2, oldChildren2) {
          if (newChildren2.length === 0 && oldChildren2.length === 0) {
            return;
          }
          new DataDiffer(oldChildren2, newChildren2, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();
          function getKey(node) {
            return node.getId();
          }
          function processNode(newId, oldId) {
            var newNode = newId == null ? null : newChildren2[newId];
            var oldNode = oldId == null ? null : oldChildren2[oldId];
            doRenderNode(newNode, oldNode);
          }
        }
        function doRenderNode(newNode, oldNode) {
          if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
            newNode = null;
          }
          if (newNode !== virtualRoot && oldNode !== virtualRoot) {
            if (oldNode && oldNode.piece) {
              if (newNode) {
                oldNode.piece.updateData(false, newNode, "normal", seriesModel, ecModel);
                data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
              } else {
                removeNode(oldNode);
              }
            } else if (newNode) {
              var piece2 = new SunburstPiece(newNode, seriesModel, ecModel);
              group.add(piece2);
              data.setItemGraphicEl(newNode.dataIndex, piece2);
            }
          }
        }
        function removeNode(node) {
          if (!node) {
            return;
          }
          if (node.piece) {
            group.remove(node.piece);
            node.piece = null;
          }
        }
        function renderRollUp(virtualRoot2, viewRoot) {
          if (viewRoot.depth > 0) {
            if (that.virtualPiece) {
              that.virtualPiece.updateData(false, virtualRoot2, "normal", seriesModel, ecModel);
            } else {
              that.virtualPiece = new SunburstPiece(virtualRoot2, seriesModel, ecModel);
              group.add(that.virtualPiece);
            }
            if (viewRoot.piece._onclickEvent) {
              viewRoot.piece.off("click", viewRoot.piece._onclickEvent);
            }
            var event = function(e) {
              that._rootToNode(viewRoot.parentNode);
            };
            viewRoot.piece._onclickEvent = event;
            that.virtualPiece.on("click", event);
          } else if (that.virtualPiece) {
            group.remove(that.virtualPiece);
            that.virtualPiece = null;
          }
        }
      },
      dispose: function() {
      },
      /**
       * @private
       */
      _initEvents: function() {
        var that = this;
        var event = function(e) {
          var targetFound = false;
          var viewRoot = that.seriesModel.getViewRoot();
          viewRoot.eachNode(function(node) {
            if (!targetFound && node.piece && node.piece.childAt(0) === e.target) {
              var nodeClick = node.getModel().get("nodeClick");
              if (nodeClick === "rootToNode") {
                that._rootToNode(node);
              } else if (nodeClick === "link") {
                var itemModel = node.getModel();
                var link = itemModel.get("link");
                if (link) {
                  var linkTarget = itemModel.get("target", true) || "_blank";
                  windowOpen(link, linkTarget);
                }
              }
              targetFound = true;
            }
          });
        };
        if (this.group._onclickEvent) {
          this.group.off("click", this.group._onclickEvent);
        }
        this.group.on("click", event);
        this.group._onclickEvent = event;
      },
      /**
       * @private
       */
      _rootToNode: function(node) {
        if (node !== this.seriesModel.getViewRoot()) {
          this.api.dispatchAction({
            type: ROOT_TO_NODE_ACTION,
            from: this.uid,
            seriesId: this.seriesModel.id,
            targetNode: node
          });
        }
      },
      /**
       * @implement
       */
      containPoint: function(point, seriesModel) {
        var treeRoot = seriesModel.getData();
        var itemLayout = treeRoot.getItemLayout(0);
        if (itemLayout) {
          var dx = point[0] - itemLayout.cx;
          var dy = point[1] - itemLayout.cy;
          var radius = Math.sqrt(dx * dx + dy * dy);
          return radius <= itemLayout.r && radius >= itemLayout.r0;
        }
      }
    });
    var _default = SunburstView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstAction.js
var require_sunburstAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstAction.js"() {
    var echarts = require_echarts();
    var helper = require_treeHelper();
    var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
    echarts.registerAction({
      type: ROOT_TO_NODE_ACTION,
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleRootToNode);
      function handleRootToNode(model, index) {
        var targetInfo = helper.retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
        if (targetInfo) {
          var originViewRoot = model.getViewRoot();
          if (originViewRoot) {
            payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
          }
          model.resetViewRoot(targetInfo.node);
        }
      }
    });
    var HIGHLIGHT_ACTION = "sunburstHighlight";
    echarts.registerAction({
      type: HIGHLIGHT_ACTION,
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleHighlight);
      function handleHighlight(model, index) {
        var targetInfo = helper.retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
        if (targetInfo) {
          payload.highlight = targetInfo.node;
        }
      }
    });
    var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
    echarts.registerAction({
      type: UNHIGHLIGHT_ACTION,
      update: "updateView"
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "series",
        subType: "sunburst",
        query: payload
      }, handleUnhighlight);
      function handleUnhighlight(model, index) {
        payload.unhighlight = true;
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstLayout.js
var require_sunburstLayout = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst/sunburstLayout.js"(exports, module) {
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var zrUtil = require_util();
    var RADIAN = Math.PI / 180;
    function _default(seriesType, ecModel, api, payload) {
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        var center = seriesModel.get("center");
        var radius = seriesModel.get("radius");
        if (!zrUtil.isArray(radius)) {
          radius = [0, radius];
        }
        if (!zrUtil.isArray(center)) {
          center = [center, center];
        }
        var width = api.getWidth();
        var height = api.getHeight();
        var size = Math.min(width, height);
        var cx = parsePercent(center[0], width);
        var cy = parsePercent(center[1], height);
        var r0 = parsePercent(radius[0], size / 2);
        var r = parsePercent(radius[1], size / 2);
        var startAngle = -seriesModel.get("startAngle") * RADIAN;
        var minAngle = seriesModel.get("minAngle") * RADIAN;
        var virtualRoot = seriesModel.getData().tree.root;
        var treeRoot = seriesModel.getViewRoot();
        var rootDepth = treeRoot.depth;
        var sort2 = seriesModel.get("sort");
        if (sort2 != null) {
          initChildren(treeRoot, sort2);
        }
        var validDataCount = 0;
        zrUtil.each(treeRoot.children, function(child) {
          !isNaN(child.getValue()) && validDataCount++;
        });
        var sum = treeRoot.getValue();
        var unitRadian = Math.PI / (sum || validDataCount) * 2;
        var renderRollupNode = treeRoot.depth > 0;
        var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
        var rPerLevel = (r - r0) / (levels || 1);
        var clockwise = seriesModel.get("clockwise");
        var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
        var dir = clockwise ? 1 : -1;
        var renderNode = function(node, startAngle2) {
          if (!node) {
            return;
          }
          var endAngle = startAngle2;
          if (node !== virtualRoot) {
            var value = node.getValue();
            var angle2 = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
            if (angle2 < minAngle) {
              angle2 = minAngle;
            }
            endAngle = startAngle2 + dir * angle2;
            var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
            var rStart2 = r0 + rPerLevel * depth;
            var rEnd2 = r0 + rPerLevel * (depth + 1);
            var itemModel = node.getModel();
            if (itemModel.get("r0") != null) {
              rStart2 = parsePercent(itemModel.get("r0"), size / 2);
            }
            if (itemModel.get("r") != null) {
              rEnd2 = parsePercent(itemModel.get("r"), size / 2);
            }
            node.setLayout({
              angle: angle2,
              startAngle: startAngle2,
              endAngle,
              clockwise,
              cx,
              cy,
              r0: rStart2,
              r: rEnd2
            });
          }
          if (node.children && node.children.length) {
            var siblingAngle = 0;
            zrUtil.each(node.children, function(node2) {
              siblingAngle += renderNode(node2, startAngle2 + siblingAngle);
            });
          }
          return endAngle - startAngle2;
        };
        if (renderRollupNode) {
          var rStart = r0;
          var rEnd = r0 + rPerLevel;
          var angle = Math.PI * 2;
          virtualRoot.setLayout({
            angle,
            startAngle,
            endAngle: startAngle + angle,
            clockwise,
            cx,
            cy,
            r0: rStart,
            r: rEnd
          });
        }
        renderNode(treeRoot, startAngle);
      });
    }
    function initChildren(node, isAsc) {
      var children = node.children || [];
      node.children = sort(children, isAsc);
      if (children.length) {
        zrUtil.each(node.children, function(child) {
          initChildren(child, isAsc);
        });
      }
    }
    function sort(children, sortOrder) {
      if (typeof sortOrder === "function") {
        return children.sort(sortOrder);
      } else {
        var isAsc = sortOrder === "asc";
        return children.sort(function(a, b) {
          var diff = (a.getValue() - b.getValue()) * (isAsc ? 1 : -1);
          return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc ? -1 : 1) : diff;
        });
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst.js
var require_sunburst = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/sunburst.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_SunburstSeries();
    require_SunburstView();
    require_sunburstAction();
    var dataColor = require_dataColor();
    var sunburstLayout = require_sunburstLayout();
    var dataFilter = require_dataFilter();
    echarts.registerVisual(zrUtil.curry(dataColor, "sunburst"));
    echarts.registerLayout(zrUtil.curry(sunburstLayout, "sunburst"));
    echarts.registerProcessor(zrUtil.curry(dataFilter, "sunburst"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/prepareCustom.js
var require_prepareCustom = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/cartesian/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      dataItem = dataItem || [0, 0];
      return zrUtil.map(["x", "y"], function(dim, dimIdx) {
        var axis = this.getAxis(dim);
        var val = dataItem[dimIdx];
        var halfSize = dataSize[dimIdx] / 2;
        return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
      }, this);
    }
    function _default(coordSys) {
      var rect = coordSys.grid.getRect();
      return {
        coordSys: {
          // The name exposed to user is always 'cartesian2d' but not 'grid'.
          type: "cartesian2d",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        },
        api: {
          coord: function(data) {
            return coordSys.dataToPoint(data);
          },
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/prepareCustom.js
var require_prepareCustom2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      dataItem = dataItem || [0, 0];
      return zrUtil.map([0, 1], function(dimIdx) {
        var val = dataItem[dimIdx];
        var halfSize = dataSize[dimIdx] / 2;
        var p1 = [];
        var p2 = [];
        p1[dimIdx] = val - halfSize;
        p2[dimIdx] = val + halfSize;
        p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
        return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
      }, this);
    }
    function _default(coordSys) {
      var rect = coordSys.getBoundingRect();
      return {
        coordSys: {
          type: "geo",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          zoom: coordSys.getZoom()
        },
        api: {
          coord: function(data) {
            return coordSys.dataToPoint(data);
          },
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/prepareCustom.js
var require_prepareCustom3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/single/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      var axis = this.getAxis();
      var val = dataItem instanceof Array ? dataItem[0] : dataItem;
      var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
      return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    }
    function _default(coordSys) {
      var rect = coordSys.getRect();
      return {
        coordSys: {
          type: "singleAxis",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        },
        api: {
          coord: function(val) {
            return coordSys.dataToPoint(val);
          },
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/prepareCustom.js
var require_prepareCustom4 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/prepareCustom.js"(exports, module) {
    var zrUtil = require_util();
    function dataToCoordSize(dataSize, dataItem) {
      return zrUtil.map(["Radius", "Angle"], function(dim, dimIdx) {
        var axis = this["get" + dim + "Axis"]();
        var val = dataItem[dimIdx];
        var halfSize = dataSize[dimIdx] / 2;
        var method = "dataTo" + dim;
        var result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis[method](val - halfSize) - axis[method](val + halfSize));
        if (dim === "Angle") {
          result = result * Math.PI / 180;
        }
        return result;
      }, this);
    }
    function _default(coordSys) {
      var radiusAxis = coordSys.getRadiusAxis();
      var angleAxis = coordSys.getAngleAxis();
      var radius = radiusAxis.getExtent();
      radius[0] > radius[1] && radius.reverse();
      return {
        coordSys: {
          type: "polar",
          cx: coordSys.cx,
          cy: coordSys.cy,
          r: radius[1],
          r0: radius[0]
        },
        api: {
          coord: zrUtil.bind(function(data) {
            var radius2 = radiusAxis.dataToRadius(data[0]);
            var angle = angleAxis.dataToAngle(data[1]);
            var coord = coordSys.coordToPoint([radius2, angle]);
            coord.push(radius2, angle * Math.PI / 180);
            return coord;
          }),
          size: zrUtil.bind(dataToCoordSize, coordSys)
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/prepareCustom.js
var require_prepareCustom5 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/prepareCustom.js"(exports, module) {
    function _default(coordSys) {
      var rect = coordSys.getRect();
      var rangeInfo = coordSys.getRangeInfo();
      return {
        coordSys: {
          type: "calendar",
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height,
          cellWidth: coordSys.getCellWidth(),
          cellHeight: coordSys.getCellHeight(),
          rangeInfo: {
            start: rangeInfo.start,
            end: rangeInfo.end,
            weeks: rangeInfo.weeks,
            dayCount: rangeInfo.allDay
          }
        },
        api: {
          coord: function(data, clamp) {
            return coordSys.dataToPoint(data, clamp);
          }
        }
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/custom.js
var require_custom = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/chart/custom.js"() {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var graphicUtil = require_graphic();
    var _labelHelper = require_labelHelper();
    var getDefaultLabel = _labelHelper.getDefaultLabel;
    var createListFromArray = require_createListFromArray();
    var _barGrid = require_barGrid();
    var getLayoutOnAxis = _barGrid.getLayoutOnAxis;
    var DataDiffer = require_DataDiffer();
    var SeriesModel = require_Series();
    var Model = require_Model();
    var ChartView = require_Chart();
    var _createClipPathFromCoordSys = require_createClipPathFromCoordSys();
    var createClipPath = _createClipPathFromCoordSys.createClipPath;
    var prepareCartesian2d = require_prepareCustom();
    var prepareGeo = require_prepareCustom2();
    var prepareSingleAxis = require_prepareCustom3();
    var preparePolar = require_prepareCustom4();
    var prepareCalendar = require_prepareCustom5();
    var CACHED_LABEL_STYLE_PROPERTIES = graphicUtil.CACHED_LABEL_STYLE_PROPERTIES;
    var ITEM_STYLE_NORMAL_PATH = ["itemStyle"];
    var ITEM_STYLE_EMPHASIS_PATH = ["emphasis", "itemStyle"];
    var LABEL_NORMAL = ["label"];
    var LABEL_EMPHASIS = ["emphasis", "label"];
    var GROUP_DIFF_PREFIX = "e\0\0";
    var prepareCustoms = {
      cartesian2d: prepareCartesian2d,
      geo: prepareGeo,
      singleAxis: prepareSingleAxis,
      polar: preparePolar,
      calendar: prepareCalendar
    };
    SeriesModel.extend({
      type: "series.custom",
      dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
      defaultOption: {
        coordinateSystem: "cartesian2d",
        // Can be set as 'none'
        zlevel: 0,
        z: 2,
        legendHoverLink: true,
        useTransform: true,
        // Custom series will not clip by default.
        // Some case will use custom series to draw label
        // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
        // Only works on polar and cartesian2d coordinate system.
        clip: false
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Polar coordinate system
        // polarIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,
        // label: {}
        // itemStyle: {}
      },
      /**
       * @override
       */
      getInitialData: function(option, ecModel) {
        return createListFromArray(this.getSource(), this);
      },
      /**
       * @override
       */
      getDataParams: function(dataIndex, dataType, el) {
        var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
        el && (params.info = el.info);
        return params;
      }
    });
    ChartView.extend({
      type: "custom",
      /**
       * @private
       * @type {module:echarts/data/List}
       */
      _data: null,
      /**
       * @override
       */
      render: function(customSeries, ecModel, api, payload) {
        var oldData = this._data;
        var data = customSeries.getData();
        var group = this.group;
        var renderItem = makeRenderItem(customSeries, data, ecModel, api);
        data.diff(oldData).add(function(newIdx) {
          createOrUpdate(null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
        }).update(function(newIdx, oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          createOrUpdate(el, newIdx, renderItem(newIdx, payload), customSeries, group, data);
        }).remove(function(oldIdx) {
          var el = oldData.getItemGraphicEl(oldIdx);
          el && group.remove(el);
        }).execute();
        var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
        if (clipPath) {
          group.setClipPath(clipPath);
        } else {
          group.removeClipPath();
        }
        this._data = data;
      },
      incrementalPrepareRender: function(customSeries, ecModel, api) {
        this.group.removeAll();
        this._data = null;
      },
      incrementalRender: function(params, customSeries, ecModel, api, payload) {
        var data = customSeries.getData();
        var renderItem = makeRenderItem(customSeries, data, ecModel, api);
        function setIncrementalAndHoverLayer(el2) {
          if (!el2.isGroup) {
            el2.incremental = true;
            el2.useHoverLayer = true;
          }
        }
        for (var idx = params.start; idx < params.end; idx++) {
          var el = createOrUpdate(null, idx, renderItem(idx, payload), customSeries, this.group, data);
          el.traverse(setIncrementalAndHoverLayer);
        }
      },
      /**
       * @override
       */
      dispose: zrUtil.noop,
      /**
       * @override
       */
      filterForExposedEvent: function(eventType, query, targetEl, packedEvent) {
        var elementName = query.element;
        if (elementName == null || targetEl.name === elementName) {
          return true;
        }
        while ((targetEl = targetEl.parent) && targetEl !== this.group) {
          if (targetEl.name === elementName) {
            return true;
          }
        }
        return false;
      }
    });
    function createEl(elOption) {
      var graphicType = elOption.type;
      var el;
      if (graphicType === "path") {
        var shape = elOption.shape;
        var pathRect = shape.width != null && shape.height != null ? {
          x: shape.x || 0,
          y: shape.y || 0,
          width: shape.width,
          height: shape.height
        } : null;
        var pathData = getPathData(shape);
        el = graphicUtil.makePath(pathData, null, pathRect, shape.layout || "center");
        el.__customPathData = pathData;
      } else if (graphicType === "image") {
        el = new graphicUtil.Image({});
        el.__customImagePath = elOption.style.image;
      } else if (graphicType === "text") {
        el = new graphicUtil.Text({});
        el.__customText = elOption.style.text;
      } else if (graphicType === "group") {
        el = new graphicUtil.Group();
      } else if (graphicType === "compoundPath") {
        throw new Error('"compoundPath" is not supported yet.');
      } else {
        var Clz = graphicUtil.getShapeClass(graphicType);
        el = new Clz();
      }
      el.__customGraphicType = graphicType;
      el.name = elOption.name;
      return el;
    }
    function updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot) {
      var transitionProps = {};
      var elOptionStyle = elOption.style || {};
      elOption.shape && (transitionProps.shape = zrUtil.clone(elOption.shape));
      elOption.position && (transitionProps.position = elOption.position.slice());
      elOption.scale && (transitionProps.scale = elOption.scale.slice());
      elOption.origin && (transitionProps.origin = elOption.origin.slice());
      elOption.rotation && (transitionProps.rotation = elOption.rotation);
      if (el.type === "image" && elOption.style) {
        var targetStyle = transitionProps.style = {};
        zrUtil.each(["x", "y", "width", "height"], function(prop) {
          prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
        });
      }
      if (el.type === "text" && elOption.style) {
        var targetStyle = transitionProps.style = {};
        zrUtil.each(["x", "y"], function(prop) {
          prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
        });
        !elOptionStyle.hasOwnProperty("textFill") && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
        !elOptionStyle.hasOwnProperty("textStroke") && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
      }
      if (el.type !== "group") {
        el.useStyle(elOptionStyle);
        if (isInit) {
          el.style.opacity = 0;
          var targetOpacity = elOptionStyle.opacity;
          targetOpacity == null && (targetOpacity = 1);
          graphicUtil.initProps(el, {
            style: {
              opacity: targetOpacity
            }
          }, animatableModel, dataIndex);
        }
      }
      if (isInit) {
        el.attr(transitionProps);
      } else {
        graphicUtil.updateProps(el, transitionProps, animatableModel, dataIndex);
      }
      elOption.hasOwnProperty("z2") && el.attr("z2", elOption.z2 || 0);
      elOption.hasOwnProperty("silent") && el.attr("silent", elOption.silent);
      elOption.hasOwnProperty("invisible") && el.attr("invisible", elOption.invisible);
      elOption.hasOwnProperty("ignore") && el.attr("ignore", elOption.ignore);
      elOption.hasOwnProperty("info") && el.attr("info", elOption.info);
      var styleEmphasis = elOption.styleEmphasis;
      graphicUtil.setElementHoverStyle(el, styleEmphasis);
      if (isRoot) {
        graphicUtil.setAsHighDownDispatcher(el, styleEmphasis !== false);
      }
    }
    function prepareStyleTransition(prop, targetStyle, elOptionStyle, oldElStyle, isInit) {
      if (elOptionStyle[prop] != null && !isInit) {
        targetStyle[prop] = elOptionStyle[prop];
        elOptionStyle[prop] = oldElStyle[prop];
      }
    }
    function makeRenderItem(customSeries, data, ecModel, api) {
      var renderItem = customSeries.get("renderItem");
      var coordSys = customSeries.coordinateSystem;
      var prepareResult = {};
      if (coordSys) {
        prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms() : prepareCustoms[coordSys.type](coordSys);
      }
      var userAPI = zrUtil.defaults({
        getWidth: api.getWidth,
        getHeight: api.getHeight,
        getZr: api.getZr,
        getDevicePixelRatio: api.getDevicePixelRatio,
        value,
        style,
        styleEmphasis,
        visual,
        barLayout,
        currentSeriesIndices,
        font
      }, prepareResult.api || {});
      var userParams = {
        // The life cycle of context: current round of rendering.
        // The global life cycle is probably not necessary, because
        // user can store global status by themselves.
        context: {},
        seriesId: customSeries.id,
        seriesName: customSeries.name,
        seriesIndex: customSeries.seriesIndex,
        coordSys: prepareResult.coordSys,
        dataInsideLength: data.count(),
        encode: wrapEncodeDef(customSeries.getData())
      };
      var currDataIndexInside;
      var currDirty = true;
      var currItemModel;
      var currLabelNormalModel;
      var currLabelEmphasisModel;
      var currVisualColor;
      return function(dataIndexInside, payload) {
        currDataIndexInside = dataIndexInside;
        currDirty = true;
        return renderItem && renderItem(zrUtil.defaults({
          dataIndexInside,
          dataIndex: data.getRawIndex(dataIndexInside),
          // Can be used for optimization when zoom or roam.
          actionType: payload ? payload.type : null
        }, userParams), userAPI);
      };
      function updateCache(dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        if (currDirty) {
          currItemModel = data.getItemModel(dataIndexInside);
          currLabelNormalModel = currItemModel.getModel(LABEL_NORMAL);
          currLabelEmphasisModel = currItemModel.getModel(LABEL_EMPHASIS);
          currVisualColor = data.getItemVisual(dataIndexInside, "color");
          currDirty = false;
        }
      }
      function value(dim, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        return data.get(data.getDimension(dim || 0), dataIndexInside);
      }
      function style(extra, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        updateCache(dataIndexInside);
        var itemStyle = currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle();
        currVisualColor != null && (itemStyle.fill = currVisualColor);
        var opacity = data.getItemVisual(dataIndexInside, "opacity");
        opacity != null && (itemStyle.opacity = opacity);
        var labelModel = extra ? applyExtraBefore(extra, currLabelNormalModel) : currLabelNormalModel;
        graphicUtil.setTextStyle(itemStyle, labelModel, null, {
          autoColor: currVisualColor,
          isRectText: true
        });
        itemStyle.text = labelModel.getShallow("show") ? zrUtil.retrieve2(customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null;
        extra && applyExtraAfter(itemStyle, extra);
        return itemStyle;
      }
      function styleEmphasis(extra, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        updateCache(dataIndexInside);
        var itemStyle = currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle();
        var labelModel = extra ? applyExtraBefore(extra, currLabelEmphasisModel) : currLabelEmphasisModel;
        graphicUtil.setTextStyle(itemStyle, labelModel, null, {
          isRectText: true
        }, true);
        itemStyle.text = labelModel.getShallow("show") ? zrUtil.retrieve3(customSeries.getFormattedLabel(dataIndexInside, "emphasis"), customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null;
        extra && applyExtraAfter(itemStyle, extra);
        return itemStyle;
      }
      function visual(visualType, dataIndexInside) {
        dataIndexInside == null && (dataIndexInside = currDataIndexInside);
        return data.getItemVisual(dataIndexInside, visualType);
      }
      function barLayout(opt) {
        if (coordSys.getBaseAxis) {
          var baseAxis = coordSys.getBaseAxis();
          return getLayoutOnAxis(zrUtil.defaults({
            axis: baseAxis
          }, opt), api);
        }
      }
      function currentSeriesIndices() {
        return ecModel.getCurrentSeriesIndices();
      }
      function font(opt) {
        return graphicUtil.getFont(opt, ecModel);
      }
    }
    function wrapEncodeDef(data) {
      var encodeDef = {};
      zrUtil.each(data.dimensions, function(dimName, dataDimIndex) {
        var dimInfo = data.getDimensionInfo(dimName);
        if (!dimInfo.isExtraCoord) {
          var coordDim = dimInfo.coordDim;
          var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
          dataDims[dimInfo.coordDimIndex] = dataDimIndex;
        }
      });
      return encodeDef;
    }
    function createOrUpdate(el, dataIndex, elOption, animatableModel, group, data) {
      el = doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, true);
      el && data.setItemGraphicEl(dataIndex, el);
      return el;
    }
    function doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, isRoot) {
      var simplyRemove = !elOption;
      elOption = elOption || {};
      var elOptionType = elOption.type;
      var elOptionShape = elOption.shape;
      var elOptionStyle = elOption.style;
      if (el && (simplyRemove || elOptionType != null && elOptionType !== el.__customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== el.__customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== el.__customImagePath || elOptionType === "text" && hasOwn(elOptionShape, "text") && elOptionStyle.text !== el.__customText)) {
        group.remove(el);
        el = null;
      }
      if (simplyRemove) {
        return;
      }
      var isInit = !el;
      !el && (el = createEl(elOption));
      updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot);
      if (elOptionType === "group") {
        mergeChildren(el, dataIndex, elOption, animatableModel, data);
      }
      group.add(el);
      return el;
    }
    function mergeChildren(el, dataIndex, elOption, animatableModel, data) {
      var newChildren = elOption.children;
      var newLen = newChildren ? newChildren.length : 0;
      var mergeChildren2 = elOption.$mergeChildren;
      var byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
      var notMerge = mergeChildren2 === false;
      if (!newLen && !byName && !notMerge) {
        return;
      }
      if (byName) {
        diffGroupChildren({
          oldChildren: el.children() || [],
          newChildren: newChildren || [],
          dataIndex,
          animatableModel,
          group: el,
          data
        });
        return;
      }
      notMerge && el.removeAll();
      var index = 0;
      for (; index < newLen; index++) {
        newChildren[index] && doCreateOrUpdate(el.childAt(index), dataIndex, newChildren[index], animatableModel, el, data);
      }
    }
    function diffGroupChildren(context) {
      new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
    }
    function getKey(item, idx) {
      var name2 = item && item.name;
      return name2 != null ? name2 : GROUP_DIFF_PREFIX + idx;
    }
    function processAddUpdate(newIndex, oldIndex) {
      var context = this.context;
      var childOption = newIndex != null ? context.newChildren[newIndex] : null;
      var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
      doCreateOrUpdate(child, context.dataIndex, childOption, context.animatableModel, context.group, context.data);
    }
    function applyExtraBefore(extra, model) {
      var dummyModel = new Model({}, model);
      zrUtil.each(CACHED_LABEL_STYLE_PROPERTIES, function(stylePropName, modelPropName) {
        if (extra.hasOwnProperty(stylePropName)) {
          dummyModel.option[modelPropName] = extra[stylePropName];
        }
      });
      return dummyModel;
    }
    function applyExtraAfter(itemStyle, extra) {
      for (var key in extra) {
        if (extra.hasOwnProperty(key) || !CACHED_LABEL_STYLE_PROPERTIES.hasOwnProperty(key)) {
          itemStyle[key] = extra[key];
        }
      }
    }
    function processRemove(oldIndex) {
      var context = this.context;
      var child = context.oldChildren[oldIndex];
      child && context.group.remove(child);
    }
    function getPathData(shape) {
      return shape && (shape.pathData || shape.d);
    }
    function hasOwnPathData(shape) {
      return shape && (shape.hasOwnProperty("pathData") || shape.hasOwnProperty("d"));
    }
    function hasOwn(host, prop) {
      return host && host.hasOwnProperty(prop);
    }
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/grid.js
var require_grid = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/grid.js"() {
    require_gridSimple();
    require_CartesianAxisPointer();
    require_axisPointer();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/barPolar.js
var require_barPolar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/layout/barPolar.js"(exports, module) {
    var zrUtil = require_util();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    function getSeriesStackId(seriesModel) {
      return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
    }
    function getAxisKey(polar, axis) {
      return axis.dim + polar.model.componentIndex;
    }
    function barLayoutPolar(seriesType, ecModel, api) {
      var lastStackCoords = {};
      var barWidthAndOffset = calRadialBar(zrUtil.filter(ecModel.getSeriesByType(seriesType), function(seriesModel) {
        return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
      }));
      ecModel.eachSeriesByType(seriesType, function(seriesModel) {
        if (seriesModel.coordinateSystem.type !== "polar") {
          return;
        }
        var data = seriesModel.getData();
        var polar = seriesModel.coordinateSystem;
        var baseAxis = polar.getBaseAxis();
        var axisKey = getAxisKey(polar, baseAxis);
        var stackId = getSeriesStackId(seriesModel);
        var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
        var columnOffset = columnLayoutInfo.offset;
        var columnWidth = columnLayoutInfo.width;
        var valueAxis = polar.getOtherAxis(baseAxis);
        var cx = seriesModel.coordinateSystem.cx;
        var cy = seriesModel.coordinateSystem.cy;
        var barMinHeight = seriesModel.get("barMinHeight") || 0;
        var barMinAngle = seriesModel.get("barMinAngle") || 0;
        lastStackCoords[stackId] = lastStackCoords[stackId] || [];
        var valueDim = data.mapDimension(valueAxis.dim);
        var baseDim = data.mapDimension(baseAxis.dim);
        var stacked = isDimensionStacked(
          data,
          valueDim
          /*, baseDim*/
        );
        var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
        var valueAxisStart = valueAxis.dim === "radius" ? valueAxis.dataToRadius(0) : valueAxis.dataToAngle(0);
        for (var idx = 0, len = data.count(); idx < len; idx++) {
          var value = data.get(valueDim, idx);
          var baseValue = data.get(baseDim, idx);
          var sign = value >= 0 ? "p" : "n";
          var baseCoord = valueAxisStart;
          if (stacked) {
            if (!lastStackCoords[stackId][baseValue]) {
              lastStackCoords[stackId][baseValue] = {
                p: valueAxisStart,
                // Positive stack
                n: valueAxisStart
                // Negative stack
              };
            }
            baseCoord = lastStackCoords[stackId][baseValue][sign];
          }
          var r0;
          var r;
          var startAngle;
          var endAngle;
          if (valueAxis.dim === "radius") {
            var radiusSpan = valueAxis.dataToRadius(value) - valueAxisStart;
            var angle = baseAxis.dataToAngle(baseValue);
            if (Math.abs(radiusSpan) < barMinHeight) {
              radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
            }
            r0 = baseCoord;
            r = baseCoord + radiusSpan;
            startAngle = angle - columnOffset;
            endAngle = startAngle - columnWidth;
            stacked && (lastStackCoords[stackId][baseValue][sign] = r);
          } else {
            var angleSpan = valueAxis.dataToAngle(value, clampLayout) - valueAxisStart;
            var radius = baseAxis.dataToRadius(baseValue);
            if (Math.abs(angleSpan) < barMinAngle) {
              angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
            }
            r0 = radius + columnOffset;
            r = r0 + columnWidth;
            startAngle = baseCoord;
            endAngle = baseCoord + angleSpan;
            stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
          }
          data.setItemLayout(idx, {
            cx,
            cy,
            r0,
            r,
            // Consider that positive angle is anti-clockwise,
            // while positive radian of sector is clockwise
            startAngle: -startAngle * Math.PI / 180,
            endAngle: -endAngle * Math.PI / 180
          });
        }
      }, this);
    }
    function calRadialBar(barSeries, api) {
      var columnsMap = {};
      zrUtil.each(barSeries, function(seriesModel, idx) {
        var data = seriesModel.getData();
        var polar = seriesModel.coordinateSystem;
        var baseAxis = polar.getBaseAxis();
        var axisKey = getAxisKey(polar, baseAxis);
        var axisExtent = baseAxis.getExtent();
        var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
        var columnsOnAxis = columnsMap[axisKey] || {
          bandWidth,
          remainedWidth: bandWidth,
          autoWidthCount: 0,
          categoryGap: "20%",
          gap: "30%",
          stacks: {}
        };
        var stacks = columnsOnAxis.stacks;
        columnsMap[axisKey] = columnsOnAxis;
        var stackId = getSeriesStackId(seriesModel);
        if (!stacks[stackId]) {
          columnsOnAxis.autoWidthCount++;
        }
        stacks[stackId] = stacks[stackId] || {
          width: 0,
          maxWidth: 0
        };
        var barWidth = parsePercent(seriesModel.get("barWidth"), bandWidth);
        var barMaxWidth = parsePercent(seriesModel.get("barMaxWidth"), bandWidth);
        var barGap = seriesModel.get("barGap");
        var barCategoryGap = seriesModel.get("barCategoryGap");
        if (barWidth && !stacks[stackId].width) {
          barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
          stacks[stackId].width = barWidth;
          columnsOnAxis.remainedWidth -= barWidth;
        }
        barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
        barGap != null && (columnsOnAxis.gap = barGap);
        barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
      });
      var result = {};
      zrUtil.each(columnsMap, function(columnsOnAxis, coordSysName) {
        result[coordSysName] = {};
        var stacks = columnsOnAxis.stacks;
        var bandWidth = columnsOnAxis.bandWidth;
        var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
        var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
        var remainedWidth = columnsOnAxis.remainedWidth;
        var autoWidthCount = columnsOnAxis.autoWidthCount;
        var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        zrUtil.each(stacks, function(column, stack) {
          var maxWidth = column.maxWidth;
          if (maxWidth && maxWidth < autoWidth) {
            maxWidth = Math.min(maxWidth, remainedWidth);
            if (column.width) {
              maxWidth = Math.min(maxWidth, column.width);
            }
            remainedWidth -= maxWidth;
            column.width = maxWidth;
            autoWidthCount--;
          }
        });
        autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
        autoWidth = Math.max(autoWidth, 0);
        var widthSum = 0;
        var lastColumn;
        zrUtil.each(stacks, function(column, idx) {
          if (!column.width) {
            column.width = autoWidth;
          }
          lastColumn = column;
          widthSum += column.width * (1 + barGapPercent);
        });
        if (lastColumn) {
          widthSum -= lastColumn.width * barGapPercent;
        }
        var offset = -widthSum / 2;
        zrUtil.each(stacks, function(column, stackId) {
          result[coordSysName][stackId] = result[coordSysName][stackId] || {
            offset,
            width: column.width
          };
          offset += column.width * (1 + barGapPercent);
        });
      });
      return result;
    }
    var _default = barLayoutPolar;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/RadiusAxis.js
var require_RadiusAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/RadiusAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    function RadiusAxis(scale, radiusExtent) {
      Axis.call(this, "radius", scale, radiusExtent);
      this.type = "category";
    }
    RadiusAxis.prototype = {
      constructor: RadiusAxis,
      /**
       * @override
       */
      pointToData: function(point, clamp) {
        return this.polar.pointToData(point, clamp)[this.dim === "radius" ? 0 : 1];
      },
      dataToRadius: Axis.prototype.dataToCoord,
      radiusToData: Axis.prototype.coordToData
    };
    zrUtil.inherits(RadiusAxis, Axis);
    var _default = RadiusAxis;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AngleAxis.js
var require_AngleAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AngleAxis.js"(exports, module) {
    var zrUtil = require_util();
    var textContain = require_text();
    var Axis = require_Axis();
    var _model = require_model();
    var makeInner = _model.makeInner;
    var inner = makeInner();
    function AngleAxis(scale, angleExtent) {
      angleExtent = angleExtent || [0, 360];
      Axis.call(this, "angle", scale, angleExtent);
      this.type = "category";
    }
    AngleAxis.prototype = {
      constructor: AngleAxis,
      /**
       * @override
       */
      pointToData: function(point, clamp) {
        return this.polar.pointToData(point, clamp)[this.dim === "radius" ? 0 : 1];
      },
      dataToAngle: Axis.prototype.dataToCoord,
      angleToData: Axis.prototype.coordToData,
      /**
       * Only be called in category axis.
       * Angle axis uses text height to decide interval
       *
       * @override
       * @return {number} Auto interval for cateogry axis tick and label
       */
      calculateCategoryInterval: function() {
        var axis = this;
        var labelModel = axis.getLabelModel();
        var ordinalScale = axis.scale;
        var ordinalExtent = ordinalScale.getExtent();
        var tickCount = ordinalScale.count();
        if (ordinalExtent[1] - ordinalExtent[0] < 1) {
          return 0;
        }
        var tickValue = ordinalExtent[0];
        var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
        var unitH = Math.abs(unitSpan);
        var rect = textContain.getBoundingRect(tickValue, labelModel.getFont(), "center", "top");
        var maxH = Math.max(rect.height, 7);
        var dh = maxH / unitH;
        isNaN(dh) && (dh = Infinity);
        var interval = Math.max(0, Math.floor(dh));
        var cache = inner(axis.model);
        var lastAutoInterval = cache.lastAutoInterval;
        var lastTickCount = cache.lastTickCount;
        if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
          interval = lastAutoInterval;
        } else {
          cache.lastTickCount = tickCount;
          cache.lastAutoInterval = interval;
        }
        return interval;
      }
    };
    zrUtil.inherits(AngleAxis, Axis);
    var _default = AngleAxis;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/Polar.js
var require_Polar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/Polar.js"(exports, module) {
    var RadiusAxis = require_RadiusAxis();
    var AngleAxis = require_AngleAxis();
    var Polar = function(name2) {
      this.name = name2 || "";
      this.cx = 0;
      this.cy = 0;
      this._radiusAxis = new RadiusAxis();
      this._angleAxis = new AngleAxis();
      this._radiusAxis.polar = this._angleAxis.polar = this;
    };
    Polar.prototype = {
      type: "polar",
      axisPointerEnabled: true,
      constructor: Polar,
      /**
       * @param {Array.<string>}
       * @readOnly
       */
      dimensions: ["radius", "angle"],
      /**
       * @type {module:echarts/coord/PolarModel}
       */
      model: null,
      /**
       * If contain coord
       * @param {Array.<number>} point
       * @return {boolean}
       */
      containPoint: function(point) {
        var coord = this.pointToCoord(point);
        return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
      },
      /**
       * If contain data
       * @param {Array.<number>} data
       * @return {boolean}
       */
      containData: function(data) {
        return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
      },
      /**
       * @param {string} dim
       * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
       */
      getAxis: function(dim) {
        return this["_" + dim + "Axis"];
      },
      /**
       * @return {Array.<module:echarts/coord/Axis>}
       */
      getAxes: function() {
        return [this._radiusAxis, this._angleAxis];
      },
      /**
       * Get axes by type of scale
       * @param {string} scaleType
       * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
       */
      getAxesByScale: function(scaleType) {
        var axes = [];
        var angleAxis = this._angleAxis;
        var radiusAxis = this._radiusAxis;
        angleAxis.scale.type === scaleType && axes.push(angleAxis);
        radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
        return axes;
      },
      /**
       * @return {module:echarts/coord/polar/AngleAxis}
       */
      getAngleAxis: function() {
        return this._angleAxis;
      },
      /**
       * @return {module:echarts/coord/polar/RadiusAxis}
       */
      getRadiusAxis: function() {
        return this._radiusAxis;
      },
      /**
       * @param {module:echarts/coord/polar/Axis}
       * @return {module:echarts/coord/polar/Axis}
       */
      getOtherAxis: function(axis) {
        var angleAxis = this._angleAxis;
        return axis === angleAxis ? this._radiusAxis : angleAxis;
      },
      /**
       * Base axis will be used on stacking.
       *
       * @return {module:echarts/coord/polar/Axis}
       */
      getBaseAxis: function() {
        return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
      },
      /**
       * @param {string} [dim] 'radius' or 'angle' or 'auto' or null/undefined
       * @return {Object} {baseAxes: [], otherAxes: []}
       */
      getTooltipAxes: function(dim) {
        var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
        return {
          baseAxes: [baseAxis],
          otherAxes: [this.getOtherAxis(baseAxis)]
        };
      },
      /**
       * Convert a single data item to (x, y) point.
       * Parameter data is an array which the first element is radius and the second is angle
       * @param {Array.<number>} data
       * @param {boolean} [clamp=false]
       * @return {Array.<number>}
       */
      dataToPoint: function(data, clamp) {
        return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);
      },
      /**
       * Convert a (x, y) point to data
       * @param {Array.<number>} point
       * @param {boolean} [clamp=false]
       * @return {Array.<number>}
       */
      pointToData: function(point, clamp) {
        var coord = this.pointToCoord(point);
        return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];
      },
      /**
       * Convert a (x, y) point to (radius, angle) coord
       * @param {Array.<number>} point
       * @return {Array.<number>}
       */
      pointToCoord: function(point) {
        var dx = point[0] - this.cx;
        var dy = point[1] - this.cy;
        var angleAxis = this.getAngleAxis();
        var extent = angleAxis.getExtent();
        var minAngle = Math.min(extent[0], extent[1]);
        var maxAngle = Math.max(extent[0], extent[1]);
        angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
        var radius = Math.sqrt(dx * dx + dy * dy);
        dx /= radius;
        dy /= radius;
        var radian = Math.atan2(-dy, dx) / Math.PI * 180;
        var dir = radian < minAngle ? 1 : -1;
        while (radian < minAngle || radian > maxAngle) {
          radian += dir * 360;
        }
        return [radius, radian];
      },
      /**
       * Convert a (radius, angle) coord to (x, y) point
       * @param {Array.<number>} coord
       * @return {Array.<number>}
       */
      coordToPoint: function(coord) {
        var radius = coord[0];
        var radian = coord[1] / 180 * Math.PI;
        var x = Math.cos(radian) * radius + this.cx;
        var y = -Math.sin(radian) * radius + this.cy;
        return [x, y];
      },
      /**
       * Get ring area of cartesian.
       * Area will have a contain function to determine if a point is in the coordinate system.
       * @return {Ring}
       */
      getArea: function() {
        var angleAxis = this.getAngleAxis();
        var radiusAxis = this.getRadiusAxis();
        var radiusExtent = radiusAxis.getExtent().slice();
        radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
        var angleExtent = angleAxis.getExtent();
        var RADIAN = Math.PI / 180;
        return {
          cx: this.cx,
          cy: this.cy,
          r0: radiusExtent[0],
          r: radiusExtent[1],
          startAngle: -angleExtent[0] * RADIAN,
          endAngle: -angleExtent[1] * RADIAN,
          clockwise: angleAxis.inverse,
          contain: function(x, y) {
            var dx = x - this.cx;
            var dy = y - this.cy;
            var d2 = dx * dx + dy * dy;
            var r = this.r;
            var r0 = this.r0;
            return d2 <= r * r && d2 >= r0 * r0;
          }
        };
      }
    };
    var _default = Polar;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AxisModel.js
var require_AxisModel4 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/AxisModel.js"() {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var axisModelCreator = require_axisModelCreator();
    var axisModelCommonMixin = require_axisModelCommonMixin();
    var PolarAxisModel = ComponentModel.extend({
      type: "polarAxis",
      /**
       * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
       */
      axis: null,
      /**
       * @override
       */
      getCoordSysModel: function() {
        return this.ecModel.queryComponents({
          mainType: "polar",
          index: this.option.polarIndex,
          id: this.option.polarId
        })[0];
      }
    });
    zrUtil.merge(PolarAxisModel.prototype, axisModelCommonMixin);
    var polarAxisDefaultExtendedOption = {
      angle: {
        // polarIndex: 0,
        // polarId: '',
        startAngle: 90,
        clockwise: true,
        splitNumber: 12,
        axisLabel: {
          rotate: false
        }
      },
      radius: {
        // polarIndex: 0,
        // polarId: '',
        splitNumber: 5
      }
    };
    function getAxisType(axisDim, option) {
      return option.type || (option.data ? "category" : "value");
    }
    axisModelCreator("angle", PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);
    axisModelCreator("radius", PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/PolarModel.js
var require_PolarModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/PolarModel.js"(exports, module) {
    var echarts = require_echarts();
    require_AxisModel4();
    var _default = echarts.extendComponentModel({
      type: "polar",
      dependencies: ["polarAxis", "angleAxis"],
      /**
       * @type {module:echarts/coord/polar/Polar}
       */
      coordinateSystem: null,
      /**
       * @param {string} axisType
       * @return {module:echarts/coord/polar/AxisModel}
       */
      findAxisModel: function(axisType) {
        var foundAxisModel;
        var ecModel = this.ecModel;
        ecModel.eachComponent(axisType, function(axisModel) {
          if (axisModel.getCoordSysModel() === this) {
            foundAxisModel = axisModel;
          }
        }, this);
        return foundAxisModel;
      },
      defaultOption: {
        zlevel: 0,
        z: 0,
        center: ["50%", "50%"],
        radius: "80%"
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/polarCreator.js
var require_polarCreator = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/polar/polarCreator.js"() {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var Polar = require_Polar();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _axisHelper = require_axisHelper();
    var createScaleByModel = _axisHelper.createScaleByModel;
    var niceScaleExtent = _axisHelper.niceScaleExtent;
    var CoordinateSystem = require_CoordinateSystem();
    var _dataStackHelper = require_dataStackHelper();
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    require_PolarModel();
    function resizePolar(polar, polarModel, api) {
      var center = polarModel.get("center");
      var width = api.getWidth();
      var height = api.getHeight();
      polar.cx = parsePercent(center[0], width);
      polar.cy = parsePercent(center[1], height);
      var radiusAxis = polar.getRadiusAxis();
      var size = Math.min(width, height) / 2;
      var radius = polarModel.get("radius");
      if (radius == null) {
        radius = [0, "100%"];
      } else if (!zrUtil.isArray(radius)) {
        radius = [0, radius];
      }
      radius = [parsePercent(radius[0], size), parsePercent(radius[1], size)];
      radiusAxis.inverse ? radiusAxis.setExtent(radius[1], radius[0]) : radiusAxis.setExtent(radius[0], radius[1]);
    }
    function updatePolarScale(ecModel, api) {
      var polar = this;
      var angleAxis = polar.getAngleAxis();
      var radiusAxis = polar.getRadiusAxis();
      angleAxis.scale.setExtent(Infinity, -Infinity);
      radiusAxis.scale.setExtent(Infinity, -Infinity);
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.coordinateSystem === polar) {
          var data = seriesModel.getData();
          zrUtil.each(data.mapDimension("radius", true), function(dim) {
            radiusAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));
          });
          zrUtil.each(data.mapDimension("angle", true), function(dim) {
            angleAxis.scale.unionExtentFromData(data, getStackedDimension(data, dim));
          });
        }
      });
      niceScaleExtent(angleAxis.scale, angleAxis.model);
      niceScaleExtent(radiusAxis.scale, radiusAxis.model);
      if (angleAxis.type === "category" && !angleAxis.onBand) {
        var extent = angleAxis.getExtent();
        var diff = 360 / angleAxis.scale.count();
        angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;
        angleAxis.setExtent(extent[0], extent[1]);
      }
    }
    function setAxis(axis, axisModel) {
      axis.type = axisModel.get("type");
      axis.scale = createScaleByModel(axisModel);
      axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
      axis.inverse = axisModel.get("inverse");
      if (axisModel.mainType === "angleAxis") {
        axis.inverse ^= axisModel.get("clockwise");
        var startAngle = axisModel.get("startAngle");
        axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
      }
      axisModel.axis = axis;
      axis.model = axisModel;
    }
    var polarCreator = {
      dimensions: Polar.prototype.dimensions,
      create: function(ecModel, api) {
        var polarList = [];
        ecModel.eachComponent("polar", function(polarModel, idx) {
          var polar = new Polar(idx);
          polar.update = updatePolarScale;
          var radiusAxis = polar.getRadiusAxis();
          var angleAxis = polar.getAngleAxis();
          var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
          var angleAxisModel = polarModel.findAxisModel("angleAxis");
          setAxis(radiusAxis, radiusAxisModel);
          setAxis(angleAxis, angleAxisModel);
          resizePolar(polar, polarModel, api);
          polarList.push(polar);
          polarModel.coordinateSystem = polar;
          polar.model = polarModel;
        });
        ecModel.eachSeries(function(seriesModel) {
          if (seriesModel.get("coordinateSystem") === "polar") {
            var polarModel = ecModel.queryComponents({
              mainType: "polar",
              index: seriesModel.get("polarIndex"),
              id: seriesModel.get("polarId")
            })[0];
            seriesModel.coordinateSystem = polarModel.coordinateSystem;
          }
        });
        return polarList;
      }
    };
    CoordinateSystem.register("polar", polarCreator);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AngleAxisView.js
var require_AngleAxisView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/AngleAxisView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var Model = require_Model();
    var AxisView = require_AxisView();
    var AxisBuilder = require_AxisBuilder();
    var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
    function getAxisLineShape(polar, rExtent, angle) {
      rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
      var start = polar.coordToPoint([rExtent[0], angle]);
      var end = polar.coordToPoint([rExtent[1], angle]);
      return {
        x1: start[0],
        y1: start[1],
        x2: end[0],
        y2: end[1]
      };
    }
    function getRadiusIdx(polar) {
      var radiusAxis = polar.getRadiusAxis();
      return radiusAxis.inverse ? 0 : 1;
    }
    function fixAngleOverlap(list) {
      var firstItem = list[0];
      var lastItem = list[list.length - 1];
      if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
        list.pop();
      }
    }
    var _default = AxisView.extend({
      type: "angleAxis",
      axisPointerClass: "PolarAxisPointer",
      render: function(angleAxisModel, ecModel) {
        this.group.removeAll();
        if (!angleAxisModel.get("show")) {
          return;
        }
        var angleAxis = angleAxisModel.axis;
        var polar = angleAxis.polar;
        var radiusExtent = polar.getRadiusAxis().getExtent();
        var ticksAngles = angleAxis.getTicksCoords();
        var minorTickAngles = angleAxis.getMinorTicksCoords();
        var labels = zrUtil.map(angleAxis.getViewLabels(), function(labelItem) {
          var labelItem = zrUtil.clone(labelItem);
          labelItem.coord = angleAxis.dataToCoord(labelItem.tickValue);
          return labelItem;
        });
        fixAngleOverlap(labels);
        fixAngleOverlap(ticksAngles);
        zrUtil.each(elementList, function(name2) {
          if (angleAxisModel.get(name2 + ".show") && (!angleAxis.scale.isBlank() || name2 === "axisLine")) {
            this["_" + name2](angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
          }
        }, this);
      },
      /**
       * @private
       */
      _axisLine: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        var lineStyleModel = angleAxisModel.getModel("axisLine.lineStyle");
        var rId = getRadiusIdx(polar);
        var r0Id = rId ? 0 : 1;
        var shape;
        if (radiusExtent[r0Id] === 0) {
          shape = new graphic.Circle({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: radiusExtent[rId]
            },
            style: lineStyleModel.getLineStyle(),
            z2: 1,
            silent: true
          });
        } else {
          shape = new graphic.Ring({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: radiusExtent[rId],
              r0: radiusExtent[r0Id]
            },
            style: lineStyleModel.getLineStyle(),
            z2: 1,
            silent: true
          });
        }
        shape.style.fill = null;
        this.group.add(shape);
      },
      /**
       * @private
       */
      _axisTick: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        var tickModel = angleAxisModel.getModel("axisTick");
        var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
        var radius = radiusExtent[getRadiusIdx(polar)];
        var lines = zrUtil.map(ticksAngles, function(tickAngleItem) {
          return new graphic.Line({
            shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
          });
        });
        this.group.add(graphic.mergePath(lines, {
          style: zrUtil.defaults(tickModel.getModel("lineStyle").getLineStyle(), {
            stroke: angleAxisModel.get("axisLine.lineStyle.color")
          })
        }));
      },
      /**
       * @private
       */
      _minorTick: function(angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
        if (!minorTickAngles.length) {
          return;
        }
        var tickModel = angleAxisModel.getModel("axisTick");
        var minorTickModel = angleAxisModel.getModel("minorTick");
        var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
        var radius = radiusExtent[getRadiusIdx(polar)];
        var lines = [];
        for (var i = 0; i < minorTickAngles.length; i++) {
          for (var k = 0; k < minorTickAngles[i].length; k++) {
            lines.push(new graphic.Line({
              shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
            }));
          }
        }
        this.group.add(graphic.mergePath(lines, {
          style: zrUtil.defaults(minorTickModel.getModel("lineStyle").getLineStyle(), zrUtil.defaults(tickModel.getLineStyle(), {
            stroke: angleAxisModel.get("axisLine.lineStyle.color")
          }))
        }));
      },
      /**
       * @private
       */
      _axisLabel: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
        var rawCategoryData = angleAxisModel.getCategories(true);
        var commonLabelModel = angleAxisModel.getModel("axisLabel");
        var labelMargin = commonLabelModel.get("margin");
        var triggerEvent = angleAxisModel.get("triggerEvent");
        zrUtil.each(labels, function(labelItem, idx) {
          var labelModel = commonLabelModel;
          var tickValue = labelItem.tickValue;
          var r = radiusExtent[getRadiusIdx(polar)];
          var p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
          var cx = polar.cx;
          var cy = polar.cy;
          var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? "center" : p[0] > cx ? "left" : "right";
          var labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? "middle" : p[1] > cy ? "top" : "bottom";
          if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
            labelModel = new Model(rawCategoryData[tickValue].textStyle, commonLabelModel, commonLabelModel.ecModel);
          }
          var textEl = new graphic.Text({
            silent: AxisBuilder.isLabelSilent(angleAxisModel)
          });
          this.group.add(textEl);
          graphic.setTextStyle(textEl.style, labelModel, {
            x: p[0],
            y: p[1],
            textFill: labelModel.getTextColor() || angleAxisModel.get("axisLine.lineStyle.color"),
            text: labelItem.formattedLabel,
            textAlign: labelTextAlign,
            textVerticalAlign: labelTextVerticalAlign
          });
          if (triggerEvent) {
            textEl.eventData = AxisBuilder.makeAxisEventDataBase(angleAxisModel);
            textEl.eventData.targetType = "axisLabel";
            textEl.eventData.value = labelItem.rawLabel;
          }
        }, this);
      },
      /**
       * @private
       */
      _splitLine: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        var splitLineModel = angleAxisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineColors = lineStyleModel.get("color");
        var lineCount = 0;
        lineColors = lineColors instanceof Array ? lineColors : [lineColors];
        var splitLines = [];
        for (var i = 0; i < ticksAngles.length; i++) {
          var colorIndex = lineCount++ % lineColors.length;
          splitLines[colorIndex] = splitLines[colorIndex] || [];
          splitLines[colorIndex].push(new graphic.Line({
            shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
          }));
        }
        for (var i = 0; i < splitLines.length; i++) {
          this.group.add(graphic.mergePath(splitLines[i], {
            style: zrUtil.defaults({
              stroke: lineColors[i % lineColors.length]
            }, lineStyleModel.getLineStyle()),
            silent: true,
            z: angleAxisModel.get("z")
          }));
        }
      },
      /**
       * @private
       */
      _minorSplitLine: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        if (!minorTickAngles.length) {
          return;
        }
        var minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
        var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
        var lines = [];
        for (var i = 0; i < minorTickAngles.length; i++) {
          for (var k = 0; k < minorTickAngles[i].length; k++) {
            lines.push(new graphic.Line({
              shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
            }));
          }
        }
        this.group.add(graphic.mergePath(lines, {
          style: lineStyleModel.getLineStyle(),
          silent: true,
          z: angleAxisModel.get("z")
        }));
      },
      /**
       * @private
       */
      _splitArea: function(angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
        if (!ticksAngles.length) {
          return;
        }
        var splitAreaModel = angleAxisModel.getModel("splitArea");
        var areaStyleModel = splitAreaModel.getModel("areaStyle");
        var areaColors = areaStyleModel.get("color");
        var lineCount = 0;
        areaColors = areaColors instanceof Array ? areaColors : [areaColors];
        var splitAreas = [];
        var RADIAN = Math.PI / 180;
        var prevAngle = -ticksAngles[0].coord * RADIAN;
        var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
        var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
        var clockwise = angleAxisModel.get("clockwise");
        for (var i = 1; i < ticksAngles.length; i++) {
          var colorIndex = lineCount++ % areaColors.length;
          splitAreas[colorIndex] = splitAreas[colorIndex] || [];
          splitAreas[colorIndex].push(new graphic.Sector({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r0,
              r: r1,
              startAngle: prevAngle,
              endAngle: -ticksAngles[i].coord * RADIAN,
              clockwise
            },
            silent: true
          }));
          prevAngle = -ticksAngles[i].coord * RADIAN;
        }
        for (var i = 0; i < splitAreas.length; i++) {
          this.group.add(graphic.mergePath(splitAreas[i], {
            style: zrUtil.defaults({
              fill: areaColors[i % areaColors.length]
            }, areaStyleModel.getAreaStyle()),
            silent: true
          }));
        }
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/angleAxis.js
var require_angleAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/angleAxis.js"() {
    require_polarCreator();
    require_AngleAxisView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/RadiusAxisView.js
var require_RadiusAxisView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axis/RadiusAxisView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var AxisBuilder = require_AxisBuilder();
    var AxisView = require_AxisView();
    var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
    var selfBuilderAttrs = ["splitLine", "splitArea", "minorSplitLine"];
    var _default = AxisView.extend({
      type: "radiusAxis",
      axisPointerClass: "PolarAxisPointer",
      render: function(radiusAxisModel, ecModel) {
        this.group.removeAll();
        if (!radiusAxisModel.get("show")) {
          return;
        }
        var radiusAxis = radiusAxisModel.axis;
        var polar = radiusAxis.polar;
        var angleAxis = polar.getAngleAxis();
        var ticksCoords = radiusAxis.getTicksCoords();
        var minorTicksCoords = radiusAxis.getMinorTicksCoords();
        var axisAngle = angleAxis.getExtent()[0];
        var radiusExtent = radiusAxis.getExtent();
        var layout = layoutAxis(polar, radiusAxisModel, axisAngle);
        var axisBuilder = new AxisBuilder(radiusAxisModel, layout);
        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        this.group.add(axisBuilder.getGroup());
        zrUtil.each(selfBuilderAttrs, function(name2) {
          if (radiusAxisModel.get(name2 + ".show") && !radiusAxis.scale.isBlank()) {
            this["_" + name2](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
          }
        }, this);
      },
      /**
       * @private
       */
      _splitLine: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
        var splitLineModel = radiusAxisModel.getModel("splitLine");
        var lineStyleModel = splitLineModel.getModel("lineStyle");
        var lineColors = lineStyleModel.get("color");
        var lineCount = 0;
        lineColors = lineColors instanceof Array ? lineColors : [lineColors];
        var splitLines = [];
        for (var i = 0; i < ticksCoords.length; i++) {
          var colorIndex = lineCount++ % lineColors.length;
          splitLines[colorIndex] = splitLines[colorIndex] || [];
          splitLines[colorIndex].push(new graphic.Circle({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: ticksCoords[i].coord
            }
          }));
        }
        for (var i = 0; i < splitLines.length; i++) {
          this.group.add(graphic.mergePath(splitLines[i], {
            style: zrUtil.defaults({
              stroke: lineColors[i % lineColors.length],
              fill: null
            }, lineStyleModel.getLineStyle()),
            silent: true
          }));
        }
      },
      /**
       * @private
       */
      _minorSplitLine: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
        if (!minorTicksCoords.length) {
          return;
        }
        var minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
        var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
        var lines = [];
        for (var i = 0; i < minorTicksCoords.length; i++) {
          for (var k = 0; k < minorTicksCoords[i].length; k++) {
            lines.push(new graphic.Circle({
              shape: {
                cx: polar.cx,
                cy: polar.cy,
                r: minorTicksCoords[i][k].coord
              }
            }));
          }
        }
        this.group.add(graphic.mergePath(lines, {
          style: zrUtil.defaults({
            fill: null
          }, lineStyleModel.getLineStyle()),
          silent: true
        }));
      },
      /**
       * @private
       */
      _splitArea: function(radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
        if (!ticksCoords.length) {
          return;
        }
        var splitAreaModel = radiusAxisModel.getModel("splitArea");
        var areaStyleModel = splitAreaModel.getModel("areaStyle");
        var areaColors = areaStyleModel.get("color");
        var lineCount = 0;
        areaColors = areaColors instanceof Array ? areaColors : [areaColors];
        var splitAreas = [];
        var prevRadius = ticksCoords[0].coord;
        for (var i = 1; i < ticksCoords.length; i++) {
          var colorIndex = lineCount++ % areaColors.length;
          splitAreas[colorIndex] = splitAreas[colorIndex] || [];
          splitAreas[colorIndex].push(new graphic.Sector({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r0: prevRadius,
              r: ticksCoords[i].coord,
              startAngle: 0,
              endAngle: Math.PI * 2
            },
            silent: true
          }));
          prevRadius = ticksCoords[i].coord;
        }
        for (var i = 0; i < splitAreas.length; i++) {
          this.group.add(graphic.mergePath(splitAreas[i], {
            style: zrUtil.defaults({
              fill: areaColors[i % areaColors.length]
            }, areaStyleModel.getAreaStyle()),
            silent: true
          }));
        }
      }
    });
    function layoutAxis(polar, radiusAxisModel, axisAngle) {
      return {
        position: [polar.cx, polar.cy],
        rotation: axisAngle / 180 * Math.PI,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1,
        labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
        // Over splitLine and splitArea
        z2: 1
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radiusAxis.js
var require_radiusAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/radiusAxis.js"() {
    require_polarCreator();
    require_RadiusAxisView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js
var require_PolarAxisPointer = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/axisPointer/PolarAxisPointer.js"(exports, module) {
    var formatUtil = require_format();
    var BaseAxisPointer = require_BaseAxisPointer();
    var graphic = require_graphic();
    var viewHelper = require_viewHelper();
    var matrix = require_matrix();
    var AxisBuilder = require_AxisBuilder();
    var AxisView = require_AxisView();
    var PolarAxisPointer = BaseAxisPointer.extend({
      /**
       * @override
       */
      makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
        var axis = axisModel.axis;
        if (axis.dim === "angle") {
          this.animationThreshold = Math.PI / 18;
        }
        var polar = axis.polar;
        var otherAxis = polar.getOtherAxis(axis);
        var otherExtent = otherAxis.getExtent();
        var coordValue;
        coordValue = axis["dataTo" + formatUtil.capitalFirst(axis.dim)](value);
        var axisPointerType = axisPointerModel.get("type");
        if (axisPointerType && axisPointerType !== "none") {
          var elStyle = viewHelper.buildElStyle(axisPointerModel);
          var pointerOption = pointerShapeBuilder[axisPointerType](axis, polar, coordValue, otherExtent, elStyle);
          pointerOption.style = elStyle;
          elOption.graphicKey = pointerOption.type;
          elOption.pointer = pointerOption;
        }
        var labelMargin = axisPointerModel.get("label.margin");
        var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
        viewHelper.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
      }
      // Do not support handle, utill any user requires it.
    });
    function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
      var axis = axisModel.axis;
      var coord = axis.dataToCoord(value);
      var axisAngle = polar.getAngleAxis().getExtent()[0];
      axisAngle = axisAngle / 180 * Math.PI;
      var radiusExtent = polar.getRadiusAxis().getExtent();
      var position;
      var align;
      var verticalAlign;
      if (axis.dim === "radius") {
        var transform = matrix.create();
        matrix.rotate(transform, transform, axisAngle);
        matrix.translate(transform, transform, [polar.cx, polar.cy]);
        position = graphic.applyTransform([coord, -labelMargin], transform);
        var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
        var labelLayout = AxisBuilder.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
        align = labelLayout.textAlign;
        verticalAlign = labelLayout.textVerticalAlign;
      } else {
        var r = radiusExtent[1];
        position = polar.coordToPoint([r + labelMargin, coord]);
        var cx = polar.cx;
        var cy = polar.cy;
        align = Math.abs(position[0] - cx) / r < 0.3 ? "center" : position[0] > cx ? "left" : "right";
        verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? "middle" : position[1] > cy ? "top" : "bottom";
      }
      return {
        position,
        align,
        verticalAlign
      };
    }
    var pointerShapeBuilder = {
      line: function(axis, polar, coordValue, otherExtent, elStyle) {
        return axis.dim === "angle" ? {
          type: "Line",
          shape: viewHelper.makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
        } : {
          type: "Circle",
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: coordValue
          }
        };
      },
      shadow: function(axis, polar, coordValue, otherExtent, elStyle) {
        var bandWidth = Math.max(1, axis.getBandWidth());
        var radian = Math.PI / 180;
        return axis.dim === "angle" ? {
          type: "Sector",
          shape: viewHelper.makeSectorShape(
            polar.cx,
            polar.cy,
            otherExtent[0],
            otherExtent[1],
            // In ECharts y is negative if angle is positive
            (-coordValue - bandWidth / 2) * radian,
            (-coordValue + bandWidth / 2) * radian
          )
        } : {
          type: "Sector",
          shape: viewHelper.makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
        };
      }
    };
    AxisView.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer);
    var _default = PolarAxisPointer;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/polar.js
var require_polar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/polar.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var barPolar = require_barPolar();
    require_polarCreator();
    require_angleAxis();
    require_radiusAxis();
    require_axisPointer();
    require_PolarAxisPointer();
    echarts.registerLayout(zrUtil.curry(barPolar, "bar"));
    echarts.extendComponentView({
      type: "polar"
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/GeoModel.js
var require_GeoModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/geo/GeoModel.js"(exports, module) {
    var zrUtil = require_util();
    var modelUtil = require_model();
    var ComponentModel = require_Component();
    var Model = require_Model();
    var selectableMixin = require_selectableMixin();
    var geoCreator = require_geoCreator();
    var GeoModel = ComponentModel.extend({
      type: "geo",
      /**
       * @type {module:echarts/coord/geo/Geo}
       */
      coordinateSystem: null,
      layoutMode: "box",
      init: function(option) {
        ComponentModel.prototype.init.apply(this, arguments);
        modelUtil.defaultEmphasis(option, "label", ["show"]);
      },
      optionUpdated: function() {
        var option = this.option;
        var self2 = this;
        option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap);
        this._optionModelMap = zrUtil.reduce(option.regions || [], function(optionModelMap, regionOpt) {
          if (regionOpt.name) {
            optionModelMap.set(regionOpt.name, new Model(regionOpt, self2));
          }
          return optionModelMap;
        }, zrUtil.createHashMap());
        this.updateSelectedMap(option.regions);
      },
      defaultOption: {
        zlevel: 0,
        z: 0,
        show: true,
        left: "center",
        top: "center",
        // width:,
        // height:,
        // right
        // bottom
        // Aspect is width / height. Inited to be geoJson bbox aspect
        // This parameter is used for scale this aspect
        // If svg used, aspectScale is 1 by default.
        // aspectScale: 0.75,
        aspectScale: null,
        ///// Layout with center and size
        // If you wan't to put map in a fixed size box with right aspect ratio
        // This two properties may more conveninet
        // layoutCenter: [50%, 50%]
        // layoutSize: 100
        silent: false,
        // Map type
        map: "",
        // Define left-top, right-bottom coords to control view
        // For example, [ [180, 90], [-180, -90] ]
        boundingCoords: null,
        // Default on center of map
        center: null,
        zoom: 1,
        scaleLimit: null,
        // selectedMode: false
        label: {
          show: false,
          color: "#000"
        },
        itemStyle: {
          // color: 各异,
          borderWidth: 0.5,
          borderColor: "#444",
          color: "#eee"
        },
        emphasis: {
          label: {
            show: true,
            color: "rgb(100,0,0)"
          },
          itemStyle: {
            color: "rgba(255,215,0,0.8)"
          }
        },
        regions: []
      },
      /**
       * Get model of region
       * @param  {string} name
       * @return {module:echarts/model/Model}
       */
      getRegionModel: function(name2) {
        return this._optionModelMap.get(name2) || new Model(null, this, this.ecModel);
      },
      /**
       * Format label
       * @param {string} name Region name
       * @param {string} [status='normal'] 'normal' or 'emphasis'
       * @return {string}
       */
      getFormattedLabel: function(name2, status) {
        status = status || "normal";
        var regionModel = this.getRegionModel(name2);
        var formatter = regionModel.get((status === "normal" ? "" : status + ".") + "label.formatter");
        var params = {
          name: name2
        };
        if (typeof formatter === "function") {
          params.status = status;
          return formatter(params);
        } else if (typeof formatter === "string") {
          return formatter.replace("{a}", name2 != null ? name2 : "");
        }
      },
      setZoom: function(zoom) {
        this.option.zoom = zoom;
      },
      setCenter: function(center) {
        this.option.center = center;
      }
    });
    zrUtil.mixin(GeoModel, selectableMixin);
    var _default = GeoModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo/GeoView.js
var require_GeoView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo/GeoView.js"(exports, module) {
    var MapDraw = require_MapDraw();
    var echarts = require_echarts();
    var _default = echarts.extendComponentView({
      type: "geo",
      init: function(ecModel, api) {
        var mapDraw = new MapDraw(api, true);
        this._mapDraw = mapDraw;
        this.group.add(mapDraw.group);
      },
      render: function(geoModel, ecModel, api, payload) {
        if (payload && payload.type === "geoToggleSelect" && payload.from === this.uid) {
          return;
        }
        var mapDraw = this._mapDraw;
        if (geoModel.get("show")) {
          mapDraw.draw(geoModel, ecModel, api, this, payload);
        } else {
          this._mapDraw.group.removeAll();
        }
        this.group.silent = geoModel.get("silent");
      },
      dispose: function() {
        this._mapDraw && this._mapDraw.remove();
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo.js
var require_geo = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/geo.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    require_GeoModel();
    require_geoCreator();
    require_GeoView();
    require_geoRoam();
    function makeAction(method, actionInfo) {
      actionInfo.update = "updateView";
      echarts.registerAction(actionInfo, function(payload, ecModel) {
        var selected = {};
        ecModel.eachComponent({
          mainType: "geo",
          query: payload
        }, function(geoModel) {
          geoModel[method](payload.name);
          var geo = geoModel.coordinateSystem;
          zrUtil.each(geo.regions, function(region) {
            selected[region.name] = geoModel.isSelected(region.name) || false;
          });
        });
        return {
          selected,
          name: payload.name
        };
      });
    }
    makeAction("toggleSelected", {
      type: "geoToggleSelect",
      event: "geoselectchanged"
    });
    makeAction("select", {
      type: "geoSelect",
      event: "geoselected"
    });
    makeAction("unSelect", {
      type: "geoUnSelect",
      event: "geounselected"
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/Calendar.js
var require_Calendar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/Calendar.js"(exports, module) {
    var zrUtil = require_util();
    var layout = require_layout();
    var numberUtil = require_number();
    var CoordinateSystem = require_CoordinateSystem();
    var PROXIMATE_ONE_DAY = 864e5;
    function Calendar(calendarModel, ecModel, api) {
      this._model = calendarModel;
    }
    Calendar.prototype = {
      constructor: Calendar,
      type: "calendar",
      dimensions: ["time", "value"],
      // Required in createListFromData
      getDimensionsInfo: function() {
        return [{
          name: "time",
          type: "time"
        }, "value"];
      },
      getRangeInfo: function() {
        return this._rangeInfo;
      },
      getModel: function() {
        return this._model;
      },
      getRect: function() {
        return this._rect;
      },
      getCellWidth: function() {
        return this._sw;
      },
      getCellHeight: function() {
        return this._sh;
      },
      getOrient: function() {
        return this._orient;
      },
      /**
       * getFirstDayOfWeek
       *
       * @example
       *     0 : start at Sunday
       *     1 : start at Monday
       *
       * @return {number}
       */
      getFirstDayOfWeek: function() {
        return this._firstDayOfWeek;
      },
      /**
       * get date info
       *
       * @param  {string|number} date date
       * @return {Object}
       * {
       *      y: string, local full year, eg., '1940',
       *      m: string, local month, from '01' ot '12',
       *      d: string, local date, from '01' to '31' (if exists),
       *      day: It is not date.getDay(). It is the location of the cell in a week, from 0 to 6,
       *      time: timestamp,
       *      formatedDate: string, yyyy-MM-dd,
       *      date: original date object.
       * }
       */
      getDateInfo: function(date) {
        date = numberUtil.parseDate(date);
        var y = date.getFullYear();
        var m = date.getMonth() + 1;
        m = m < 10 ? "0" + m : m;
        var d = date.getDate();
        d = d < 10 ? "0" + d : d;
        var day = date.getDay();
        day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
        return {
          y,
          m,
          d,
          day,
          time: date.getTime(),
          formatedDate: y + "-" + m + "-" + d,
          date
        };
      },
      getNextNDay: function(date, n) {
        n = n || 0;
        if (n === 0) {
          return this.getDateInfo(date);
        }
        date = new Date(this.getDateInfo(date).time);
        date.setDate(date.getDate() + n);
        return this.getDateInfo(date);
      },
      update: function(ecModel, api) {
        this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
        this._orient = this._model.get("orient");
        this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
        this._rangeInfo = this._getRangeInfo(this._initRangeOption());
        var weeks = this._rangeInfo.weeks || 1;
        var whNames = ["width", "height"];
        var cellSize = this._model.get("cellSize").slice();
        var layoutParams = this._model.getBoxLayoutParams();
        var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
        zrUtil.each([0, 1], function(idx) {
          if (cellSizeSpecified(cellSize, idx)) {
            layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
          }
        });
        var whGlobal = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var calendarRect = this._rect = layout.getLayoutRect(layoutParams, whGlobal);
        zrUtil.each([0, 1], function(idx) {
          if (!cellSizeSpecified(cellSize, idx)) {
            cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
          }
        });
        function cellSizeSpecified(cellSize2, idx) {
          return cellSize2[idx] != null && cellSize2[idx] !== "auto";
        }
        this._sw = cellSize[0];
        this._sh = cellSize[1];
      },
      /**
       * Convert a time data(time, value) item to (x, y) point.
       *
       * @override
       * @param  {Array|number} data data
       * @param  {boolean} [clamp=true] out of range
       * @return {Array} point
       */
      dataToPoint: function(data, clamp) {
        zrUtil.isArray(data) && (data = data[0]);
        clamp == null && (clamp = true);
        var dayInfo = this.getDateInfo(data);
        var range = this._rangeInfo;
        var date = dayInfo.formatedDate;
        if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
          return [NaN, NaN];
        }
        var week = dayInfo.day;
        var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
        if (this._orient === "vertical") {
          return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
        }
        return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
      },
      /**
       * Convert a (x, y) point to time data
       *
       * @override
       * @param  {string} point point
       * @return {string}       data
       */
      pointToData: function(point) {
        var date = this.pointToDate(point);
        return date && date.time;
      },
      /**
       * Convert a time date item to (x, y) four point.
       *
       * @param  {Array} data  date[0] is date
       * @param  {boolean} [clamp=true]  out of range
       * @return {Object}       point
       */
      dataToRect: function(data, clamp) {
        var point = this.dataToPoint(data, clamp);
        return {
          contentShape: {
            x: point[0] - (this._sw - this._lineWidth) / 2,
            y: point[1] - (this._sh - this._lineWidth) / 2,
            width: this._sw - this._lineWidth,
            height: this._sh - this._lineWidth
          },
          center: point,
          tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
          tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
          br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
          bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
        };
      },
      /**
       * Convert a (x, y) point to time date
       *
       * @param  {Array} point point
       * @return {Object}       date
       */
      pointToDate: function(point) {
        var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
        var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
        var range = this._rangeInfo.range;
        if (this._orient === "vertical") {
          return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
        }
        return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
      },
      /**
       * @inheritDoc
       */
      convertToPixel: zrUtil.curry(doConvert, "dataToPoint"),
      /**
       * @inheritDoc
       */
      convertFromPixel: zrUtil.curry(doConvert, "pointToData"),
      /**
       * initRange
       *
       * @private
       * @return {Array} [start, end]
       */
      _initRangeOption: function() {
        var range = this._model.get("range");
        var rg = range;
        if (zrUtil.isArray(rg) && rg.length === 1) {
          rg = rg[0];
        }
        if (/^\d{4}$/.test(rg)) {
          range = [rg + "-01-01", rg + "-12-31"];
        }
        if (/^\d{4}[\/|-]\d{1,2}$/.test(rg)) {
          var start = this.getDateInfo(rg);
          var firstDay = start.date;
          firstDay.setMonth(firstDay.getMonth() + 1);
          var end = this.getNextNDay(firstDay, -1);
          range = [start.formatedDate, end.formatedDate];
        }
        if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rg)) {
          range = [rg, rg];
        }
        var tmp = this._getRangeInfo(range);
        if (tmp.start.time > tmp.end.time) {
          range.reverse();
        }
        return range;
      },
      /**
       * range info
       *
       * @private
       * @param  {Array} range range ['2017-01-01', '2017-07-08']
       *  If range[0] > range[1], they will not be reversed.
       * @return {Object}       obj
       */
      _getRangeInfo: function(range) {
        range = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
        var reversed;
        if (range[0].time > range[1].time) {
          reversed = true;
          range.reverse();
        }
        var allDay = Math.floor(range[1].time / PROXIMATE_ONE_DAY) - Math.floor(range[0].time / PROXIMATE_ONE_DAY) + 1;
        var date = new Date(range[0].time);
        var startDateNum = date.getDate();
        var endDateNum = range[1].date.getDate();
        date.setDate(startDateNum + allDay - 1);
        var dateNum = date.getDate();
        if (dateNum !== endDateNum) {
          var sign = date.getTime() - range[1].time > 0 ? 1 : -1;
          while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - range[1].time) * sign > 0) {
            allDay -= sign;
            date.setDate(dateNum - sign);
          }
        }
        var weeks = Math.floor((allDay + range[0].day + 6) / 7);
        var nthWeek = reversed ? -weeks + 1 : weeks - 1;
        reversed && range.reverse();
        return {
          range: [range[0].formatedDate, range[1].formatedDate],
          start: range[0],
          end: range[1],
          allDay,
          weeks,
          // From 0.
          nthWeek,
          fweek: range[0].day,
          lweek: range[1].day
        };
      },
      /**
       * get date by nthWeeks and week day in range
       *
       * @private
       * @param  {number} nthWeek the week
       * @param  {number} day   the week day
       * @param  {Array} range [d1, d2]
       * @return {Object}
       */
      _getDateByWeeksAndDay: function(nthWeek, day, range) {
        var rangeInfo = this._getRangeInfo(range);
        if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
          return false;
        }
        var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
        var date = new Date(rangeInfo.start.time);
        date.setDate(rangeInfo.start.d + nthDay);
        return this.getDateInfo(date);
      }
    };
    Calendar.dimensions = Calendar.prototype.dimensions;
    Calendar.getDimensionsInfo = Calendar.prototype.getDimensionsInfo;
    Calendar.create = function(ecModel, api) {
      var calendarList = [];
      ecModel.eachComponent("calendar", function(calendarModel) {
        var calendar = new Calendar(calendarModel, ecModel, api);
        calendarList.push(calendar);
        calendarModel.coordinateSystem = calendar;
      });
      ecModel.eachSeries(function(calendarSeries) {
        if (calendarSeries.get("coordinateSystem") === "calendar") {
          calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
        }
      });
      return calendarList;
    };
    function doConvert(methodName, ecModel, finder, value) {
      var calendarModel = finder.calendarModel;
      var seriesModel = finder.seriesModel;
      var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
      return coordSys === this ? coordSys[methodName](value) : null;
    }
    CoordinateSystem.register("calendar", Calendar);
    var _default = Calendar;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/CalendarModel.js
var require_CalendarModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/coord/calendar/CalendarModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var _layout = require_layout();
    var getLayoutParams = _layout.getLayoutParams;
    var sizeCalculable = _layout.sizeCalculable;
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var CalendarModel = ComponentModel.extend({
      type: "calendar",
      /**
       * @type {module:echarts/coord/calendar/Calendar}
       */
      coordinateSystem: null,
      defaultOption: {
        zlevel: 0,
        z: 2,
        left: 80,
        top: 60,
        cellSize: 20,
        // horizontal vertical
        orient: "horizontal",
        // month separate line style
        splitLine: {
          show: true,
          lineStyle: {
            color: "#000",
            width: 1,
            type: "solid"
          }
        },
        // rect style  temporarily unused emphasis
        itemStyle: {
          color: "#fff",
          borderWidth: 1,
          borderColor: "#ccc"
        },
        // week text style
        dayLabel: {
          show: true,
          // a week first day
          firstDay: 0,
          // start end
          position: "start",
          margin: "50%",
          // 50% of cellSize
          nameMap: "en",
          color: "#000"
        },
        // month text style
        monthLabel: {
          show: true,
          // start end
          position: "start",
          margin: 5,
          // center or left
          align: "center",
          // cn en []
          nameMap: "en",
          formatter: null,
          color: "#000"
        },
        // year text style
        yearLabel: {
          show: true,
          // top bottom left right
          position: null,
          margin: 30,
          formatter: null,
          color: "#ccc",
          fontFamily: "sans-serif",
          fontWeight: "bolder",
          fontSize: 20
        }
      },
      /**
       * @override
       */
      init: function(option, parentModel, ecModel, extraOpt) {
        var inputPositionParams = getLayoutParams(option);
        CalendarModel.superApply(this, "init", arguments);
        mergeAndNormalizeLayoutParams(option, inputPositionParams);
      },
      /**
       * @override
       */
      mergeOption: function(option, extraOpt) {
        CalendarModel.superApply(this, "mergeOption", arguments);
        mergeAndNormalizeLayoutParams(this.option, option);
      }
    });
    function mergeAndNormalizeLayoutParams(target, raw) {
      var cellSize = target.cellSize;
      if (!zrUtil.isArray(cellSize)) {
        cellSize = target.cellSize = [cellSize, cellSize];
      } else if (cellSize.length === 1) {
        cellSize[1] = cellSize[0];
      }
      var ignoreSize = zrUtil.map([0, 1], function(hvIdx) {
        if (sizeCalculable(raw, hvIdx)) {
          cellSize[hvIdx] = "auto";
        }
        return cellSize[hvIdx] != null && cellSize[hvIdx] !== "auto";
      });
      mergeLayoutParam(target, raw, {
        type: "box",
        ignoreSize
      });
    }
    var _default = CalendarModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar/CalendarView.js
var require_CalendarView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar/CalendarView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var formatUtil = require_format();
    var numberUtil = require_number();
    var MONTH_TEXT = {
      EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      CN: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
    };
    var WEEK_TEXT = {
      EN: ["S", "M", "T", "W", "T", "F", "S"],
      CN: ["日", "一", "二", "三", "四", "五", "六"]
    };
    var _default = echarts.extendComponentView({
      type: "calendar",
      /**
       * top/left line points
       *  @private
       */
      _tlpoints: null,
      /**
       * bottom/right line points
       *  @private
       */
      _blpoints: null,
      /**
       * first day of month
       *  @private
       */
      _firstDayOfMonth: null,
      /**
       * first day point of month
       *  @private
       */
      _firstDayPoints: null,
      render: function(calendarModel, ecModel, api) {
        var group = this.group;
        group.removeAll();
        var coordSys = calendarModel.coordinateSystem;
        var rangeData = coordSys.getRangeInfo();
        var orient = coordSys.getOrient();
        this._renderDayRect(calendarModel, rangeData, group);
        this._renderLines(calendarModel, rangeData, orient, group);
        this._renderYearText(calendarModel, rangeData, orient, group);
        this._renderMonthText(calendarModel, orient, group);
        this._renderWeekText(calendarModel, rangeData, orient, group);
      },
      // render day rect
      _renderDayRect: function(calendarModel, rangeData, group) {
        var coordSys = calendarModel.coordinateSystem;
        var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
        var sw = coordSys.getCellWidth();
        var sh = coordSys.getCellHeight();
        for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
          var point = coordSys.dataToRect([i], false).tl;
          var rect = new graphic.Rect({
            shape: {
              x: point[0],
              y: point[1],
              width: sw,
              height: sh
            },
            cursor: "default",
            style: itemRectStyleModel
          });
          group.add(rect);
        }
      },
      // render separate line
      _renderLines: function(calendarModel, rangeData, orient, group) {
        var self2 = this;
        var coordSys = calendarModel.coordinateSystem;
        var lineStyleModel = calendarModel.getModel("splitLine.lineStyle").getLineStyle();
        var show = calendarModel.get("splitLine.show");
        var lineWidth = lineStyleModel.lineWidth;
        this._tlpoints = [];
        this._blpoints = [];
        this._firstDayOfMonth = [];
        this._firstDayPoints = [];
        var firstDay = rangeData.start;
        for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
          addPoints(firstDay.formatedDate);
          if (i === 0) {
            firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
          }
          var date = firstDay.date;
          date.setMonth(date.getMonth() + 1);
          firstDay = coordSys.getDateInfo(date);
        }
        addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
        function addPoints(date2) {
          self2._firstDayOfMonth.push(coordSys.getDateInfo(date2));
          self2._firstDayPoints.push(coordSys.dataToRect([date2], false).tl);
          var points = self2._getLinePointsOfOneWeek(calendarModel, date2, orient);
          self2._tlpoints.push(points[0]);
          self2._blpoints.push(points[points.length - 1]);
          show && self2._drawSplitline(points, lineStyleModel, group);
        }
        show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
        show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
      },
      // get points at both ends
      _getEdgesPoints: function(points, lineWidth, orient) {
        var rs = [points[0].slice(), points[points.length - 1].slice()];
        var idx = orient === "horizontal" ? 0 : 1;
        rs[0][idx] = rs[0][idx] - lineWidth / 2;
        rs[1][idx] = rs[1][idx] + lineWidth / 2;
        return rs;
      },
      // render split line
      _drawSplitline: function(points, lineStyleModel, group) {
        var poyline = new graphic.Polyline({
          z2: 20,
          shape: {
            points
          },
          style: lineStyleModel
        });
        group.add(poyline);
      },
      // render month line of one week points
      _getLinePointsOfOneWeek: function(calendarModel, date, orient) {
        var coordSys = calendarModel.coordinateSystem;
        date = coordSys.getDateInfo(date);
        var points = [];
        for (var i = 0; i < 7; i++) {
          var tmpD = coordSys.getNextNDay(date.time, i);
          var point = coordSys.dataToRect([tmpD.time], false);
          points[2 * tmpD.day] = point.tl;
          points[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
        }
        return points;
      },
      _formatterLabel: function(formatter, params) {
        if (typeof formatter === "string" && formatter) {
          return formatUtil.formatTplSimple(formatter, params);
        }
        if (typeof formatter === "function") {
          return formatter(params);
        }
        return params.nameMap;
      },
      _yearTextPositionControl: function(textEl, point, orient, position, margin) {
        point = point.slice();
        var aligns = ["center", "bottom"];
        if (position === "bottom") {
          point[1] += margin;
          aligns = ["center", "top"];
        } else if (position === "left") {
          point[0] -= margin;
        } else if (position === "right") {
          point[0] += margin;
          aligns = ["center", "top"];
        } else {
          point[1] -= margin;
        }
        var rotate = 0;
        if (position === "left" || position === "right") {
          rotate = Math.PI / 2;
        }
        return {
          rotation: rotate,
          position: point,
          style: {
            textAlign: aligns[0],
            textVerticalAlign: aligns[1]
          }
        };
      },
      // render year
      _renderYearText: function(calendarModel, rangeData, orient, group) {
        var yearLabel = calendarModel.getModel("yearLabel");
        if (!yearLabel.get("show")) {
          return;
        }
        var margin = yearLabel.get("margin");
        var pos = yearLabel.get("position");
        if (!pos) {
          pos = orient !== "horizontal" ? "top" : "left";
        }
        var points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
        var xc = (points[0][0] + points[1][0]) / 2;
        var yc = (points[0][1] + points[1][1]) / 2;
        var idx = orient === "horizontal" ? 0 : 1;
        var posPoints = {
          top: [xc, points[idx][1]],
          bottom: [xc, points[1 - idx][1]],
          left: [points[1 - idx][0], yc],
          right: [points[idx][0], yc]
        };
        var name2 = rangeData.start.y;
        if (+rangeData.end.y > +rangeData.start.y) {
          name2 = name2 + "-" + rangeData.end.y;
        }
        var formatter = yearLabel.get("formatter");
        var params = {
          start: rangeData.start.y,
          end: rangeData.end.y,
          nameMap: name2
        };
        var content = this._formatterLabel(formatter, params);
        var yearText = new graphic.Text({
          z2: 30
        });
        graphic.setTextStyle(yearText.style, yearLabel, {
          text: content
        }), yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
        group.add(yearText);
      },
      _monthTextPositionControl: function(point, isCenter, orient, position, margin) {
        var align = "left";
        var vAlign = "top";
        var x = point[0];
        var y = point[1];
        if (orient === "horizontal") {
          y = y + margin;
          if (isCenter) {
            align = "center";
          }
          if (position === "start") {
            vAlign = "bottom";
          }
        } else {
          x = x + margin;
          if (isCenter) {
            vAlign = "middle";
          }
          if (position === "start") {
            align = "right";
          }
        }
        return {
          x,
          y,
          textAlign: align,
          textVerticalAlign: vAlign
        };
      },
      // render month and year text
      _renderMonthText: function(calendarModel, orient, group) {
        var monthLabel = calendarModel.getModel("monthLabel");
        if (!monthLabel.get("show")) {
          return;
        }
        var nameMap = monthLabel.get("nameMap");
        var margin = monthLabel.get("margin");
        var pos = monthLabel.get("position");
        var align = monthLabel.get("align");
        var termPoints = [this._tlpoints, this._blpoints];
        if (zrUtil.isString(nameMap)) {
          nameMap = MONTH_TEXT[nameMap.toUpperCase()] || [];
        }
        var idx = pos === "start" ? 0 : 1;
        var axis = orient === "horizontal" ? 0 : 1;
        margin = pos === "start" ? -margin : margin;
        var isCenter = align === "center";
        for (var i = 0; i < termPoints[idx].length - 1; i++) {
          var tmp = termPoints[idx][i].slice();
          var firstDay = this._firstDayOfMonth[i];
          if (isCenter) {
            var firstDayPoints = this._firstDayPoints[i];
            tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
          }
          var formatter = monthLabel.get("formatter");
          var name2 = nameMap[+firstDay.m - 1];
          var params = {
            yyyy: firstDay.y,
            yy: (firstDay.y + "").slice(2),
            MM: firstDay.m,
            M: +firstDay.m,
            nameMap: name2
          };
          var content = this._formatterLabel(formatter, params);
          var monthText = new graphic.Text({
            z2: 30
          });
          zrUtil.extend(graphic.setTextStyle(monthText.style, monthLabel, {
            text: content
          }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin));
          group.add(monthText);
        }
      },
      _weekTextPositionControl: function(point, orient, position, margin, cellSize) {
        var align = "center";
        var vAlign = "middle";
        var x = point[0];
        var y = point[1];
        var isStart = position === "start";
        if (orient === "horizontal") {
          x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
          align = isStart ? "right" : "left";
        } else {
          y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
          vAlign = isStart ? "bottom" : "top";
        }
        return {
          x,
          y,
          textAlign: align,
          textVerticalAlign: vAlign
        };
      },
      // render weeks
      _renderWeekText: function(calendarModel, rangeData, orient, group) {
        var dayLabel = calendarModel.getModel("dayLabel");
        if (!dayLabel.get("show")) {
          return;
        }
        var coordSys = calendarModel.coordinateSystem;
        var pos = dayLabel.get("position");
        var nameMap = dayLabel.get("nameMap");
        var margin = dayLabel.get("margin");
        var firstDayOfWeek = coordSys.getFirstDayOfWeek();
        if (zrUtil.isString(nameMap)) {
          nameMap = WEEK_TEXT[nameMap.toUpperCase()] || [];
        }
        var start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
        var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
        margin = numberUtil.parsePercent(margin, cellSize[orient === "horizontal" ? 0 : 1]);
        if (pos === "start") {
          start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
          margin = -margin;
        }
        for (var i = 0; i < 7; i++) {
          var tmpD = coordSys.getNextNDay(start, i);
          var point = coordSys.dataToRect([tmpD.time], false).center;
          var day = i;
          day = Math.abs((i + firstDayOfWeek) % 7);
          var weekText = new graphic.Text({
            z2: 30
          });
          zrUtil.extend(graphic.setTextStyle(weekText.style, dayLabel, {
            text: nameMap[day]
          }), this._weekTextPositionControl(point, orient, pos, margin, cellSize));
          group.add(weekText);
        }
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar.js
var require_calendar = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/calendar.js"() {
    require_Calendar();
    require_CalendarModel();
    require_CalendarView();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/graphic.js
var require_graphic2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/graphic.js"() {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var modelUtil = require_model();
    var graphicUtil = require_graphic();
    var layoutUtil = require_layout();
    var _number = require_number();
    var parsePercent = _number.parsePercent;
    var _nonShapeGraphicElements = {
      // Reserved but not supported in graphic component.
      path: null,
      compoundPath: null,
      // Supported in graphic component.
      group: graphicUtil.Group,
      image: graphicUtil.Image,
      text: graphicUtil.Text
    };
    echarts.registerPreprocessor(function(option) {
      var graphicOption = option.graphic;
      if (zrUtil.isArray(graphicOption)) {
        if (!graphicOption[0] || !graphicOption[0].elements) {
          option.graphic = [{
            elements: graphicOption
          }];
        } else {
          option.graphic = [option.graphic[0]];
        }
      } else if (graphicOption && !graphicOption.elements) {
        option.graphic = [{
          elements: [graphicOption]
        }];
      }
    });
    var GraphicModel = echarts.extendComponentModel({
      type: "graphic",
      defaultOption: {
        // Extra properties for each elements:
        //
        // left/right/top/bottom: (like 12, '22%', 'center', default undefined)
        //      If left/rigth is set, shape.x/shape.cx/position will not be used.
        //      If top/bottom is set, shape.y/shape.cy/position will not be used.
        //      This mechanism is useful when you want to position a group/element
        //      against the right side or the center of this container.
        //
        // width/height: (can only be pixel value, default 0)
        //      Only be used to specify contianer(group) size, if needed. And
        //      can not be percentage value (like '33%'). See the reason in the
        //      layout algorithm below.
        //
        // bounding: (enum: 'all' (default) | 'raw')
        //      Specify how to calculate boundingRect when locating.
        //      'all': Get uioned and transformed boundingRect
        //          from both itself and its descendants.
        //          This mode simplies confining a group of elements in the bounding
        //          of their ancester container (e.g., using 'right: 0').
        //      'raw': Only use the boundingRect of itself and before transformed.
        //          This mode is similar to css behavior, which is useful when you
        //          want an element to be able to overflow its container. (Consider
        //          a rotated circle needs to be located in a corner.)
        // info: custom info. enables user to mount some info on elements and use them
        //      in event handlers. Update them only when user specified, otherwise, remain.
        // Note: elements is always behind its ancestors in this elements array.
        elements: [],
        parentId: null
      },
      /**
       * Save el options for the sake of the performance (only update modified graphics).
       * The order is the same as those in option. (ancesters -> descendants)
       *
       * @private
       * @type {Array.<Object>}
       */
      _elOptionsToUpdate: null,
      /**
       * @override
       */
      mergeOption: function(option) {
        var elements = this.option.elements;
        this.option.elements = null;
        GraphicModel.superApply(this, "mergeOption", arguments);
        this.option.elements = elements;
      },
      /**
       * @override
       */
      optionUpdated: function(newOption, isInit) {
        var thisOption = this.option;
        var newList = (isInit ? thisOption : newOption).elements;
        var existList = thisOption.elements = isInit ? [] : thisOption.elements;
        var flattenedList = [];
        this._flatten(newList, flattenedList);
        var mappingResult = modelUtil.mappingToExists(existList, flattenedList);
        modelUtil.makeIdAndName(mappingResult);
        var elOptionsToUpdate = this._elOptionsToUpdate = [];
        zrUtil.each(mappingResult, function(resultItem, index) {
          var newElOption = resultItem.option;
          if (!newElOption) {
            return;
          }
          elOptionsToUpdate.push(newElOption);
          setKeyInfoToNewElOption(resultItem, newElOption);
          mergeNewElOptionToExist(existList, index, newElOption);
          setLayoutInfoToExist(existList[index], newElOption);
        }, this);
        for (var i = existList.length - 1; i >= 0; i--) {
          if (existList[i] == null) {
            existList.splice(i, 1);
          } else {
            delete existList[i].$action;
          }
        }
      },
      /**
       * Convert
       * [{
       *  type: 'group',
       *  id: 'xx',
       *  children: [{type: 'circle'}, {type: 'polygon'}]
       * }]
       * to
       * [
       *  {type: 'group', id: 'xx'},
       *  {type: 'circle', parentId: 'xx'},
       *  {type: 'polygon', parentId: 'xx'}
       * ]
       *
       * @private
       * @param {Array.<Object>} optionList option list
       * @param {Array.<Object>} result result of flatten
       * @param {Object} parentOption parent option
       */
      _flatten: function(optionList, result, parentOption) {
        zrUtil.each(optionList, function(option) {
          if (!option) {
            return;
          }
          if (parentOption) {
            option.parentOption = parentOption;
          }
          result.push(option);
          var children = option.children;
          if (option.type === "group" && children) {
            this._flatten(children, result, option);
          }
          delete option.children;
        }, this);
      },
      // FIXME
      // Pass to view using payload? setOption has a payload?
      useElOptionsToUpdate: function() {
        var els = this._elOptionsToUpdate;
        this._elOptionsToUpdate = null;
        return els;
      }
    });
    echarts.extendComponentView({
      type: "graphic",
      /**
       * @override
       */
      init: function(ecModel, api) {
        this._elMap = zrUtil.createHashMap();
        this._lastGraphicModel;
      },
      /**
       * @override
       */
      render: function(graphicModel, ecModel, api) {
        if (graphicModel !== this._lastGraphicModel) {
          this._clear();
        }
        this._lastGraphicModel = graphicModel;
        this._updateElements(graphicModel);
        this._relocate(graphicModel, api);
      },
      /**
       * Update graphic elements.
       *
       * @private
       * @param {Object} graphicModel graphic model
       */
      _updateElements: function(graphicModel) {
        var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
        if (!elOptionsToUpdate) {
          return;
        }
        var elMap = this._elMap;
        var rootGroup = this.group;
        zrUtil.each(elOptionsToUpdate, function(elOption) {
          var $action = elOption.$action;
          var id = elOption.id;
          var existEl = elMap.get(id);
          var parentId = elOption.parentId;
          var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
          var elOptionStyle = elOption.style;
          if (elOption.type === "text" && elOptionStyle) {
            if (elOption.hv && elOption.hv[1]) {
              elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null;
            }
            !elOptionStyle.hasOwnProperty("textFill") && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
            !elOptionStyle.hasOwnProperty("textStroke") && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
          }
          var elOptionCleaned = getCleanedElOption(elOption);
          if (!$action || $action === "merge") {
            existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap);
          } else if ($action === "replace") {
            removeEl(existEl, elMap);
            createEl(id, targetElParent, elOptionCleaned, elMap);
          } else if ($action === "remove") {
            removeEl(existEl, elMap);
          }
          var el = elMap.get(id);
          if (el) {
            el.__ecGraphicWidthOption = elOption.width;
            el.__ecGraphicHeightOption = elOption.height;
            setEventData(el, graphicModel, elOption);
          }
        });
      },
      /**
       * Locate graphic elements.
       *
       * @private
       * @param {Object} graphicModel graphic model
       * @param {module:echarts/ExtensionAPI} api extension API
       */
      _relocate: function(graphicModel, api) {
        var elOptions = graphicModel.option.elements;
        var rootGroup = this.group;
        var elMap = this._elMap;
        var apiWidth = api.getWidth();
        var apiHeight = api.getHeight();
        for (var i = 0; i < elOptions.length; i++) {
          var elOption = elOptions[i];
          var el = elMap.get(elOption.id);
          if (!el || !el.isGroup) {
            continue;
          }
          var parentEl = el.parent;
          var isParentRoot = parentEl === rootGroup;
          el.__ecGraphicWidth = parsePercent(el.__ecGraphicWidthOption, isParentRoot ? apiWidth : parentEl.__ecGraphicWidth) || 0;
          el.__ecGraphicHeight = parsePercent(el.__ecGraphicHeightOption, isParentRoot ? apiHeight : parentEl.__ecGraphicHeight) || 0;
        }
        for (var i = elOptions.length - 1; i >= 0; i--) {
          var elOption = elOptions[i];
          var el = elMap.get(elOption.id);
          if (!el) {
            continue;
          }
          var parentEl = el.parent;
          var containerInfo = parentEl === rootGroup ? {
            width: apiWidth,
            height: apiHeight
          } : {
            width: parentEl.__ecGraphicWidth,
            height: parentEl.__ecGraphicHeight
          };
          layoutUtil.positionElement(el, elOption, containerInfo, null, {
            hv: elOption.hv,
            boundingMode: elOption.bounding
          });
        }
      },
      /**
       * Clear all elements.
       *
       * @private
       */
      _clear: function() {
        var elMap = this._elMap;
        elMap.each(function(el) {
          removeEl(el, elMap);
        });
        this._elMap = zrUtil.createHashMap();
      },
      /**
       * @override
       */
      dispose: function() {
        this._clear();
      }
    });
    function createEl(id, targetElParent, elOption, elMap) {
      var graphicType = elOption.type;
      var Clz = _nonShapeGraphicElements.hasOwnProperty(graphicType) ? _nonShapeGraphicElements[graphicType] : graphicUtil.getShapeClass(graphicType);
      var el = new Clz(elOption);
      targetElParent.add(el);
      elMap.set(id, el);
      el.__ecGraphicId = id;
    }
    function removeEl(existEl, elMap) {
      var existElParent = existEl && existEl.parent;
      if (existElParent) {
        existEl.type === "group" && existEl.traverse(function(el) {
          removeEl(el, elMap);
        });
        elMap.removeKey(existEl.__ecGraphicId);
        existElParent.remove(existEl);
      }
    }
    function getCleanedElOption(elOption) {
      elOption = zrUtil.extend({}, elOption);
      zrUtil.each(["id", "parentId", "$action", "hv", "bounding"].concat(layoutUtil.LOCATION_PARAMS), function(name2) {
        delete elOption[name2];
      });
      return elOption;
    }
    function isSetLoc(obj, props) {
      var isSet;
      zrUtil.each(props, function(prop) {
        obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
      });
      return isSet;
    }
    function setKeyInfoToNewElOption(resultItem, newElOption) {
      var existElOption = resultItem.exist;
      newElOption.id = resultItem.keyInfo.id;
      !newElOption.type && existElOption && (newElOption.type = existElOption.type);
      if (newElOption.parentId == null) {
        var newElParentOption = newElOption.parentOption;
        if (newElParentOption) {
          newElOption.parentId = newElParentOption.id;
        } else if (existElOption) {
          newElOption.parentId = existElOption.parentId;
        }
      }
      newElOption.parentOption = null;
    }
    function mergeNewElOptionToExist(existList, index, newElOption) {
      var newElOptCopy = zrUtil.extend({}, newElOption);
      var existElOption = existList[index];
      var $action = newElOption.$action || "merge";
      if ($action === "merge") {
        if (existElOption) {
          zrUtil.merge(existElOption, newElOptCopy, true);
          layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {
            ignoreSize: true
          });
          layoutUtil.copyLayoutParams(newElOption, existElOption);
        } else {
          existList[index] = newElOptCopy;
        }
      } else if ($action === "replace") {
        existList[index] = newElOptCopy;
      } else if ($action === "remove") {
        existElOption && (existList[index] = null);
      }
    }
    function setLayoutInfoToExist(existItem, newElOption) {
      if (!existItem) {
        return;
      }
      existItem.hv = newElOption.hv = [
        // Rigid body, dont care `width`.
        isSetLoc(newElOption, ["left", "right"]),
        // Rigid body, dont care `height`.
        isSetLoc(newElOption, ["top", "bottom"])
      ];
      if (existItem.type === "group") {
        existItem.width == null && (existItem.width = newElOption.width = 0);
        existItem.height == null && (existItem.height = newElOption.height = 0);
      }
    }
    function setEventData(el, graphicModel, elOption) {
      var eventData = el.eventData;
      if (!el.silent && !el.ignore && !eventData) {
        eventData = el.eventData = {
          componentType: "graphic",
          componentIndex: graphicModel.componentIndex,
          name: el.name
        };
      }
      if (eventData) {
        eventData.info = el.info;
      }
    }
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/featureManager.js
var require_featureManager = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/featureManager.js"(exports) {
    var features = {};
    function register(name2, ctor) {
      features[name2] = ctor;
    }
    function get(name2) {
      return features[name2];
    }
    exports.register = register;
    exports.get = get;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxModel.js
var require_ToolboxModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var featureManager = require_featureManager();
    var ToolboxModel = echarts.extendComponentModel({
      type: "toolbox",
      layoutMode: {
        type: "box",
        ignoreSize: true
      },
      optionUpdated: function() {
        ToolboxModel.superApply(this, "optionUpdated", arguments);
        zrUtil.each(this.option.feature, function(featureOpt, featureName) {
          var Feature = featureManager.get(featureName);
          Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
        });
      },
      defaultOption: {
        show: true,
        z: 6,
        zlevel: 0,
        orient: "horizontal",
        left: "right",
        top: "top",
        // right
        // bottom
        backgroundColor: "transparent",
        borderColor: "#ccc",
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemSize: 15,
        itemGap: 8,
        showTitle: true,
        iconStyle: {
          borderColor: "#666",
          color: "none"
        },
        emphasis: {
          iconStyle: {
            borderColor: "#3E98C5"
          }
        },
        // textStyle: {},
        // feature
        tooltip: {
          show: false
        }
      }
    });
    var _default = ToolboxModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/listComponent.js
var require_listComponent = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/listComponent.js"(exports) {
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var layoutBox = _layout.box;
    var positionElement = _layout.positionElement;
    var formatUtil = require_format();
    var graphic = require_graphic();
    function layout(group, componentModel, api) {
      var boxLayoutParams = componentModel.getBoxLayoutParams();
      var padding = componentModel.get("padding");
      var viewportSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
      layoutBox(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
      positionElement(group, boxLayoutParams, viewportSize, padding);
    }
    function makeBackground(rect, componentModel) {
      var padding = formatUtil.normalizeCssArray(componentModel.get("padding"));
      var style = componentModel.getItemStyle(["color", "opacity"]);
      style.fill = componentModel.get("backgroundColor");
      var rect = new graphic.Rect({
        shape: {
          x: rect.x - padding[3],
          y: rect.y - padding[0],
          width: rect.width + padding[1] + padding[3],
          height: rect.height + padding[0] + padding[2],
          r: componentModel.get("borderRadius")
        },
        style,
        silent: true,
        z2: -1
      });
      return rect;
    }
    exports.layout = layout;
    exports.makeBackground = makeBackground;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxView.js
var require_ToolboxView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/ToolboxView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var textContain = require_text();
    var featureManager = require_featureManager();
    var graphic = require_graphic();
    var Model = require_Model();
    var DataDiffer = require_DataDiffer();
    var listComponentHelper = require_listComponent();
    var _default = echarts.extendComponentView({
      type: "toolbox",
      render: function(toolboxModel, ecModel, api, payload) {
        var group = this.group;
        group.removeAll();
        if (!toolboxModel.get("show")) {
          return;
        }
        var itemSize = +toolboxModel.get("itemSize");
        var featureOpts = toolboxModel.get("feature") || {};
        var features = this._features || (this._features = {});
        var featureNames = [];
        zrUtil.each(featureOpts, function(opt, name2) {
          featureNames.push(name2);
        });
        new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil.curry(processFeature, null)).execute();
        this._featureNames = featureNames;
        function processFeature(newIndex, oldIndex) {
          var featureName = featureNames[newIndex];
          var oldName = featureNames[oldIndex];
          var featureOpt = featureOpts[featureName];
          var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
          var feature;
          if (payload && payload.newTitle != null && payload.featureName === featureName) {
            featureOpt.title = payload.newTitle;
          }
          if (featureName && !oldName) {
            if (isUserFeatureName(featureName)) {
              feature = {
                model: featureModel,
                onclick: featureModel.option.onclick,
                featureName
              };
            } else {
              var Feature = featureManager.get(featureName);
              if (!Feature) {
                return;
              }
              feature = new Feature(featureModel, ecModel, api);
            }
            features[featureName] = feature;
          } else {
            feature = features[oldName];
            if (!feature) {
              return;
            }
            feature.model = featureModel;
            feature.ecModel = ecModel;
            feature.api = api;
          }
          if (!featureName && oldName) {
            feature.dispose && feature.dispose(ecModel, api);
            return;
          }
          if (!featureModel.get("show") || feature.unusable) {
            feature.remove && feature.remove(ecModel, api);
            return;
          }
          createIconPaths(featureModel, feature, featureName);
          featureModel.setIconStatus = function(iconName, status) {
            var option = this.option;
            var iconPaths = this.iconPaths;
            option.iconStatus = option.iconStatus || {};
            option.iconStatus[iconName] = status;
            iconPaths[iconName] && iconPaths[iconName].trigger(status);
          };
          if (feature.render) {
            feature.render(featureModel, ecModel, api, payload);
          }
        }
        function createIconPaths(featureModel, feature, featureName) {
          var iconStyleModel = featureModel.getModel("iconStyle");
          var iconStyleEmphasisModel = featureModel.getModel("emphasis.iconStyle");
          var icons = feature.getIcons ? feature.getIcons() : featureModel.get("icon");
          var titles = featureModel.get("title") || {};
          if (typeof icons === "string") {
            var icon = icons;
            var title = titles;
            icons = {};
            titles = {};
            icons[featureName] = icon;
            titles[featureName] = title;
          }
          var iconPaths = featureModel.iconPaths = {};
          zrUtil.each(icons, function(iconStr, iconName) {
            var path = graphic.createIcon(iconStr, {}, {
              x: -itemSize / 2,
              y: -itemSize / 2,
              width: itemSize,
              height: itemSize
            });
            path.setStyle(iconStyleModel.getItemStyle());
            path.hoverStyle = iconStyleEmphasisModel.getItemStyle();
            path.setStyle({
              text: titles[iconName],
              textAlign: iconStyleEmphasisModel.get("textAlign"),
              textBorderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
              textPadding: iconStyleEmphasisModel.get("textPadding"),
              textFill: null
            });
            var tooltipModel = toolboxModel.getModel("tooltip");
            if (tooltipModel && tooltipModel.get("show")) {
              path.attr("tooltip", zrUtil.extend({
                content: titles[iconName],
                formatter: tooltipModel.get("formatter", true) || function() {
                  return titles[iconName];
                },
                formatterParams: {
                  componentType: "toolbox",
                  name: iconName,
                  title: titles[iconName],
                  $vars: ["name", "title"]
                },
                position: tooltipModel.get("position", true) || "bottom"
              }, tooltipModel.option));
            }
            graphic.setHoverStyle(path);
            if (toolboxModel.get("showTitle")) {
              path.__title = titles[iconName];
              path.on("mouseover", function() {
                var hoverStyle = iconStyleEmphasisModel.getItemStyle();
                var defaultTextPosition = toolboxModel.get("orient") === "vertical" ? toolboxModel.get("right") == null ? "right" : "left" : toolboxModel.get("bottom") == null ? "bottom" : "top";
                path.setStyle({
                  textFill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
                  textBackgroundColor: iconStyleEmphasisModel.get("textBackgroundColor"),
                  textPosition: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
                });
              }).on("mouseout", function() {
                path.setStyle({
                  textFill: null,
                  textBackgroundColor: null
                });
              });
            }
            path.trigger(featureModel.get("iconStatus." + iconName) || "normal");
            group.add(path);
            path.on("click", zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
            iconPaths[iconName] = path;
          });
        }
        listComponentHelper.layout(group, toolboxModel, api);
        group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel));
        group.eachChild(function(icon) {
          var titleText = icon.__title;
          var hoverStyle = icon.hoverStyle;
          if (hoverStyle && titleText) {
            var rect = textContain.getBoundingRect(titleText, textContain.makeFont(hoverStyle));
            var offsetX = icon.position[0] + group.position[0];
            var offsetY = icon.position[1] + group.position[1] + itemSize;
            var needPutOnTop = false;
            if (offsetY + rect.height > api.getHeight()) {
              hoverStyle.textPosition = "top";
              needPutOnTop = true;
            }
            var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;
            if (offsetX + rect.width / 2 > api.getWidth()) {
              hoverStyle.textPosition = ["100%", topOffset];
              hoverStyle.textAlign = "right";
            } else if (offsetX - rect.width / 2 < 0) {
              hoverStyle.textPosition = [0, topOffset];
              hoverStyle.textAlign = "left";
            }
          }
        });
      },
      updateView: function(toolboxModel, ecModel, api, payload) {
        zrUtil.each(this._features, function(feature) {
          feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
        });
      },
      // updateLayout: function (toolboxModel, ecModel, api, payload) {
      //     zrUtil.each(this._features, function (feature) {
      //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
      //     });
      // },
      remove: function(ecModel, api) {
        zrUtil.each(this._features, function(feature) {
          feature.remove && feature.remove(ecModel, api);
        });
        this.group.removeAll();
      },
      dispose: function(ecModel, api) {
        zrUtil.each(this._features, function(feature) {
          feature.dispose && feature.dispose(ecModel, api);
        });
      }
    });
    function isUserFeatureName(featureName) {
      return featureName.indexOf("my") === 0;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js
var require_SaveAsImage = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/SaveAsImage.js"(exports, module) {
    var env = require_env();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var saveAsImageLang = lang.toolbox.saveAsImage;
    function SaveAsImage(model) {
      this.model = model;
    }
    SaveAsImage.defaultOption = {
      show: true,
      icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
      title: saveAsImageLang.title,
      type: "png",
      // Default use option.backgroundColor
      // backgroundColor: '#fff',
      connectedBackgroundColor: "#fff",
      name: "",
      excludeComponents: ["toolbox"],
      pixelRatio: 1,
      lang: saveAsImageLang.lang.slice()
    };
    SaveAsImage.prototype.unusable = !env.canvasSupported;
    var proto = SaveAsImage.prototype;
    proto.onclick = function(ecModel, api) {
      var model = this.model;
      var title = model.get("name") || ecModel.get("title.0.text") || "echarts";
      var isSvg = api.getZr().painter.getType() === "svg";
      var type = isSvg ? "svg" : model.get("type", true) || "png";
      var url = api.getConnectedDataURL({
        type,
        backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
        connectedBackgroundColor: model.get("connectedBackgroundColor"),
        excludeComponents: model.get("excludeComponents"),
        pixelRatio: model.get("pixelRatio")
      });
      if (typeof MouseEvent === "function" && !env.browser.ie && !env.browser.edge) {
        var $a = document.createElement("a");
        $a.download = title + "." + type;
        $a.target = "_blank";
        $a.href = url;
        var evt = new MouseEvent("click", {
          // some micro front-end framework， window maybe is a Proxy
          view: document.defaultView,
          bubbles: true,
          cancelable: false
        });
        $a.dispatchEvent(evt);
      } else {
        if (window.navigator.msSaveOrOpenBlob) {
          var bstr = atob(url.split(",")[1]);
          var n = bstr.length;
          var u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          var blob = new Blob([u8arr]);
          window.navigator.msSaveOrOpenBlob(blob, title + "." + type);
        } else {
          var lang2 = model.get("lang");
          var html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang2 && lang2[0] || "") + '" /></body>';
          var tab = window.open();
          tab.document.write(html);
        }
      }
    };
    featureManager.register("saveAsImage", SaveAsImage);
    var _default = SaveAsImage;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/MagicType.js
var require_MagicType = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/MagicType.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var magicTypeLang = lang.toolbox.magicType;
    var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
    function MagicType(model) {
      this.model = model;
    }
    MagicType.defaultOption = {
      show: true,
      type: [],
      // Icon group
      icon: {
        /* eslint-disable */
        line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
        bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
        stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
        // jshint ignore:line
        /* eslint-enable */
      },
      // `line`, `bar`, `stack`, `tiled`
      title: zrUtil.clone(magicTypeLang.title),
      option: {},
      seriesIndex: {}
    };
    var proto = MagicType.prototype;
    proto.getIcons = function() {
      var model = this.model;
      var availableIcons = model.get("icon");
      var icons = {};
      zrUtil.each(model.get("type"), function(type) {
        if (availableIcons[type]) {
          icons[type] = availableIcons[type];
        }
      });
      return icons;
    };
    var seriesOptGenreator = {
      "line": function(seriesType, seriesId, seriesModel, model) {
        if (seriesType === "bar") {
          return zrUtil.merge({
            id: seriesId,
            type: "line",
            // Preserve data related option
            data: seriesModel.get("data"),
            stack: seriesModel.get("stack"),
            markPoint: seriesModel.get("markPoint"),
            markLine: seriesModel.get("markLine")
          }, model.get("option.line") || {}, true);
        }
      },
      "bar": function(seriesType, seriesId, seriesModel, model) {
        if (seriesType === "line") {
          return zrUtil.merge({
            id: seriesId,
            type: "bar",
            // Preserve data related option
            data: seriesModel.get("data"),
            stack: seriesModel.get("stack"),
            markPoint: seriesModel.get("markPoint"),
            markLine: seriesModel.get("markLine")
          }, model.get("option.bar") || {}, true);
        }
      },
      "stack": function(seriesType, seriesId, seriesModel, model) {
        var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
        if (seriesType === "line" || seriesType === "bar") {
          model.setIconStatus("stack", isStack ? "normal" : "emphasis");
          return zrUtil.merge({
            id: seriesId,
            stack: isStack ? "" : INNER_STACK_KEYWORD
          }, model.get("option.stack") || {}, true);
        }
      }
    };
    var radioTypes = [["line", "bar"], ["stack"]];
    proto.onclick = function(ecModel, api, type) {
      var model = this.model;
      var seriesIndex = model.get("seriesIndex." + type);
      if (!seriesOptGenreator[type]) {
        return;
      }
      var newOption = {
        series: []
      };
      var generateNewSeriesTypes = function(seriesModel) {
        var seriesType = seriesModel.subType;
        var seriesId = seriesModel.id;
        var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);
        if (newSeriesOpt) {
          zrUtil.defaults(newSeriesOpt, seriesModel.option);
          newOption.series.push(newSeriesOpt);
        }
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
          var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
          if (categoryAxis) {
            var axisDim = categoryAxis.dim;
            var axisType = axisDim + "Axis";
            var axisModel = ecModel.queryComponents({
              mainType: axisType,
              index: seriesModel.get(name + "Index"),
              id: seriesModel.get(name + "Id")
            })[0];
            var axisIndex = axisModel.componentIndex;
            newOption[axisType] = newOption[axisType] || [];
            for (var i = 0; i <= axisIndex; i++) {
              newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
            }
            newOption[axisType][axisIndex].boundaryGap = type === "bar";
          }
        }
      };
      zrUtil.each(radioTypes, function(radio) {
        if (zrUtil.indexOf(radio, type) >= 0) {
          zrUtil.each(radio, function(item) {
            model.setIconStatus(item, "normal");
          });
        }
      });
      model.setIconStatus(type, "emphasis");
      ecModel.eachComponent({
        mainType: "series",
        query: seriesIndex == null ? null : {
          seriesIndex
        }
      }, generateNewSeriesTypes);
      var newTitle;
      if (type === "stack") {
        var isStack = newOption.series && newOption.series[0] && newOption.series[0].stack === INNER_STACK_KEYWORD;
        newTitle = isStack ? zrUtil.merge({
          stack: magicTypeLang.title.tiled
        }, magicTypeLang.title) : zrUtil.clone(magicTypeLang.title);
      }
      api.dispatchAction({
        type: "changeMagicType",
        currentType: type,
        newOption,
        newTitle,
        featureName: "magicType"
      });
    };
    echarts.registerAction({
      type: "changeMagicType",
      event: "magicTypeChanged",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      ecModel.mergeOption(payload.newOption);
    });
    featureManager.register("magicType", MagicType);
    var _default = MagicType;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataView.js
var require_DataView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var eventTool = require_event();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var dataViewLang = lang.toolbox.dataView;
    var BLOCK_SPLITER = new Array(60).join("-");
    var ITEM_SPLITER = "	";
    function groupSeries(ecModel) {
      var seriesGroupByCategoryAxis = {};
      var otherSeries = [];
      var meta = [];
      ecModel.eachRawSeries(function(seriesModel) {
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
          var baseAxis = coordSys.getBaseAxis();
          if (baseAxis.type === "category") {
            var key = baseAxis.dim + "_" + baseAxis.index;
            if (!seriesGroupByCategoryAxis[key]) {
              seriesGroupByCategoryAxis[key] = {
                categoryAxis: baseAxis,
                valueAxis: coordSys.getOtherAxis(baseAxis),
                series: []
              };
              meta.push({
                axisDim: baseAxis.dim,
                axisIndex: baseAxis.index
              });
            }
            seriesGroupByCategoryAxis[key].series.push(seriesModel);
          } else {
            otherSeries.push(seriesModel);
          }
        } else {
          otherSeries.push(seriesModel);
        }
      });
      return {
        seriesGroupByCategoryAxis,
        other: otherSeries,
        meta
      };
    }
    function assembleSeriesWithCategoryAxis(series) {
      var tables = [];
      zrUtil.each(series, function(group, key) {
        var categoryAxis = group.categoryAxis;
        var valueAxis = group.valueAxis;
        var valueAxisDim = valueAxis.dim;
        var headers = [" "].concat(zrUtil.map(group.series, function(series2) {
          return series2.name;
        }));
        var columns = [categoryAxis.model.getCategories()];
        zrUtil.each(group.series, function(series2) {
          var rawData = series2.getRawData();
          columns.push(series2.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
            return val;
          }));
        });
        var lines = [headers.join(ITEM_SPLITER)];
        for (var i = 0; i < columns[0].length; i++) {
          var items = [];
          for (var j = 0; j < columns.length; j++) {
            items.push(columns[j][i]);
          }
          lines.push(items.join(ITEM_SPLITER));
        }
        tables.push(lines.join("\n"));
      });
      return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
    }
    function assembleOtherSeries(series) {
      return zrUtil.map(series, function(series2) {
        var data = series2.getRawData();
        var lines = [series2.name];
        var vals = [];
        data.each(data.dimensions, function() {
          var argLen = arguments.length;
          var dataIndex = arguments[argLen - 1];
          var name2 = data.getName(dataIndex);
          for (var i = 0; i < argLen - 1; i++) {
            vals[i] = arguments[i];
          }
          lines.push((name2 ? name2 + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
        });
        return lines.join("\n");
      }).join("\n\n" + BLOCK_SPLITER + "\n\n");
    }
    function getContentFromModel(ecModel) {
      var result = groupSeries(ecModel);
      return {
        value: zrUtil.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
          return str.replace(/[\n\t\s]/g, "");
        }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
        meta: result.meta
      };
    }
    function trim(str) {
      return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function isTSVFormat(block) {
      var firstLine = block.slice(0, block.indexOf("\n"));
      if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
        return true;
      }
    }
    var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
    function parseTSVContents(tsv) {
      var tsvLines = tsv.split(/\n+/g);
      var headers = trim(tsvLines.shift()).split(itemSplitRegex);
      var categories = [];
      var series = zrUtil.map(headers, function(header) {
        return {
          name: header,
          data: []
        };
      });
      for (var i = 0; i < tsvLines.length; i++) {
        var items = trim(tsvLines[i]).split(itemSplitRegex);
        categories.push(items.shift());
        for (var j = 0; j < items.length; j++) {
          series[j] && (series[j].data[i] = items[j]);
        }
      }
      return {
        series,
        categories
      };
    }
    function parseListContents(str) {
      var lines = str.split(/\n+/g);
      var seriesName = trim(lines.shift());
      var data = [];
      for (var i = 0; i < lines.length; i++) {
        var line = trim(lines[i]);
        if (!line) {
          continue;
        }
        var items = line.split(itemSplitRegex);
        var name2 = "";
        var value;
        var hasName = false;
        if (isNaN(items[0])) {
          hasName = true;
          name2 = items[0];
          items = items.slice(1);
          data[i] = {
            name: name2,
            value: []
          };
          value = data[i].value;
        } else {
          value = data[i] = [];
        }
        for (var j = 0; j < items.length; j++) {
          value.push(+items[j]);
        }
        if (value.length === 1) {
          hasName ? data[i].value = value[0] : data[i] = value[0];
        }
      }
      return {
        name: seriesName,
        data
      };
    }
    function parseContents(str, blockMetaList) {
      var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
      var newOption = {
        series: []
      };
      zrUtil.each(blocks, function(block, idx) {
        if (isTSVFormat(block)) {
          var result = parseTSVContents(block);
          var blockMeta = blockMetaList[idx];
          var axisKey = blockMeta.axisDim + "Axis";
          if (blockMeta) {
            newOption[axisKey] = newOption[axisKey] || [];
            newOption[axisKey][blockMeta.axisIndex] = {
              data: result.categories
            };
            newOption.series = newOption.series.concat(result.series);
          }
        } else {
          var result = parseListContents(block);
          newOption.series.push(result);
        }
      });
      return newOption;
    }
    function DataView(model) {
      this._dom = null;
      this.model = model;
    }
    DataView.defaultOption = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
      title: zrUtil.clone(dataViewLang.title),
      lang: zrUtil.clone(dataViewLang.lang),
      backgroundColor: "#fff",
      textColor: "#000",
      textareaColor: "#fff",
      textareaBorderColor: "#333",
      buttonColor: "#c23531",
      buttonTextColor: "#fff"
    };
    DataView.prototype.onclick = function(ecModel, api) {
      var container = api.getDom();
      var model = this.model;
      if (this._dom) {
        container.removeChild(this._dom);
      }
      var root = document.createElement("div");
      root.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;";
      root.style.backgroundColor = model.get("backgroundColor") || "#fff";
      var header = document.createElement("h4");
      var lang2 = model.get("lang") || [];
      header.innerHTML = lang2[0] || model.get("title");
      header.style.cssText = "margin: 10px 20px;";
      header.style.color = model.get("textColor");
      var viewMain = document.createElement("div");
      var textarea = document.createElement("textarea");
      viewMain.style.cssText = "display:block;width:100%;overflow:auto;";
      var optionToContent = model.get("optionToContent");
      var contentToOption = model.get("contentToOption");
      var result = getContentFromModel(ecModel);
      if (typeof optionToContent === "function") {
        var htmlOrDom = optionToContent(api.getOption());
        if (typeof htmlOrDom === "string") {
          viewMain.innerHTML = htmlOrDom;
        } else if (zrUtil.isDom(htmlOrDom)) {
          viewMain.appendChild(htmlOrDom);
        }
      } else {
        viewMain.appendChild(textarea);
        textarea.readOnly = model.get("readOnly");
        textarea.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;";
        textarea.style.color = model.get("textColor");
        textarea.style.borderColor = model.get("textareaBorderColor");
        textarea.style.backgroundColor = model.get("textareaColor");
        textarea.value = result.value;
      }
      var blockMetaList = result.meta;
      var buttonContainer = document.createElement("div");
      buttonContainer.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
      var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
      var closeButton = document.createElement("div");
      var refreshButton = document.createElement("div");
      buttonStyle += ";background-color:" + model.get("buttonColor");
      buttonStyle += ";color:" + model.get("buttonTextColor");
      var self2 = this;
      function close() {
        container.removeChild(root);
        self2._dom = null;
      }
      eventTool.addEventListener(closeButton, "click", close);
      eventTool.addEventListener(refreshButton, "click", function() {
        var newOption;
        try {
          if (typeof contentToOption === "function") {
            newOption = contentToOption(viewMain, api.getOption());
          } else {
            newOption = parseContents(textarea.value, blockMetaList);
          }
        } catch (e) {
          close();
          throw new Error("Data view format error " + e);
        }
        if (newOption) {
          api.dispatchAction({
            type: "changeDataView",
            newOption
          });
        }
        close();
      });
      closeButton.innerHTML = lang2[1];
      refreshButton.innerHTML = lang2[2];
      refreshButton.style.cssText = buttonStyle;
      closeButton.style.cssText = buttonStyle;
      !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
      buttonContainer.appendChild(closeButton);
      root.appendChild(header);
      root.appendChild(viewMain);
      root.appendChild(buttonContainer);
      viewMain.style.height = container.clientHeight - 80 + "px";
      container.appendChild(root);
      this._dom = root;
    };
    DataView.prototype.remove = function(ecModel, api) {
      this._dom && api.getDom().removeChild(this._dom);
    };
    DataView.prototype.dispose = function(ecModel, api) {
      this.remove(ecModel, api);
    };
    function tryMergeDataOption(newData, originalData) {
      return zrUtil.map(newData, function(newVal, idx) {
        var original = originalData && originalData[idx];
        if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
          var newValIsObject = zrUtil.isObject(newVal) && !zrUtil.isArray(newVal);
          if (!newValIsObject) {
            newVal = {
              value: newVal
            };
          }
          var shouldDeleteName = original.name != null && newVal.name == null;
          newVal = zrUtil.defaults(newVal, original);
          shouldDeleteName && delete newVal.name;
          return newVal;
        } else {
          return newVal;
        }
      });
    }
    featureManager.register("dataView", DataView);
    echarts.registerAction({
      type: "changeDataView",
      event: "dataViewChanged",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      var newSeriesOptList = [];
      zrUtil.each(payload.newOption.series, function(seriesOpt) {
        var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
        if (!seriesModel) {
          newSeriesOptList.push(zrUtil.extend({
            // Default is scatter
            type: "scatter"
          }, seriesOpt));
        } else {
          var originalData = seriesModel.get("data");
          newSeriesOptList.push({
            name: seriesOpt.name,
            data: tryMergeDataOption(seriesOpt.data, originalData)
          });
        }
      });
      ecModel.mergeOption(zrUtil.defaults({
        series: newSeriesOptList
      }, payload.newOption));
    });
    var _default = DataView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushTargetManager.js
var require_BrushTargetManager = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/helper/BrushTargetManager.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var graphic = require_graphic();
    var modelUtil = require_model();
    var brushHelper = require_brushHelper();
    var each = zrUtil.each;
    var indexOf = zrUtil.indexOf;
    var curry = zrUtil.curry;
    var COORD_CONVERTS = ["dataToPoint", "pointToData"];
    var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
    function BrushTargetManager(option, ecModel, opt) {
      var targetInfoList = this._targetInfoList = [];
      var info = {};
      var foundCpts = parseFinder(ecModel, option);
      each(targetInfoBuilders, function(builder, type) {
        if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
          builder(foundCpts, targetInfoList, info);
        }
      });
    }
    var proto = BrushTargetManager.prototype;
    proto.setOutputRanges = function(areas, ecModel) {
      this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
        (area.coordRanges || (area.coordRanges = [])).push(coordRange);
        if (!area.coordRange) {
          area.coordRange = coordRange;
          var result = coordConvert[area.brushType](0, coordSys, coordRange);
          area.__rangeOffset = {
            offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
            xyMinMax: result.xyMinMax
          };
        }
      });
    };
    proto.matchOutputRanges = function(areas, ecModel, cb) {
      each(areas, function(area) {
        var targetInfo = this.findTargetInfo(area, ecModel);
        if (targetInfo && targetInfo !== true) {
          zrUtil.each(targetInfo.coordSyses, function(coordSys) {
            var result = coordConvert[area.brushType](1, coordSys, area.range);
            cb(area, result.values, coordSys, ecModel);
          });
        }
      }, this);
    };
    proto.setInputRanges = function(areas, ecModel) {
      each(areas, function(area) {
        var targetInfo = this.findTargetInfo(area, ecModel);
        area.range = area.range || [];
        if (targetInfo && targetInfo !== true) {
          area.panelId = targetInfo.panelId;
          var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
          var rangeOffset = area.__rangeOffset;
          area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
        }
      }, this);
    };
    proto.makePanelOpts = function(api, getDefaultBrushType) {
      return zrUtil.map(this._targetInfoList, function(targetInfo) {
        var rect = targetInfo.getPanelRect();
        return {
          panelId: targetInfo.panelId,
          defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
          clipPath: brushHelper.makeRectPanelClipPath(rect),
          isTargetByCursor: brushHelper.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
          getLinearBrushOtherExtent: brushHelper.makeLinearBrushOtherExtent(rect)
        };
      });
    };
    proto.controlSeries = function(area, seriesModel, ecModel) {
      var targetInfo = this.findTargetInfo(area, ecModel);
      return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
    };
    proto.findTargetInfo = function(area, ecModel) {
      var targetInfoList = this._targetInfoList;
      var foundCpts = parseFinder(ecModel, area);
      for (var i = 0; i < targetInfoList.length; i++) {
        var targetInfo = targetInfoList[i];
        var areaPanelId = area.panelId;
        if (areaPanelId) {
          if (targetInfo.panelId === areaPanelId) {
            return targetInfo;
          }
        } else {
          for (var i = 0; i < targetInfoMatchers.length; i++) {
            if (targetInfoMatchers[i](foundCpts, targetInfo)) {
              return targetInfo;
            }
          }
        }
      }
      return true;
    };
    function formatMinMax(minMax) {
      minMax[0] > minMax[1] && minMax.reverse();
      return minMax;
    }
    function parseFinder(ecModel, option) {
      return modelUtil.parseFinder(ecModel, option, {
        includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
      });
    }
    var targetInfoBuilders = {
      grid: function(foundCpts, targetInfoList) {
        var xAxisModels = foundCpts.xAxisModels;
        var yAxisModels = foundCpts.yAxisModels;
        var gridModels = foundCpts.gridModels;
        var gridModelMap = zrUtil.createHashMap();
        var xAxesHas = {};
        var yAxesHas = {};
        if (!xAxisModels && !yAxisModels && !gridModels) {
          return;
        }
        each(xAxisModels, function(axisModel) {
          var gridModel = axisModel.axis.grid.model;
          gridModelMap.set(gridModel.id, gridModel);
          xAxesHas[gridModel.id] = true;
        });
        each(yAxisModels, function(axisModel) {
          var gridModel = axisModel.axis.grid.model;
          gridModelMap.set(gridModel.id, gridModel);
          yAxesHas[gridModel.id] = true;
        });
        each(gridModels, function(gridModel) {
          gridModelMap.set(gridModel.id, gridModel);
          xAxesHas[gridModel.id] = true;
          yAxesHas[gridModel.id] = true;
        });
        gridModelMap.each(function(gridModel) {
          var grid = gridModel.coordinateSystem;
          var cartesians = [];
          each(grid.getCartesians(), function(cartesian, index) {
            if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) {
              cartesians.push(cartesian);
            }
          });
          targetInfoList.push({
            panelId: "grid--" + gridModel.id,
            gridModel,
            coordSysModel: gridModel,
            // Use the first one as the representitive coordSys.
            coordSys: cartesians[0],
            coordSyses: cartesians,
            getPanelRect: panelRectBuilder.grid,
            xAxisDeclared: xAxesHas[gridModel.id],
            yAxisDeclared: yAxesHas[gridModel.id]
          });
        });
      },
      geo: function(foundCpts, targetInfoList) {
        each(foundCpts.geoModels, function(geoModel) {
          var coordSys = geoModel.coordinateSystem;
          targetInfoList.push({
            panelId: "geo--" + geoModel.id,
            geoModel,
            coordSysModel: geoModel,
            coordSys,
            coordSyses: [coordSys],
            getPanelRect: panelRectBuilder.geo
          });
        });
      }
    };
    var targetInfoMatchers = [
      // grid
      function(foundCpts, targetInfo) {
        var xAxisModel = foundCpts.xAxisModel;
        var yAxisModel = foundCpts.yAxisModel;
        var gridModel = foundCpts.gridModel;
        !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
        !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
        return gridModel && gridModel === targetInfo.gridModel;
      },
      // geo
      function(foundCpts, targetInfo) {
        var geoModel = foundCpts.geoModel;
        return geoModel && geoModel === targetInfo.geoModel;
      }
    ];
    var panelRectBuilder = {
      grid: function() {
        return this.coordSys.grid.getRect().clone();
      },
      geo: function() {
        var coordSys = this.coordSys;
        var rect = coordSys.getBoundingRect().clone();
        rect.applyTransform(graphic.getTransform(coordSys));
        return rect;
      }
    };
    var coordConvert = {
      lineX: curry(axisConvert, 0),
      lineY: curry(axisConvert, 1),
      rect: function(to, coordSys, rangeOrCoordRange) {
        var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
        var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
        var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
        return {
          values,
          xyMinMax: values
        };
      },
      polygon: function(to, coordSys, rangeOrCoordRange) {
        var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
        var values = zrUtil.map(rangeOrCoordRange, function(item) {
          var p = coordSys[COORD_CONVERTS[to]](item);
          xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
          xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
          xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
          xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
          return p;
        });
        return {
          values,
          xyMinMax
        };
      }
    };
    function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
      var axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
      var values = formatMinMax(zrUtil.map([0, 1], function(i) {
        return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i])) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
      }));
      var xyMinMax = [];
      xyMinMax[axisNameIndex] = values;
      xyMinMax[1 - axisNameIndex] = [NaN, NaN];
      return {
        values,
        xyMinMax
      };
    }
    var diffProcessor = {
      lineX: curry(axisDiffProcessor, 0),
      lineY: curry(axisDiffProcessor, 1),
      rect: function(values, refer, scales) {
        return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
      },
      polygon: function(values, refer, scales) {
        return zrUtil.map(values, function(item, idx) {
          return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
        });
      }
    };
    function axisDiffProcessor(axisNameIndex, values, refer, scales) {
      return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
    }
    function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
      var sizeCurr = getSize(xyMinMaxCurr);
      var sizeOrigin = getSize(xyMinMaxOrigin);
      var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
      isNaN(scales[0]) && (scales[0] = 1);
      isNaN(scales[1]) && (scales[1] = 1);
      return scales;
    }
    function getSize(xyMinMax) {
      return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
    }
    var _default = BrushTargetManager;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/history.js
var require_history = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/history.js"(exports) {
    var zrUtil = require_util();
    var each = zrUtil.each;
    var ATTR = "\0_ec_hist_store";
    function push(ecModel, newSnapshot) {
      var store = giveStore(ecModel);
      each(newSnapshot, function(batchItem, dataZoomId) {
        var i = store.length - 1;
        for (; i >= 0; i--) {
          var snapshot = store[i];
          if (snapshot[dataZoomId]) {
            break;
          }
        }
        if (i < 0) {
          var dataZoomModel = ecModel.queryComponents({
            mainType: "dataZoom",
            subType: "select",
            id: dataZoomId
          })[0];
          if (dataZoomModel) {
            var percentRange = dataZoomModel.getPercentRange();
            store[0][dataZoomId] = {
              dataZoomId,
              start: percentRange[0],
              end: percentRange[1]
            };
          }
        }
      });
      store.push(newSnapshot);
    }
    function pop(ecModel) {
      var store = giveStore(ecModel);
      var head = store[store.length - 1];
      store.length > 1 && store.pop();
      var snapshot = {};
      each(head, function(batchItem, dataZoomId) {
        for (var i = store.length - 1; i >= 0; i--) {
          var batchItem = store[i][dataZoomId];
          if (batchItem) {
            snapshot[dataZoomId] = batchItem;
            break;
          }
        }
      });
      return snapshot;
    }
    function clear(ecModel) {
      ecModel[ATTR] = null;
    }
    function count(ecModel) {
      return giveStore(ecModel).length;
    }
    function giveStore(ecModel) {
      var store = ecModel[ATTR];
      if (!store) {
        store = ecModel[ATTR] = [{}];
      }
      return store;
    }
    exports.push = push;
    exports.pop = pop;
    exports.clear = clear;
    exports.count = count;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/typeDefaulter.js
var require_typeDefaulter = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/typeDefaulter.js"() {
    var Component = require_Component();
    Component.registerSubTypeDefaulter("dataZoom", function() {
      return "slider";
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/helper.js
var require_helper5 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/helper.js"(exports) {
    var zrUtil = require_util();
    var formatUtil = require_format();
    var AXIS_DIMS = ["x", "y", "z", "radius", "angle", "single"];
    var COORDS = ["cartesian2d", "polar", "singleAxis"];
    function isCoordSupported(coordType) {
      return zrUtil.indexOf(COORDS, coordType) >= 0;
    }
    function createNameEach(names, attrs) {
      names = names.slice();
      var capitalNames = zrUtil.map(names, formatUtil.capitalFirst);
      attrs = (attrs || []).slice();
      var capitalAttrs = zrUtil.map(attrs, formatUtil.capitalFirst);
      return function(callback, context) {
        zrUtil.each(names, function(name2, index) {
          var nameObj = {
            name: name2,
            capital: capitalNames[index]
          };
          for (var j = 0; j < attrs.length; j++) {
            nameObj[attrs[j]] = name2 + capitalAttrs[j];
          }
          callback.call(context, nameObj);
        });
      };
    }
    var eachAxisDim = createNameEach(AXIS_DIMS, ["axisIndex", "axis", "index", "id"]);
    function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {
      return function(sourceNode) {
        var result = {
          nodes: [],
          records: {}
          // key: edgeType.name, value: Object (key: edge id, value: boolean).
        };
        forEachEdgeType(function(edgeType) {
          result.records[edgeType.name] = {};
        });
        if (!sourceNode) {
          return result;
        }
        absorb(sourceNode, result);
        var existsLink;
        do {
          existsLink = false;
          forEachNode(processSingleNode);
        } while (existsLink);
        function processSingleNode(node) {
          if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
            absorb(node, result);
            existsLink = true;
          }
        }
        return result;
      };
      function isNodeAbsorded(node, result) {
        return zrUtil.indexOf(result.nodes, node) >= 0;
      }
      function isLinked(node, result) {
        var hasLink = false;
        forEachEdgeType(function(edgeType) {
          zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
            result.records[edgeType.name][edgeId] && (hasLink = true);
          });
        });
        return hasLink;
      }
      function absorb(node, result) {
        result.nodes.push(node);
        forEachEdgeType(function(edgeType) {
          zrUtil.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
            result.records[edgeType.name][edgeId] = true;
          });
        });
      }
    }
    exports.isCoordSupported = isCoordSupported;
    exports.createNameEach = createNameEach;
    exports.eachAxisDim = eachAxisDim;
    exports.createLinkedNodesFinder = createLinkedNodesFinder;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/AxisProxy.js
var require_AxisProxy = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/AxisProxy.js"(exports, module) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    var helper = require_helper5();
    var sliderMove = require_sliderMove();
    var each = zrUtil.each;
    var asc = numberUtil.asc;
    var AxisProxy = function(dimName, axisIndex, dataZoomModel, ecModel) {
      this._dimName = dimName;
      this._axisIndex = axisIndex;
      this._valueWindow;
      this._percentWindow;
      this._dataExtent;
      this._minMaxSpan;
      this.ecModel = ecModel;
      this._dataZoomModel = dataZoomModel;
    };
    AxisProxy.prototype = {
      constructor: AxisProxy,
      /**
       * Whether the axisProxy is hosted by dataZoomModel.
       *
       * @public
       * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
       * @return {boolean}
       */
      hostedBy: function(dataZoomModel) {
        return this._dataZoomModel === dataZoomModel;
      },
      /**
       * @return {Array.<number>} Value can only be NaN or finite value.
       */
      getDataValueWindow: function() {
        return this._valueWindow.slice();
      },
      /**
       * @return {Array.<number>}
       */
      getDataPercentWindow: function() {
        return this._percentWindow.slice();
      },
      /**
       * @public
       * @param {number} axisIndex
       * @return {Array} seriesModels
       */
      getTargetSeriesModels: function() {
        var seriesModels = [];
        var ecModel = this.ecModel;
        ecModel.eachSeries(function(seriesModel) {
          if (helper.isCoordSupported(seriesModel.get("coordinateSystem"))) {
            var dimName = this._dimName;
            var axisModel = ecModel.queryComponents({
              mainType: dimName + "Axis",
              index: seriesModel.get(dimName + "AxisIndex"),
              id: seriesModel.get(dimName + "AxisId")
            })[0];
            if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
              seriesModels.push(seriesModel);
            }
          }
        }, this);
        return seriesModels;
      },
      getAxisModel: function() {
        return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
      },
      getOtherAxisModel: function() {
        var axisDim = this._dimName;
        var ecModel = this.ecModel;
        var axisModel = this.getAxisModel();
        var isCartesian = axisDim === "x" || axisDim === "y";
        var otherAxisDim;
        var coordSysIndexName;
        if (isCartesian) {
          coordSysIndexName = "gridIndex";
          otherAxisDim = axisDim === "x" ? "y" : "x";
        } else {
          coordSysIndexName = "polarIndex";
          otherAxisDim = axisDim === "angle" ? "radius" : "angle";
        }
        var foundOtherAxisModel;
        ecModel.eachComponent(otherAxisDim + "Axis", function(otherAxisModel) {
          if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
            foundOtherAxisModel = otherAxisModel;
          }
        });
        return foundOtherAxisModel;
      },
      getMinMaxSpan: function() {
        return zrUtil.clone(this._minMaxSpan);
      },
      /**
       * Only calculate by given range and this._dataExtent, do not change anything.
       *
       * @param {Object} opt
       * @param {number} [opt.start]
       * @param {number} [opt.end]
       * @param {number} [opt.startValue]
       * @param {number} [opt.endValue]
       */
      calculateDataWindow: function(opt) {
        var dataExtent = this._dataExtent;
        var axisModel = this.getAxisModel();
        var scale = axisModel.axis.scale;
        var rangePropMode = this._dataZoomModel.getRangePropMode();
        var percentExtent = [0, 100];
        var percentWindow = [];
        var valueWindow = [];
        var hasPropModeValue;
        each(["start", "end"], function(prop, idx) {
          var boundPercent = opt[prop];
          var boundValue = opt[prop + "Value"];
          if (rangePropMode[idx] === "percent") {
            boundPercent == null && (boundPercent = percentExtent[idx]);
            boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));
          } else {
            hasPropModeValue = true;
            boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue);
            boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);
          }
          valueWindow[idx] = boundValue;
          percentWindow[idx] = boundPercent;
        });
        asc(valueWindow);
        asc(percentWindow);
        var spans = this._minMaxSpan;
        hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
        function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
          var suffix = toValue ? "Span" : "ValueSpan";
          sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
          for (var i = 0; i < 2; i++) {
            toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);
            toValue && (toWindow[i] = scale.parse(toWindow[i]));
          }
        }
        return {
          valueWindow,
          percentWindow
        };
      },
      /**
       * Notice: reset should not be called before series.restoreData() called,
       * so it is recommanded to be called in "process stage" but not "model init
       * stage".
       *
       * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
       */
      reset: function(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        var targetSeries = this.getTargetSeriesModels();
        this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
        setMinMaxSpan(this);
        var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
        this._valueWindow = dataWindow.valueWindow;
        this._percentWindow = dataWindow.percentWindow;
        setAxisModel(this);
      },
      /**
       * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
       */
      restore: function(dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        this._valueWindow = this._percentWindow = null;
        setAxisModel(this, true);
      },
      /**
       * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
       */
      filterData: function(dataZoomModel, api) {
        if (dataZoomModel !== this._dataZoomModel) {
          return;
        }
        var axisDim = this._dimName;
        var seriesModels = this.getTargetSeriesModels();
        var filterMode = dataZoomModel.get("filterMode");
        var valueWindow = this._valueWindow;
        if (filterMode === "none") {
          return;
        }
        each(seriesModels, function(seriesModel) {
          var seriesData = seriesModel.getData();
          var dataDims = seriesData.mapDimension(axisDim, true);
          if (!dataDims.length) {
            return;
          }
          if (filterMode === "weakFilter") {
            seriesData.filterSelf(function(dataIndex) {
              var leftOut;
              var rightOut;
              var hasValue;
              for (var i = 0; i < dataDims.length; i++) {
                var value = seriesData.get(dataDims[i], dataIndex);
                var thisHasValue = !isNaN(value);
                var thisLeftOut = value < valueWindow[0];
                var thisRightOut = value > valueWindow[1];
                if (thisHasValue && !thisLeftOut && !thisRightOut) {
                  return true;
                }
                thisHasValue && (hasValue = true);
                thisLeftOut && (leftOut = true);
                thisRightOut && (rightOut = true);
              }
              return hasValue && leftOut && rightOut;
            });
          } else {
            each(dataDims, function(dim) {
              if (filterMode === "empty") {
                seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
                  return !isInWindow(value) ? NaN : value;
                }));
              } else {
                var range = {};
                range[dim] = valueWindow;
                seriesData.selectRange(range);
              }
            });
          }
          each(dataDims, function(dim) {
            seriesData.setApproximateExtent(valueWindow, dim);
          });
        });
        function isInWindow(value) {
          return value >= valueWindow[0] && value <= valueWindow[1];
        }
      }
    };
    function calculateDataExtent(axisProxy, axisDim, seriesModels) {
      var dataExtent = [Infinity, -Infinity];
      each(seriesModels, function(seriesModel) {
        var seriesData = seriesModel.getData();
        if (seriesData) {
          each(seriesData.mapDimension(axisDim, true), function(dim) {
            var seriesExtent = seriesData.getApproximateExtent(dim);
            seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
            seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
          });
        }
      });
      if (dataExtent[1] < dataExtent[0]) {
        dataExtent = [NaN, NaN];
      }
      fixExtentByAxis(axisProxy, dataExtent);
      return dataExtent;
    }
    function fixExtentByAxis(axisProxy, dataExtent) {
      var axisModel = axisProxy.getAxisModel();
      var min = axisModel.getMin(true);
      var isCategoryAxis = axisModel.get("type") === "category";
      var axisDataLen = isCategoryAxis && axisModel.getCategories().length;
      if (min != null && min !== "dataMin" && typeof min !== "function") {
        dataExtent[0] = min;
      } else if (isCategoryAxis) {
        dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
      }
      var max = axisModel.getMax(true);
      if (max != null && max !== "dataMax" && typeof max !== "function") {
        dataExtent[1] = max;
      } else if (isCategoryAxis) {
        dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
      }
      if (!axisModel.get("scale", true)) {
        dataExtent[0] > 0 && (dataExtent[0] = 0);
        dataExtent[1] < 0 && (dataExtent[1] = 0);
      }
      return dataExtent;
    }
    function setAxisModel(axisProxy, isRestore) {
      var axisModel = axisProxy.getAxisModel();
      var percentWindow = axisProxy._percentWindow;
      var valueWindow = axisProxy._valueWindow;
      if (!percentWindow) {
        return;
      }
      var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
      precision = Math.min(precision, 20);
      var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
      axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
    }
    function setMinMaxSpan(axisProxy) {
      var minMaxSpan = axisProxy._minMaxSpan = {};
      var dataZoomModel = axisProxy._dataZoomModel;
      var dataExtent = axisProxy._dataExtent;
      each(["min", "max"], function(minMax) {
        var percentSpan = dataZoomModel.get(minMax + "Span");
        var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
        valueSpan != null && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan));
        if (valueSpan != null) {
          percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
        } else if (percentSpan != null) {
          valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
        }
        minMaxSpan[minMax + "Span"] = percentSpan;
        minMaxSpan[minMax + "ValueSpan"] = valueSpan;
      });
    }
    var _default = AxisProxy;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomModel.js
var require_DataZoomModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var modelUtil = require_model();
    var helper = require_helper5();
    var AxisProxy = require_AxisProxy();
    var each = zrUtil.each;
    var eachAxisDim = helper.eachAxisDim;
    var DataZoomModel = echarts.extendComponentModel({
      type: "dataZoom",
      dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"],
      /**
       * @protected
       */
      defaultOption: {
        zlevel: 0,
        z: 4,
        // Higher than normal component (z: 2).
        orient: null,
        // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
        xAxisIndex: null,
        // Default the first horizontal category axis.
        yAxisIndex: null,
        // Default the first vertical category axis.
        filterMode: "filter",
        // Possible values: 'filter' or 'empty' or 'weakFilter'.
        // 'filter': data items which are out of window will be removed. This option is
        //          applicable when filtering outliers. For each data item, it will be
        //          filtered if one of the relevant dimensions is out of the window.
        // 'weakFilter': data items which are out of window will be removed. This option
        //          is applicable when filtering outliers. For each data item, it will be
        //          filtered only if all  of the relevant dimensions are out of the same
        //          side of the window.
        // 'empty': data items which are out of window will be set to empty.
        //          This option is applicable when user should not neglect
        //          that there are some data items out of window.
        // 'none': Do not filter.
        // Taking line chart as an example, line will be broken in
        // the filtered points when filterModel is set to 'empty', but
        // be connected when set to 'filter'.
        throttle: null,
        // Dispatch action by the fixed rate, avoid frequency.
        // default 100. Do not throttle when use null/undefined.
        // If animation === true and animationDurationUpdate > 0,
        // default value is 100, otherwise 20.
        start: 0,
        // Start percent. 0 ~ 100
        end: 100,
        // End percent. 0 ~ 100
        startValue: null,
        // Start value. If startValue specified, start is ignored.
        endValue: null,
        // End value. If endValue specified, end is ignored.
        minSpan: null,
        // 0 ~ 100
        maxSpan: null,
        // 0 ~ 100
        minValueSpan: null,
        // The range of dataZoom can not be smaller than that.
        maxValueSpan: null,
        // The range of dataZoom can not be larger than that.
        rangeMode: null
        // Array, can be 'value' or 'percent'.
      },
      /**
       * @override
       */
      init: function(option, parentModel, ecModel) {
        this._dataIntervalByAxis = {};
        this._dataInfo = {};
        this._axisProxies = {};
        this.textStyleModel;
        this._autoThrottle = true;
        this._rangePropMode = ["percent", "percent"];
        var inputRawOption = retrieveRawOption(option);
        this.settledOption = inputRawOption;
        this.mergeDefaultAndTheme(option, ecModel);
        this.doInit(inputRawOption);
      },
      /**
       * @override
       */
      mergeOption: function(newOption) {
        var inputRawOption = retrieveRawOption(newOption);
        zrUtil.merge(this.option, newOption, true);
        zrUtil.merge(this.settledOption, inputRawOption, true);
        this.doInit(inputRawOption);
      },
      /**
       * @protected
       */
      doInit: function(inputRawOption) {
        var thisOption = this.option;
        if (!env.canvasSupported) {
          thisOption.realtime = false;
        }
        this._setDefaultThrottle(inputRawOption);
        updateRangeUse(this, inputRawOption);
        var settledOption = this.settledOption;
        each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
          if (this._rangePropMode[index] === "value") {
            thisOption[names[0]] = settledOption[names[0]] = null;
          }
        }, this);
        this.textStyleModel = this.getModel("textStyle");
        this._resetTarget();
        this._giveAxisProxies();
      },
      /**
       * @private
       */
      _giveAxisProxies: function() {
        var axisProxies = this._axisProxies;
        this.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel, ecModel) {
          var axisModel = this.dependentModels[dimNames.axis][axisIndex];
          var axisProxy = axisModel.__dzAxisProxy || // Use the first dataZoomModel as the main model of axisProxy.
          (axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel));
          axisProxies[dimNames.name + "_" + axisIndex] = axisProxy;
        }, this);
      },
      /**
       * @private
       */
      _resetTarget: function() {
        var thisOption = this.option;
        var autoMode = this._judgeAutoMode();
        eachAxisDim(function(dimNames) {
          var axisIndexName = dimNames.axisIndex;
          thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
        }, this);
        if (autoMode === "axisIndex") {
          this._autoSetAxisIndex();
        } else if (autoMode === "orient") {
          this._autoSetOrient();
        }
      },
      /**
       * @private
       */
      _judgeAutoMode: function() {
        var thisOption = this.option;
        var hasIndexSpecified = false;
        eachAxisDim(function(dimNames) {
          if (thisOption[dimNames.axisIndex] != null) {
            hasIndexSpecified = true;
          }
        }, this);
        var orient = thisOption.orient;
        if (orient == null && hasIndexSpecified) {
          return "orient";
        } else if (!hasIndexSpecified) {
          if (orient == null) {
            thisOption.orient = "horizontal";
          }
          return "axisIndex";
        }
      },
      /**
       * @private
       */
      _autoSetAxisIndex: function() {
        var autoAxisIndex = true;
        var orient = this.get("orient", true);
        var thisOption = this.option;
        var dependentModels = this.dependentModels;
        if (autoAxisIndex) {
          var dimName = orient === "vertical" ? "y" : "x";
          if (dependentModels[dimName + "Axis"].length) {
            thisOption[dimName + "AxisIndex"] = [0];
            autoAxisIndex = false;
          } else {
            each(dependentModels.singleAxis, function(singleAxisModel) {
              if (autoAxisIndex && singleAxisModel.get("orient", true) === orient) {
                thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
                autoAxisIndex = false;
              }
            });
          }
        }
        if (autoAxisIndex) {
          eachAxisDim(function(dimNames) {
            if (!autoAxisIndex) {
              return;
            }
            var axisIndices = [];
            var axisModels = this.dependentModels[dimNames.axis];
            if (axisModels.length && !axisIndices.length) {
              for (var i = 0, len = axisModels.length; i < len; i++) {
                if (axisModels[i].get("type") === "category") {
                  axisIndices.push(i);
                }
              }
            }
            thisOption[dimNames.axisIndex] = axisIndices;
            if (axisIndices.length) {
              autoAxisIndex = false;
            }
          }, this);
        }
        if (autoAxisIndex) {
          this.ecModel.eachSeries(function(seriesModel) {
            if (this._isSeriesHasAllAxesTypeOf(seriesModel, "value")) {
              eachAxisDim(function(dimNames) {
                var axisIndices = thisOption[dimNames.axisIndex];
                var axisIndex = seriesModel.get(dimNames.axisIndex);
                var axisId = seriesModel.get(dimNames.axisId);
                var axisModel = seriesModel.ecModel.queryComponents({
                  mainType: dimNames.axis,
                  index: axisIndex,
                  id: axisId
                })[0];
                axisIndex = axisModel.componentIndex;
                if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
                  axisIndices.push(axisIndex);
                }
              });
            }
          }, this);
        }
      },
      /**
       * @private
       */
      _autoSetOrient: function() {
        var dim;
        this.eachTargetAxis(function(dimNames) {
          !dim && (dim = dimNames.name);
        }, this);
        this.option.orient = dim === "y" ? "vertical" : "horizontal";
      },
      /**
       * @private
       */
      _isSeriesHasAllAxesTypeOf: function(seriesModel, axisType) {
        var is = true;
        eachAxisDim(function(dimNames) {
          var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
          var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];
          if (!axisModel || axisModel.get("type") !== axisType) {
            is = false;
          }
        }, this);
        return is;
      },
      /**
       * @private
       */
      _setDefaultThrottle: function(inputRawOption) {
        if (inputRawOption.hasOwnProperty("throttle")) {
          this._autoThrottle = false;
        }
        if (this._autoThrottle) {
          var globalOption = this.ecModel.option;
          this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
        }
      },
      /**
       * @public
       */
      getFirstTargetAxisModel: function() {
        var firstAxisModel;
        eachAxisDim(function(dimNames) {
          if (firstAxisModel == null) {
            var indices = this.get(dimNames.axisIndex);
            if (indices.length) {
              firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
            }
          }
        }, this);
        return firstAxisModel;
      },
      /**
       * @public
       * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
       */
      eachTargetAxis: function(callback, context) {
        var ecModel = this.ecModel;
        eachAxisDim(function(dimNames) {
          each(this.get(dimNames.axisIndex), function(axisIndex) {
            callback.call(context, dimNames, axisIndex, this, ecModel);
          }, this);
        }, this);
      },
      /**
       * @param {string} dimName
       * @param {number} axisIndex
       * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
       */
      getAxisProxy: function(dimName, axisIndex) {
        return this._axisProxies[dimName + "_" + axisIndex];
      },
      /**
       * @param {string} dimName
       * @param {number} axisIndex
       * @return {module:echarts/model/Model} If not found, return null/undefined.
       */
      getAxisModel: function(dimName, axisIndex) {
        var axisProxy = this.getAxisProxy(dimName, axisIndex);
        return axisProxy && axisProxy.getAxisModel();
      },
      /**
       * If not specified, set to undefined.
       *
       * @public
       * @param {Object} opt
       * @param {number} [opt.start]
       * @param {number} [opt.end]
       * @param {number} [opt.startValue]
       * @param {number} [opt.endValue]
       */
      setRawRange: function(opt) {
        var thisOption = this.option;
        var settledOption = this.settledOption;
        each([["start", "startValue"], ["end", "endValue"]], function(names) {
          if (opt[names[0]] != null || opt[names[1]] != null) {
            thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
            thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
          }
        }, this);
        updateRangeUse(this, opt);
      },
      /**
       * @public
       * @param {Object} opt
       * @param {number} [opt.start]
       * @param {number} [opt.end]
       * @param {number} [opt.startValue]
       * @param {number} [opt.endValue]
       */
      setCalculatedRange: function(opt) {
        var option = this.option;
        each(["start", "startValue", "end", "endValue"], function(name2) {
          option[name2] = opt[name2];
        });
      },
      /**
       * @public
       * @return {Array.<number>} [startPercent, endPercent]
       */
      getPercentRange: function() {
        var axisProxy = this.findRepresentativeAxisProxy();
        if (axisProxy) {
          return axisProxy.getDataPercentWindow();
        }
      },
      /**
       * @public
       * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
       *
       * @param {string} [axisDimName]
       * @param {number} [axisIndex]
       * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
       */
      getValueRange: function(axisDimName, axisIndex) {
        if (axisDimName == null && axisIndex == null) {
          var axisProxy = this.findRepresentativeAxisProxy();
          if (axisProxy) {
            return axisProxy.getDataValueWindow();
          }
        } else {
          return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
        }
      },
      /**
       * @public
       * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
       *      corresponding to the axisModel
       * @return {module:echarts/component/dataZoom/AxisProxy}
       */
      findRepresentativeAxisProxy: function(axisModel) {
        if (axisModel) {
          return axisModel.__dzAxisProxy;
        }
        var axisProxies = this._axisProxies;
        for (var key in axisProxies) {
          if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
            return axisProxies[key];
          }
        }
        for (var key in axisProxies) {
          if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
            return axisProxies[key];
          }
        }
      },
      /**
       * @return {Array.<string>}
       */
      getRangePropMode: function() {
        return this._rangePropMode.slice();
      }
    });
    function retrieveRawOption(option) {
      var ret = {};
      each(["start", "end", "startValue", "endValue", "throttle"], function(name2) {
        option.hasOwnProperty(name2) && (ret[name2] = option[name2]);
      });
      return ret;
    }
    function updateRangeUse(dataZoomModel, inputRawOption) {
      var rangePropMode = dataZoomModel._rangePropMode;
      var rangeModeInOption = dataZoomModel.get("rangeMode");
      each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
        var percentSpecified = inputRawOption[names[0]] != null;
        var valueSpecified = inputRawOption[names[1]] != null;
        if (percentSpecified && !valueSpecified) {
          rangePropMode[index] = "percent";
        } else if (!percentSpecified && valueSpecified) {
          rangePropMode[index] = "value";
        } else if (rangeModeInOption) {
          rangePropMode[index] = rangeModeInOption[index];
        } else if (percentSpecified) {
          rangePropMode[index] = "percent";
        }
      });
    }
    var _default = DataZoomModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomView.js
var require_DataZoomView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/DataZoomView.js"(exports, module) {
    var ComponentView = require_Component2();
    var _default = ComponentView.extend({
      type: "dataZoom",
      render: function(dataZoomModel, ecModel, api, payload) {
        this.dataZoomModel = dataZoomModel;
        this.ecModel = ecModel;
        this.api = api;
      },
      /**
       * Find the first target coordinate system.
       *
       * @protected
       * @return {Object} {
       *                   grid: [
       *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
       *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
       *                       ...
       *                   ],  // cartesians must not be null/undefined.
       *                   polar: [
       *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
       *                       ...
       *                   ],  // polars must not be null/undefined.
       *                   singleAxis: [
       *                       {model: coord0, axisModels: [], coordIndex: 0}
       *                   ]
       */
      getTargetCoordInfo: function() {
        var dataZoomModel = this.dataZoomModel;
        var ecModel = this.ecModel;
        var coordSysLists = {};
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
          var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);
          if (axisModel) {
            var coordModel = axisModel.getCoordSysModel();
            coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
          }
        }, this);
        function save(coordModel, axisModel, store, coordIndex) {
          var item;
          for (var i = 0; i < store.length; i++) {
            if (store[i].model === coordModel) {
              item = store[i];
              break;
            }
          }
          if (!item) {
            store.push(item = {
              model: coordModel,
              axisModels: [],
              coordIndex
            });
          }
          item.axisModels.push(axisModel);
        }
        return coordSysLists;
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js
var require_SelectZoomModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomModel.js"(exports, module) {
    var DataZoomModel = require_DataZoomModel();
    var _default = DataZoomModel.extend({
      type: "dataZoom.select"
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomView.js
var require_SelectZoomView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SelectZoomView.js"(exports, module) {
    var DataZoomView = require_DataZoomView();
    var _default = DataZoomView.extend({
      type: "dataZoom.select"
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js
var require_dataZoomProcessor = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomProcessor.js"() {
    var echarts = require_echarts();
    var _util = require_util();
    var createHashMap = _util.createHashMap;
    var each = _util.each;
    echarts.registerProcessor({
      // `dataZoomProcessor` will only be performed in needed series. Consider if
      // there is a line series and a pie series, it is better not to update the
      // line series if only pie series is needed to be updated.
      getTargetSeries: function(ecModel) {
        var seriesModelMap = createHashMap();
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
            var axisProxy = dataZoomModel2.getAxisProxy(dimNames.name, axisIndex);
            each(axisProxy.getTargetSeriesModels(), function(seriesModel) {
              seriesModelMap.set(seriesModel.uid, seriesModel);
            });
          });
        });
        return seriesModelMap;
      },
      modifyOutputEnd: true,
      // Consider appendData, where filter should be performed. Because data process is
      // in block mode currently, it is not need to worry about that the overallProgress
      // execute every frame.
      overallReset: function(ecModel, api) {
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
            dataZoomModel2.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel2, api);
          });
          dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
            dataZoomModel2.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel2, api);
          });
        });
        ecModel.eachComponent("dataZoom", function(dataZoomModel) {
          var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
          var percentRange = axisProxy.getDataPercentWindow();
          var valueRange = axisProxy.getDataValueWindow();
          dataZoomModel.setCalculatedRange({
            start: percentRange[0],
            end: percentRange[1],
            startValue: valueRange[0],
            endValue: valueRange[1]
          });
        });
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomAction.js
var require_dataZoomAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/dataZoomAction.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var helper = require_helper5();
    echarts.registerAction("dataZoom", function(payload, ecModel) {
      var linkedNodesFinder = helper.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, "dataZoom"), helper.eachAxisDim, function(model, dimNames) {
        return model.get(dimNames.axisIndex);
      });
      var effectedModels = [];
      ecModel.eachComponent({
        mainType: "dataZoom",
        query: payload
      }, function(model, index) {
        effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
      });
      zrUtil.each(effectedModels, function(dataZoomModel, index) {
        dataZoomModel.setRawRange({
          start: payload.start,
          end: payload.end,
          startValue: payload.startValue,
          endValue: payload.endValue
        });
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSelect.js
var require_dataZoomSelect = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSelect.js"() {
    require_typeDefaulter();
    require_DataZoomModel();
    require_DataZoomView();
    require_SelectZoomModel();
    require_SelectZoomView();
    require_dataZoomProcessor();
    require_dataZoomAction();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataZoom.js
var require_DataZoom = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/DataZoom.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var BrushController = require_BrushController();
    var BrushTargetManager = require_BrushTargetManager();
    var history = require_history();
    var sliderMove = require_sliderMove();
    var lang = require_lang();
    var featureManager = require_featureManager();
    require_dataZoomSelect();
    var dataZoomLang = lang.toolbox.dataZoom;
    var each = zrUtil.each;
    var DATA_ZOOM_ID_BASE = "\0_ec_\0toolbox-dataZoom_";
    function DataZoom(model, ecModel, api) {
      (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil.bind(this._onBrush, this)).mount();
      this._isZoomActive;
    }
    DataZoom.defaultOption = {
      show: true,
      filterMode: "filter",
      // Icon group
      icon: {
        zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
        back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
      },
      // `zoom`, `back`
      title: zrUtil.clone(dataZoomLang.title),
      brushStyle: {
        borderWidth: 0,
        color: "rgba(0,0,0,0.2)"
      }
    };
    var proto = DataZoom.prototype;
    proto.render = function(featureModel, ecModel, api, payload) {
      this.model = featureModel;
      this.ecModel = ecModel;
      this.api = api;
      updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
      updateBackBtnStatus(featureModel, ecModel);
    };
    proto.onclick = function(ecModel, api, type) {
      handlers[type].call(this);
    };
    proto.remove = function(ecModel, api) {
      this._brushController.unmount();
    };
    proto.dispose = function(ecModel, api) {
      this._brushController.dispose();
    };
    var handlers = {
      zoom: function() {
        var nextActive = !this._isZoomActive;
        this.api.dispatchAction({
          type: "takeGlobalCursor",
          key: "dataZoomSelect",
          dataZoomSelectActive: nextActive
        });
      },
      back: function() {
        this._dispatchZoomAction(history.pop(this.ecModel));
      }
    };
    proto._onBrush = function(areas, opt) {
      if (!opt.isEnd || !areas.length) {
        return;
      }
      var snapshot = {};
      var ecModel = this.ecModel;
      this._brushController.updateCovers([]);
      var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {
        include: ["grid"]
      });
      brushTargetManager.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
        if (coordSys.type !== "cartesian2d") {
          return;
        }
        var brushType = area.brushType;
        if (brushType === "rect") {
          setBatch("x", coordSys, coordRange[0]);
          setBatch("y", coordSys, coordRange[1]);
        } else {
          setBatch({
            lineX: "x",
            lineY: "y"
          }[brushType], coordSys, coordRange);
        }
      });
      history.push(ecModel, snapshot);
      this._dispatchZoomAction(snapshot);
      function setBatch(dimName, coordSys, minMax) {
        var axis = coordSys.getAxis(dimName);
        var axisModel = axis.model;
        var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
        if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
          minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
        }
        dataZoomModel && (snapshot[dataZoomModel.id] = {
          dataZoomId: dataZoomModel.id,
          startValue: minMax[0],
          endValue: minMax[1]
        });
      }
      function findDataZoom(dimName, axisModel, ecModel2) {
        var found;
        ecModel2.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(dzModel) {
          var has = dzModel.getAxisModel(dimName, axisModel.componentIndex);
          has && (found = dzModel);
        });
        return found;
      }
    };
    proto._dispatchZoomAction = function(snapshot) {
      var batch = [];
      each(snapshot, function(batchItem, dataZoomId) {
        batch.push(zrUtil.clone(batchItem));
      });
      batch.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch
      });
    };
    function retrieveAxisSetting(option) {
      var setting = {};
      zrUtil.each(["xAxisIndex", "yAxisIndex"], function(name2) {
        setting[name2] = option[name2];
        setting[name2] == null && (setting[name2] = "all");
        (setting[name2] === false || setting[name2] === "none") && (setting[name2] = []);
      });
      return setting;
    }
    function updateBackBtnStatus(featureModel, ecModel) {
      featureModel.setIconStatus("back", history.count(ecModel) > 1 ? "emphasis" : "normal");
    }
    function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
      var zoomActive = view._isZoomActive;
      if (payload && payload.type === "takeGlobalCursor") {
        zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
      }
      view._isZoomActive = zoomActive;
      featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
      var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {
        include: ["grid"]
      });
      view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function(targetInfo) {
        return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
      })).enableBrush(zoomActive ? {
        brushType: "auto",
        brushStyle: featureModel.getModel("brushStyle").getItemStyle()
      } : false);
    }
    featureManager.register("dataZoom", DataZoom);
    echarts.registerPreprocessor(function(option) {
      if (!option) {
        return;
      }
      var dataZoomOpts = option.dataZoom || (option.dataZoom = []);
      if (!zrUtil.isArray(dataZoomOpts)) {
        option.dataZoom = dataZoomOpts = [dataZoomOpts];
      }
      var toolboxOpt = option.toolbox;
      if (toolboxOpt) {
        if (zrUtil.isArray(toolboxOpt)) {
          toolboxOpt = toolboxOpt[0];
        }
        if (toolboxOpt && toolboxOpt.feature) {
          var dataZoomOpt = toolboxOpt.feature.dataZoom;
          addForAxis("xAxis", dataZoomOpt);
          addForAxis("yAxis", dataZoomOpt);
        }
      }
      function addForAxis(axisName, dataZoomOpt2) {
        if (!dataZoomOpt2) {
          return;
        }
        var axisIndicesName = axisName + "Index";
        var givenAxisIndices = dataZoomOpt2[axisIndicesName];
        if (givenAxisIndices != null && givenAxisIndices !== "all" && !zrUtil.isArray(givenAxisIndices)) {
          givenAxisIndices = givenAxisIndices === false || givenAxisIndices === "none" ? [] : [givenAxisIndices];
        }
        forEachComponent(axisName, function(axisOpt, axisIndex) {
          if (givenAxisIndices != null && givenAxisIndices !== "all" && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
            return;
          }
          var newOpt = {
            type: "select",
            $fromToolbox: true,
            // Default to be filter
            filterMode: dataZoomOpt2.filterMode || "filter",
            // Id for merge mapping.
            id: DATA_ZOOM_ID_BASE + axisName + axisIndex
          };
          newOpt[axisIndicesName] = axisIndex;
          dataZoomOpts.push(newOpt);
        });
      }
      function forEachComponent(mainType, cb) {
        var opts = option[mainType];
        if (!zrUtil.isArray(opts)) {
          opts = opts ? [opts] : [];
        }
        each(opts, cb);
      }
    });
    var _default = DataZoom;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Restore.js
var require_Restore = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Restore.js"(exports, module) {
    var echarts = require_echarts();
    var history = require_history();
    var lang = require_lang();
    var featureManager = require_featureManager();
    var restoreLang = lang.toolbox.restore;
    function Restore(model) {
      this.model = model;
    }
    Restore.defaultOption = {
      show: true,
      /* eslint-disable */
      icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
      /* eslint-enable */
      title: restoreLang.title
    };
    var proto = Restore.prototype;
    proto.onclick = function(ecModel, api, type) {
      history.clear(ecModel);
      api.dispatchAction({
        type: "restore",
        from: this.uid
      });
    };
    featureManager.register("restore", Restore);
    echarts.registerAction({
      type: "restore",
      event: "restore",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      ecModel.resetOption("recreate");
    });
    var _default = Restore;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox.js
var require_toolbox = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox.js"() {
    require_ToolboxModel();
    require_ToolboxView();
    require_SaveAsImage();
    require_MagicType();
    require_DataView();
    require_DataZoom();
    require_Restore();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipModel.js
var require_TooltipModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipModel.js"(exports, module) {
    var echarts = require_echarts();
    var _default = echarts.extendComponentModel({
      type: "tooltip",
      dependencies: ["axisPointer"],
      defaultOption: {
        zlevel: 0,
        z: 60,
        show: true,
        // tooltip主体内容
        showContent: true,
        // 'trigger' only works on coordinate system.
        // 'item' | 'axis' | 'none'
        trigger: "item",
        // 'click' | 'mousemove' | 'none'
        triggerOn: "mousemove|click",
        alwaysShowContent: false,
        displayMode: "single",
        // 'single' | 'multipleByCoordSys'
        renderMode: "auto",
        // 'auto' | 'html' | 'richText'
        // 'auto': use html by default, and use non-html if `document` is not defined
        // 'html': use html for tooltip
        // 'richText': use canvas, svg, and etc. for tooltip
        // 位置 {Array} | {Function}
        // position: null
        // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
        // align: null,
        // verticalAlign: null,
        // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
        confine: false,
        // 内容格式器：{string}（Template） ¦ {Function}
        // formatter: null
        showDelay: 0,
        // 隐藏延迟，单位ms
        hideDelay: 100,
        // 动画变换时间，单位s
        transitionDuration: 0.4,
        enterable: false,
        // 提示背景颜色，默认为透明度为0.7的黑色
        backgroundColor: "rgba(50,50,50,0.7)",
        // 提示边框颜色
        borderColor: "#333",
        // 提示边框圆角，单位px，默认为4
        borderRadius: 4,
        // 提示边框线宽，单位px，默认为0（无边框）
        borderWidth: 0,
        // 提示内边距，单位px，默认各方向内边距为5，
        // 接受数组分别设定上右下左边距，同css
        padding: 5,
        // Extra css text
        extraCssText: "",
        // 坐标轴指示器，坐标轴触发有效
        axisPointer: {
          // 默认为直线
          // 可选为：'line' | 'shadow' | 'cross'
          type: "line",
          // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
          // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
          // 默认 'auto'，会选择类型为 category 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
          // 极坐标系会默认选择 angle 轴
          axis: "auto",
          animation: "auto",
          animationDurationUpdate: 200,
          animationEasingUpdate: "exponentialOut",
          crossStyle: {
            color: "#999",
            width: 1,
            type: "dashed",
            // TODO formatter
            textStyle: {}
            // lineStyle and shadowStyle should not be specified here,
            // otherwise it will always override those styles on option.axisPointer.
          }
        },
        textStyle: {
          color: "#fff",
          fontSize: 14
        }
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipContent.js
var require_TooltipContent = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipContent.js"(exports, module) {
    var zrUtil = require_util();
    var zrColor = require_color();
    var eventUtil = require_event();
    var domUtil = require_dom();
    var env = require_env();
    var formatUtil = require_format();
    var each = zrUtil.each;
    var toCamelCase = formatUtil.toCamelCase;
    var vendors = ["", "-webkit-", "-moz-", "-o-"];
    var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
    function assembleTransition(duration) {
      var transitionCurve = "cubic-bezier(0.23, 1, 0.32, 1)";
      var transitionText = "left " + duration + "s " + transitionCurve + ",top " + duration + "s " + transitionCurve;
      return zrUtil.map(vendors, function(vendorPrefix) {
        return vendorPrefix + "transition:" + transitionText;
      }).join(";");
    }
    function assembleFont(textStyleModel) {
      var cssText = [];
      var fontSize = textStyleModel.get("fontSize");
      var color = textStyleModel.getTextColor();
      color && cssText.push("color:" + color);
      cssText.push("font:" + textStyleModel.getFont());
      var lineHeight = textStyleModel.get("lineHeight");
      if (lineHeight == null) {
        lineHeight = Math.round(fontSize * 3 / 2);
      }
      fontSize && cssText.push("line-height:" + lineHeight + "px");
      var shadowColor = textStyleModel.get("textShadowColor");
      var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
      var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
      var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
      shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
      each(["decoration", "align"], function(name2) {
        var val = textStyleModel.get(name2);
        val && cssText.push("text-" + name2 + ":" + val);
      });
      return cssText.join(";");
    }
    function assembleCssText(tooltipModel) {
      var cssText = [];
      var transitionDuration = tooltipModel.get("transitionDuration");
      var backgroundColor = tooltipModel.get("backgroundColor");
      var textStyleModel = tooltipModel.getModel("textStyle");
      var padding = tooltipModel.get("padding");
      transitionDuration && cssText.push(assembleTransition(transitionDuration));
      if (backgroundColor) {
        if (env.canvasSupported) {
          cssText.push("background-Color:" + backgroundColor);
        } else {
          cssText.push("background-Color:#" + zrColor.toHex(backgroundColor));
          cssText.push("filter:alpha(opacity=70)");
        }
      }
      each(["width", "color", "radius"], function(name2) {
        var borderName = "border-" + name2;
        var camelCase = toCamelCase(borderName);
        var val = tooltipModel.get(camelCase);
        val != null && cssText.push(borderName + ":" + val + (name2 === "color" ? "" : "px"));
      });
      cssText.push(assembleFont(textStyleModel));
      if (padding != null) {
        cssText.push("padding:" + formatUtil.normalizeCssArray(padding).join("px ") + "px");
      }
      return cssText.join(";") + ";";
    }
    function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {
      var zrPainter = zr && zr.painter;
      if (appendToBody) {
        var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
        if (zrViewportRoot) {
          domUtil.transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);
        }
      } else {
        out[0] = zrX;
        out[1] = zrY;
        var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
        if (viewportRootOffset) {
          out[0] += viewportRootOffset.offsetLeft;
          out[1] += viewportRootOffset.offsetTop;
        }
      }
      out[2] = out[0] / zr.getWidth();
      out[3] = out[1] / zr.getHeight();
    }
    function TooltipContent(container, api, opt) {
      if (env.wxa) {
        return null;
      }
      var el = document.createElement("div");
      el.domBelongToZr = true;
      this.el = el;
      var zr = this._zr = api.getZr();
      var appendToBody = this._appendToBody = opt && opt.appendToBody;
      this._styleCoord = [0, 0, 0, 0];
      makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
      if (appendToBody) {
        document.body.appendChild(el);
      } else {
        container.appendChild(el);
      }
      this._container = container;
      this._show = false;
      this._hideTimeout;
      var self2 = this;
      el.onmouseenter = function() {
        if (self2._enterable) {
          clearTimeout(self2._hideTimeout);
          self2._show = true;
        }
        self2._inContent = true;
      };
      el.onmousemove = function(e) {
        e = e || window.event;
        if (!self2._enterable) {
          var handler = zr.handler;
          var zrViewportRoot = zr.painter.getViewportRoot();
          eventUtil.normalizeEvent(zrViewportRoot, e, true);
          handler.dispatch("mousemove", e);
        }
      };
      el.onmouseleave = function() {
        if (self2._enterable) {
          if (self2._show) {
            self2.hideLater(self2._hideDelay);
          }
        }
        self2._inContent = false;
      };
    }
    TooltipContent.prototype = {
      constructor: TooltipContent,
      /**
       * @private
       * @type {boolean}
       */
      _enterable: true,
      /**
       * Update when tooltip is rendered
       */
      update: function(tooltipModel) {
        var container = this._container;
        var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
        var domStyle = container.style;
        if (domStyle.position !== "absolute" && stl.position !== "absolute") {
          domStyle.position = "relative";
        }
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveTooltipIfResized();
      },
      /**
       * when `alwaysShowContent` is true,
       * we should move the tooltip after chart resized
       */
      _moveTooltipIfResized: function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        var realX = ratioX * this._zr.getWidth();
        var realY = ratioY * this._zr.getHeight();
        this.moveTo(realX, realY);
      },
      show: function(tooltipModel) {
        clearTimeout(this._hideTimeout);
        var el = this.el;
        var styleCoord = this._styleCoord;
        el.style.cssText = gCssText + assembleCssText(tooltipModel) + ";left:" + styleCoord[0] + "px;top:" + styleCoord[1] + "px;" + (tooltipModel.get("extraCssText") || "");
        el.style.display = el.innerHTML ? "block" : "none";
        el.style.pointerEvents = this._enterable ? "auto" : "none";
        this._show = true;
      },
      setContent: function(content) {
        this.el.innerHTML = content == null ? "" : content;
      },
      setEnterable: function(enterable) {
        this._enterable = enterable;
      },
      getSize: function() {
        var el = this.el;
        return [el.clientWidth, el.clientHeight];
      },
      moveTo: function(zrX, zrY) {
        var styleCoord = this._styleCoord;
        makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
        var style = this.el.style;
        style.left = styleCoord[0] + "px";
        style.top = styleCoord[1] + "px";
      },
      hide: function() {
        this.el.style.display = "none";
        this._show = false;
      },
      hideLater: function(time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time;
            this._show = false;
            this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      },
      isShow: function() {
        return this._show;
      },
      dispose: function() {
        this.el.parentNode.removeChild(this.el);
      },
      getOuterSize: function() {
        var width = this.el.clientWidth;
        var height = this.el.clientHeight;
        if (document.defaultView && document.defaultView.getComputedStyle) {
          var stl = document.defaultView.getComputedStyle(this.el);
          if (stl) {
            width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
            height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
          }
        }
        return {
          width,
          height
        };
      }
    };
    var _default = TooltipContent;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipRichContent.js
var require_TooltipRichContent = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipRichContent.js"(exports, module) {
    var zrUtil = require_util();
    var Text = require_Text();
    var graphicUtil = require_graphic();
    function makeStyleCoord(out, zr, zrX, zrY) {
      out[0] = zrX;
      out[1] = zrY;
      out[2] = out[0] / zr.getWidth();
      out[3] = out[1] / zr.getHeight();
    }
    function TooltipRichContent(api) {
      var zr = this._zr = api.getZr();
      this._styleCoord = [0, 0, 0, 0];
      makeStyleCoord(this._styleCoord, zr, api.getWidth() / 2, api.getHeight() / 2);
      this._show = false;
      this._hideTimeout;
    }
    TooltipRichContent.prototype = {
      constructor: TooltipRichContent,
      /**
       * @private
       * @type {boolean}
       */
      _enterable: true,
      /**
       * Update when tooltip is rendered
       */
      update: function(tooltipModel) {
        var alwaysShowContent = tooltipModel.get("alwaysShowContent");
        alwaysShowContent && this._moveTooltipIfResized();
      },
      /**
       * when `alwaysShowContent` is true,
       * we should move the tooltip after chart resized
       */
      _moveTooltipIfResized: function() {
        var ratioX = this._styleCoord[2];
        var ratioY = this._styleCoord[3];
        var realX = ratioX * this._zr.getWidth();
        var realY = ratioY * this._zr.getHeight();
        this.moveTo(realX, realY);
      },
      show: function(tooltipModel) {
        if (this._hideTimeout) {
          clearTimeout(this._hideTimeout);
        }
        this.el.attr("show", true);
        this._show = true;
      },
      /**
       * Set tooltip content
       *
       * @param {string} content rich text string of content
       * @param {Object} markerRich rich text style
       * @param {Object} tooltipModel tooltip model
       */
      setContent: function(content, markerRich, tooltipModel) {
        if (this.el) {
          this._zr.remove(this.el);
        }
        var markers = {};
        var text = content;
        var prefix = "{marker";
        var suffix = "|}";
        var startId = text.indexOf(prefix);
        while (startId >= 0) {
          var endId = text.indexOf(suffix);
          var name2 = text.substr(startId + prefix.length, endId - startId - prefix.length);
          if (name2.indexOf("sub") > -1) {
            markers["marker" + name2] = {
              textWidth: 4,
              textHeight: 4,
              textBorderRadius: 2,
              textBackgroundColor: markerRich[name2],
              // TODO: textOffset is not implemented for rich text
              textOffset: [3, 0]
            };
          } else {
            markers["marker" + name2] = {
              textWidth: 10,
              textHeight: 10,
              textBorderRadius: 5,
              textBackgroundColor: markerRich[name2]
            };
          }
          text = text.substr(endId + 1);
          startId = text.indexOf("{marker");
        }
        var textStyleModel = tooltipModel.getModel("textStyle");
        var fontSize = textStyleModel.get("fontSize");
        var lineHeight = tooltipModel.get("textLineHeight");
        if (lineHeight == null) {
          lineHeight = Math.round(fontSize * 3 / 2);
        }
        this.el = new Text({
          style: graphicUtil.setTextStyle({}, textStyleModel, {
            rich: markers,
            text: content,
            textBackgroundColor: tooltipModel.get("backgroundColor"),
            textBorderRadius: tooltipModel.get("borderRadius"),
            textFill: tooltipModel.get("textStyle.color"),
            textPadding: tooltipModel.get("padding"),
            textLineHeight: lineHeight
          }),
          z: tooltipModel.get("z")
        });
        this._zr.add(this.el);
        var self2 = this;
        this.el.on("mouseover", function() {
          if (self2._enterable) {
            clearTimeout(self2._hideTimeout);
            self2._show = true;
          }
          self2._inContent = true;
        });
        this.el.on("mouseout", function() {
          if (self2._enterable) {
            if (self2._show) {
              self2.hideLater(self2._hideDelay);
            }
          }
          self2._inContent = false;
        });
      },
      setEnterable: function(enterable) {
        this._enterable = enterable;
      },
      getSize: function() {
        var bounding = this.el.getBoundingRect();
        return [bounding.width, bounding.height];
      },
      moveTo: function(x, y) {
        if (this.el) {
          var styleCoord = this._styleCoord;
          makeStyleCoord(styleCoord, this._zr, x, y);
          this.el.attr("position", [styleCoord[0], styleCoord[1]]);
        }
      },
      hide: function() {
        if (this.el) {
          this.el.hide();
        }
        this._show = false;
      },
      hideLater: function(time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time;
            this._show = false;
            this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
          } else {
            this.hide();
          }
        }
      },
      isShow: function() {
        return this._show;
      },
      dispose: function() {
        clearTimeout(this._hideTimeout);
        if (this.el) {
          this._zr.remove(this.el);
        }
      },
      getOuterSize: function() {
        var size = this.getSize();
        return {
          width: size[0],
          height: size[1]
        };
      }
    };
    var _default = TooltipRichContent;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipView.js
var require_TooltipView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip/TooltipView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var TooltipContent = require_TooltipContent();
    var TooltipRichContent = require_TooltipRichContent();
    var formatUtil = require_format();
    var numberUtil = require_number();
    var graphic = require_graphic();
    var findPointFromSeries = require_findPointFromSeries();
    var layoutUtil = require_layout();
    var Model = require_Model();
    var globalListener = require_globalListener();
    var axisHelper = require_axisHelper();
    var axisPointerViewHelper = require_viewHelper();
    var _model = require_model();
    var getTooltipRenderMode = _model.getTooltipRenderMode;
    var bind = zrUtil.bind;
    var each = zrUtil.each;
    var parsePercent = numberUtil.parsePercent;
    var proxyRect = new graphic.Rect({
      shape: {
        x: -1,
        y: -1,
        width: 2,
        height: 2
      }
    });
    var _default = echarts.extendComponentView({
      type: "tooltip",
      init: function(ecModel, api) {
        if (env.node) {
          return;
        }
        var tooltipModel = ecModel.getComponent("tooltip");
        var renderMode = tooltipModel.get("renderMode");
        this._renderMode = getTooltipRenderMode(renderMode);
        var tooltipContent;
        if (this._renderMode === "html") {
          tooltipContent = new TooltipContent(api.getDom(), api, {
            appendToBody: tooltipModel.get("appendToBody", true)
          });
          this._newLine = "<br/>";
        } else {
          tooltipContent = new TooltipRichContent(api);
          this._newLine = "\n";
        }
        this._tooltipContent = tooltipContent;
      },
      render: function(tooltipModel, ecModel, api) {
        if (env.node) {
          return;
        }
        this.group.removeAll();
        this._tooltipModel = tooltipModel;
        this._ecModel = ecModel;
        this._api = api;
        this._lastDataByCoordSys = null;
        this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
        var tooltipContent = this._tooltipContent;
        tooltipContent.update(tooltipModel);
        tooltipContent.setEnterable(tooltipModel.get("enterable"));
        this._initGlobalListener();
        this._keepShow();
      },
      _initGlobalListener: function() {
        var tooltipModel = this._tooltipModel;
        var triggerOn = tooltipModel.get("triggerOn");
        globalListener.register("itemTooltip", this._api, bind(function(currTrigger, e, dispatchAction) {
          if (triggerOn !== "none") {
            if (triggerOn.indexOf(currTrigger) >= 0) {
              this._tryShow(e, dispatchAction);
            } else if (currTrigger === "leave") {
              this._hide(dispatchAction);
            }
          }
        }, this));
      },
      _keepShow: function() {
        var tooltipModel = this._tooltipModel;
        var ecModel = this._ecModel;
        var api = this._api;
        if (this._lastX != null && this._lastY != null && tooltipModel.get("triggerOn") !== "none") {
          var self2 = this;
          clearTimeout(this._refreshUpdateTimeout);
          this._refreshUpdateTimeout = setTimeout(function() {
            !api.isDisposed() && self2.manuallyShowTip(tooltipModel, ecModel, api, {
              x: self2._lastX,
              y: self2._lastY
            });
          });
        }
      },
      /**
       * Show tip manually by
       * dispatchAction({
       *     type: 'showTip',
       *     x: 10,
       *     y: 10
       * });
       * Or
       * dispatchAction({
       *      type: 'showTip',
       *      seriesIndex: 0,
       *      dataIndex or dataIndexInside or name
       * });
       *
       *  TODO Batch
       */
      manuallyShowTip: function(tooltipModel, ecModel, api, payload) {
        if (payload.from === this.uid || env.node) {
          return;
        }
        var dispatchAction = makeDispatchAction(payload, api);
        this._ticket = "";
        var dataByCoordSys = payload.dataByCoordSys;
        if (payload.tooltip && payload.x != null && payload.y != null) {
          var el = proxyRect;
          el.position = [payload.x, payload.y];
          el.update();
          el.tooltip = payload.tooltip;
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            target: el
          }, dispatchAction);
        } else if (dataByCoordSys) {
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            dataByCoordSys: payload.dataByCoordSys,
            tooltipOption: payload.tooltipOption
          }, dispatchAction);
        } else if (payload.seriesIndex != null) {
          if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
            return;
          }
          var pointInfo = findPointFromSeries(payload, ecModel);
          var cx = pointInfo.point[0];
          var cy = pointInfo.point[1];
          if (cx != null && cy != null) {
            this._tryShow({
              offsetX: cx,
              offsetY: cy,
              position: payload.position,
              target: pointInfo.el
            }, dispatchAction);
          }
        } else if (payload.x != null && payload.y != null) {
          api.dispatchAction({
            type: "updateAxisPointer",
            x: payload.x,
            y: payload.y
          });
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            target: api.getZr().findHover(payload.x, payload.y).target
          }, dispatchAction);
        }
      },
      manuallyHideTip: function(tooltipModel, ecModel, api, payload) {
        var tooltipContent = this._tooltipContent;
        if (!this._alwaysShowContent && this._tooltipModel) {
          tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
        }
        this._lastX = this._lastY = null;
        if (payload.from !== this.uid) {
          this._hide(makeDispatchAction(payload, api));
        }
      },
      // Be compatible with previous design, that is, when tooltip.type is 'axis' and
      // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
      // and tooltip.
      _manuallyAxisShowTip: function(tooltipModel, ecModel, api, payload) {
        var seriesIndex = payload.seriesIndex;
        var dataIndex = payload.dataIndex;
        var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
          return;
        }
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        if (!seriesModel) {
          return;
        }
        var data = seriesModel.getData();
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);
        if (tooltipModel.get("trigger") !== "axis") {
          return;
        }
        api.dispatchAction({
          type: "updateAxisPointer",
          seriesIndex,
          dataIndex,
          position: payload.position
        });
        return true;
      },
      _tryShow: function(e, dispatchAction) {
        var el = e.target;
        var tooltipModel = this._tooltipModel;
        if (!tooltipModel) {
          return;
        }
        this._lastX = e.offsetX;
        this._lastY = e.offsetY;
        var dataByCoordSys = e.dataByCoordSys;
        if (dataByCoordSys && dataByCoordSys.length) {
          this._showAxisTooltip(dataByCoordSys, e);
        } else if (el && el.dataIndex != null) {
          this._lastDataByCoordSys = null;
          this._showSeriesItemTooltip(e, el, dispatchAction);
        } else if (el && el.tooltip) {
          this._lastDataByCoordSys = null;
          this._showComponentItemTooltip(e, el, dispatchAction);
        } else {
          this._lastDataByCoordSys = null;
          this._hide(dispatchAction);
        }
      },
      _showOrMove: function(tooltipModel, cb) {
        var delay = tooltipModel.get("showDelay");
        cb = zrUtil.bind(cb, this);
        clearTimeout(this._showTimout);
        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
      },
      _showAxisTooltip: function(dataByCoordSys, e) {
        var ecModel = this._ecModel;
        var globalTooltipModel = this._tooltipModel;
        var point = [e.offsetX, e.offsetY];
        var singleDefaultHTML = [];
        var singleParamsList = [];
        var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
        var renderMode = this._renderMode;
        var newLine = this._newLine;
        var markers = {};
        each(dataByCoordSys, function(itemCoordSys) {
          each(itemCoordSys.dataByAxis, function(item) {
            var axisModel = ecModel.getComponent(item.axisDim + "Axis", item.axisIndex);
            var axisValue = item.value;
            var seriesDefaultHTML = [];
            if (!axisModel || axisValue == null) {
              return;
            }
            var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
            zrUtil.each(item.seriesDataIndices, function(idxItem) {
              var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
              var dataIndex = idxItem.dataIndexInside;
              var dataParams = series && series.getDataParams(dataIndex);
              dataParams.axisDim = item.axisDim;
              dataParams.axisIndex = item.axisIndex;
              dataParams.axisType = item.axisType;
              dataParams.axisId = item.axisId;
              dataParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, axisValue);
              dataParams.axisValueLabel = valueLabel;
              if (dataParams) {
                singleParamsList.push(dataParams);
                var seriesTooltip = series.formatTooltip(dataIndex, true, null, renderMode);
                var html;
                if (zrUtil.isObject(seriesTooltip)) {
                  html = seriesTooltip.html;
                  var newMarkers = seriesTooltip.markers;
                  zrUtil.merge(markers, newMarkers);
                } else {
                  html = seriesTooltip;
                }
                seriesDefaultHTML.push(html);
              }
            });
            var firstLine = valueLabel;
            if (renderMode !== "html") {
              singleDefaultHTML.push(seriesDefaultHTML.join(newLine));
            } else {
              singleDefaultHTML.push((firstLine ? formatUtil.encodeHTML(firstLine) + newLine : "") + seriesDefaultHTML.join(newLine));
            }
          });
        }, this);
        singleDefaultHTML.reverse();
        singleDefaultHTML = singleDefaultHTML.join(this._newLine + this._newLine);
        var positionExpr = e.position;
        this._showOrMove(singleTooltipModel, function() {
          if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
            this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
          } else {
            this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr, void 0, markers);
          }
        });
      },
      _showSeriesItemTooltip: function(e, el, dispatchAction) {
        var ecModel = this._ecModel;
        var seriesIndex = el.seriesIndex;
        var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
        var dataModel = el.dataModel || seriesModel;
        var dataIndex = el.dataIndex;
        var dataType = el.dataType;
        var data = dataModel.getData(dataType);
        var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
        var tooltipTrigger = tooltipModel.get("trigger");
        if (tooltipTrigger != null && tooltipTrigger !== "item") {
          return;
        }
        var params = dataModel.getDataParams(dataIndex, dataType);
        var seriesTooltip = dataModel.formatTooltip(dataIndex, false, dataType, this._renderMode);
        var defaultHtml;
        var markers;
        if (zrUtil.isObject(seriesTooltip)) {
          defaultHtml = seriesTooltip.html;
          markers = seriesTooltip.markers;
        } else {
          defaultHtml = seriesTooltip;
          markers = null;
        }
        var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
        this._showOrMove(tooltipModel, function() {
          this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markers);
        });
        dispatchAction({
          type: "showTip",
          dataIndexInside: dataIndex,
          dataIndex: data.getRawIndex(dataIndex),
          seriesIndex,
          from: this.uid
        });
      },
      _showComponentItemTooltip: function(e, el, dispatchAction) {
        var tooltipOpt = el.tooltip;
        if (typeof tooltipOpt === "string") {
          var content = tooltipOpt;
          tooltipOpt = {
            content,
            // Fixed formatter
            formatter: content
          };
        }
        var subTooltipModel = new Model(tooltipOpt, this._tooltipModel, this._ecModel);
        var defaultHtml = subTooltipModel.get("content");
        var asyncTicket = Math.random();
        this._showOrMove(subTooltipModel, function() {
          this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get("formatterParams") || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el);
        });
        dispatchAction({
          type: "showTip",
          from: this.uid
        });
      },
      _showTooltipContent: function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markers) {
        this._ticket = "";
        if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
          return;
        }
        var tooltipContent = this._tooltipContent;
        var formatter = tooltipModel.get("formatter");
        positionExpr = positionExpr || tooltipModel.get("position");
        var html = defaultHtml;
        if (formatter && typeof formatter === "string") {
          html = formatUtil.formatTpl(formatter, params, true);
        } else if (typeof formatter === "function") {
          var callback = bind(function(cbTicket, html2) {
            if (cbTicket === this._ticket) {
              tooltipContent.setContent(html2, markers, tooltipModel);
              this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
            }
          }, this);
          this._ticket = asyncTicket;
          html = formatter(params, asyncTicket, callback);
        }
        tooltipContent.setContent(html, markers, tooltipModel);
        tooltipContent.show(tooltipModel);
        this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
      },
      /**
       * @param  {string|Function|Array.<number>|Object} positionExpr
       * @param  {number} x Mouse x
       * @param  {number} y Mouse y
       * @param  {boolean} confine Whether confine tooltip content in view rect.
       * @param  {Object|<Array.<Object>} params
       * @param  {module:zrender/Element} el target element
       * @param  {module:echarts/ExtensionAPI} api
       * @return {Array.<number>}
       */
      _updatePosition: function(tooltipModel, positionExpr, x, y, content, params, el) {
        var viewWidth = this._api.getWidth();
        var viewHeight = this._api.getHeight();
        positionExpr = positionExpr || tooltipModel.get("position");
        var contentSize = content.getSize();
        var align = tooltipModel.get("align");
        var vAlign = tooltipModel.get("verticalAlign");
        var rect = el && el.getBoundingRect().clone();
        el && rect.applyTransform(el.transform);
        if (typeof positionExpr === "function") {
          positionExpr = positionExpr([x, y], params, content.el, rect, {
            viewSize: [viewWidth, viewHeight],
            contentSize: contentSize.slice()
          });
        }
        if (zrUtil.isArray(positionExpr)) {
          x = parsePercent(positionExpr[0], viewWidth);
          y = parsePercent(positionExpr[1], viewHeight);
        } else if (zrUtil.isObject(positionExpr)) {
          positionExpr.width = contentSize[0];
          positionExpr.height = contentSize[1];
          var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
            width: viewWidth,
            height: viewHeight
          });
          x = layoutRect.x;
          y = layoutRect.y;
          align = null;
          vAlign = null;
        } else if (typeof positionExpr === "string" && el) {
          var pos = calcTooltipPosition(positionExpr, rect, contentSize);
          x = pos[0];
          y = pos[1];
        } else {
          var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
          x = pos[0];
          y = pos[1];
        }
        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
        if (tooltipModel.get("confine")) {
          var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
          x = pos[0];
          y = pos[1];
        }
        content.moveTo(x, y);
      },
      // FIXME
      // Should we remove this but leave this to user?
      _updateContentNotChangedOnAxis: function(dataByCoordSys) {
        var lastCoordSys = this._lastDataByCoordSys;
        var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
        contentNotChanged && each(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
          var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
          var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
          var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
          contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
          contentNotChanged && each(lastDataByAxis, function(lastItem, indexAxis) {
            var thisItem = thisDataByAxis[indexAxis] || {};
            var lastIndices = lastItem.seriesDataIndices || [];
            var newIndices = thisItem.seriesDataIndices || [];
            contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
            contentNotChanged && each(lastIndices, function(lastIdxItem, j) {
              var newIdxItem = newIndices[j];
              contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
            });
          });
        });
        this._lastDataByCoordSys = dataByCoordSys;
        return !!contentNotChanged;
      },
      _hide: function(dispatchAction) {
        this._lastDataByCoordSys = null;
        dispatchAction({
          type: "hideTip",
          from: this.uid
        });
      },
      dispose: function(ecModel, api) {
        if (env.node) {
          return;
        }
        this._tooltipContent.dispose();
        globalListener.unregister("itemTooltip", api);
      }
    });
    function buildTooltipModel(modelCascade) {
      var resultModel = modelCascade.pop();
      while (modelCascade.length) {
        var tooltipOpt = modelCascade.pop();
        if (tooltipOpt) {
          if (Model.isInstance(tooltipOpt)) {
            tooltipOpt = tooltipOpt.get("tooltip", true);
          }
          if (typeof tooltipOpt === "string") {
            tooltipOpt = {
              formatter: tooltipOpt
            };
          }
          resultModel = new Model(tooltipOpt, resultModel, resultModel.ecModel);
        }
      }
      return resultModel;
    }
    function makeDispatchAction(payload, api) {
      return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
    }
    function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
      var size = content.getOuterSize();
      var width = size.width;
      var height = size.height;
      if (gapH != null) {
        if (x + width + gapH > viewWidth) {
          x -= width + gapH;
        } else {
          x += gapH;
        }
      }
      if (gapV != null) {
        if (y + height + gapV > viewHeight) {
          y -= height + gapV;
        } else {
          y += gapV;
        }
      }
      return [x, y];
    }
    function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
      var size = content.getOuterSize();
      var width = size.width;
      var height = size.height;
      x = Math.min(x + width, viewWidth) - width;
      y = Math.min(y + height, viewHeight) - height;
      x = Math.max(x, 0);
      y = Math.max(y, 0);
      return [x, y];
    }
    function calcTooltipPosition(position, rect, contentSize) {
      var domWidth = contentSize[0];
      var domHeight = contentSize[1];
      var gap = 5;
      var x = 0;
      var y = 0;
      var rectWidth = rect.width;
      var rectHeight = rect.height;
      switch (position) {
        case "inside":
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y + rectHeight / 2 - domHeight / 2;
          break;
        case "top":
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y - domHeight - gap;
          break;
        case "bottom":
          x = rect.x + rectWidth / 2 - domWidth / 2;
          y = rect.y + rectHeight + gap;
          break;
        case "left":
          x = rect.x - domWidth - gap;
          y = rect.y + rectHeight / 2 - domHeight / 2;
          break;
        case "right":
          x = rect.x + rectWidth + gap;
          y = rect.y + rectHeight / 2 - domHeight / 2;
      }
      return [x, y];
    }
    function isCenterAlign(align) {
      return align === "center" || align === "middle";
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip.js
var require_tooltip = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/tooltip.js"() {
    var echarts = require_echarts();
    require_axisPointer();
    require_TooltipModel();
    require_TooltipView();
    echarts.registerAction(
      {
        type: "showTip",
        event: "showTip",
        update: "tooltip:manuallyShowTip"
      },
      // noop
      function() {
      }
    );
    echarts.registerAction(
      {
        type: "hideTip",
        event: "hideTip",
        update: "tooltip:manuallyHideTip"
      },
      // noop
      function() {
      }
    );
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/preprocessor.js
var require_preprocessor2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
    function _default(option, isNew) {
      var brushComponents = option && option.brush;
      if (!zrUtil.isArray(brushComponents)) {
        brushComponents = brushComponents ? [brushComponents] : [];
      }
      if (!brushComponents.length) {
        return;
      }
      var brushComponentSpecifiedBtns = [];
      zrUtil.each(brushComponents, function(brushOpt) {
        var tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
        if (tbs instanceof Array) {
          brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
        }
      });
      var toolbox = option && option.toolbox;
      if (zrUtil.isArray(toolbox)) {
        toolbox = toolbox[0];
      }
      if (!toolbox) {
        toolbox = {
          feature: {}
        };
        option.toolbox = [toolbox];
      }
      var toolboxFeature = toolbox.feature || (toolbox.feature = {});
      var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
      var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
      brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
      removeDuplicate(brushTypes);
      if (isNew && !brushTypes.length) {
        brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
      }
    }
    function removeDuplicate(arr) {
      var map = {};
      zrUtil.each(arr, function(val) {
        map[val] = 1;
      });
      arr.length = 0;
      zrUtil.each(map, function(flag, val) {
        arr.push(val);
      });
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualSolution.js
var require_visualSolution = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualSolution.js"(exports) {
    var zrUtil = require_util();
    var VisualMapping = require_VisualMapping();
    var each = zrUtil.each;
    function hasKeys(obj) {
      if (obj) {
        for (var name2 in obj) {
          if (obj.hasOwnProperty(name2)) {
            return true;
          }
        }
      }
    }
    function createVisualMappings(option, stateList, supplementVisualOption) {
      var visualMappings = {};
      each(stateList, function(state) {
        var mappings = visualMappings[state] = createMappings();
        each(option[state], function(visualData, visualType) {
          if (!VisualMapping.isValidType(visualType)) {
            return;
          }
          var mappingOption = {
            type: visualType,
            visual: visualData
          };
          supplementVisualOption && supplementVisualOption(mappingOption, state);
          mappings[visualType] = new VisualMapping(mappingOption);
          if (visualType === "opacity") {
            mappingOption = zrUtil.clone(mappingOption);
            mappingOption.type = "colorAlpha";
            mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);
          }
        });
      });
      return visualMappings;
      function createMappings() {
        var Creater = function() {
        };
        Creater.prototype.__hidden = Creater.prototype;
        var obj = new Creater();
        return obj;
      }
    }
    function replaceVisualOption(thisOption, newOption, keys) {
      var has;
      zrUtil.each(keys, function(key) {
        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
          has = true;
        }
      });
      has && zrUtil.each(keys, function(key) {
        if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
          thisOption[key] = zrUtil.clone(newOption[key]);
        } else {
          delete thisOption[key];
        }
      });
    }
    function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
      var visualTypesMap = {};
      zrUtil.each(stateList, function(state) {
        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
        visualTypesMap[state] = visualTypes;
      });
      var dataIndex;
      function getVisual(key) {
        return data.getItemVisual(dataIndex, key);
      }
      function setVisual(key, value) {
        data.setItemVisual(dataIndex, key, value);
      }
      if (dimension == null) {
        data.each(eachItem);
      } else {
        data.each([dimension], eachItem);
      }
      function eachItem(valueOrIndex, index) {
        dataIndex = dimension == null ? valueOrIndex : index;
        var rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          return;
        }
        var valueState = getValueState.call(scope, valueOrIndex);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];
        for (var i = 0, len = visualTypes.length; i < len; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
        }
      }
    }
    function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
      var visualTypesMap = {};
      zrUtil.each(stateList, function(state) {
        var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
        visualTypesMap[state] = visualTypes;
      });
      function progress(params, data) {
        if (dim != null) {
          dim = data.getDimension(dim);
        }
        function getVisual(key) {
          return data.getItemVisual(dataIndex, key);
        }
        function setVisual(key, value2) {
          data.setItemVisual(dataIndex, key, value2);
        }
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var rawDataItem = data.getRawDataItem(dataIndex);
          if (rawDataItem && rawDataItem.visualMap === false) {
            continue;
          }
          var value = dim != null ? data.get(dim, dataIndex, true) : dataIndex;
          var valueState = getValueState(value);
          var mappings = visualMappings[valueState];
          var visualTypes = visualTypesMap[valueState];
          for (var i = 0, len = visualTypes.length; i < len; i++) {
            var type = visualTypes[i];
            mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
          }
        }
      }
      return {
        progress
      };
    }
    exports.createVisualMappings = createVisualMappings;
    exports.replaceVisualOption = replaceVisualOption;
    exports.applyVisual = applyVisual;
    exports.incrementalApplyVisual = incrementalApplyVisual;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/selector.js
var require_selector = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/selector.js"(exports, module) {
    var polygonContain = require_polygon();
    var BoundingRect = require_BoundingRect();
    var _graphic = require_graphic();
    var linePolygonIntersect = _graphic.linePolygonIntersect;
    var selector = {
      lineX: getLineSelectors(0),
      lineY: getLineSelectors(1),
      rect: {
        point: function(itemLayout, selectors, area) {
          return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
        },
        rect: function(itemLayout, selectors, area) {
          return itemLayout && area.boundingRect.intersect(itemLayout);
        }
      },
      polygon: {
        point: function(itemLayout, selectors, area) {
          return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && polygonContain.contain(area.range, itemLayout[0], itemLayout[1]);
        },
        rect: function(itemLayout, selectors, area) {
          var points = area.range;
          if (!itemLayout || points.length <= 1) {
            return false;
          }
          var x = itemLayout.x;
          var y = itemLayout.y;
          var width = itemLayout.width;
          var height = itemLayout.height;
          var p = points[0];
          if (polygonContain.contain(points, x, y) || polygonContain.contain(points, x + width, y) || polygonContain.contain(points, x, y + height) || polygonContain.contain(points, x + width, y + height) || BoundingRect.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points) || linePolygonIntersect(x, y, x, y + height, points) || linePolygonIntersect(x + width, y, x + width, y + height, points) || linePolygonIntersect(x, y + height, x + width, y + height, points)) {
            return true;
          }
        }
      }
    };
    function getLineSelectors(xyIndex) {
      var xy = ["x", "y"];
      var wh = ["width", "height"];
      return {
        point: function(itemLayout, selectors, area) {
          if (itemLayout) {
            var range = area.range;
            var p = itemLayout[xyIndex];
            return inLineRange(p, range);
          }
        },
        rect: function(itemLayout, selectors, area) {
          if (itemLayout) {
            var range = area.range;
            var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
            layoutRange[1] < layoutRange[0] && layoutRange.reverse();
            return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
          }
        }
      };
    }
    function inLineRange(p, range) {
      return range[0] <= p && p <= range[1];
    }
    var _default = selector;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/visualEncoding.js
var require_visualEncoding = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/visualEncoding.js"(exports) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var visualSolution = require_visualSolution();
    var selector = require_selector();
    var throttleUtil = require_throttle();
    var BrushTargetManager = require_BrushTargetManager();
    var STATE_LIST = ["inBrush", "outOfBrush"];
    var DISPATCH_METHOD = "__ecBrushSelect";
    var DISPATCH_FLAG = "__ecInBrushSelectEvent";
    var PRIORITY_BRUSH = echarts.PRIORITY.VISUAL.BRUSH;
    echarts.registerLayout(PRIORITY_BRUSH, function(ecModel, api, payload) {
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel) {
        payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {
          brushType: false
        });
      });
      layoutCovers(ecModel);
    });
    function layoutCovers(ecModel) {
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel) {
        var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel);
        brushTargetManager.setInputRanges(brushModel.areas, ecModel);
      });
    }
    echarts.registerVisual(PRIORITY_BRUSH, function(ecModel, api, payload) {
      var brushSelected = [];
      var throttleType;
      var throttleDelay;
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel, brushIndex) {
        var thisBrushSelected = {
          brushId: brushModel.id,
          brushIndex,
          brushName: brushModel.name,
          areas: zrUtil.clone(brushModel.areas),
          selected: []
        };
        brushSelected.push(thisBrushSelected);
        var brushOption = brushModel.option;
        var brushLink = brushOption.brushLink;
        var linkedSeriesMap = [];
        var selectedDataIndexForLink = [];
        var rangeInfoBySeries = [];
        var hasBrushExists = 0;
        if (!brushIndex) {
          throttleType = brushOption.throttleType;
          throttleDelay = brushOption.throttleDelay;
        }
        var areas = zrUtil.map(brushModel.areas, function(area) {
          return bindSelector(zrUtil.defaults({
            boundingRect: boundingRectBuilders[area.brushType](area)
          }, area));
        });
        var visualMappings = visualSolution.createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
          mappingOption.mappingMethod = "fixed";
        });
        zrUtil.isArray(brushLink) && zrUtil.each(brushLink, function(seriesIndex) {
          linkedSeriesMap[seriesIndex] = 1;
        });
        function linkOthers(seriesIndex) {
          return brushLink === "all" || linkedSeriesMap[seriesIndex];
        }
        function brushed(rangeInfoList) {
          return !!rangeInfoList.length;
        }
        ecModel.eachSeries(function(seriesModel, seriesIndex) {
          var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
          seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex, rangeInfoList) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
        });
        function stepAParallel(seriesModel, seriesIndex) {
          var coordSys = seriesModel.coordinateSystem;
          hasBrushExists |= coordSys.hasAxisBrushed();
          linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
            activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
          });
        }
        function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
          var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
          if (!selectorsByBrushType || brushModelNotControll(brushModel, seriesIndex)) {
            return;
          }
          zrUtil.each(areas, function(area) {
            selectorsByBrushType[area.brushType] && brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel) && rangeInfoList.push(area);
            hasBrushExists |= brushed(rangeInfoList);
          });
          if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
            var data = seriesModel.getData();
            data.each(function(dataIndex) {
              if (checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)) {
                selectedDataIndexForLink[dataIndex] = 1;
              }
            });
          }
        }
        ecModel.eachSeries(function(seriesModel, seriesIndex) {
          var seriesBrushSelected = {
            seriesId: seriesModel.id,
            seriesIndex,
            seriesName: seriesModel.name,
            dataIndex: []
          };
          thisBrushSelected.selected.push(seriesBrushSelected);
          var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
          var rangeInfoList = rangeInfoBySeries[seriesIndex];
          var data = seriesModel.getData();
          var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
            return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
          } : function(dataIndex) {
            return checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
          };
          (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && visualSolution.applyVisual(STATE_LIST, visualMappings, data, getValueState);
        });
      });
      dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);
    });
    function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {
      if (!payload) {
        return;
      }
      var zr = api.getZr();
      if (zr[DISPATCH_FLAG]) {
        return;
      }
      if (!zr[DISPATCH_METHOD]) {
        zr[DISPATCH_METHOD] = doDispatch;
      }
      var fn = throttleUtil.createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
      fn(api, brushSelected);
    }
    function doDispatch(api, brushSelected) {
      if (!api.isDisposed()) {
        var zr = api.getZr();
        zr[DISPATCH_FLAG] = true;
        api.dispatchAction({
          type: "brushSelect",
          batch: brushSelected
        });
        zr[DISPATCH_FLAG] = false;
      }
    }
    function checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) {
      for (var i = 0, len = rangeInfoList.length; i < len; i++) {
        var area = rangeInfoList[i];
        if (selectorsByBrushType[area.brushType](dataIndex, data, area.selectors, area)) {
          return true;
        }
      }
    }
    function getSelectorsByBrushType(seriesModel) {
      var brushSelector = seriesModel.brushSelector;
      if (zrUtil.isString(brushSelector)) {
        var sels = [];
        zrUtil.each(selector, function(selectorsByElementType, brushType) {
          sels[brushType] = function(dataIndex, data, selectors, area) {
            var itemLayout = data.getItemLayout(dataIndex);
            return selectorsByElementType[brushSelector](itemLayout, selectors, area);
          };
        });
        return sels;
      } else if (zrUtil.isFunction(brushSelector)) {
        var bSelector = {};
        zrUtil.each(selector, function(sel, brushType) {
          bSelector[brushType] = brushSelector;
        });
        return bSelector;
      }
      return brushSelector;
    }
    function brushModelNotControll(brushModel, seriesIndex) {
      var seriesIndices = brushModel.option.seriesIndex;
      return seriesIndices != null && seriesIndices !== "all" && (zrUtil.isArray(seriesIndices) ? zrUtil.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
    }
    function bindSelector(area) {
      var selectors = area.selectors = {};
      zrUtil.each(selector[area.brushType], function(selFn, elType) {
        selectors[elType] = function(itemLayout) {
          return selFn(itemLayout, selectors, area);
        };
      });
      return area;
    }
    var boundingRectBuilders = {
      lineX: zrUtil.noop,
      lineY: zrUtil.noop,
      rect: function(area) {
        return getBoundingRectFromMinMax(area.range);
      },
      polygon: function(area) {
        var minMax;
        var range = area.range;
        for (var i = 0, len = range.length; i < len; i++) {
          minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
          var rg = range[i];
          rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
          rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
          rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
          rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
        }
        return minMax && getBoundingRectFromMinMax(minMax);
      }
    };
    function getBoundingRectFromMinMax(minMax) {
      return new BoundingRect(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
    }
    exports.layoutCovers = layoutCovers;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushModel.js
var require_BrushModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var visualSolution = require_visualSolution();
    var Model = require_Model();
    var DEFAULT_OUT_OF_BRUSH_COLOR = ["#ddd"];
    var BrushModel = echarts.extendComponentModel({
      type: "brush",
      dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
      /**
       * @protected
       */
      defaultOption: {
        // inBrush: null,
        // outOfBrush: null,
        toolbox: null,
        // Default value see preprocessor.
        brushLink: null,
        // Series indices array, broadcast using dataIndex.
        // or 'all', which means all series. 'none' or null means no series.
        seriesIndex: "all",
        // seriesIndex array, specify series controlled by this brush component.
        geoIndex: null,
        //
        xAxisIndex: null,
        yAxisIndex: null,
        brushType: "rect",
        // Default brushType, see BrushController.
        brushMode: "single",
        // Default brushMode, 'single' or 'multiple'
        transformable: true,
        // Default transformable.
        brushStyle: {
          // Default brushStyle
          borderWidth: 1,
          color: "rgba(120,140,180,0.3)",
          borderColor: "rgba(120,140,180,0.8)"
        },
        throttleType: "fixRate",
        // Throttle in brushSelected event. 'fixRate' or 'debounce'.
        // If null, no throttle. Valid only in the first brush component
        throttleDelay: 0,
        // Unit: ms, 0 means every event will be triggered.
        // FIXME
        // 试验效果
        removeOnClick: true,
        z: 1e4
      },
      /**
       * @readOnly
       * @type {Array.<Object>}
       */
      areas: [],
      /**
       * Current activated brush type.
       * If null, brush is inactived.
       * see module:echarts/component/helper/BrushController
       * @readOnly
       * @type {string}
       */
      brushType: null,
      /**
       * Current brush opt.
       * see module:echarts/component/helper/BrushController
       * @readOnly
       * @type {Object}
       */
      brushOption: {},
      /**
       * @readOnly
       * @type {Array.<Object>}
       */
      coordInfoList: [],
      optionUpdated: function(newOption, isInit) {
        var thisOption = this.option;
        !isInit && visualSolution.replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
        var inBrush = thisOption.inBrush = thisOption.inBrush || {};
        thisOption.outOfBrush = thisOption.outOfBrush || {
          color: DEFAULT_OUT_OF_BRUSH_COLOR
        };
        if (!inBrush.hasOwnProperty("liftZ")) {
          inBrush.liftZ = 5;
        }
      },
      /**
       * If ranges is null/undefined, range state remain.
       *
       * @param {Array.<Object>} [ranges]
       */
      setAreas: function(areas) {
        if (!areas) {
          return;
        }
        this.areas = zrUtil.map(areas, function(area) {
          return generateBrushOption(this.option, area);
        }, this);
      },
      /**
       * see module:echarts/component/helper/BrushController
       * @param {Object} brushOption
       */
      setBrushOption: function(brushOption) {
        this.brushOption = generateBrushOption(this.option, brushOption);
        this.brushType = this.brushOption.brushType;
      }
    });
    function generateBrushOption(option, brushOption) {
      return zrUtil.merge({
        brushType: option.brushType,
        brushMode: option.brushMode,
        transformable: option.transformable,
        brushStyle: new Model(option.brushStyle).getItemStyle(),
        removeOnClick: option.removeOnClick,
        z: option.z
      }, brushOption, true);
    }
    var _default = BrushModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushView.js
var require_BrushView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/BrushView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var BrushController = require_BrushController();
    var _visualEncoding = require_visualEncoding();
    var layoutCovers = _visualEncoding.layoutCovers;
    var _default = echarts.extendComponentView({
      type: "brush",
      init: function(ecModel, api) {
        this.ecModel = ecModel;
        this.api = api;
        this.model;
        (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil.bind(this._onBrush, this)).mount();
      },
      /**
       * @override
       */
      render: function(brushModel) {
        this.model = brushModel;
        return updateController.apply(this, arguments);
      },
      /**
       * @override
       */
      updateTransform: function(brushModel, ecModel) {
        layoutCovers(ecModel);
        return updateController.apply(this, arguments);
      },
      /**
       * @override
       */
      updateView: updateController,
      // /**
      //  * @override
      //  */
      // updateLayout: updateController,
      // /**
      //  * @override
      //  */
      // updateVisual: updateController,
      /**
       * @override
       */
      dispose: function() {
        this._brushController.dispose();
      },
      /**
       * @private
       */
      _onBrush: function(areas, opt) {
        var modelId = this.model.id;
        this.model.brushTargetManager.setOutputRanges(areas, this.ecModel);
        (!opt.isEnd || opt.removeOnClick) && this.api.dispatchAction({
          type: "brush",
          brushId: modelId,
          areas: zrUtil.clone(areas),
          $from: modelId
        });
        opt.isEnd && this.api.dispatchAction({
          type: "brushEnd",
          brushId: modelId,
          areas: zrUtil.clone(areas),
          $from: modelId
        });
      }
    });
    function updateController(brushModel, ecModel, api, payload) {
      (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/brushAction.js
var require_brushAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush/brushAction.js"() {
    var echarts = require_echarts();
    echarts.registerAction({
      type: "brush",
      event: "brush"
      /*, update: 'updateView' */
    }, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "brush",
        query: payload
      }, function(brushModel) {
        brushModel.setAreas(payload.areas);
      });
    });
    echarts.registerAction({
      type: "brushSelect",
      event: "brushSelected",
      update: "none"
    }, function() {
    });
    echarts.registerAction({
      type: "brushEnd",
      event: "brushEnd",
      update: "none"
    }, function() {
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Brush.js
var require_Brush = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/toolbox/feature/Brush.js"(exports, module) {
    var zrUtil = require_util();
    var featureManager = require_featureManager();
    var lang = require_lang();
    var brushLang = lang.toolbox.brush;
    function Brush(model, ecModel, api) {
      this.model = model;
      this.ecModel = ecModel;
      this.api = api;
      this._brushType;
      this._brushMode;
    }
    Brush.defaultOption = {
      show: true,
      type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
      icon: {
        /* eslint-disable */
        rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
        // jshint ignore:line
        polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
        // jshint ignore:line
        lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
        // jshint ignore:line
        lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
        // jshint ignore:line
        keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
        // jshint ignore:line
        clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
        // jshint ignore:line
        /* eslint-enable */
      },
      // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
      title: zrUtil.clone(brushLang.title)
    };
    var proto = Brush.prototype;
    proto.render = /* eslint-enable */
    proto.updateView = function(featureModel, ecModel, api) {
      var brushType;
      var brushMode;
      var isBrushed;
      ecModel.eachComponent({
        mainType: "brush"
      }, function(brushModel) {
        brushType = brushModel.brushType;
        brushMode = brushModel.brushOption.brushMode || "single";
        isBrushed |= brushModel.areas.length;
      });
      this._brushType = brushType;
      this._brushMode = brushMode;
      zrUtil.each(featureModel.get("type", true), function(type) {
        featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
      });
    };
    proto.getIcons = function() {
      var model = this.model;
      var availableIcons = model.get("icon", true);
      var icons = {};
      zrUtil.each(model.get("type", true), function(type) {
        if (availableIcons[type]) {
          icons[type] = availableIcons[type];
        }
      });
      return icons;
    };
    proto.onclick = function(ecModel, api, type) {
      var brushType = this._brushType;
      var brushMode = this._brushMode;
      if (type === "clear") {
        api.dispatchAction({
          type: "axisAreaSelect",
          intervals: []
        });
        api.dispatchAction({
          type: "brush",
          command: "clear",
          // Clear all areas of all brush components.
          areas: []
        });
      } else {
        api.dispatchAction({
          type: "takeGlobalCursor",
          key: "brush",
          brushOption: {
            brushType: type === "keep" ? brushType : brushType === type ? false : type,
            brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
          }
        });
      }
    };
    featureManager.register("brush", Brush);
    var _default = Brush;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush.js
var require_brush = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/brush.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor2();
    require_visualEncoding();
    require_BrushModel();
    require_BrushView();
    require_brushAction();
    require_Brush();
    echarts.registerPreprocessor(preprocessor);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/title.js
var require_title = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/title.js"() {
    var zrUtil = require_util();
    var echarts = require_echarts();
    var graphic = require_graphic();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    var _format = require_format();
    var windowOpen = _format.windowOpen;
    echarts.extendComponentModel({
      type: "title",
      layoutMode: {
        type: "box",
        ignoreSize: true
      },
      defaultOption: {
        // 一级层叠
        zlevel: 0,
        // 二级层叠
        z: 6,
        show: true,
        text: "",
        // 超链接跳转
        // link: null,
        // 仅支持self | blank
        target: "blank",
        subtext: "",
        // 超链接跳转
        // sublink: null,
        // 仅支持self | blank
        subtarget: "blank",
        // 'center' ¦ 'left' ¦ 'right'
        // ¦ {number}（x坐标，单位px）
        left: 0,
        // 'top' ¦ 'bottom' ¦ 'center'
        // ¦ {number}（y坐标，单位px）
        top: 0,
        // 水平对齐
        // 'auto' | 'left' | 'right' | 'center'
        // 默认根据 left 的位置判断是左对齐还是右对齐
        // textAlign: null
        //
        // 垂直对齐
        // 'auto' | 'top' | 'bottom' | 'middle'
        // 默认根据 top 位置判断是上对齐还是下对齐
        // textVerticalAlign: null
        // textBaseline: null // The same as textVerticalAlign.
        backgroundColor: "rgba(0,0,0,0)",
        // 标题边框颜色
        borderColor: "#ccc",
        // 标题边框线宽，单位px，默认为0（无边框）
        borderWidth: 0,
        // 标题内边距，单位px，默认各方向内边距为5，
        // 接受数组分别设定上右下左边距，同css
        padding: 5,
        // 主副标题纵向间隔，单位px，默认为10，
        itemGap: 10,
        textStyle: {
          fontSize: 18,
          fontWeight: "bolder",
          color: "#333"
        },
        subtextStyle: {
          color: "#aaa"
        }
      }
    });
    echarts.extendComponentView({
      type: "title",
      render: function(titleModel, ecModel, api) {
        this.group.removeAll();
        if (!titleModel.get("show")) {
          return;
        }
        var group = this.group;
        var textStyleModel = titleModel.getModel("textStyle");
        var subtextStyleModel = titleModel.getModel("subtextStyle");
        var textAlign = titleModel.get("textAlign");
        var textVerticalAlign = zrUtil.retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
        var textEl = new graphic.Text({
          style: graphic.setTextStyle({}, textStyleModel, {
            text: titleModel.get("text"),
            textFill: textStyleModel.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var textRect = textEl.getBoundingRect();
        var subText = titleModel.get("subtext");
        var subTextEl = new graphic.Text({
          style: graphic.setTextStyle({}, subtextStyleModel, {
            text: subText,
            textFill: subtextStyleModel.getTextColor(),
            y: textRect.height + titleModel.get("itemGap"),
            textVerticalAlign: "top"
          }, {
            disableBox: true
          }),
          z2: 10
        });
        var link = titleModel.get("link");
        var sublink = titleModel.get("sublink");
        var triggerEvent = titleModel.get("triggerEvent", true);
        textEl.silent = !link && !triggerEvent;
        subTextEl.silent = !sublink && !triggerEvent;
        if (link) {
          textEl.on("click", function() {
            windowOpen(link, "_" + titleModel.get("target"));
          });
        }
        if (sublink) {
          subTextEl.on("click", function() {
            windowOpen(sublink, "_" + titleModel.get("subtarget"));
          });
        }
        textEl.eventData = subTextEl.eventData = triggerEvent ? {
          componentType: "title",
          componentIndex: titleModel.componentIndex
        } : null;
        group.add(textEl);
        subText && group.add(subTextEl);
        var groupRect = group.getBoundingRect();
        var layoutOption = titleModel.getBoxLayoutParams();
        layoutOption.width = groupRect.width;
        layoutOption.height = groupRect.height;
        var layoutRect = getLayoutRect(layoutOption, {
          width: api.getWidth(),
          height: api.getHeight()
        }, titleModel.get("padding"));
        if (!textAlign) {
          textAlign = titleModel.get("left") || titleModel.get("right");
          if (textAlign === "middle") {
            textAlign = "center";
          }
          if (textAlign === "right") {
            layoutRect.x += layoutRect.width;
          } else if (textAlign === "center") {
            layoutRect.x += layoutRect.width / 2;
          }
        }
        if (!textVerticalAlign) {
          textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
          if (textVerticalAlign === "center") {
            textVerticalAlign = "middle";
          }
          if (textVerticalAlign === "bottom") {
            layoutRect.y += layoutRect.height;
          } else if (textVerticalAlign === "middle") {
            layoutRect.y += layoutRect.height / 2;
          }
          textVerticalAlign = textVerticalAlign || "top";
        }
        group.attr("position", [layoutRect.x, layoutRect.y]);
        var alignStyle = {
          textAlign,
          textVerticalAlign
        };
        textEl.setStyle(alignStyle);
        subTextEl.setStyle(alignStyle);
        groupRect = group.getBoundingRect();
        var padding = layoutRect.margin;
        var style = titleModel.getItemStyle(["color", "opacity"]);
        style.fill = titleModel.get("backgroundColor");
        var rect = new graphic.Rect({
          shape: {
            x: groupRect.x - padding[3],
            y: groupRect.y - padding[0],
            width: groupRect.width + padding[1] + padding[3],
            height: groupRect.height + padding[0] + padding[2],
            r: titleModel.get("borderRadius")
          },
          style,
          subPixelOptimize: true,
          silent: true
        });
        group.add(rect);
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/preprocessor.js
var require_preprocessor3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    function _default(option) {
      var timelineOpt = option && option.timeline;
      if (!zrUtil.isArray(timelineOpt)) {
        timelineOpt = timelineOpt ? [timelineOpt] : [];
      }
      zrUtil.each(timelineOpt, function(opt) {
        if (!opt) {
          return;
        }
        compatibleEC2(opt);
      });
    }
    function compatibleEC2(opt) {
      var type = opt.type;
      var ec2Types = {
        "number": "value",
        "time": "time"
      };
      if (ec2Types[type]) {
        opt.axisType = ec2Types[type];
        delete opt.type;
      }
      transferItem(opt);
      if (has(opt, "controlPosition")) {
        var controlStyle = opt.controlStyle || (opt.controlStyle = {});
        if (!has(controlStyle, "position")) {
          controlStyle.position = opt.controlPosition;
        }
        if (controlStyle.position === "none" && !has(controlStyle, "show")) {
          controlStyle.show = false;
          delete controlStyle.position;
        }
        delete opt.controlPosition;
      }
      zrUtil.each(opt.data || [], function(dataItem) {
        if (zrUtil.isObject(dataItem) && !zrUtil.isArray(dataItem)) {
          if (!has(dataItem, "value") && has(dataItem, "name")) {
            dataItem.value = dataItem.name;
          }
          transferItem(dataItem);
        }
      });
    }
    function transferItem(opt) {
      var itemStyle = opt.itemStyle || (opt.itemStyle = {});
      var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
      var label = opt.label || opt.label || {};
      var labelNormal = label.normal || (label.normal = {});
      var excludeLabelAttr = {
        normal: 1,
        emphasis: 1
      };
      zrUtil.each(label, function(value, name2) {
        if (!excludeLabelAttr[name2] && !has(labelNormal, name2)) {
          labelNormal[name2] = value;
        }
      });
      if (itemStyleEmphasis.label && !has(label, "emphasis")) {
        label.emphasis = itemStyleEmphasis.label;
        delete itemStyleEmphasis.label;
      }
    }
    function has(obj, attr) {
      return obj.hasOwnProperty(attr);
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/typeDefaulter.js
var require_typeDefaulter2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/typeDefaulter.js"() {
    var Component = require_Component();
    Component.registerSubTypeDefaulter("timeline", function() {
      return "slider";
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/timelineAction.js
var require_timelineAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/timelineAction.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    echarts.registerAction({
      type: "timelineChange",
      event: "timelineChanged",
      update: "prepareAndUpdate"
    }, function(payload, ecModel) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel && payload.currentIndex != null) {
        timelineModel.setCurrentIndex(payload.currentIndex);
        if (!timelineModel.get("loop", true) && timelineModel.isIndexMax()) {
          timelineModel.setPlayState(false);
        }
      }
      ecModel.resetOption("timeline");
      return zrUtil.defaults({
        currentIndex: timelineModel.option.currentIndex
      }, payload);
    });
    echarts.registerAction({
      type: "timelinePlayChange",
      event: "timelinePlayChanged",
      update: "update"
    }, function(payload, ecModel) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel && payload.playState != null) {
        timelineModel.setPlayState(payload.playState);
      }
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineModel.js
var require_TimelineModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineModel.js"(exports, module) {
    var zrUtil = require_util();
    var ComponentModel = require_Component();
    var List = require_List();
    var modelUtil = require_model();
    var TimelineModel = ComponentModel.extend({
      type: "timeline",
      layoutMode: "box",
      /**
       * @protected
       */
      defaultOption: {
        zlevel: 0,
        // 一级层叠
        z: 4,
        // 二级层叠
        show: true,
        axisType: "time",
        // 模式是时间类型，支持 value, category
        realtime: true,
        left: "20%",
        top: null,
        right: "20%",
        bottom: 0,
        width: null,
        height: 40,
        padding: 5,
        controlPosition: "left",
        // 'left' 'right' 'top' 'bottom' 'none'
        autoPlay: false,
        rewind: false,
        // 反向播放
        loop: true,
        playInterval: 2e3,
        // 播放时间间隔，单位ms
        currentIndex: 0,
        itemStyle: {},
        label: {
          color: "#000"
        },
        data: []
      },
      /**
       * @override
       */
      init: function(option, parentModel, ecModel) {
        this._data;
        this._names;
        this.mergeDefaultAndTheme(option, ecModel);
        this._initData();
      },
      /**
       * @override
       */
      mergeOption: function(option) {
        TimelineModel.superApply(this, "mergeOption", arguments);
        this._initData();
      },
      /**
       * @param {number} [currentIndex]
       */
      setCurrentIndex: function(currentIndex) {
        if (currentIndex == null) {
          currentIndex = this.option.currentIndex;
        }
        var count = this._data.count();
        if (this.option.loop) {
          currentIndex = (currentIndex % count + count) % count;
        } else {
          currentIndex >= count && (currentIndex = count - 1);
          currentIndex < 0 && (currentIndex = 0);
        }
        this.option.currentIndex = currentIndex;
      },
      /**
       * @return {number} currentIndex
       */
      getCurrentIndex: function() {
        return this.option.currentIndex;
      },
      /**
       * @return {boolean}
       */
      isIndexMax: function() {
        return this.getCurrentIndex() >= this._data.count() - 1;
      },
      /**
       * @param {boolean} state true: play, false: stop
       */
      setPlayState: function(state) {
        this.option.autoPlay = !!state;
      },
      /**
       * @return {boolean} true: play, false: stop
       */
      getPlayState: function() {
        return !!this.option.autoPlay;
      },
      /**
       * @private
       */
      _initData: function() {
        var thisOption = this.option;
        var dataArr = thisOption.data || [];
        var axisType = thisOption.axisType;
        var names = this._names = [];
        if (axisType === "category") {
          var idxArr = [];
          zrUtil.each(dataArr, function(item, index) {
            var value = modelUtil.getDataItemValue(item);
            var newItem;
            if (zrUtil.isObject(item)) {
              newItem = zrUtil.clone(item);
              newItem.value = index;
            } else {
              newItem = index;
            }
            idxArr.push(newItem);
            if (!zrUtil.isString(value) && (value == null || isNaN(value))) {
              value = "";
            }
            names.push(value + "");
          });
          dataArr = idxArr;
        }
        var dimType = {
          category: "ordinal",
          time: "time"
        }[axisType] || "number";
        var data = this._data = new List([{
          name: "value",
          type: dimType
        }], this);
        data.initData(dataArr, names);
      },
      getData: function() {
        return this._data;
      },
      /**
       * @public
       * @return {Array.<string>} categoreis
       */
      getCategories: function() {
        if (this.get("axisType") === "category") {
          return this._names.slice();
        }
      }
    });
    var _default = TimelineModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineModel.js
var require_SliderTimelineModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineModel.js"(exports, module) {
    var zrUtil = require_util();
    var TimelineModel = require_TimelineModel();
    var dataFormatMixin = require_dataFormat();
    var SliderTimelineModel = TimelineModel.extend({
      type: "timeline.slider",
      /**
       * @protected
       */
      defaultOption: {
        backgroundColor: "rgba(0,0,0,0)",
        // 时间轴背景颜色
        borderColor: "#ccc",
        // 时间轴边框颜色
        borderWidth: 0,
        // 时间轴边框线宽，单位px，默认为0（无边框）
        orient: "horizontal",
        // 'vertical'
        inverse: false,
        tooltip: {
          // boolean or Object
          trigger: "item"
          // data item may also have tootip attr.
        },
        symbol: "emptyCircle",
        symbolSize: 10,
        lineStyle: {
          show: true,
          width: 2,
          color: "#304654"
        },
        label: {
          // 文本标签
          position: "auto",
          // auto left right top bottom
          // When using number, label position is not
          // restricted by viewRect.
          // positive: right/bottom, negative: left/top
          show: true,
          interval: "auto",
          rotate: 0,
          // formatter: null,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#304654"
        },
        itemStyle: {
          color: "#304654",
          borderWidth: 1
        },
        checkpointStyle: {
          symbol: "circle",
          symbolSize: 13,
          color: "#c23531",
          borderWidth: 5,
          borderColor: "rgba(194,53,49, 0.5)",
          animation: true,
          animationDuration: 300,
          animationEasing: "quinticInOut"
        },
        controlStyle: {
          show: true,
          showPlayBtn: true,
          showPrevBtn: true,
          showNextBtn: true,
          itemSize: 22,
          itemGap: 12,
          position: "left",
          // 'left' 'right' 'top' 'bottom'
          playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
          // jshint ignore:line
          stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
          // jshint ignore:line
          nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
          // jshint ignore:line
          prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
          // jshint ignore:line
          color: "#304654",
          borderColor: "#304654",
          borderWidth: 1
        },
        emphasis: {
          label: {
            show: true,
            // 其余属性默认使用全局文本样式，详见TEXTSTYLE
            color: "#c23531"
          },
          itemStyle: {
            color: "#c23531"
          },
          controlStyle: {
            color: "#c23531",
            borderColor: "#c23531",
            borderWidth: 2
          }
        },
        data: []
      }
    });
    zrUtil.mixin(SliderTimelineModel, dataFormatMixin);
    var _default = SliderTimelineModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineView.js
var require_TimelineView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineView.js"(exports, module) {
    var ComponentView = require_Component2();
    var _default = ComponentView.extend({
      type: "timeline"
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineAxis.js
var require_TimelineAxis = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/TimelineAxis.js"(exports, module) {
    var zrUtil = require_util();
    var Axis = require_Axis();
    var TimelineAxis = function(dim, scale, coordExtent, axisType) {
      Axis.call(this, dim, scale, coordExtent);
      this.type = axisType || "value";
      this.model = null;
    };
    TimelineAxis.prototype = {
      constructor: TimelineAxis,
      /**
       * @override
       */
      getLabelModel: function() {
        return this.model.getModel("label");
      },
      /**
       * @override
       */
      isHorizontal: function() {
        return this.model.get("orient") === "horizontal";
      }
    };
    zrUtil.inherits(TimelineAxis, Axis);
    var _default = TimelineAxis;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineView.js
var require_SliderTimelineView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline/SliderTimelineView.js"(exports, module) {
    var zrUtil = require_util();
    var BoundingRect = require_BoundingRect();
    var matrix = require_matrix();
    var graphic = require_graphic();
    var layout = require_layout();
    var TimelineView = require_TimelineView();
    var TimelineAxis = require_TimelineAxis();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var axisHelper = require_axisHelper();
    var numberUtil = require_number();
    var _format = require_format();
    var encodeHTML = _format.encodeHTML;
    var bind = zrUtil.bind;
    var each = zrUtil.each;
    var PI = Math.PI;
    var _default = TimelineView.extend({
      type: "timeline.slider",
      init: function(ecModel, api) {
        this.api = api;
        this._axis;
        this._viewRect;
        this._timer;
        this._currentPointer;
        this._mainGroup;
        this._labelGroup;
      },
      /**
       * @override
       */
      render: function(timelineModel, ecModel, api, payload) {
        this.model = timelineModel;
        this.api = api;
        this.ecModel = ecModel;
        this.group.removeAll();
        if (timelineModel.get("show", true)) {
          var layoutInfo = this._layout(timelineModel, api);
          var mainGroup = this._createGroup("mainGroup");
          var labelGroup = this._createGroup("labelGroup");
          var axis = this._axis = this._createAxis(layoutInfo, timelineModel);
          timelineModel.formatTooltip = function(dataIndex) {
            return encodeHTML(axis.scale.getLabel(dataIndex));
          };
          each(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name2) {
            this["_render" + name2](layoutInfo, mainGroup, axis, timelineModel);
          }, this);
          this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);
          this._position(layoutInfo, timelineModel);
        }
        this._doPlayStop();
      },
      /**
       * @override
       */
      remove: function() {
        this._clearTimer();
        this.group.removeAll();
      },
      /**
       * @override
       */
      dispose: function() {
        this._clearTimer();
      },
      _layout: function(timelineModel, api) {
        var labelPosOpt = timelineModel.get("label.position");
        var orient = timelineModel.get("orient");
        var viewRect = getViewRect(timelineModel, api);
        if (labelPosOpt == null || labelPosOpt === "auto") {
          labelPosOpt = orient === "horizontal" ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? "+" : "-";
        } else if (isNaN(labelPosOpt)) {
          labelPosOpt = {
            horizontal: {
              top: "-",
              bottom: "+"
            },
            vertical: {
              left: "-",
              right: "+"
            }
          }[orient][labelPosOpt];
        }
        var labelAlignMap = {
          horizontal: "center",
          vertical: labelPosOpt >= 0 || labelPosOpt === "+" ? "left" : "right"
        };
        var labelBaselineMap = {
          horizontal: labelPosOpt >= 0 || labelPosOpt === "+" ? "top" : "bottom",
          vertical: "middle"
        };
        var rotationMap = {
          horizontal: 0,
          vertical: PI / 2
        };
        var mainLength = orient === "vertical" ? viewRect.height : viewRect.width;
        var controlModel = timelineModel.getModel("controlStyle");
        var showControl = controlModel.get("show", true);
        var controlSize = showControl ? controlModel.get("itemSize") : 0;
        var controlGap = showControl ? controlModel.get("itemGap") : 0;
        var sizePlusGap = controlSize + controlGap;
        var labelRotation = timelineModel.get("label.rotate") || 0;
        labelRotation = labelRotation * PI / 180;
        var playPosition;
        var prevBtnPosition;
        var nextBtnPosition;
        var axisExtent;
        var controlPosition = controlModel.get("position", true);
        var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
        var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
        var showNextBtn = showControl && controlModel.get("showNextBtn", true);
        var xLeft = 0;
        var xRight = mainLength;
        if (controlPosition === "left" || controlPosition === "bottom") {
          showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
          showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
        } else {
          showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
          showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
        }
        axisExtent = [xLeft, xRight];
        if (timelineModel.get("inverse")) {
          axisExtent.reverse();
        }
        return {
          viewRect,
          mainLength,
          orient,
          rotation: rotationMap[orient],
          labelRotation,
          labelPosOpt,
          labelAlign: timelineModel.get("label.align") || labelAlignMap[orient],
          labelBaseline: timelineModel.get("label.verticalAlign") || timelineModel.get("label.baseline") || labelBaselineMap[orient],
          // Based on mainGroup.
          playPosition,
          prevBtnPosition,
          nextBtnPosition,
          axisExtent,
          controlSize,
          controlGap
        };
      },
      _position: function(layoutInfo, timelineModel) {
        var mainGroup = this._mainGroup;
        var labelGroup = this._labelGroup;
        var viewRect = layoutInfo.viewRect;
        if (layoutInfo.orient === "vertical") {
          var m = matrix.create();
          var rotateOriginX = viewRect.x;
          var rotateOriginY = viewRect.y + viewRect.height;
          matrix.translate(m, m, [-rotateOriginX, -rotateOriginY]);
          matrix.rotate(m, m, -PI / 2);
          matrix.translate(m, m, [rotateOriginX, rotateOriginY]);
          viewRect = viewRect.clone();
          viewRect.applyTransform(m);
        }
        var viewBound = getBound(viewRect);
        var mainBound = getBound(mainGroup.getBoundingRect());
        var labelBound = getBound(labelGroup.getBoundingRect());
        var mainPosition = mainGroup.position;
        var labelsPosition = labelGroup.position;
        labelsPosition[0] = mainPosition[0] = viewBound[0][0];
        var labelPosOpt = layoutInfo.labelPosOpt;
        if (isNaN(labelPosOpt)) {
          var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
          toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
        } else {
          var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
          labelsPosition[1] = mainPosition[1] + labelPosOpt;
        }
        mainGroup.attr("position", mainPosition);
        labelGroup.attr("position", labelsPosition);
        mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
        setOrigin(mainGroup);
        setOrigin(labelGroup);
        function setOrigin(targetGroup) {
          var pos = targetGroup.position;
          targetGroup.origin = [viewBound[0][0] - pos[0], viewBound[1][0] - pos[1]];
        }
        function getBound(rect) {
          return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
        }
        function toBound(fromPos, from, to, dimIdx, boundIdx) {
          fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
        }
      },
      _createAxis: function(layoutInfo, timelineModel) {
        var data = timelineModel.getData();
        var axisType = timelineModel.get("axisType");
        var scale = axisHelper.createScaleByModel(timelineModel, axisType);
        scale.getTicks = function() {
          return data.mapArray(["value"], function(value) {
            return value;
          });
        };
        var dataExtent = data.getDataExtent("value");
        scale.setExtent(dataExtent[0], dataExtent[1]);
        scale.niceTicks();
        var axis = new TimelineAxis("value", scale, layoutInfo.axisExtent, axisType);
        axis.model = timelineModel;
        return axis;
      },
      _createGroup: function(name2) {
        var newGroup = this["_" + name2] = new graphic.Group();
        this.group.add(newGroup);
        return newGroup;
      },
      _renderAxisLine: function(layoutInfo, group, axis, timelineModel) {
        var axisExtent = axis.getExtent();
        if (!timelineModel.get("lineStyle.show")) {
          return;
        }
        group.add(new graphic.Line({
          shape: {
            x1: axisExtent[0],
            y1: 0,
            x2: axisExtent[1],
            y2: 0
          },
          style: zrUtil.extend({
            lineCap: "round"
          }, timelineModel.getModel("lineStyle").getLineStyle()),
          silent: true,
          z2: 1
        }));
      },
      /**
       * @private
       */
      _renderAxisTick: function(layoutInfo, group, axis, timelineModel) {
        var data = timelineModel.getData();
        var ticks = axis.scale.getTicks();
        each(ticks, function(value) {
          var tickCoord = axis.dataToCoord(value);
          var itemModel = data.getItemModel(value);
          var itemStyleModel = itemModel.getModel("itemStyle");
          var hoverStyleModel = itemModel.getModel("emphasis.itemStyle");
          var symbolOpt = {
            position: [tickCoord, 0],
            onclick: bind(this._changeTimeline, this, value)
          };
          var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
          graphic.setHoverStyle(el, hoverStyleModel.getItemStyle());
          if (itemModel.get("tooltip")) {
            el.dataIndex = value;
            el.dataModel = timelineModel;
          } else {
            el.dataIndex = el.dataModel = null;
          }
        }, this);
      },
      /**
       * @private
       */
      _renderAxisLabel: function(layoutInfo, group, axis, timelineModel) {
        var labelModel = axis.getLabelModel();
        if (!labelModel.get("show")) {
          return;
        }
        var data = timelineModel.getData();
        var labels = axis.getViewLabels();
        each(labels, function(labelItem) {
          var dataIndex = labelItem.tickValue;
          var itemModel = data.getItemModel(dataIndex);
          var normalLabelModel = itemModel.getModel("label");
          var hoverLabelModel = itemModel.getModel("emphasis.label");
          var tickCoord = axis.dataToCoord(labelItem.tickValue);
          var textEl = new graphic.Text({
            position: [tickCoord, 0],
            rotation: layoutInfo.labelRotation - layoutInfo.rotation,
            onclick: bind(this._changeTimeline, this, dataIndex),
            silent: false
          });
          graphic.setTextStyle(textEl.style, normalLabelModel, {
            text: labelItem.formattedLabel,
            textAlign: layoutInfo.labelAlign,
            textVerticalAlign: layoutInfo.labelBaseline
          });
          group.add(textEl);
          graphic.setHoverStyle(textEl, graphic.setTextStyle({}, hoverLabelModel));
        }, this);
      },
      /**
       * @private
       */
      _renderControl: function(layoutInfo, group, axis, timelineModel) {
        var controlSize = layoutInfo.controlSize;
        var rotation = layoutInfo.rotation;
        var itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
        var hoverStyle = timelineModel.getModel("emphasis.controlStyle").getItemStyle();
        var rect = [0, -controlSize / 2, controlSize, controlSize];
        var playState = timelineModel.getPlayState();
        var inverse = timelineModel.get("inverse", true);
        makeBtn(layoutInfo.nextBtnPosition, "controlStyle.nextIcon", bind(this._changeTimeline, this, inverse ? "-" : "+"));
        makeBtn(layoutInfo.prevBtnPosition, "controlStyle.prevIcon", bind(this._changeTimeline, this, inverse ? "+" : "-"));
        makeBtn(layoutInfo.playPosition, "controlStyle." + (playState ? "stopIcon" : "playIcon"), bind(this._handlePlayClick, this, !playState), true);
        function makeBtn(position, iconPath, onclick, willRotate) {
          if (!position) {
            return;
          }
          var opt = {
            position,
            origin: [controlSize / 2, 0],
            rotation: willRotate ? -rotation : 0,
            rectHover: true,
            style: itemStyle,
            onclick
          };
          var btn = makeIcon(timelineModel, iconPath, rect, opt);
          group.add(btn);
          graphic.setHoverStyle(btn, hoverStyle);
        }
      },
      _renderCurrentPointer: function(layoutInfo, group, axis, timelineModel) {
        var data = timelineModel.getData();
        var currentIndex = timelineModel.getCurrentIndex();
        var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
        var me = this;
        var callback = {
          onCreate: function(pointer) {
            pointer.draggable = true;
            pointer.drift = bind(me._handlePointerDrag, me);
            pointer.ondragend = bind(me._handlePointerDragend, me);
            pointerMoveTo(pointer, currentIndex, axis, timelineModel, true);
          },
          onUpdate: function(pointer) {
            pointerMoveTo(pointer, currentIndex, axis, timelineModel);
          }
        };
        this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
      },
      _handlePlayClick: function(nextState) {
        this._clearTimer();
        this.api.dispatchAction({
          type: "timelinePlayChange",
          playState: nextState,
          from: this.uid
        });
      },
      _handlePointerDrag: function(dx, dy, e) {
        this._clearTimer();
        this._pointerChangeTimeline([e.offsetX, e.offsetY]);
      },
      _handlePointerDragend: function(e) {
        this._pointerChangeTimeline([e.offsetX, e.offsetY], true);
      },
      _pointerChangeTimeline: function(mousePos, trigger) {
        var toCoord = this._toAxisCoord(mousePos)[0];
        var axis = this._axis;
        var axisExtent = numberUtil.asc(axis.getExtent().slice());
        toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
        toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
        this._currentPointer.position[0] = toCoord;
        this._currentPointer.dirty();
        var targetDataIndex = this._findNearestTick(toCoord);
        var timelineModel = this.model;
        if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
          this._changeTimeline(targetDataIndex);
        }
      },
      _doPlayStop: function() {
        this._clearTimer();
        if (this.model.getPlayState()) {
          this._timer = setTimeout(bind(handleFrame, this), this.model.get("playInterval"));
        }
        function handleFrame() {
          var timelineModel = this.model;
          this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
        }
      },
      _toAxisCoord: function(vertex) {
        var trans = this._mainGroup.getLocalTransform();
        return graphic.applyTransform(vertex, trans, true);
      },
      _findNearestTick: function(axisCoord) {
        var data = this.model.getData();
        var dist = Infinity;
        var targetDataIndex;
        var axis = this._axis;
        data.each(["value"], function(value, dataIndex) {
          var coord = axis.dataToCoord(value);
          var d = Math.abs(coord - axisCoord);
          if (d < dist) {
            dist = d;
            targetDataIndex = dataIndex;
          }
        });
        return targetDataIndex;
      },
      _clearTimer: function() {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = null;
        }
      },
      _changeTimeline: function(nextIndex) {
        var currentIndex = this.model.getCurrentIndex();
        if (nextIndex === "+") {
          nextIndex = currentIndex + 1;
        } else if (nextIndex === "-") {
          nextIndex = currentIndex - 1;
        }
        this.api.dispatchAction({
          type: "timelineChange",
          currentIndex: nextIndex,
          from: this.uid
        });
      }
    });
    function getViewRect(model, api) {
      return layout.getLayoutRect(model.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      }, model.get("padding"));
    }
    function makeIcon(timelineModel, objPath, rect, opts) {
      var style = opts.style;
      var icon = graphic.createIcon(timelineModel.get(objPath), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3]));
      if (style) {
        icon.setStyle(style);
      }
      return icon;
    }
    function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
      var color = itemStyleModel.get("color");
      if (!symbol) {
        var symbolType = hostModel.get("symbol");
        symbol = createSymbol(symbolType, -1, -1, 2, 2, color);
        symbol.setStyle("strokeNoScale", true);
        group.add(symbol);
        callback && callback.onCreate(symbol);
      } else {
        symbol.setColor(color);
        group.add(symbol);
        callback && callback.onUpdate(symbol);
      }
      var itemStyle = itemStyleModel.getItemStyle(["color", "symbol", "symbolSize"]);
      symbol.setStyle(itemStyle);
      opt = zrUtil.merge({
        rectHover: true,
        z2: 100
      }, opt, true);
      var symbolSize = hostModel.get("symbolSize");
      symbolSize = symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
      symbolSize[0] /= 2;
      symbolSize[1] /= 2;
      opt.scale = symbolSize;
      var symbolOffset = hostModel.get("symbolOffset");
      if (symbolOffset) {
        var pos = opt.position = opt.position || [0, 0];
        pos[0] += numberUtil.parsePercent(symbolOffset[0], symbolSize[0]);
        pos[1] += numberUtil.parsePercent(symbolOffset[1], symbolSize[1]);
      }
      var symbolRotate = hostModel.get("symbolRotate");
      opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
      symbol.attr(opt);
      symbol.updateTransform();
      return symbol;
    }
    function pointerMoveTo(pointer, dataIndex, axis, timelineModel, noAnimation) {
      if (pointer.dragging) {
        return;
      }
      var pointerModel = timelineModel.getModel("checkpointStyle");
      var toCoord = axis.dataToCoord(timelineModel.getData().get(["value"], dataIndex));
      if (noAnimation || !pointerModel.get("animation", true)) {
        pointer.attr({
          position: [toCoord, 0]
        });
      } else {
        pointer.stopAnimation(true);
        pointer.animateTo({
          position: [toCoord, 0]
        }, pointerModel.get("animationDuration", true), pointerModel.get("animationEasing", true));
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline.js
var require_timeline = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/timeline.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor3();
    require_typeDefaulter2();
    require_timelineAction();
    require_SliderTimelineModel();
    require_SliderTimelineView();
    echarts.registerPreprocessor(preprocessor);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerModel.js
var require_MarkerModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var modelUtil = require_model();
    var formatUtil = require_format();
    var dataFormatMixin = require_dataFormat();
    var addCommas = formatUtil.addCommas;
    var encodeHTML = formatUtil.encodeHTML;
    function fillLabel(opt) {
      modelUtil.defaultEmphasis(opt, "label", ["show"]);
    }
    var MarkerModel = echarts.extendComponentModel({
      type: "marker",
      dependencies: ["series", "grid", "polar", "geo"],
      /**
       * @overrite
       */
      init: function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
        this._mergeOption(option, ecModel, false, true);
      },
      /**
       * @return {boolean}
       */
      isAnimationEnabled: function() {
        if (env.node) {
          return false;
        }
        var hostSeries = this.__hostSeries;
        return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
      },
      /**
       * @overrite
       */
      mergeOption: function(newOpt, ecModel) {
        this._mergeOption(newOpt, ecModel, false, false);
      },
      _mergeOption: function(newOpt, ecModel, createdBySelf, isInit) {
        var MarkerModel2 = this.constructor;
        var modelPropName = this.mainType + "Model";
        if (!createdBySelf) {
          ecModel.eachSeries(function(seriesModel) {
            var markerOpt = seriesModel.get(this.mainType, true);
            var markerModel = seriesModel[modelPropName];
            if (!markerOpt || !markerOpt.data) {
              seriesModel[modelPropName] = null;
              return;
            }
            if (!markerModel) {
              if (isInit) {
                fillLabel(markerOpt);
              }
              zrUtil.each(markerOpt.data, function(item) {
                if (item instanceof Array) {
                  fillLabel(item[0]);
                  fillLabel(item[1]);
                } else {
                  fillLabel(item);
                }
              });
              markerModel = new MarkerModel2(markerOpt, this, ecModel);
              zrUtil.extend(markerModel, {
                mainType: this.mainType,
                // Use the same series index and name
                seriesIndex: seriesModel.seriesIndex,
                name: seriesModel.name,
                createdBySelf: true
              });
              markerModel.__hostSeries = seriesModel;
            } else {
              markerModel._mergeOption(markerOpt, ecModel, true);
            }
            seriesModel[modelPropName] = markerModel;
          }, this);
        }
      },
      formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
        var data = this.getData();
        var value = this.getRawValue(dataIndex);
        var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(", ") : addCommas(value);
        var name2 = data.getName(dataIndex);
        var html = encodeHTML(this.name);
        var newLine = renderMode === "html" ? "<br/>" : "\n";
        if (value != null || name2) {
          html += newLine;
        }
        if (name2) {
          html += encodeHTML(name2);
          if (value != null) {
            html += " : ";
          }
        }
        if (value != null) {
          html += encodeHTML(formattedValue);
        }
        return html;
      },
      getData: function() {
        return this._data;
      },
      setData: function(data) {
        this._data = data;
      }
    });
    zrUtil.mixin(MarkerModel, dataFormatMixin);
    var _default = MarkerModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointModel.js
var require_MarkPointModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointModel.js"(exports, module) {
    var MarkerModel = require_MarkerModel();
    var _default = MarkerModel.extend({
      type: "markPoint",
      defaultOption: {
        zlevel: 0,
        z: 5,
        symbol: "pin",
        symbolSize: 50,
        //symbolRotate: 0,
        //symbolOffset: [0, 0]
        tooltip: {
          trigger: "item"
        },
        label: {
          show: true,
          position: "inside"
        },
        itemStyle: {
          borderWidth: 2
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/markerHelper.js
var require_markerHelper = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/markerHelper.js"(exports) {
    var zrUtil = require_util();
    var numberUtil = require_number();
    var _dataStackHelper = require_dataStackHelper();
    var isDimensionStacked = _dataStackHelper.isDimensionStacked;
    var indexOf = zrUtil.indexOf;
    function hasXOrY(item) {
      return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
    }
    function hasXAndY(item) {
      return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
    }
    function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
      var coordArr = [];
      var stacked = isDimensionStacked(
        data,
        targetDataDim
        /*, otherDataDim*/
      );
      var calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
      var value = numCalculate(data, calcDataDim, mlType);
      var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
      coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
      coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
      var coordArrValue = data.get(targetDataDim, dataIndex);
      var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));
      precision = Math.min(precision, 20);
      if (precision >= 0) {
        coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
      }
      return [coordArr, coordArrValue];
    }
    var curry = zrUtil.curry;
    var markerTypeCalculator = {
      /**
       * @method
       * @param {module:echarts/data/List} data
       * @param {string} baseAxisDim
       * @param {string} valueAxisDim
       */
      min: curry(markerTypeCalculatorWithExtent, "min"),
      /**
       * @method
       * @param {module:echarts/data/List} data
       * @param {string} baseAxisDim
       * @param {string} valueAxisDim
       */
      max: curry(markerTypeCalculatorWithExtent, "max"),
      /**
       * @method
       * @param {module:echarts/data/List} data
       * @param {string} baseAxisDim
       * @param {string} valueAxisDim
       */
      average: curry(markerTypeCalculatorWithExtent, "average")
    };
    function dataTransform(seriesModel, item) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      if (item && !hasXAndY(item) && !zrUtil.isArray(item.coord) && coordSys) {
        var dims = coordSys.dimensions;
        var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
        item = zrUtil.clone(item);
        if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
          var otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
          var targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
          var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
          item.coord = coordInfo[0];
          item.value = coordInfo[1];
        } else {
          var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
          for (var i = 0; i < 2; i++) {
            if (markerTypeCalculator[coord[i]]) {
              coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
            }
          }
          item.coord = coord;
        }
      }
      return item;
    }
    function getAxisInfo(item, data, coordSys, seriesModel) {
      var ret = {};
      if (item.valueIndex != null || item.valueDim != null) {
        ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
        ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
        ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
      } else {
        ret.baseAxis = seriesModel.getBaseAxis();
        ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
        ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
        ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
      }
      return ret;
    }
    function dataDimToCoordDim(seriesModel, dataDim) {
      var data = seriesModel.getData();
      var dimensions = data.dimensions;
      dataDim = data.getDimension(dataDim);
      for (var i = 0; i < dimensions.length; i++) {
        var dimItem = data.getDimensionInfo(dimensions[i]);
        if (dimItem.name === dataDim) {
          return dimItem.coordDim;
        }
      }
    }
    function dataFilter(coordSys, item) {
      return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
    }
    function dimValueGetter(item, dimName, dataIndex, dimIndex) {
      if (dimIndex < 2) {
        return item.coord && item.coord[dimIndex];
      }
      return item.value;
    }
    function numCalculate(data, valueDataDim, type) {
      if (type === "average") {
        var sum = 0;
        var count = 0;
        data.each(valueDataDim, function(val, idx) {
          if (!isNaN(val)) {
            sum += val;
            count++;
          }
        });
        return sum / count;
      } else if (type === "median") {
        return data.getMedian(valueDataDim);
      } else {
        return data.getDataExtent(valueDataDim, true)[type === "max" ? 1 : 0];
      }
    }
    exports.dataTransform = dataTransform;
    exports.getAxisInfo = getAxisInfo;
    exports.dataFilter = dataFilter;
    exports.dimValueGetter = dimValueGetter;
    exports.numCalculate = numCalculate;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerView.js
var require_MarkerView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkerView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _default = echarts.extendComponentView({
      type: "marker",
      init: function() {
        this.markerGroupMap = zrUtil.createHashMap();
      },
      render: function(markerModel, ecModel, api) {
        var markerGroupMap = this.markerGroupMap;
        markerGroupMap.each(function(item) {
          item.__keep = false;
        });
        var markerModelKey = this.type + "Model";
        ecModel.eachSeries(function(seriesModel) {
          var markerModel2 = seriesModel[markerModelKey];
          markerModel2 && this.renderSeries(seriesModel, markerModel2, ecModel, api);
        }, this);
        markerGroupMap.each(function(item) {
          !item.__keep && this.group.remove(item.group);
        }, this);
      },
      renderSeries: function() {
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointView.js
var require_MarkPointView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkPointView.js"(exports, module) {
    var zrUtil = require_util();
    var SymbolDraw = require_SymbolDraw();
    var numberUtil = require_number();
    var List = require_List();
    var markerHelper = require_markerHelper();
    var MarkerView = require_MarkerView();
    function updateMarkerLayout(mpData, seriesModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      mpData.each(function(idx) {
        var itemModel = mpData.getItemModel(idx);
        var point;
        var xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth());
        var yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
        if (!isNaN(xPx) && !isNaN(yPx)) {
          point = [xPx, yPx];
        } else if (seriesModel.getMarkerPosition) {
          point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
        } else if (coordSys) {
          var x = mpData.get(coordSys.dimensions[0], idx);
          var y = mpData.get(coordSys.dimensions[1], idx);
          point = coordSys.dataToPoint([x, y]);
        }
        if (!isNaN(xPx)) {
          point[0] = xPx;
        }
        if (!isNaN(yPx)) {
          point[1] = yPx;
        }
        mpData.setItemLayout(idx, point);
      });
    }
    var _default = MarkerView.extend({
      type: "markPoint",
      // updateLayout: function (markPointModel, ecModel, api) {
      //     ecModel.eachSeries(function (seriesModel) {
      //         var mpModel = seriesModel.markPointModel;
      //         if (mpModel) {
      //             updateMarkerLayout(mpModel.getData(), seriesModel, api);
      //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
      //         }
      //     }, this);
      // },
      updateTransform: function(markPointModel, ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          var mpModel = seriesModel.markPointModel;
          if (mpModel) {
            updateMarkerLayout(mpModel.getData(), seriesModel, api);
            this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
          }
        }, this);
      },
      renderSeries: function(seriesModel, mpModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesId = seriesModel.id;
        var seriesData = seriesModel.getData();
        var symbolDrawMap = this.markerGroupMap;
        var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());
        var mpData = createList(coordSys, seriesModel, mpModel);
        mpModel.setData(mpData);
        updateMarkerLayout(mpModel.getData(), seriesModel, api);
        mpData.each(function(idx) {
          var itemModel = mpData.getItemModel(idx);
          var symbol = itemModel.getShallow("symbol");
          var symbolSize = itemModel.getShallow("symbolSize");
          var symbolRotate = itemModel.getShallow("symbolRotate");
          var isFnSymbol = zrUtil.isFunction(symbol);
          var isFnSymbolSize = zrUtil.isFunction(symbolSize);
          var isFnSymbolRotate = zrUtil.isFunction(symbolRotate);
          if (isFnSymbol || isFnSymbolSize || isFnSymbolRotate) {
            var rawIdx = mpModel.getRawValue(idx);
            var dataParams = mpModel.getDataParams(idx);
            if (isFnSymbol) {
              symbol = symbol(rawIdx, dataParams);
            }
            if (isFnSymbolSize) {
              symbolSize = symbolSize(rawIdx, dataParams);
            }
            if (isFnSymbolRotate) {
              symbolRotate = symbolRotate(rawIdx, dataParams);
            }
          }
          mpData.setItemVisual(idx, {
            symbol,
            symbolSize,
            symbolRotate,
            color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
          });
        });
        symbolDraw.updateData(mpData);
        this.group.add(symbolDraw.group);
        mpData.eachItemGraphicEl(function(el) {
          el.traverse(function(child) {
            child.dataModel = mpModel;
          });
        });
        symbolDraw.__keep = true;
        symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
      }
    });
    function createList(coordSys, seriesModel, mpModel) {
      var coordDimsInfos;
      if (coordSys) {
        coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
          var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
          return zrUtil.defaults({
            name: coordDim
          }, info);
        });
      } else {
        coordDimsInfos = [{
          name: "value",
          type: "float"
        }];
      }
      var mpData = new List(coordDimsInfos, mpModel);
      var dataOpt = zrUtil.map(mpModel.get("data"), zrUtil.curry(markerHelper.dataTransform, seriesModel));
      if (coordSys) {
        dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
      }
      mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function(item) {
        return item.value;
      });
      return mpData;
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markPoint.js
var require_markPoint = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markPoint.js"() {
    var echarts = require_echarts();
    require_MarkPointModel();
    require_MarkPointView();
    echarts.registerPreprocessor(function(opt) {
      opt.markPoint = opt.markPoint || {};
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineModel.js
var require_MarkLineModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineModel.js"(exports, module) {
    var MarkerModel = require_MarkerModel();
    var _default = MarkerModel.extend({
      type: "markLine",
      defaultOption: {
        zlevel: 0,
        z: 5,
        symbol: ["circle", "arrow"],
        symbolSize: [8, 16],
        //symbolRotate: 0,
        precision: 2,
        tooltip: {
          trigger: "item"
        },
        label: {
          show: true,
          position: "end",
          distance: 5
        },
        lineStyle: {
          type: "dashed"
        },
        emphasis: {
          label: {
            show: true
          },
          lineStyle: {
            width: 3
          }
        },
        animationEasing: "linear"
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineView.js
var require_MarkLineView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkLineView.js"(exports, module) {
    var zrUtil = require_util();
    var List = require_List();
    var numberUtil = require_number();
    var markerHelper = require_markerHelper();
    var LineDraw = require_LineDraw();
    var MarkerView = require_MarkerView();
    var _dataStackHelper = require_dataStackHelper();
    var getStackedDimension = _dataStackHelper.getStackedDimension;
    var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
      var data = seriesModel.getData();
      var mlType = item.type;
      if (!zrUtil.isArray(item) && (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || item.xAxis != null || item.yAxis != null)) {
        var valueAxis;
        var value;
        if (item.yAxis != null || item.xAxis != null) {
          valueAxis = coordSys.getAxis(item.yAxis != null ? "y" : "x");
          value = zrUtil.retrieve(item.yAxis, item.xAxis);
        } else {
          var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
          valueAxis = axisInfo.valueAxis;
          var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
          value = markerHelper.numCalculate(data, valueDataDim, mlType);
        }
        var valueIndex = valueAxis.dim === "x" ? 0 : 1;
        var baseIndex = 1 - valueIndex;
        var mlFrom = zrUtil.clone(item);
        var mlTo = {};
        mlFrom.type = null;
        mlFrom.coord = [];
        mlTo.coord = [];
        mlFrom.coord[baseIndex] = -Infinity;
        mlTo.coord[baseIndex] = Infinity;
        var precision = mlModel.get("precision");
        if (precision >= 0 && typeof value === "number") {
          value = +value.toFixed(Math.min(precision, 20));
        }
        mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
        item = [mlFrom, mlTo, {
          // Extra option for tooltip and label
          type: mlType,
          valueIndex: item.valueIndex,
          // Force to use the value of calculated value.
          value
        }];
      }
      item = [markerHelper.dataTransform(seriesModel, item[0]), markerHelper.dataTransform(seriesModel, item[1]), zrUtil.extend({}, item[2])];
      item[2].type = item[2].type || "";
      zrUtil.merge(item[2], item[0]);
      zrUtil.merge(item[2], item[1]);
      return item;
    };
    function isInifinity(val) {
      return !isNaN(val) && !isFinite(val);
    }
    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
      var otherDimIndex = 1 - dimIndex;
      var dimName = coordSys.dimensions[dimIndex];
      return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
    }
    function markLineFilter(coordSys, item) {
      if (coordSys.type === "cartesian2d") {
        var fromCoord = item[0].coord;
        var toCoord = item[1].coord;
        if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
          return true;
        }
      }
      return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
    }
    function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var itemModel = data.getItemModel(idx);
      var point;
      var xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth());
      var yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else {
        if (seriesModel.getMarkerPosition) {
          point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
        } else {
          var dims = coordSys.dimensions;
          var x = data.get(dims[0], idx);
          var y = data.get(dims[1], idx);
          point = coordSys.dataToPoint([x, y]);
        }
        if (coordSys.type === "cartesian2d") {
          var xAxis = coordSys.getAxis("x");
          var yAxis = coordSys.getAxis("y");
          var dims = coordSys.dimensions;
          if (isInifinity(data.get(dims[0], idx))) {
            point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
          } else if (isInifinity(data.get(dims[1], idx))) {
            point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
          }
        }
        if (!isNaN(xPx)) {
          point[0] = xPx;
        }
        if (!isNaN(yPx)) {
          point[1] = yPx;
        }
      }
      data.setItemLayout(idx, point);
    }
    var _default = MarkerView.extend({
      type: "markLine",
      // updateLayout: function (markLineModel, ecModel, api) {
      //     ecModel.eachSeries(function (seriesModel) {
      //         var mlModel = seriesModel.markLineModel;
      //         if (mlModel) {
      //             var mlData = mlModel.getData();
      //             var fromData = mlModel.__from;
      //             var toData = mlModel.__to;
      //             // Update visual and layout of from symbol and to symbol
      //             fromData.each(function (idx) {
      //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
      //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
      //             });
      //             // Update layout of line
      //             mlData.each(function (idx) {
      //                 mlData.setItemLayout(idx, [
      //                     fromData.getItemLayout(idx),
      //                     toData.getItemLayout(idx)
      //                 ]);
      //             });
      //             this.markerGroupMap.get(seriesModel.id).updateLayout();
      //         }
      //     }, this);
      // },
      updateTransform: function(markLineModel, ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          var mlModel = seriesModel.markLineModel;
          if (mlModel) {
            var mlData = mlModel.getData();
            var fromData = mlModel.__from;
            var toData = mlModel.__to;
            fromData.each(function(idx) {
              updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
              updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
            });
            mlData.each(function(idx) {
              mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
            });
            this.markerGroupMap.get(seriesModel.id).updateLayout();
          }
        }, this);
      },
      renderSeries: function(seriesModel, mlModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesId = seriesModel.id;
        var seriesData = seriesModel.getData();
        var lineDrawMap = this.markerGroupMap;
        var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
        this.group.add(lineDraw.group);
        var mlData = createList(coordSys, seriesModel, mlModel);
        var fromData = mlData.from;
        var toData = mlData.to;
        var lineData = mlData.line;
        mlModel.__from = fromData;
        mlModel.__to = toData;
        mlModel.setData(lineData);
        var symbolType = mlModel.get("symbol");
        var symbolSize = mlModel.get("symbolSize");
        if (!zrUtil.isArray(symbolType)) {
          symbolType = [symbolType, symbolType];
        }
        if (typeof symbolSize === "number") {
          symbolSize = [symbolSize, symbolSize];
        }
        mlData.from.each(function(idx) {
          updateDataVisualAndLayout(fromData, idx, true);
          updateDataVisualAndLayout(toData, idx, false);
        });
        lineData.each(function(idx) {
          var lineColor = lineData.getItemModel(idx).get("lineStyle.color");
          lineData.setItemVisual(idx, {
            color: lineColor || fromData.getItemVisual(idx, "color")
          });
          lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
          lineData.setItemVisual(idx, {
            "fromSymbolRotate": fromData.getItemVisual(idx, "symbolRotate"),
            "fromSymbolSize": fromData.getItemVisual(idx, "symbolSize"),
            "fromSymbol": fromData.getItemVisual(idx, "symbol"),
            "toSymbolRotate": toData.getItemVisual(idx, "symbolRotate"),
            "toSymbolSize": toData.getItemVisual(idx, "symbolSize"),
            "toSymbol": toData.getItemVisual(idx, "symbol")
          });
        });
        lineDraw.updateData(lineData);
        mlData.line.eachItemGraphicEl(function(el, idx) {
          el.traverse(function(child) {
            child.dataModel = mlModel;
          });
        });
        function updateDataVisualAndLayout(data, idx, isFrom) {
          var itemModel = data.getItemModel(idx);
          updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
          data.setItemVisual(idx, {
            symbolRotate: itemModel.get("symbolRotate"),
            symbolSize: itemModel.get("symbolSize") || symbolSize[isFrom ? 0 : 1],
            symbol: itemModel.get("symbol", true) || symbolType[isFrom ? 0 : 1],
            color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
          });
        }
        lineDraw.__keep = true;
        lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
      }
    });
    function createList(coordSys, seriesModel, mlModel) {
      var coordDimsInfos;
      if (coordSys) {
        coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
          var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
          return zrUtil.defaults({
            name: coordDim
          }, info);
        });
      } else {
        coordDimsInfos = [{
          name: "value",
          type: "float"
        }];
      }
      var fromData = new List(coordDimsInfos, mlModel);
      var toData = new List(coordDimsInfos, mlModel);
      var lineData = new List([], mlModel);
      var optData = zrUtil.map(mlModel.get("data"), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));
      if (coordSys) {
        optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
      }
      var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function(item) {
        return item.value;
      };
      fromData.initData(zrUtil.map(optData, function(item) {
        return item[0];
      }), null, dimValueGetter);
      toData.initData(zrUtil.map(optData, function(item) {
        return item[1];
      }), null, dimValueGetter);
      lineData.initData(zrUtil.map(optData, function(item) {
        return item[2];
      }));
      lineData.hasItemOption = true;
      return {
        from: fromData,
        to: toData,
        line: lineData
      };
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markLine.js
var require_markLine = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markLine.js"() {
    var echarts = require_echarts();
    require_MarkLineModel();
    require_MarkLineView();
    echarts.registerPreprocessor(function(opt) {
      opt.markLine = opt.markLine || {};
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaModel.js
var require_MarkAreaModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaModel.js"(exports, module) {
    var MarkerModel = require_MarkerModel();
    var _default = MarkerModel.extend({
      type: "markArea",
      defaultOption: {
        zlevel: 0,
        // PENDING
        z: 1,
        tooltip: {
          trigger: "item"
        },
        // markArea should fixed on the coordinate system
        animation: false,
        label: {
          show: true,
          position: "top"
        },
        itemStyle: {
          // color and borderColor default to use color from series
          // color: 'auto'
          // borderColor: 'auto'
          borderWidth: 0
        },
        emphasis: {
          label: {
            show: true,
            position: "top"
          }
        }
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaView.js
var require_MarkAreaView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/marker/MarkAreaView.js"() {
    var zrUtil = require_util();
    var colorUtil = require_color();
    var List = require_List();
    var numberUtil = require_number();
    var graphic = require_graphic();
    var markerHelper = require_markerHelper();
    var MarkerView = require_MarkerView();
    var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
      var lt = markerHelper.dataTransform(seriesModel, item[0]);
      var rb = markerHelper.dataTransform(seriesModel, item[1]);
      var retrieve = zrUtil.retrieve;
      var ltCoord = lt.coord;
      var rbCoord = rb.coord;
      ltCoord[0] = retrieve(ltCoord[0], -Infinity);
      ltCoord[1] = retrieve(ltCoord[1], -Infinity);
      rbCoord[0] = retrieve(rbCoord[0], Infinity);
      rbCoord[1] = retrieve(rbCoord[1], Infinity);
      var result = zrUtil.mergeAll([{}, lt, rb]);
      result.coord = [lt.coord, rb.coord];
      result.x0 = lt.x;
      result.y0 = lt.y;
      result.x1 = rb.x;
      result.y1 = rb.y;
      return result;
    };
    function isInifinity(val) {
      return !isNaN(val) && !isFinite(val);
    }
    function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
      var otherDimIndex = 1 - dimIndex;
      return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
    }
    function markAreaFilter(coordSys, item) {
      var fromCoord = item.coord[0];
      var toCoord = item.coord[1];
      if (coordSys.type === "cartesian2d") {
        if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
          return true;
        }
      }
      return markerHelper.dataFilter(coordSys, {
        coord: fromCoord,
        x: item.x0,
        y: item.y0
      }) || markerHelper.dataFilter(coordSys, {
        coord: toCoord,
        x: item.x1,
        y: item.y1
      });
    }
    function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var itemModel = data.getItemModel(idx);
      var point;
      var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());
      var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());
      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else {
        if (seriesModel.getMarkerPosition) {
          point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
        } else {
          var x = data.get(dims[0], idx);
          var y = data.get(dims[1], idx);
          var pt = [x, y];
          coordSys.clampData && coordSys.clampData(pt, pt);
          point = coordSys.dataToPoint(pt, true);
        }
        if (coordSys.type === "cartesian2d") {
          var xAxis = coordSys.getAxis("x");
          var yAxis = coordSys.getAxis("y");
          var x = data.get(dims[0], idx);
          var y = data.get(dims[1], idx);
          if (isInifinity(x)) {
            point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
          } else if (isInifinity(y)) {
            point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
          }
        }
        if (!isNaN(xPx)) {
          point[0] = xPx;
        }
        if (!isNaN(yPx)) {
          point[1] = yPx;
        }
      }
      return point;
    }
    var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
    MarkerView.extend({
      type: "markArea",
      // updateLayout: function (markAreaModel, ecModel, api) {
      //     ecModel.eachSeries(function (seriesModel) {
      //         var maModel = seriesModel.markAreaModel;
      //         if (maModel) {
      //             var areaData = maModel.getData();
      //             areaData.each(function (idx) {
      //                 var points = zrUtil.map(dimPermutations, function (dim) {
      //                     return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
      //                 });
      //                 // Layout
      //                 areaData.setItemLayout(idx, points);
      //                 var el = areaData.getItemGraphicEl(idx);
      //                 el.setShape('points', points);
      //             });
      //         }
      //     }, this);
      // },
      updateTransform: function(markAreaModel, ecModel, api) {
        ecModel.eachSeries(function(seriesModel) {
          var maModel = seriesModel.markAreaModel;
          if (maModel) {
            var areaData = maModel.getData();
            areaData.each(function(idx) {
              var points = zrUtil.map(dimPermutations, function(dim) {
                return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
              });
              areaData.setItemLayout(idx, points);
              var el = areaData.getItemGraphicEl(idx);
              el.setShape("points", points);
            });
          }
        }, this);
      },
      renderSeries: function(seriesModel, maModel, ecModel, api) {
        var coordSys = seriesModel.coordinateSystem;
        var seriesId = seriesModel.id;
        var seriesData = seriesModel.getData();
        var areaGroupMap = this.markerGroupMap;
        var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
          group: new graphic.Group()
        });
        this.group.add(polygonGroup.group);
        polygonGroup.__keep = true;
        var areaData = createList(coordSys, seriesModel, maModel);
        maModel.setData(areaData);
        areaData.each(function(idx) {
          var points = zrUtil.map(dimPermutations, function(dim) {
            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
          });
          var allClipped = true;
          zrUtil.each(dimPermutations, function(dim) {
            if (!allClipped) {
              return;
            }
            var xValue = areaData.get(dim[0], idx);
            var yValue = areaData.get(dim[1], idx);
            if ((isInifinity(xValue) || coordSys.getAxis("x").containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis("y").containData(yValue))) {
              allClipped = false;
            }
          });
          areaData.setItemLayout(idx, {
            points,
            allClipped
          });
          areaData.setItemVisual(idx, {
            color: seriesData.getVisual("color")
          });
        });
        areaData.diff(polygonGroup.__data).add(function(idx) {
          var layout = areaData.getItemLayout(idx);
          if (!layout.allClipped) {
            var polygon = new graphic.Polygon({
              shape: {
                points: layout.points
              }
            });
            areaData.setItemGraphicEl(idx, polygon);
            polygonGroup.group.add(polygon);
          }
        }).update(function(newIdx, oldIdx) {
          var polygon = polygonGroup.__data.getItemGraphicEl(oldIdx);
          var layout = areaData.getItemLayout(newIdx);
          if (!layout.allClipped) {
            if (polygon) {
              graphic.updateProps(polygon, {
                shape: {
                  points: layout.points
                }
              }, maModel, newIdx);
            } else {
              polygon = new graphic.Polygon({
                shape: {
                  points: layout.points
                }
              });
            }
            areaData.setItemGraphicEl(newIdx, polygon);
            polygonGroup.group.add(polygon);
          } else if (polygon) {
            polygonGroup.group.remove(polygon);
          }
        }).remove(function(idx) {
          var polygon = polygonGroup.__data.getItemGraphicEl(idx);
          polygonGroup.group.remove(polygon);
        }).execute();
        areaData.eachItemGraphicEl(function(polygon, idx) {
          var itemModel = areaData.getItemModel(idx);
          var labelModel = itemModel.getModel("label");
          var labelHoverModel = itemModel.getModel("emphasis.label");
          var color = areaData.getItemVisual(idx, "color");
          polygon.useStyle(zrUtil.defaults(itemModel.getModel("itemStyle").getItemStyle(), {
            fill: colorUtil.modifyAlpha(color, 0.4),
            stroke: color
          }));
          polygon.hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
          graphic.setLabelStyle(polygon.style, polygon.hoverStyle, labelModel, labelHoverModel, {
            labelFetcher: maModel,
            labelDataIndex: idx,
            defaultText: areaData.getName(idx) || "",
            isRectText: true,
            autoColor: color
          });
          graphic.setHoverStyle(polygon, {});
          polygon.dataModel = maModel;
        });
        polygonGroup.__data = areaData;
        polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
      }
    });
    function createList(coordSys, seriesModel, maModel) {
      var coordDimsInfos;
      var areaData;
      var dims = ["x0", "y0", "x1", "y1"];
      if (coordSys) {
        coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function(coordDim) {
          var data = seriesModel.getData();
          var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
          return zrUtil.defaults({
            name: coordDim
          }, info);
        });
        areaData = new List(zrUtil.map(dims, function(dim, idx) {
          return {
            name: dim,
            type: coordDimsInfos[idx % 2].type
          };
        }), maModel);
      } else {
        coordDimsInfos = [{
          name: "value",
          type: "float"
        }];
        areaData = new List(coordDimsInfos, maModel);
      }
      var optData = zrUtil.map(maModel.get("data"), zrUtil.curry(markAreaTransform, seriesModel, coordSys, maModel));
      if (coordSys) {
        optData = zrUtil.filter(optData, zrUtil.curry(markAreaFilter, coordSys));
      }
      var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
        return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
      } : function(item) {
        return item.value;
      };
      areaData.initData(optData, null, dimValueGetter);
      areaData.hasItemOption = true;
      return areaData;
    }
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markArea.js
var require_markArea = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/markArea.js"() {
    var echarts = require_echarts();
    require_MarkAreaModel();
    require_MarkAreaView();
    echarts.registerPreprocessor(function(opt) {
      opt.markArea = opt.markArea || {};
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendModel.js
var require_LegendModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var Model = require_Model();
    var _model = require_model();
    var isNameSpecified = _model.isNameSpecified;
    var lang = require_lang();
    var langSelector = lang.legend.selector;
    var defaultSelectorOption = {
      all: {
        type: "all",
        title: zrUtil.clone(langSelector.all)
      },
      inverse: {
        type: "inverse",
        title: zrUtil.clone(langSelector.inverse)
      }
    };
    var LegendModel = echarts.extendComponentModel({
      type: "legend.plain",
      dependencies: ["series"],
      layoutMode: {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas realy width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: true
      },
      init: function(option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel);
        option.selected = option.selected || {};
        this._updateSelector(option);
      },
      mergeOption: function(option) {
        LegendModel.superCall(this, "mergeOption", option);
        this._updateSelector(option);
      },
      _updateSelector: function(option) {
        var selector = option.selector;
        if (selector === true) {
          selector = option.selector = ["all", "inverse"];
        }
        if (zrUtil.isArray(selector)) {
          zrUtil.each(selector, function(item, index) {
            zrUtil.isString(item) && (item = {
              type: item
            });
            selector[index] = zrUtil.merge(item, defaultSelectorOption[item.type]);
          });
        }
      },
      optionUpdated: function() {
        this._updateData(this.ecModel);
        var legendData = this._data;
        if (legendData[0] && this.get("selectedMode") === "single") {
          var hasSelected = false;
          for (var i = 0; i < legendData.length; i++) {
            var name2 = legendData[i].get("name");
            if (this.isSelected(name2)) {
              this.select(name2);
              hasSelected = true;
              break;
            }
          }
          !hasSelected && this.select(legendData[0].get("name"));
        }
      },
      _updateData: function(ecModel) {
        var potentialData = [];
        var availableNames = [];
        ecModel.eachRawSeries(function(seriesModel) {
          var seriesName = seriesModel.name;
          availableNames.push(seriesName);
          var isPotential;
          if (seriesModel.legendVisualProvider) {
            var provider = seriesModel.legendVisualProvider;
            var names = provider.getAllNames();
            if (!ecModel.isSeriesFiltered(seriesModel)) {
              availableNames = availableNames.concat(names);
            }
            if (names.length) {
              potentialData = potentialData.concat(names);
            } else {
              isPotential = true;
            }
          } else {
            isPotential = true;
          }
          if (isPotential && isNameSpecified(seriesModel)) {
            potentialData.push(seriesModel.name);
          }
        });
        this._availableNames = availableNames;
        var rawData = this.get("data") || potentialData;
        var legendData = zrUtil.map(rawData, function(dataItem) {
          if (typeof dataItem === "string" || typeof dataItem === "number") {
            dataItem = {
              name: dataItem
            };
          }
          return new Model(dataItem, this, this.ecModel);
        }, this);
        this._data = legendData;
      },
      /**
       * @return {Array.<module:echarts/model/Model>}
       */
      getData: function() {
        return this._data;
      },
      /**
       * @param {string} name
       */
      select: function(name2) {
        var selected = this.option.selected;
        var selectedMode = this.get("selectedMode");
        if (selectedMode === "single") {
          var data = this._data;
          zrUtil.each(data, function(dataItem) {
            selected[dataItem.get("name")] = false;
          });
        }
        selected[name2] = true;
      },
      /**
       * @param {string} name
       */
      unSelect: function(name2) {
        if (this.get("selectedMode") !== "single") {
          this.option.selected[name2] = false;
        }
      },
      /**
       * @param {string} name
       */
      toggleSelected: function(name2) {
        var selected = this.option.selected;
        if (!selected.hasOwnProperty(name2)) {
          selected[name2] = true;
        }
        this[selected[name2] ? "unSelect" : "select"](name2);
      },
      allSelect: function() {
        var data = this._data;
        var selected = this.option.selected;
        zrUtil.each(data, function(dataItem) {
          selected[dataItem.get("name", true)] = true;
        });
      },
      inverseSelect: function() {
        var data = this._data;
        var selected = this.option.selected;
        zrUtil.each(data, function(dataItem) {
          var name2 = dataItem.get("name", true);
          if (!selected.hasOwnProperty(name2)) {
            selected[name2] = true;
          }
          selected[name2] = !selected[name2];
        });
      },
      /**
       * @param {string} name
       */
      isSelected: function(name2) {
        var selected = this.option.selected;
        return !(selected.hasOwnProperty(name2) && !selected[name2]) && zrUtil.indexOf(this._availableNames, name2) >= 0;
      },
      getOrient: function() {
        return this.get("orient") === "vertical" ? {
          index: 1,
          name: "vertical"
        } : {
          index: 0,
          name: "horizontal"
        };
      },
      defaultOption: {
        // 一级层叠
        zlevel: 0,
        // 二级层叠
        z: 4,
        show: true,
        // 布局方式，默认为水平布局，可选为：
        // 'horizontal' | 'vertical'
        orient: "horizontal",
        left: "center",
        // right: 'center',
        top: 0,
        // bottom: null,
        // 水平对齐
        // 'auto' | 'left' | 'right'
        // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
        align: "auto",
        backgroundColor: "rgba(0,0,0,0)",
        // 图例边框颜色
        borderColor: "#ccc",
        borderRadius: 0,
        // 图例边框线宽，单位px，默认为0（无边框）
        borderWidth: 0,
        // 图例内边距，单位px，默认各方向内边距为5，
        // 接受数组分别设定上右下左边距，同css
        padding: 5,
        // 各个item之间的间隔，单位px，默认为10，
        // 横向布局时为水平间隔，纵向布局时为纵向间隔
        itemGap: 10,
        // the width of legend symbol
        itemWidth: 25,
        // the height of legend symbol
        itemHeight: 14,
        // the color of unselected legend symbol
        inactiveColor: "#ccc",
        // the borderColor of unselected legend symbol
        inactiveBorderColor: "#ccc",
        itemStyle: {
          // the default borderWidth of legend symbol
          borderWidth: 0
        },
        textStyle: {
          // 图例文字颜色
          color: "#333"
        },
        // formatter: '',
        // 选择模式，默认开启图例开关
        selectedMode: true,
        // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
        // selected: null,
        // 图例内容（详见legend.data，数组中每一项代表一个item
        // data: [],
        // Usage:
        // selector: [{type: 'all or inverse', title: xxx}]
        // or
        // selector: true
        // or
        // selector: ['all', 'inverse']
        selector: false,
        selectorLabel: {
          show: true,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: " sans-serif",
          color: "#666",
          borderWidth: 1,
          borderColor: "#666"
        },
        emphasis: {
          selectorLabel: {
            show: true,
            color: "#eee",
            backgroundColor: "#666"
          }
        },
        // Value can be 'start' or 'end'
        selectorPosition: "auto",
        selectorItemGap: 7,
        selectorButtonGap: 10,
        // Tooltip 相关配置
        tooltip: {
          show: false
        }
      }
    });
    var _default = LegendModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendAction.js
var require_legendAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendAction.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    function legendSelectActionHandler(methodName, payload, ecModel) {
      var selectedMap = {};
      var isToggleSelect = methodName === "toggleSelected";
      var isSelected;
      ecModel.eachComponent("legend", function(legendModel) {
        if (isToggleSelect && isSelected != null) {
          legendModel[isSelected ? "select" : "unSelect"](payload.name);
        } else if (methodName === "allSelect" || methodName === "inverseSelect") {
          legendModel[methodName]();
        } else {
          legendModel[methodName](payload.name);
          isSelected = legendModel.isSelected(payload.name);
        }
        var legendData = legendModel.getData();
        zrUtil.each(legendData, function(model) {
          var name2 = model.get("name");
          if (name2 === "\n" || name2 === "") {
            return;
          }
          var isItemSelected = legendModel.isSelected(name2);
          if (selectedMap.hasOwnProperty(name2)) {
            selectedMap[name2] = selectedMap[name2] && isItemSelected;
          } else {
            selectedMap[name2] = isItemSelected;
          }
        });
      });
      return methodName === "allSelect" || methodName === "inverseSelect" ? {
        selected: selectedMap
      } : {
        name: payload.name,
        selected: selectedMap
      };
    }
    echarts.registerAction("legendToggleSelect", "legendselectchanged", zrUtil.curry(legendSelectActionHandler, "toggleSelected"));
    echarts.registerAction("legendAllSelect", "legendselectall", zrUtil.curry(legendSelectActionHandler, "allSelect"));
    echarts.registerAction("legendInverseSelect", "legendinverseselect", zrUtil.curry(legendSelectActionHandler, "inverseSelect"));
    echarts.registerAction("legendSelect", "legendselected", zrUtil.curry(legendSelectActionHandler, "select"));
    echarts.registerAction("legendUnSelect", "legendunselected", zrUtil.curry(legendSelectActionHandler, "unSelect"));
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendView.js
var require_LegendView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/LegendView.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var echarts = require_echarts();
    var zrUtil = require_util();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var graphic = require_graphic();
    var _listComponent = require_listComponent();
    var makeBackground = _listComponent.makeBackground;
    var layoutUtil = require_layout();
    var curry = zrUtil.curry;
    var each = zrUtil.each;
    var Group = graphic.Group;
    var _default = echarts.extendComponentView({
      type: "legend.plain",
      newlineDisabled: false,
      /**
       * @override
       */
      init: function() {
        this.group.add(this._contentGroup = new Group());
        this._backgroundEl;
        this.group.add(this._selectorGroup = new Group());
        this._isFirstRender = true;
      },
      /**
       * @protected
       */
      getContentGroup: function() {
        return this._contentGroup;
      },
      /**
       * @protected
       */
      getSelectorGroup: function() {
        return this._selectorGroup;
      },
      /**
       * @override
       */
      render: function(legendModel, ecModel, api) {
        var isFirstRender = this._isFirstRender;
        this._isFirstRender = false;
        this.resetInner();
        if (!legendModel.get("show", true)) {
          return;
        }
        var itemAlign = legendModel.get("align");
        var orient = legendModel.get("orient");
        if (!itemAlign || itemAlign === "auto") {
          itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
        }
        var selector = legendModel.get("selector", true);
        var selectorPosition = legendModel.get("selectorPosition", true);
        if (selector && (!selectorPosition || selectorPosition === "auto")) {
          selectorPosition = orient === "horizontal" ? "end" : "start";
        }
        this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
        var positionInfo = legendModel.getBoxLayoutParams();
        var viewportSize = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var padding = legendModel.get("padding");
        var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
        var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
        var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
          width: mainRect.width,
          height: mainRect.height
        }, positionInfo), viewportSize, padding);
        this.group.attr("position", [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]);
        this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
      },
      /**
       * @protected
       */
      resetInner: function() {
        this.getContentGroup().removeAll();
        this._backgroundEl && this.group.remove(this._backgroundEl);
        this.getSelectorGroup().removeAll();
      },
      /**
       * @protected
       */
      renderInner: function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var legendDrawnMap = zrUtil.createHashMap();
        var selectMode = legendModel.get("selectedMode");
        var excludeSeriesId = [];
        ecModel.eachRawSeries(function(seriesModel) {
          !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
        });
        each(legendModel.getData(), function(itemModel, dataIndex) {
          var name2 = itemModel.get("name");
          if (!this.newlineDisabled && (name2 === "" || name2 === "\n")) {
            contentGroup.add(new Group({
              newline: true
            }));
            return;
          }
          var seriesModel = ecModel.getSeriesByName(name2)[0];
          if (legendDrawnMap.get(name2)) {
            return;
          }
          if (seriesModel) {
            var data = seriesModel.getData();
            var color = data.getVisual("color");
            var borderColor = data.getVisual("borderColor");
            if (typeof color === "function") {
              color = color(seriesModel.getDataParams(0));
            }
            if (typeof borderColor === "function") {
              borderColor = borderColor(seriesModel.getDataParams(0));
            }
            var legendSymbolType = data.getVisual("legendSymbol") || "roundRect";
            var symbolType = data.getVisual("symbol");
            var itemGroup = this._createItem(name2, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode);
            itemGroup.on("click", curry(dispatchSelectAction, name2, null, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
            legendDrawnMap.set(name2, true);
          } else {
            ecModel.eachRawSeries(function(seriesModel2) {
              if (legendDrawnMap.get(name2)) {
                return;
              }
              if (seriesModel2.legendVisualProvider) {
                var provider = seriesModel2.legendVisualProvider;
                if (!provider.containName(name2)) {
                  return;
                }
                var idx = provider.indexOfName(name2);
                var color2 = provider.getItemVisual(idx, "color");
                var borderColor2 = provider.getItemVisual(idx, "borderColor");
                var legendSymbolType2 = "roundRect";
                var itemGroup2 = this._createItem(name2, dataIndex, itemModel, legendModel, legendSymbolType2, null, itemAlign, color2, borderColor2, selectMode);
                itemGroup2.on("click", curry(dispatchSelectAction, null, name2, api, excludeSeriesId)).on("mouseover", curry(dispatchHighlightAction, null, name2, api, excludeSeriesId)).on("mouseout", curry(dispatchDownplayAction, null, name2, api, excludeSeriesId));
                legendDrawnMap.set(name2, true);
              }
            }, this);
          }
        }, this);
        if (selector) {
          this._createSelector(selector, legendModel, api, orient, selectorPosition);
        }
      },
      _createSelector: function(selector, legendModel, api, orient, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        each(selector, function(selectorItem) {
          createSelectorButton(selectorItem);
        });
        function createSelectorButton(selectorItem) {
          var type = selectorItem.type;
          var labelText = new graphic.Text({
            style: {
              x: 0,
              y: 0,
              align: "center",
              verticalAlign: "middle"
            },
            onclick: function() {
              api.dispatchAction({
                type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
              });
            }
          });
          selectorGroup.add(labelText);
          var labelModel = legendModel.getModel("selectorLabel");
          var emphasisLabelModel = legendModel.getModel("emphasis.selectorLabel");
          graphic.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, emphasisLabelModel, {
            defaultText: selectorItem.title,
            isRectText: false
          });
          graphic.setHoverStyle(labelText);
        }
      },
      _createItem: function(name2, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, selectMode) {
        var itemWidth = legendModel.get("itemWidth");
        var itemHeight = legendModel.get("itemHeight");
        var inactiveColor = legendModel.get("inactiveColor");
        var inactiveBorderColor = legendModel.get("inactiveBorderColor");
        var symbolKeepAspect = legendModel.get("symbolKeepAspect");
        var legendModelItemStyle = legendModel.getModel("itemStyle");
        var isSelected = legendModel.isSelected(name2);
        var itemGroup = new Group();
        var textStyleModel = itemModel.getModel("textStyle");
        var itemIcon = itemModel.get("icon");
        var tooltipModel = itemModel.getModel("tooltip");
        var legendGlobalTooltipModel = tooltipModel.parentModel;
        legendSymbolType = itemIcon || legendSymbolType;
        var legendSymbol = createSymbol(
          legendSymbolType,
          0,
          0,
          itemWidth,
          itemHeight,
          isSelected ? color : inactiveColor,
          // symbolKeepAspect default true for legend
          symbolKeepAspect == null ? true : symbolKeepAspect
        );
        itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
        if (!itemIcon && symbolType && (symbolType !== legendSymbolType || symbolType === "none")) {
          var size = itemHeight * 0.8;
          if (symbolType === "none") {
            symbolType = "circle";
          }
          var legendSymbolCenter = createSymbol(
            symbolType,
            (itemWidth - size) / 2,
            (itemHeight - size) / 2,
            size,
            size,
            isSelected ? color : inactiveColor,
            // symbolKeepAspect default true for legend
            symbolKeepAspect == null ? true : symbolKeepAspect
          );
          itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
        }
        var textX = itemAlign === "left" ? itemWidth + 5 : -5;
        var textAlign = itemAlign;
        var formatter = legendModel.get("formatter");
        var content = name2;
        if (typeof formatter === "string" && formatter) {
          content = formatter.replace("{name}", name2 != null ? name2 : "");
        } else if (typeof formatter === "function") {
          content = formatter(name2);
        }
        itemGroup.add(new graphic.Text({
          style: graphic.setTextStyle({}, textStyleModel, {
            text: content,
            x: textX,
            y: itemHeight / 2,
            textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
            textAlign,
            textVerticalAlign: "middle"
          })
        }));
        var hitRect = new graphic.Rect({
          shape: itemGroup.getBoundingRect(),
          invisible: true,
          tooltip: tooltipModel.get("show") ? zrUtil.extend({
            content: name2,
            // Defaul formatter
            formatter: legendGlobalTooltipModel.get("formatter", true) || function() {
              return name2;
            },
            formatterParams: {
              componentType: "legend",
              legendIndex: legendModel.componentIndex,
              name: name2,
              $vars: ["name"]
            }
          }, tooltipModel.option) : null
        });
        itemGroup.add(hitRect);
        itemGroup.eachChild(function(child) {
          child.silent = true;
        });
        hitRect.silent = !selectMode;
        this.getContentGroup().add(itemGroup);
        graphic.setHoverStyle(itemGroup);
        itemGroup.__legendDataIndex = dataIndex;
        return itemGroup;
      },
      /**
       * @protected
       */
      layoutInner: function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var contentGroup = this.getContentGroup();
        var selectorGroup = this.getSelectorGroup();
        layoutUtil.box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
        var contentRect = contentGroup.getBoundingRect();
        var contentPos = [-contentRect.x, -contentRect.y];
        if (selector) {
          layoutUtil.box(
            // Buttons in selectorGroup always layout horizontally
            "horizontal",
            selectorGroup,
            legendModel.get("selectorItemGap", true)
          );
          var selectorRect = selectorGroup.getBoundingRect();
          var selectorPos = [-selectorRect.x, -selectorRect.y];
          var selectorButtonGap = legendModel.get("selectorButtonGap", true);
          var orientIdx = legendModel.getOrient().index;
          var wh = orientIdx === 0 ? "width" : "height";
          var hw = orientIdx === 0 ? "height" : "width";
          var yx = orientIdx === 0 ? "y" : "x";
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
          } else {
            contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
          }
          selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
          selectorGroup.attr("position", selectorPos);
          contentGroup.attr("position", contentPos);
          var mainRect = {
            x: 0,
            y: 0
          };
          mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
          mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
          return mainRect;
        } else {
          contentGroup.attr("position", contentPos);
          return this.group.getBoundingRect();
        }
      },
      /**
       * @protected
       */
      remove: function() {
        this.getContentGroup().removeAll();
        this._isFirstRender = true;
      }
    });
    function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected) {
      var itemStyle;
      if (symbolType !== "line" && symbolType.indexOf("empty") < 0) {
        itemStyle = legendModelItemStyle.getItemStyle();
        symbol.style.stroke = borderColor;
        if (!isSelected) {
          itemStyle.stroke = inactiveBorderColor;
        }
      } else {
        itemStyle = legendModelItemStyle.getItemStyle(["borderWidth", "borderColor"]);
      }
      return symbol.setStyle(itemStyle);
    }
    function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
      dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
      api.dispatchAction({
        type: "legendToggleSelect",
        name: seriesName != null ? seriesName : dataName
      });
      dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
    }
    function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
      var el = api.getZr().storage.getDisplayList()[0];
      if (!(el && el.useHoverLayer)) {
        api.dispatchAction({
          type: "highlight",
          seriesName,
          name: dataName,
          excludeSeriesId
        });
      }
    }
    function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
      var el = api.getZr().storage.getDisplayList()[0];
      if (!(el && el.useHoverLayer)) {
        api.dispatchAction({
          type: "downplay",
          seriesName,
          name: dataName,
          excludeSeriesId
        });
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendFilter.js
var require_legendFilter = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/legendFilter.js"(exports, module) {
    function _default(ecModel) {
      var legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (legendModels && legendModels.length) {
        ecModel.filterSeries(function(series) {
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(series.name)) {
              return false;
            }
          }
          return true;
        });
      }
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend.js
var require_legend = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend.js"() {
    var echarts = require_echarts();
    require_LegendModel();
    require_legendAction();
    require_LegendView();
    var legendFilter = require_legendFilter();
    var Component = require_Component();
    echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
    Component.registerSubTypeDefaulter("legend", function() {
      return "plain";
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendModel.js
var require_ScrollableLegendModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendModel.js"(exports, module) {
    var LegendModel = require_LegendModel();
    var _layout = require_layout();
    var mergeLayoutParam = _layout.mergeLayoutParam;
    var getLayoutParams = _layout.getLayoutParams;
    var ScrollableLegendModel = LegendModel.extend({
      type: "legend.scroll",
      /**
       * @param {number} scrollDataIndex
       */
      setScrollDataIndex: function(scrollDataIndex) {
        this.option.scrollDataIndex = scrollDataIndex;
      },
      defaultOption: {
        scrollDataIndex: 0,
        pageButtonItemGap: 5,
        pageButtonGap: null,
        pageButtonPosition: "end",
        // 'start' or 'end'
        pageFormatter: "{current}/{total}",
        // If null/undefined, do not show page.
        pageIcons: {
          horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
          vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
        },
        pageIconColor: "#2f4554",
        pageIconInactiveColor: "#aaa",
        pageIconSize: 15,
        // Can be [10, 3], which represents [width, height]
        pageTextStyle: {
          color: "#333"
        },
        animationDurationUpdate: 800
      },
      /**
       * @override
       */
      init: function(option, parentModel, ecModel, extraOpt) {
        var inputPositionParams = getLayoutParams(option);
        ScrollableLegendModel.superCall(this, "init", option, parentModel, ecModel, extraOpt);
        mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
      },
      /**
       * @override
       */
      mergeOption: function(option, extraOpt) {
        ScrollableLegendModel.superCall(this, "mergeOption", option, extraOpt);
        mergeAndNormalizeLayoutParams(this, this.option, option);
      }
    });
    function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
      var orient = legendModel.getOrient();
      var ignoreSize = [1, 1];
      ignoreSize[orient.index] = 0;
      mergeLayoutParam(target, raw, {
        type: "box",
        ignoreSize
      });
    }
    var _default = ScrollableLegendModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendView.js
var require_ScrollableLegendView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/ScrollableLegendView.js"(exports, module) {
    var zrUtil = require_util();
    var graphic = require_graphic();
    var layoutUtil = require_layout();
    var LegendView = require_LegendView();
    var Group = graphic.Group;
    var WH = ["width", "height"];
    var XY = ["x", "y"];
    var ScrollableLegendView = LegendView.extend({
      type: "legend.scroll",
      newlineDisabled: true,
      init: function() {
        ScrollableLegendView.superCall(this, "init");
        this._currentIndex = 0;
        this.group.add(this._containerGroup = new Group());
        this._containerGroup.add(this.getContentGroup());
        this.group.add(this._controllerGroup = new Group());
        this._showController;
      },
      /**
       * @override
       */
      resetInner: function() {
        ScrollableLegendView.superCall(this, "resetInner");
        this._controllerGroup.removeAll();
        this._containerGroup.removeClipPath();
        this._containerGroup.__rectSize = null;
      },
      /**
       * @override
       */
      renderInner: function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        var me = this;
        ScrollableLegendView.superCall(this, "renderInner", itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
        var controllerGroup = this._controllerGroup;
        var pageIconSize = legendModel.get("pageIconSize", true);
        if (!zrUtil.isArray(pageIconSize)) {
          pageIconSize = [pageIconSize, pageIconSize];
        }
        createPageButton("pagePrev", 0);
        var pageTextStyleModel = legendModel.getModel("pageTextStyle");
        controllerGroup.add(new graphic.Text({
          name: "pageText",
          style: {
            textFill: pageTextStyleModel.getTextColor(),
            font: pageTextStyleModel.getFont(),
            textVerticalAlign: "middle",
            textAlign: "center"
          },
          silent: true
        }));
        createPageButton("pageNext", 1);
        function createPageButton(name2, iconIdx) {
          var pageDataIndexName = name2 + "DataIndex";
          var icon = graphic.createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
            // Buttons will be created in each render, so we do not need
            // to worry about avoiding using legendModel kept in scope.
            onclick: zrUtil.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
          }, {
            x: -pageIconSize[0] / 2,
            y: -pageIconSize[1] / 2,
            width: pageIconSize[0],
            height: pageIconSize[1]
          });
          icon.name = name2;
          controllerGroup.add(icon);
        }
      },
      /**
       * @override
       */
      layoutInner: function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        var selectorGroup = this.getSelectorGroup();
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var hw = WH[1 - orientIdx];
        var yx = XY[1 - orientIdx];
        selector && layoutUtil.box(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          selectorGroup,
          legendModel.get("selectorItemGap", true)
        );
        var selectorButtonGap = legendModel.get("selectorButtonGap", true);
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var processMaxSize = zrUtil.clone(maxSize);
        selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
        var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);
        if (selector) {
          if (selectorPosition === "end") {
            selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
          } else {
            var offset = selectorRect[wh] + selectorButtonGap;
            selectorPos[orientIdx] -= offset;
            mainRect[xy] -= offset;
          }
          mainRect[wh] += selectorRect[wh] + selectorButtonGap;
          selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
          mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
          mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
          selectorGroup.attr("position", selectorPos);
        }
        return mainRect;
      },
      _layoutContentAndController: function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {
        var contentGroup = this.getContentGroup();
        var containerGroup = this._containerGroup;
        var controllerGroup = this._controllerGroup;
        layoutUtil.box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
        layoutUtil.box(
          // Buttons in controller are layout always horizontally.
          "horizontal",
          controllerGroup,
          legendModel.get("pageButtonItemGap", true)
        );
        var contentRect = contentGroup.getBoundingRect();
        var controllerRect = controllerGroup.getBoundingRect();
        var showController = this._showController = contentRect[wh] > maxSize[wh];
        var contentPos = [-contentRect.x, -contentRect.y];
        if (!isFirstRender) {
          contentPos[orientIdx] = contentGroup.position[orientIdx];
        }
        var containerPos = [0, 0];
        var controllerPos = [-controllerRect.x, -controllerRect.y];
        var pageButtonGap = zrUtil.retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
        if (showController) {
          var pageButtonPosition = legendModel.get("pageButtonPosition", true);
          if (pageButtonPosition === "end") {
            controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
          } else {
            containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
          }
        }
        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
        contentGroup.attr("position", contentPos);
        containerGroup.attr("position", containerPos);
        controllerGroup.attr("position", controllerPos);
        var mainRect = {
          x: 0,
          y: 0
        };
        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
        containerGroup.__rectSize = maxSize[wh];
        if (showController) {
          var clipShape = {
            x: 0,
            y: 0
          };
          clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
          clipShape[hw] = mainRect[hw];
          containerGroup.setClipPath(new graphic.Rect({
            shape: clipShape
          }));
          containerGroup.__rectSize = clipShape[wh];
        } else {
          controllerGroup.eachChild(function(child) {
            child.attr({
              invisible: true,
              silent: true
            });
          });
        }
        var pageInfo = this._getPageInfo(legendModel);
        pageInfo.pageIndex != null && graphic.updateProps(
          contentGroup,
          {
            position: pageInfo.contentPosition
          },
          // When switch from "show controller" to "not show controller", view should be
          // updated immediately without animation, otherwise causes weird effect.
          showController ? legendModel : false
        );
        this._updatePageInfoView(legendModel, pageInfo);
        return mainRect;
      },
      _pageGo: function(to, legendModel, api) {
        var scrollDataIndex = this._getPageInfo(legendModel)[to];
        scrollDataIndex != null && api.dispatchAction({
          type: "legendScroll",
          scrollDataIndex,
          legendId: legendModel.id
        });
      },
      _updatePageInfoView: function(legendModel, pageInfo) {
        var controllerGroup = this._controllerGroup;
        zrUtil.each(["pagePrev", "pageNext"], function(name2) {
          var canJump = pageInfo[name2 + "DataIndex"] != null;
          var icon = controllerGroup.childOfName(name2);
          if (icon) {
            icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
            icon.cursor = canJump ? "pointer" : "default";
          }
        });
        var pageText = controllerGroup.childOfName("pageText");
        var pageFormatter = legendModel.get("pageFormatter");
        var pageIndex = pageInfo.pageIndex;
        var current = pageIndex != null ? pageIndex + 1 : 0;
        var total = pageInfo.pageCount;
        pageText && pageFormatter && pageText.setStyle("text", zrUtil.isString(pageFormatter) ? pageFormatter.replace("{current}", current).replace("{total}", total) : pageFormatter({
          current,
          total
        }));
      },
      /**
       * @param {module:echarts/model/Model} legendModel
       * @return {Object} {
       *  contentPosition: Array.<number>, null when data item not found.
       *  pageIndex: number, null when data item not found.
       *  pageCount: number, always be a number, can be 0.
       *  pagePrevDataIndex: number, null when no previous page.
       *  pageNextDataIndex: number, null when no next page.
       * }
       */
      _getPageInfo: function(legendModel) {
        var scrollDataIndex = legendModel.get("scrollDataIndex", true);
        var contentGroup = this.getContentGroup();
        var containerRectSize = this._containerGroup.__rectSize;
        var orientIdx = legendModel.getOrient().index;
        var wh = WH[orientIdx];
        var xy = XY[orientIdx];
        var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
        var children = contentGroup.children();
        var targetItem = children[targetItemIndex];
        var itemCount = children.length;
        var pCount = !itemCount ? 0 : 1;
        var result = {
          contentPosition: contentGroup.position.slice(),
          pageCount: pCount,
          pageIndex: pCount - 1,
          pagePrevDataIndex: null,
          pageNextDataIndex: null
        };
        if (!targetItem) {
          return result;
        }
        var targetItemInfo = getItemInfo(targetItem);
        result.contentPosition[orientIdx] = -targetItemInfo.s;
        for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
          currItemInfo = getItemInfo(children[i]);
          if (
            // Half of the last item is out of the window.
            !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page
            // can be started at the current item or the last item.
            currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)
          ) {
            if (winEndItemInfo.i > winStartItemInfo.i) {
              winStartItemInfo = winEndItemInfo;
            } else {
              winStartItemInfo = currItemInfo;
            }
            if (winStartItemInfo) {
              if (result.pageNextDataIndex == null) {
                result.pageNextDataIndex = winStartItemInfo.i;
              }
              ++result.pageCount;
            }
          }
          winEndItemInfo = currItemInfo;
        }
        for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
          currItemInfo = getItemInfo(children[i]);
          if (
            // If the the end item does not intersect with the window started
            // from the current item, a page can be settled.
            (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.
            winStartItemInfo.i < winEndItemInfo.i
          ) {
            winEndItemInfo = winStartItemInfo;
            if (result.pagePrevDataIndex == null) {
              result.pagePrevDataIndex = winStartItemInfo.i;
            }
            ++result.pageCount;
            ++result.pageIndex;
          }
          winStartItemInfo = currItemInfo;
        }
        return result;
        function getItemInfo(el) {
          if (el) {
            var itemRect = el.getBoundingRect();
            var start = itemRect[xy] + el.position[orientIdx];
            return {
              s: start,
              e: start + itemRect[wh],
              i: el.__legendDataIndex
            };
          }
        }
        function intersect(itemInfo, winStart) {
          return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
        }
      },
      _findTargetItemIndex: function(targetDataIndex) {
        if (!this._showController) {
          return 0;
        }
        var index;
        var contentGroup = this.getContentGroup();
        var defaultIndex;
        contentGroup.eachChild(function(child, idx) {
          var legendDataIdx = child.__legendDataIndex;
          if (defaultIndex == null && legendDataIdx != null) {
            defaultIndex = idx;
          }
          if (legendDataIdx === targetDataIndex) {
            index = idx;
          }
        });
        return index != null ? index : defaultIndex;
      }
    });
    var _default = ScrollableLegendView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/scrollableLegendAction.js
var require_scrollableLegendAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legend/scrollableLegendAction.js"() {
    var echarts = require_echarts();
    echarts.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
      var scrollDataIndex = payload.scrollDataIndex;
      scrollDataIndex != null && ecModel.eachComponent({
        mainType: "legend",
        subType: "scroll",
        query: payload
      }, function(legendModel) {
        legendModel.setScrollDataIndex(scrollDataIndex);
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legendScroll.js
var require_legendScroll = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/legendScroll.js"() {
    require_legend();
    require_ScrollableLegendModel();
    require_ScrollableLegendView();
    require_scrollableLegendAction();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js
var require_SliderZoomModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomModel.js"(exports, module) {
    var DataZoomModel = require_DataZoomModel();
    var SliderZoomModel = DataZoomModel.extend({
      type: "dataZoom.slider",
      layoutMode: "box",
      /**
       * @protected
       */
      defaultOption: {
        show: true,
        // ph => placeholder. Using placehoder here because
        // deault value can only be drived in view stage.
        right: "ph",
        // Default align to grid rect.
        top: "ph",
        // Default align to grid rect.
        width: "ph",
        // Default align to grid rect.
        height: "ph",
        // Default align to grid rect.
        left: null,
        // Default align to grid rect.
        bottom: null,
        // Default align to grid rect.
        backgroundColor: "rgba(47,69,84,0)",
        // Background of slider zoom component.
        // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,
        // highest priority, remain for compatibility of
        // previous version, but not recommended any more.
        dataBackground: {
          lineStyle: {
            color: "#2f4554",
            width: 0.5,
            opacity: 0.3
          },
          areaStyle: {
            color: "rgba(47,69,84,0.3)",
            opacity: 0.3
          }
        },
        borderColor: "#ddd",
        // border color of the box. For compatibility,
        // if dataBackgroundColor is set, borderColor
        // is ignored.
        fillerColor: "rgba(167,183,204,0.4)",
        // Color of selected area.
        // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.
        // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',
        /* eslint-disable */
        handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
        /* eslint-enable */
        // Percent of the slider height
        handleSize: "100%",
        handleStyle: {
          color: "#a7b7cc"
        },
        labelPrecision: null,
        labelFormatter: null,
        showDetail: true,
        showDataShadow: "auto",
        // Default auto decision.
        realtime: true,
        zoomLock: false,
        // Whether disable zoom.
        textStyle: {
          color: "#333"
        }
      }
    });
    var _default = SliderZoomModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomView.js
var require_SliderZoomView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/SliderZoomView.js"(exports, module) {
    var zrUtil = require_util();
    var eventTool = require_event();
    var graphic = require_graphic();
    var throttle = require_throttle();
    var DataZoomView = require_DataZoomView();
    var numberUtil = require_number();
    var layout = require_layout();
    var sliderMove = require_sliderMove();
    var Rect = graphic.Rect;
    var linearMap = numberUtil.linearMap;
    var asc = numberUtil.asc;
    var bind = zrUtil.bind;
    var each = zrUtil.each;
    var DEFAULT_LOCATION_EDGE_GAP = 7;
    var DEFAULT_FRAME_BORDER_WIDTH = 1;
    var DEFAULT_FILLER_SIZE = 30;
    var HORIZONTAL = "horizontal";
    var VERTICAL = "vertical";
    var LABEL_GAP = 5;
    var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
    var SliderZoomView = DataZoomView.extend({
      type: "dataZoom.slider",
      init: function(ecModel, api) {
        this._displayables = {};
        this._orient;
        this._range;
        this._handleEnds;
        this._size;
        this._handleWidth;
        this._handleHeight;
        this._location;
        this._dragging;
        this._dataShadowInfo;
        this.api = api;
      },
      /**
       * @override
       */
      render: function(dataZoomModel, ecModel, api, payload) {
        SliderZoomView.superApply(this, "render", arguments);
        throttle.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate");
        this._orient = dataZoomModel.get("orient");
        if (this.dataZoomModel.get("show") === false) {
          this.group.removeAll();
          return;
        }
        if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
          this._buildView();
        }
        this._updateView();
      },
      /**
       * @override
       */
      remove: function() {
        SliderZoomView.superApply(this, "remove", arguments);
        throttle.clear(this, "_dispatchZoomAction");
      },
      /**
       * @override
       */
      dispose: function() {
        SliderZoomView.superApply(this, "dispose", arguments);
        throttle.clear(this, "_dispatchZoomAction");
      },
      _buildView: function() {
        var thisGroup = this.group;
        thisGroup.removeAll();
        this._resetLocation();
        this._resetInterval();
        var barGroup = this._displayables.barGroup = new graphic.Group();
        this._renderBackground();
        this._renderHandle();
        this._renderDataShadow();
        thisGroup.add(barGroup);
        this._positionGroup();
      },
      /**
       * @private
       */
      _resetLocation: function() {
        var dataZoomModel = this.dataZoomModel;
        var api = this.api;
        var coordRect = this._findCoordRect();
        var ecSize = {
          width: api.getWidth(),
          height: api.getHeight()
        };
        var positionInfo = this._orient === HORIZONTAL ? {
          // Why using 'right', because right should be used in vertical,
          // and it is better to be consistent for dealing with position param merge.
          right: ecSize.width - coordRect.x - coordRect.width,
          top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
          width: coordRect.width,
          height: DEFAULT_FILLER_SIZE
        } : {
          // vertical
          right: DEFAULT_LOCATION_EDGE_GAP,
          top: coordRect.y,
          width: DEFAULT_FILLER_SIZE,
          height: coordRect.height
        };
        var layoutParams = layout.getLayoutParams(dataZoomModel.option);
        zrUtil.each(["right", "top", "width", "height"], function(name2) {
          if (layoutParams[name2] === "ph") {
            layoutParams[name2] = positionInfo[name2];
          }
        });
        var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
        this._location = {
          x: layoutRect.x,
          y: layoutRect.y
        };
        this._size = [layoutRect.width, layoutRect.height];
        this._orient === VERTICAL && this._size.reverse();
      },
      /**
       * @private
       */
      _positionGroup: function() {
        var thisGroup = this.group;
        var location = this._location;
        var orient = this._orient;
        var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
        var inverse = targetAxisModel && targetAxisModel.get("inverse");
        var barGroup = this._displayables.barGroup;
        var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
        barGroup.attr(orient === HORIZONTAL && !inverse ? {
          scale: otherAxisInverse ? [1, 1] : [1, -1]
        } : orient === HORIZONTAL && inverse ? {
          scale: otherAxisInverse ? [-1, 1] : [-1, -1]
        } : orient === VERTICAL && !inverse ? {
          scale: otherAxisInverse ? [1, -1] : [1, 1],
          rotation: Math.PI / 2
          // Dont use Math.PI, considering shadow direction.
        } : {
          scale: otherAxisInverse ? [-1, -1] : [-1, 1],
          rotation: Math.PI / 2
        });
        var rect = thisGroup.getBoundingRect([barGroup]);
        thisGroup.attr("position", [location.x - rect.x, location.y - rect.y]);
      },
      /**
       * @private
       */
      _getViewExtent: function() {
        return [0, this._size[0]];
      },
      _renderBackground: function() {
        var dataZoomModel = this.dataZoomModel;
        var size = this._size;
        var barGroup = this._displayables.barGroup;
        barGroup.add(new Rect({
          silent: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: dataZoomModel.get("backgroundColor")
          },
          z2: -40
        }));
        barGroup.add(new Rect({
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: "transparent"
          },
          z2: 0,
          onclick: zrUtil.bind(this._onClickPanelClick, this)
        }));
      },
      _renderDataShadow: function() {
        var info = this._dataShadowInfo = this._prepareDataShadowInfo();
        if (!info) {
          return;
        }
        var size = this._size;
        var seriesModel = info.series;
        var data = seriesModel.getRawData();
        var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
        if (otherDim == null) {
          return;
        }
        var otherDataExtent = data.getDataExtent(otherDim);
        var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
        otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
        var otherShadowExtent = [0, size[1]];
        var thisShadowExtent = [0, size[0]];
        var areaPoints = [[size[0], 0], [0, 0]];
        var linePoints = [];
        var step = thisShadowExtent[1] / (data.count() - 1);
        var thisCoord = 0;
        var stride = Math.round(data.count() / size[0]);
        var lastIsEmpty;
        data.each([otherDim], function(value, index) {
          if (stride > 0 && index % stride) {
            thisCoord += step;
            return;
          }
          var isEmpty = value == null || isNaN(value) || value === "";
          var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);
          if (isEmpty && !lastIsEmpty && index) {
            areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
            linePoints.push([linePoints[linePoints.length - 1][0], 0]);
          } else if (!isEmpty && lastIsEmpty) {
            areaPoints.push([thisCoord, 0]);
            linePoints.push([thisCoord, 0]);
          }
          areaPoints.push([thisCoord, otherCoord]);
          linePoints.push([thisCoord, otherCoord]);
          thisCoord += step;
          lastIsEmpty = isEmpty;
        });
        var dataZoomModel = this.dataZoomModel;
        this._displayables.barGroup.add(new graphic.Polygon({
          shape: {
            points: areaPoints
          },
          style: zrUtil.defaults({
            fill: dataZoomModel.get("dataBackgroundColor")
          }, dataZoomModel.getModel("dataBackground.areaStyle").getAreaStyle()),
          silent: true,
          z2: -20
        }));
        this._displayables.barGroup.add(new graphic.Polyline({
          shape: {
            points: linePoints
          },
          style: dataZoomModel.getModel("dataBackground.lineStyle").getLineStyle(),
          silent: true,
          z2: -19
        }));
      },
      _prepareDataShadowInfo: function() {
        var dataZoomModel = this.dataZoomModel;
        var showDataShadow = dataZoomModel.get("showDataShadow");
        if (showDataShadow === false) {
          return;
        }
        var result;
        var ecModel = this.ecModel;
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
          var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
          zrUtil.each(seriesModels, function(seriesModel) {
            if (result) {
              return;
            }
            if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
              return;
            }
            var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
            var otherDim = getOtherDim(dimNames.name);
            var otherAxisInverse;
            var coordSys = seriesModel.coordinateSystem;
            if (otherDim != null && coordSys.getOtherAxis) {
              otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
            }
            otherDim = seriesModel.getData().mapDimension(otherDim);
            result = {
              thisAxis,
              series: seriesModel,
              thisDim: dimNames.name,
              otherDim,
              otherAxisInverse
            };
          }, this);
        }, this);
        return result;
      },
      _renderHandle: function() {
        var displaybles = this._displayables;
        var handles = displaybles.handles = [];
        var handleLabels = displaybles.handleLabels = [];
        var barGroup = this._displayables.barGroup;
        var size = this._size;
        var dataZoomModel = this.dataZoomModel;
        barGroup.add(displaybles.filler = new Rect({
          draggable: true,
          cursor: getCursor(this._orient),
          drift: bind(this._onDragMove, this, "all"),
          ondragstart: bind(this._showDataInfo, this, true),
          ondragend: bind(this._onDragEnd, this),
          onmouseover: bind(this._showDataInfo, this, true),
          onmouseout: bind(this._showDataInfo, this, false),
          style: {
            fill: dataZoomModel.get("fillerColor"),
            textPosition: "inside"
          }
        }));
        barGroup.add(new Rect({
          silent: true,
          subPixelOptimize: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
            lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
            fill: "rgba(0,0,0,0)"
          }
        }));
        each([0, 1], function(handleIndex) {
          var path = graphic.createIcon(dataZoomModel.get("handleIcon"), {
            cursor: getCursor(this._orient),
            draggable: true,
            drift: bind(this._onDragMove, this, handleIndex),
            ondragend: bind(this._onDragEnd, this),
            onmouseover: bind(this._showDataInfo, this, true),
            onmouseout: bind(this._showDataInfo, this, false)
          }, {
            x: -1,
            y: 0,
            width: 2,
            height: 2
          });
          var bRect = path.getBoundingRect();
          this._handleHeight = numberUtil.parsePercent(dataZoomModel.get("handleSize"), this._size[1]);
          this._handleWidth = bRect.width / bRect.height * this._handleHeight;
          path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
          var handleColor = dataZoomModel.get("handleColor");
          if (handleColor != null) {
            path.style.fill = handleColor;
          }
          barGroup.add(handles[handleIndex] = path);
          var textStyleModel = dataZoomModel.textStyleModel;
          this.group.add(handleLabels[handleIndex] = new graphic.Text({
            silent: true,
            invisible: true,
            style: {
              x: 0,
              y: 0,
              text: "",
              textVerticalAlign: "middle",
              textAlign: "center",
              textFill: textStyleModel.getTextColor(),
              textFont: textStyleModel.getFont()
            },
            z2: 10
          }));
        }, this);
      },
      /**
       * @private
       */
      _resetInterval: function() {
        var range = this._range = this.dataZoomModel.getPercentRange();
        var viewExtent = this._getViewExtent();
        this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
      },
      /**
       * @private
       * @param {(number|string)} handleIndex 0 or 1 or 'all'
       * @param {number} delta
       * @return {boolean} changed
       */
      _updateInterval: function(handleIndex, delta) {
        var dataZoomModel = this.dataZoomModel;
        var handleEnds = this._handleEnds;
        var viewExtend = this._getViewExtent();
        var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        var percentExtent = [0, 100];
        sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
        var lastRange = this._range;
        var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
        return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
      },
      /**
       * @private
       */
      _updateView: function(nonRealtime) {
        var displaybles = this._displayables;
        var handleEnds = this._handleEnds;
        var handleInterval = asc(handleEnds.slice());
        var size = this._size;
        each([0, 1], function(handleIndex) {
          var handle = displaybles.handles[handleIndex];
          var handleHeight = this._handleHeight;
          handle.attr({
            scale: [handleHeight / 2, handleHeight / 2],
            position: [handleEnds[handleIndex], size[1] / 2 - handleHeight / 2]
          });
        }, this);
        displaybles.filler.setShape({
          x: handleInterval[0],
          y: 0,
          width: handleInterval[1] - handleInterval[0],
          height: size[1]
        });
        this._updateDataInfo(nonRealtime);
      },
      /**
       * @private
       */
      _updateDataInfo: function(nonRealtime) {
        var dataZoomModel = this.dataZoomModel;
        var displaybles = this._displayables;
        var handleLabels = displaybles.handleLabels;
        var orient = this._orient;
        var labelTexts = ["", ""];
        if (dataZoomModel.get("showDetail")) {
          var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
          if (axisProxy) {
            var axis = axisProxy.getAxisModel().axis;
            var range = this._range;
            var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
              start: range[0],
              end: range[1]
            }).valueWindow : axisProxy.getDataValueWindow();
            labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
          }
        }
        var orderedHandleEnds = asc(this._handleEnds.slice());
        setLabel.call(this, 0);
        setLabel.call(this, 1);
        function setLabel(handleIndex) {
          var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
          var direction = graphic.transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
          var offset = this._handleWidth / 2 + LABEL_GAP;
          var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
          handleLabels[handleIndex].setStyle({
            x: textPoint[0],
            y: textPoint[1],
            textVerticalAlign: orient === HORIZONTAL ? "middle" : direction,
            textAlign: orient === HORIZONTAL ? direction : "center",
            text: labelTexts[handleIndex]
          });
        }
      },
      /**
       * @private
       */
      _formatLabel: function(value, axis) {
        var dataZoomModel = this.dataZoomModel;
        var labelFormatter = dataZoomModel.get("labelFormatter");
        var labelPrecision = dataZoomModel.get("labelPrecision");
        if (labelPrecision == null || labelPrecision === "auto") {
          labelPrecision = axis.getPixelPrecision();
        }
        var valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel(Math.round(value)) : value.toFixed(Math.min(labelPrecision, 20));
        return zrUtil.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil.isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
      },
      /**
       * @private
       * @param {boolean} showOrHide true: show, false: hide
       */
      _showDataInfo: function(showOrHide) {
        showOrHide = this._dragging || showOrHide;
        var handleLabels = this._displayables.handleLabels;
        handleLabels[0].attr("invisible", !showOrHide);
        handleLabels[1].attr("invisible", !showOrHide);
      },
      _onDragMove: function(handleIndex, dx, dy, event) {
        this._dragging = true;
        eventTool.stop(event.event);
        var barTransform = this._displayables.barGroup.getLocalTransform();
        var vertex = graphic.applyTransform([dx, dy], barTransform, true);
        var changed = this._updateInterval(handleIndex, vertex[0]);
        var realtime = this.dataZoomModel.get("realtime");
        this._updateView(!realtime);
        changed && realtime && this._dispatchZoomAction();
      },
      _onDragEnd: function() {
        this._dragging = false;
        this._showDataInfo(false);
        var realtime = this.dataZoomModel.get("realtime");
        !realtime && this._dispatchZoomAction();
      },
      _onClickPanelClick: function(e) {
        var size = this._size;
        var localPoint = this._displayables.barGroup.transformCoordToLocal(e.offsetX, e.offsetY);
        if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
          return;
        }
        var handleEnds = this._handleEnds;
        var center = (handleEnds[0] + handleEnds[1]) / 2;
        var changed = this._updateInterval("all", localPoint[0] - center);
        this._updateView();
        changed && this._dispatchZoomAction();
      },
      /**
       * This action will be throttled.
       * @private
       */
      _dispatchZoomAction: function() {
        var range = this._range;
        this.api.dispatchAction({
          type: "dataZoom",
          from: this.uid,
          dataZoomId: this.dataZoomModel.id,
          start: range[0],
          end: range[1]
        });
      },
      /**
       * @private
       */
      _findCoordRect: function() {
        var rect;
        each(this.getTargetCoordInfo(), function(coordInfoList) {
          if (!rect && coordInfoList.length) {
            var coordSys = coordInfoList[0].model.coordinateSystem;
            rect = coordSys.getRect && coordSys.getRect();
          }
        });
        if (!rect) {
          var width = this.api.getWidth();
          var height = this.api.getHeight();
          rect = {
            x: width * 0.2,
            y: height * 0.2,
            width: width * 0.6,
            height: height * 0.6
          };
        }
        return rect;
      }
    });
    function getOtherDim(thisDim) {
      var map = {
        x: "y",
        y: "x",
        radius: "angle",
        angle: "radius"
      };
      return map[thisDim];
    }
    function getCursor(orient) {
      return orient === "vertical" ? "ns-resize" : "ew-resize";
    }
    var _default = SliderZoomView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSlider.js
var require_dataZoomSlider = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomSlider.js"() {
    require_typeDefaulter();
    require_DataZoomModel();
    require_DataZoomView();
    require_SliderZoomModel();
    require_SliderZoomView();
    require_dataZoomProcessor();
    require_dataZoomAction();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js
var require_InsideZoomModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomModel.js"(exports, module) {
    var DataZoomModel = require_DataZoomModel();
    var _default = DataZoomModel.extend({
      type: "dataZoom.inside",
      /**
       * @protected
       */
      defaultOption: {
        disabled: false,
        // Whether disable this inside zoom.
        zoomLock: false,
        // Whether disable zoom but only pan.
        zoomOnMouseWheel: true,
        // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
        moveOnMouseMove: true,
        // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
        moveOnMouseWheel: false,
        // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
        preventDefaultMouseMove: true
      }
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/roams.js
var require_roams = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/roams.js"(exports) {
    var zrUtil = require_util();
    var RoamController = require_RoamController();
    var throttleUtil = require_throttle();
    var ATTR = "\0_ec_dataZoom_roams";
    function register(api, dataZoomInfo) {
      var store = giveStore(api);
      var theDataZoomId = dataZoomInfo.dataZoomId;
      var theCoordId = dataZoomInfo.coordId;
      zrUtil.each(store, function(record2, coordId) {
        var dataZoomInfos = record2.dataZoomInfos;
        if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
          delete dataZoomInfos[theDataZoomId];
          record2.count--;
        }
      });
      cleanStore(store);
      var record = store[theCoordId];
      if (!record) {
        record = store[theCoordId] = {
          coordId: theCoordId,
          dataZoomInfos: {},
          count: 0
        };
        record.controller = createController(api, record);
        record.dispatchAction = zrUtil.curry(dispatchAction, api);
      }
      !record.dataZoomInfos[theDataZoomId] && record.count++;
      record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
      var controllerParams = mergeControllerParams(record.dataZoomInfos);
      record.controller.enable(controllerParams.controlType, controllerParams.opt);
      record.controller.setPointerChecker(dataZoomInfo.containsPoint);
      throttleUtil.createOrUpdate(record, "dispatchAction", dataZoomInfo.dataZoomModel.get("throttle", true), "fixRate");
    }
    function unregister(api, dataZoomId) {
      var store = giveStore(api);
      zrUtil.each(store, function(record) {
        record.controller.dispose();
        var dataZoomInfos = record.dataZoomInfos;
        if (dataZoomInfos[dataZoomId]) {
          delete dataZoomInfos[dataZoomId];
          record.count--;
        }
      });
      cleanStore(store);
    }
    function generateCoordId(coordModel) {
      return coordModel.type + "\0_" + coordModel.id;
    }
    function giveStore(api) {
      var zr = api.getZr();
      return zr[ATTR] || (zr[ATTR] = {});
    }
    function createController(api, newRecord) {
      var controller = new RoamController(api.getZr());
      zrUtil.each(["pan", "zoom", "scrollMove"], function(eventName) {
        controller.on(eventName, function(event) {
          var batch = [];
          zrUtil.each(newRecord.dataZoomInfos, function(info) {
            if (!event.isAvailableBehavior(info.dataZoomModel.option)) {
              return;
            }
            var method = (info.getRange || {})[eventName];
            var range = method && method(newRecord.controller, event);
            !info.dataZoomModel.get("disabled", true) && range && batch.push({
              dataZoomId: info.dataZoomId,
              start: range[0],
              end: range[1]
            });
          });
          batch.length && newRecord.dispatchAction(batch);
        });
      });
      return controller;
    }
    function cleanStore(store) {
      zrUtil.each(store, function(record, coordId) {
        if (!record.count) {
          record.controller.dispose();
          delete store[coordId];
        }
      });
    }
    function dispatchAction(api, batch) {
      api.dispatchAction({
        type: "dataZoom",
        batch
      });
    }
    function mergeControllerParams(dataZoomInfos) {
      var controlType;
      var prefix = "type_";
      var typePriority = {
        "type_true": 2,
        "type_move": 1,
        "type_false": 0,
        "type_undefined": -1
      };
      var preventDefaultMouseMove = true;
      zrUtil.each(dataZoomInfos, function(dataZoomInfo) {
        var dataZoomModel = dataZoomInfo.dataZoomModel;
        var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
        if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
          controlType = oneType;
        }
        preventDefaultMouseMove &= dataZoomModel.get("preventDefaultMouseMove", true);
      });
      return {
        controlType,
        opt: {
          // RoamController will enable all of these functionalities,
          // and the final behavior is determined by its event listener
          // provided by each inside zoom.
          zoomOnMouseWheel: true,
          moveOnMouseMove: true,
          moveOnMouseWheel: true,
          preventDefaultMouseMove: !!preventDefaultMouseMove
        }
      };
    }
    exports.register = register;
    exports.unregister = unregister;
    exports.generateCoordId = generateCoordId;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomView.js
var require_InsideZoomView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom/InsideZoomView.js"(exports, module) {
    var zrUtil = require_util();
    var DataZoomView = require_DataZoomView();
    var sliderMove = require_sliderMove();
    var roams = require_roams();
    var bind = zrUtil.bind;
    var InsideZoomView = DataZoomView.extend({
      type: "dataZoom.inside",
      /**
       * @override
       */
      init: function(ecModel, api) {
        this._range;
      },
      /**
       * @override
       */
      render: function(dataZoomModel, ecModel, api, payload) {
        InsideZoomView.superApply(this, "render", arguments);
        this._range = dataZoomModel.getPercentRange();
        zrUtil.each(this.getTargetCoordInfo(), function(coordInfoList, coordSysName) {
          var allCoordIds = zrUtil.map(coordInfoList, function(coordInfo) {
            return roams.generateCoordId(coordInfo.model);
          });
          zrUtil.each(coordInfoList, function(coordInfo) {
            var coordModel = coordInfo.model;
            var getRange = {};
            zrUtil.each(["pan", "zoom", "scrollMove"], function(eventName) {
              getRange[eventName] = bind(roamHandlers[eventName], this, coordInfo, coordSysName);
            }, this);
            roams.register(api, {
              coordId: roams.generateCoordId(coordModel),
              allCoordIds,
              containsPoint: function(e, x, y) {
                return coordModel.coordinateSystem.containPoint([x, y]);
              },
              dataZoomId: dataZoomModel.id,
              dataZoomModel,
              getRange
            });
          }, this);
        }, this);
      },
      /**
       * @override
       */
      dispose: function() {
        roams.unregister(this.api, this.dataZoomModel.id);
        InsideZoomView.superApply(this, "dispose", arguments);
        this._range = null;
      }
    });
    var roamHandlers = {
      /**
       * @this {module:echarts/component/dataZoom/InsideZoomView}
       */
      zoom: function(coordInfo, coordSysName, controller, e) {
        var lastRange = this._range;
        var range = lastRange.slice();
        var axisModel = coordInfo.axisModels[0];
        if (!axisModel) {
          return;
        }
        var directionInfo = getDirectionInfo[coordSysName](null, [e.originX, e.originY], axisModel, controller, coordInfo);
        var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
        var scale = Math.max(1 / e.scale, 0);
        range[0] = (range[0] - percentPoint) * scale + percentPoint;
        range[1] = (range[1] - percentPoint) * scale + percentPoint;
        var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
        sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
        this._range = range;
        if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
          return range;
        }
      },
      /**
       * @this {module:echarts/component/dataZoom/InsideZoomView}
       */
      pan: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e) {
        var directionInfo = getDirectionInfo[coordSysName]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordInfo);
        return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
      }),
      /**
       * @this {module:echarts/component/dataZoom/InsideZoomView}
       */
      scrollMove: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e) {
        var directionInfo = getDirectionInfo[coordSysName]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordInfo);
        return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;
      })
    };
    function makeMover(getPercentDelta) {
      return function(coordInfo, coordSysName, controller, e) {
        var lastRange = this._range;
        var range = lastRange.slice();
        var axisModel = coordInfo.axisModels[0];
        if (!axisModel) {
          return;
        }
        var percentDelta = getPercentDelta(range, axisModel, coordInfo, coordSysName, controller, e);
        sliderMove(percentDelta, range, [0, 100], "all");
        this._range = range;
        if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
          return range;
        }
      };
    }
    var getDirectionInfo = {
      grid: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
        var axis = axisModel.axis;
        var ret = {};
        var rect = coordInfo.model.coordinateSystem.getRect();
        oldPoint = oldPoint || [0, 0];
        if (axis.dim === "x") {
          ret.pixel = newPoint[0] - oldPoint[0];
          ret.pixelLength = rect.width;
          ret.pixelStart = rect.x;
          ret.signal = axis.inverse ? 1 : -1;
        } else {
          ret.pixel = newPoint[1] - oldPoint[1];
          ret.pixelLength = rect.height;
          ret.pixelStart = rect.y;
          ret.signal = axis.inverse ? -1 : 1;
        }
        return ret;
      },
      polar: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
        var axis = axisModel.axis;
        var ret = {};
        var polar = coordInfo.model.coordinateSystem;
        var radiusExtent = polar.getRadiusAxis().getExtent();
        var angleExtent = polar.getAngleAxis().getExtent();
        oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
        newPoint = polar.pointToCoord(newPoint);
        if (axisModel.mainType === "radiusAxis") {
          ret.pixel = newPoint[0] - oldPoint[0];
          ret.pixelLength = radiusExtent[1] - radiusExtent[0];
          ret.pixelStart = radiusExtent[0];
          ret.signal = axis.inverse ? 1 : -1;
        } else {
          ret.pixel = newPoint[1] - oldPoint[1];
          ret.pixelLength = angleExtent[1] - angleExtent[0];
          ret.pixelStart = angleExtent[0];
          ret.signal = axis.inverse ? -1 : 1;
        }
        return ret;
      },
      singleAxis: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
        var axis = axisModel.axis;
        var rect = coordInfo.model.coordinateSystem.getRect();
        var ret = {};
        oldPoint = oldPoint || [0, 0];
        if (axis.orient === "horizontal") {
          ret.pixel = newPoint[0] - oldPoint[0];
          ret.pixelLength = rect.width;
          ret.pixelStart = rect.x;
          ret.signal = axis.inverse ? 1 : -1;
        } else {
          ret.pixel = newPoint[1] - oldPoint[1];
          ret.pixelLength = rect.height;
          ret.pixelStart = rect.y;
          ret.signal = axis.inverse ? -1 : 1;
        }
        return ret;
      }
    };
    var _default = InsideZoomView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomInside.js
var require_dataZoomInside = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoomInside.js"() {
    require_typeDefaulter();
    require_DataZoomModel();
    require_DataZoomView();
    require_InsideZoomModel();
    require_InsideZoomView();
    require_dataZoomProcessor();
    require_dataZoomAction();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom.js
var require_dataZoom = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/dataZoom.js"() {
    require_dataZoomSlider();
    require_dataZoomInside();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/preprocessor.js
var require_preprocessor4 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/preprocessor.js"(exports, module) {
    var zrUtil = require_util();
    var each = zrUtil.each;
    function _default(option) {
      var visualMap = option && option.visualMap;
      if (!zrUtil.isArray(visualMap)) {
        visualMap = visualMap ? [visualMap] : [];
      }
      each(visualMap, function(opt) {
        if (!opt) {
          return;
        }
        if (has(opt, "splitList") && !has(opt, "pieces")) {
          opt.pieces = opt.splitList;
          delete opt.splitList;
        }
        var pieces = opt.pieces;
        if (pieces && zrUtil.isArray(pieces)) {
          each(pieces, function(piece) {
            if (zrUtil.isObject(piece)) {
              if (has(piece, "start") && !has(piece, "min")) {
                piece.min = piece.start;
              }
              if (has(piece, "end") && !has(piece, "max")) {
                piece.max = piece.end;
              }
            }
          });
        }
      });
    }
    function has(obj, name2) {
      return obj && obj.hasOwnProperty && obj.hasOwnProperty(name2);
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/typeDefaulter.js
var require_typeDefaulter3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/typeDefaulter.js"() {
    var Component = require_Component();
    Component.registerSubTypeDefaulter("visualMap", function(option) {
      return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualEncoding.js
var require_visualEncoding2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualEncoding.js"() {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var visualSolution = require_visualSolution();
    var VisualMapping = require_VisualMapping();
    var VISUAL_PRIORITY = echarts.PRIORITY.VISUAL.COMPONENT;
    echarts.registerVisual(VISUAL_PRIORITY, {
      createOnAllSeries: true,
      reset: function(seriesModel, ecModel) {
        var resetDefines = [];
        ecModel.eachComponent("visualMap", function(visualMapModel) {
          var pipelineContext = seriesModel.pipelineContext;
          if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
            return;
          }
          resetDefines.push(visualSolution.incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, zrUtil.bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimension(seriesModel.getData())));
        });
        return resetDefines;
      }
    });
    echarts.registerVisual(VISUAL_PRIORITY, {
      createOnAllSeries: true,
      reset: function(seriesModel, ecModel) {
        var data = seriesModel.getData();
        var visualMetaList = [];
        ecModel.eachComponent("visualMap", function(visualMapModel) {
          if (visualMapModel.isTargetSeries(seriesModel)) {
            var visualMeta = visualMapModel.getVisualMeta(zrUtil.bind(getColorVisual, null, seriesModel, visualMapModel)) || {
              stops: [],
              outerColors: []
            };
            var concreteDim = visualMapModel.getDataDimension(data);
            var dimInfo = data.getDimensionInfo(concreteDim);
            if (dimInfo != null) {
              visualMeta.dimension = dimInfo.index;
              visualMetaList.push(visualMeta);
            }
          }
        });
        seriesModel.getData().setVisual("visualMeta", visualMetaList);
      }
    });
    function getColorVisual(seriesModel, visualMapModel, value, valueState) {
      var mappings = visualMapModel.targetVisuals[valueState];
      var visualTypes = VisualMapping.prepareVisualTypes(mappings);
      var resultVisual = {
        color: seriesModel.getData().getVisual("color")
        // default color.
      };
      for (var i = 0, len = visualTypes.length; i < len; i++) {
        var type = visualTypes[i];
        var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
        mapping && mapping.applyVisual(value, getVisual, setVisual);
      }
      return resultVisual.color;
      function getVisual(key) {
        return resultVisual[key];
      }
      function setVisual(key, value2) {
        resultVisual[key] = value2;
      }
    }
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualDefault.js
var require_visualDefault = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/visual/visualDefault.js"(exports, module) {
    var zrUtil = require_util();
    var visualDefault = {
      /**
       * @public
       */
      get: function(visualType, key, isCategory) {
        var value = zrUtil.clone((defaultOption[visualType] || {})[key]);
        return isCategory ? zrUtil.isArray(value) ? value[value.length - 1] : value : value;
      }
    };
    var defaultOption = {
      color: {
        active: ["#006edd", "#e0ffff"],
        inactive: ["rgba(0,0,0,0)"]
      },
      colorHue: {
        active: [0, 360],
        inactive: [0, 0]
      },
      colorSaturation: {
        active: [0.3, 1],
        inactive: [0, 0]
      },
      colorLightness: {
        active: [0.9, 0.5],
        inactive: [0, 0]
      },
      colorAlpha: {
        active: [0.3, 1],
        inactive: [0, 0]
      },
      opacity: {
        active: [0.3, 1],
        inactive: [0, 0]
      },
      symbol: {
        active: ["circle", "roundRect", "diamond"],
        inactive: ["none"]
      },
      symbolSize: {
        active: [10, 50],
        inactive: [0, 0]
      }
    };
    var _default = visualDefault;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapModel.js
var require_VisualMapModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapModel.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var env = require_env();
    var visualDefault = require_visualDefault();
    var VisualMapping = require_VisualMapping();
    var visualSolution = require_visualSolution();
    var modelUtil = require_model();
    var numberUtil = require_number();
    var mapVisual = VisualMapping.mapVisual;
    var eachVisual = VisualMapping.eachVisual;
    var isArray = zrUtil.isArray;
    var each = zrUtil.each;
    var asc = numberUtil.asc;
    var linearMap = numberUtil.linearMap;
    var noop = zrUtil.noop;
    var VisualMapModel = echarts.extendComponentModel({
      type: "visualMap",
      dependencies: ["series"],
      /**
       * @readOnly
       * @type {Array.<string>}
       */
      stateList: ["inRange", "outOfRange"],
      /**
       * @readOnly
       * @type {Array.<string>}
       */
      replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
      /**
       * [lowerBound, upperBound]
       *
       * @readOnly
       * @type {Array.<number>}
       */
      dataBound: [-Infinity, Infinity],
      /**
       * @readOnly
       * @type {string|Object}
       */
      layoutMode: {
        type: "box",
        ignoreSize: true
      },
      /**
       * @protected
       */
      defaultOption: {
        show: true,
        zlevel: 0,
        z: 4,
        seriesIndex: "all",
        // 'all' or null/undefined: all series.
        // A number or an array of number: the specified series.
        // set min: 0, max: 200, only for campatible with ec2.
        // In fact min max should not have default value.
        min: 0,
        // min value, must specified if pieces is not specified.
        max: 200,
        // max value, must specified if pieces is not specified.
        dimension: null,
        inRange: null,
        // 'color', 'colorHue', 'colorSaturation', 'colorLightness', 'colorAlpha',
        // 'symbol', 'symbolSize'
        outOfRange: null,
        // 'color', 'colorHue', 'colorSaturation',
        // 'colorLightness', 'colorAlpha',
        // 'symbol', 'symbolSize'
        left: 0,
        // 'center' ¦ 'left' ¦ 'right' ¦ {number} (px)
        right: null,
        // The same as left.
        top: null,
        // 'top' ¦ 'bottom' ¦ 'center' ¦ {number} (px)
        bottom: 0,
        // The same as top.
        itemWidth: null,
        itemHeight: null,
        inverse: false,
        orient: "vertical",
        // 'horizontal' ¦ 'vertical'
        backgroundColor: "rgba(0,0,0,0)",
        borderColor: "#ccc",
        // 值域边框颜色
        contentColor: "#5793f3",
        inactiveColor: "#aaa",
        borderWidth: 0,
        // 值域边框线宽，单位px，默认为0（无边框）
        padding: 5,
        // 值域内边距，单位px，默认各方向内边距为5，
        // 接受数组分别设定上右下左边距，同css
        textGap: 10,
        //
        precision: 0,
        // 小数精度，默认为0，无小数点
        color: null,
        //颜色（deprecated，兼容ec2，顺序同pieces，不同于inRange/outOfRange）
        formatter: null,
        text: null,
        // 文本，如['高', '低']，兼容ec2，text[0]对应高值，text[1]对应低值
        textStyle: {
          color: "#333"
          // 值域文字颜色
        }
      },
      /**
       * @protected
       */
      init: function(option, parentModel, ecModel) {
        this._dataExtent;
        this.targetVisuals = {};
        this.controllerVisuals = {};
        this.textStyleModel;
        this.itemSize;
        this.mergeDefaultAndTheme(option, ecModel);
      },
      /**
       * @protected
       */
      optionUpdated: function(newOption, isInit) {
        var thisOption = this.option;
        if (!env.canvasSupported) {
          thisOption.realtime = false;
        }
        !isInit && visualSolution.replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
        this.textStyleModel = this.getModel("textStyle");
        this.resetItemSize();
        this.completeVisualOption();
      },
      /**
       * @protected
       */
      resetVisual: function(supplementVisualOption) {
        var stateList = this.stateList;
        supplementVisualOption = zrUtil.bind(supplementVisualOption, this);
        this.controllerVisuals = visualSolution.createVisualMappings(this.option.controller, stateList, supplementVisualOption);
        this.targetVisuals = visualSolution.createVisualMappings(this.option.target, stateList, supplementVisualOption);
      },
      /**
       * @protected
       * @return {Array.<number>} An array of series indices.
       */
      getTargetSeriesIndices: function() {
        var optionSeriesIndex = this.option.seriesIndex;
        var seriesIndices = [];
        if (optionSeriesIndex == null || optionSeriesIndex === "all") {
          this.ecModel.eachSeries(function(seriesModel, index) {
            seriesIndices.push(index);
          });
        } else {
          seriesIndices = modelUtil.normalizeToArray(optionSeriesIndex);
        }
        return seriesIndices;
      },
      /**
       * @public
       */
      eachTargetSeries: function(callback, context) {
        zrUtil.each(this.getTargetSeriesIndices(), function(seriesIndex) {
          callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));
        }, this);
      },
      /**
       * @pubilc
       */
      isTargetSeries: function(seriesModel) {
        var is = false;
        this.eachTargetSeries(function(model) {
          model === seriesModel && (is = true);
        });
        return is;
      },
      /**
       * @example
       * this.formatValueText(someVal); // format single numeric value to text.
       * this.formatValueText(someVal, true); // format single category value to text.
       * this.formatValueText([min, max]); // format numeric min-max to text.
       * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
       * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
       *
       * @param {number|Array.<number>} value Real value, or this.dataBound[0 or 1].
       * @param {boolean} [isCategory=false] Only available when value is number.
       * @param {Array.<string>} edgeSymbols Open-close symbol when value is interval.
       * @return {string}
       * @protected
       */
      formatValueText: function(value, isCategory, edgeSymbols) {
        var option = this.option;
        var precision = option.precision;
        var dataBound = this.dataBound;
        var formatter = option.formatter;
        var isMinMax;
        var textValue;
        edgeSymbols = edgeSymbols || ["<", ">"];
        if (zrUtil.isArray(value)) {
          value = value.slice();
          isMinMax = true;
        }
        textValue = isCategory ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
        if (zrUtil.isString(formatter)) {
          return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
        } else if (zrUtil.isFunction(formatter)) {
          return isMinMax ? formatter(value[0], value[1]) : formatter(value);
        }
        if (isMinMax) {
          if (value[0] === dataBound[0]) {
            return edgeSymbols[0] + " " + textValue[1];
          } else if (value[1] === dataBound[1]) {
            return edgeSymbols[1] + " " + textValue[0];
          } else {
            return textValue[0] + " - " + textValue[1];
          }
        } else {
          return textValue;
        }
        function toFixed(val) {
          return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
        }
      },
      /**
       * @protected
       */
      resetExtent: function() {
        var thisOption = this.option;
        var extent = asc([thisOption.min, thisOption.max]);
        this._dataExtent = extent;
      },
      /**
       * @public
       * @param {module:echarts/data/List} list
       * @return {string} Concrete dimention. If return null/undefined,
       *                  no dimension used.
       */
      getDataDimension: function(list) {
        var optDim = this.option.dimension;
        var listDimensions = list.dimensions;
        if (optDim == null && !listDimensions.length) {
          return;
        }
        if (optDim != null) {
          return list.getDimension(optDim);
        }
        var dimNames = list.dimensions;
        for (var i = dimNames.length - 1; i >= 0; i--) {
          var dimName = dimNames[i];
          var dimInfo = list.getDimensionInfo(dimName);
          if (!dimInfo.isCalculationCoord) {
            return dimName;
          }
        }
      },
      /**
       * @public
       * @override
       */
      getExtent: function() {
        return this._dataExtent.slice();
      },
      /**
       * @protected
       */
      completeVisualOption: function() {
        var ecModel = this.ecModel;
        var thisOption = this.option;
        var base = {
          inRange: thisOption.inRange,
          outOfRange: thisOption.outOfRange
        };
        var target = thisOption.target || (thisOption.target = {});
        var controller = thisOption.controller || (thisOption.controller = {});
        zrUtil.merge(target, base);
        zrUtil.merge(controller, base);
        var isCategory = this.isCategory();
        completeSingle.call(this, target);
        completeSingle.call(this, controller);
        completeInactive.call(this, target, "inRange", "outOfRange");
        completeController.call(this, controller);
        function completeSingle(base2) {
          if (isArray(thisOption.color) && !base2.inRange) {
            base2.inRange = {
              color: thisOption.color.slice().reverse()
            };
          }
          base2.inRange = base2.inRange || {
            color: ecModel.get("gradientColor")
          };
          each(this.stateList, function(state) {
            var visualType = base2[state];
            if (zrUtil.isString(visualType)) {
              var defa = visualDefault.get(visualType, "active", isCategory);
              if (defa) {
                base2[state] = {};
                base2[state][visualType] = defa;
              } else {
                delete base2[state];
              }
            }
          }, this);
        }
        function completeInactive(base2, stateExist, stateAbsent) {
          var optExist = base2[stateExist];
          var optAbsent = base2[stateAbsent];
          if (optExist && !optAbsent) {
            optAbsent = base2[stateAbsent] = {};
            each(optExist, function(visualData, visualType) {
              if (!VisualMapping.isValidType(visualType)) {
                return;
              }
              var defa = visualDefault.get(visualType, "inactive", isCategory);
              if (defa != null) {
                optAbsent[visualType] = defa;
                if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
                  optAbsent.opacity = [0, 0];
                }
              }
            });
          }
        }
        function completeController(controller2) {
          var symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
          var symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
          var inactiveColor = this.get("inactiveColor");
          each(this.stateList, function(state) {
            var itemSize = this.itemSize;
            var visuals = controller2[state];
            if (!visuals) {
              visuals = controller2[state] = {
                color: isCategory ? inactiveColor : [inactiveColor]
              };
            }
            if (visuals.symbol == null) {
              visuals.symbol = symbolExists && zrUtil.clone(symbolExists) || (isCategory ? "roundRect" : ["roundRect"]);
            }
            if (visuals.symbolSize == null) {
              visuals.symbolSize = symbolSizeExists && zrUtil.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);
            }
            visuals.symbol = mapVisual(visuals.symbol, function(symbol) {
              return symbol === "none" || symbol === "square" ? "roundRect" : symbol;
            });
            var symbolSize = visuals.symbolSize;
            if (symbolSize != null) {
              var max = -Infinity;
              eachVisual(symbolSize, function(value) {
                value > max && (max = value);
              });
              visuals.symbolSize = mapVisual(symbolSize, function(value) {
                return linearMap(value, [0, max], [0, itemSize[0]], true);
              });
            }
          }, this);
        }
      },
      /**
       * @protected
       */
      resetItemSize: function() {
        this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
      },
      /**
       * @public
       */
      isCategory: function() {
        return !!this.option.categories;
      },
      /**
       * @public
       * @abstract
       */
      setSelected: noop,
      /**
       * @public
       * @abstract
       * @param {*|module:echarts/data/List} valueOrData
       * @param {number} dataIndex
       * @return {string} state See this.stateList
       */
      getValueState: noop,
      /**
       * FIXME
       * Do not publish to thirt-part-dev temporarily
       * util the interface is stable. (Should it return
       * a function but not visual meta?)
       *
       * @pubilc
       * @abstract
       * @param {Function} getColorVisual
       *        params: value, valueState
       *        return: color
       * @return {Object} visualMeta
       *        should includes {stops, outerColors}
       *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
       */
      getVisualMeta: noop
    });
    var _default = VisualMapModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousModel.js
var require_ContinuousModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousModel.js"(exports, module) {
    var zrUtil = require_util();
    var VisualMapModel = require_VisualMapModel();
    var numberUtil = require_number();
    var DEFAULT_BAR_BOUND = [20, 140];
    var ContinuousModel = VisualMapModel.extend({
      type: "visualMap.continuous",
      /**
       * @protected
       */
      defaultOption: {
        align: "auto",
        // 'auto', 'left', 'right', 'top', 'bottom'
        calculable: false,
        // This prop effect default component type determine,
        // See echarts/component/visualMap/typeDefaulter.
        range: null,
        // selected range. In default case `range` is [min, max]
        // and can auto change along with modification of min max,
        // util use specifid a range.
        realtime: true,
        // Whether realtime update.
        itemHeight: null,
        // The length of the range control edge.
        itemWidth: null,
        // The length of the other side.
        hoverLink: true,
        // Enable hover highlight.
        hoverLinkDataSize: null,
        // The size of hovered data.
        hoverLinkOnHandle: null
        // Whether trigger hoverLink when hover handle.
        // If not specified, follow the value of `realtime`.
      },
      /**
       * @override
       */
      optionUpdated: function(newOption, isInit) {
        ContinuousModel.superApply(this, "optionUpdated", arguments);
        this.resetExtent();
        this.resetVisual(function(mappingOption) {
          mappingOption.mappingMethod = "linear";
          mappingOption.dataExtent = this.getExtent();
        });
        this._resetRange();
      },
      /**
       * @protected
       * @override
       */
      resetItemSize: function() {
        ContinuousModel.superApply(this, "resetItemSize", arguments);
        var itemSize = this.itemSize;
        this._orient === "horizontal" && itemSize.reverse();
        (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
        (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
      },
      /**
       * @private
       */
      _resetRange: function() {
        var dataExtent = this.getExtent();
        var range = this.option.range;
        if (!range || range.auto) {
          dataExtent.auto = 1;
          this.option.range = dataExtent;
        } else if (zrUtil.isArray(range)) {
          if (range[0] > range[1]) {
            range.reverse();
          }
          range[0] = Math.max(range[0], dataExtent[0]);
          range[1] = Math.min(range[1], dataExtent[1]);
        }
      },
      /**
       * @protected
       * @override
       */
      completeVisualOption: function() {
        VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
        zrUtil.each(this.stateList, function(state) {
          var symbolSize = this.option.controller[state].symbolSize;
          if (symbolSize && symbolSize[0] !== symbolSize[1]) {
            symbolSize[0] = 0;
          }
        }, this);
      },
      /**
       * @override
       */
      setSelected: function(selected) {
        this.option.range = selected.slice();
        this._resetRange();
      },
      /**
       * @public
       */
      getSelected: function() {
        var dataExtent = this.getExtent();
        var dataInterval = numberUtil.asc((this.get("range") || []).slice());
        dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
        dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
        dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
        dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
        return dataInterval;
      },
      /**
       * @override
       */
      getValueState: function(value) {
        var range = this.option.range;
        var dataExtent = this.getExtent();
        return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
      },
      /**
       * @params {Array.<number>} range target value: range[0] <= value && value <= range[1]
       * @return {Array.<Object>} [{seriesId, dataIndices: <Array.<number>>}, ...]
       */
      findTargetDataIndices: function(range) {
        var result = [];
        this.eachTargetSeries(function(seriesModel) {
          var dataIndices = [];
          var data = seriesModel.getData();
          data.each(this.getDataDimension(data), function(value, dataIndex) {
            range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
          }, this);
          result.push({
            seriesId: seriesModel.id,
            dataIndex: dataIndices
          });
        }, this);
        return result;
      },
      /**
       * @implement
       */
      getVisualMeta: function(getColorVisual) {
        var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
        var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
        var stops = [];
        function setStop(value, valueState) {
          stops.push({
            value,
            color: getColorVisual(value, valueState)
          });
        }
        var iIdx = 0;
        var oIdx = 0;
        var iLen = iVals.length;
        var oLen = oVals.length;
        for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
          if (oVals[oIdx] < iVals[iIdx]) {
            setStop(oVals[oIdx], "outOfRange");
          }
        }
        for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
          first && stops.length && setStop(iVals[iIdx], "outOfRange");
          setStop(iVals[iIdx], "inRange");
        }
        for (var first = 1; oIdx < oLen; oIdx++) {
          if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
            if (first) {
              stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
              first = 0;
            }
            setStop(oVals[oIdx], "outOfRange");
          }
        }
        var stopsLen = stops.length;
        return {
          stops,
          outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
        };
      }
    });
    function getColorStopValues(visualMapModel, valueState, dataExtent) {
      if (dataExtent[0] === dataExtent[1]) {
        return dataExtent.slice();
      }
      var count = 200;
      var step = (dataExtent[1] - dataExtent[0]) / count;
      var value = dataExtent[0];
      var stopValues = [];
      for (var i = 0; i <= count && value < dataExtent[1]; i++) {
        stopValues.push(value);
        value += step;
      }
      stopValues.push(dataExtent[1]);
      return stopValues;
    }
    var _default = ContinuousModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapView.js
var require_VisualMapView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/VisualMapView.js"(exports, module) {
    var echarts = require_echarts();
    var zrUtil = require_util();
    var graphic = require_graphic();
    var formatUtil = require_format();
    var layout = require_layout();
    var VisualMapping = require_VisualMapping();
    var _default = echarts.extendComponentView({
      type: "visualMap",
      /**
       * @readOnly
       * @type {Object}
       */
      autoPositionValues: {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      },
      init: function(ecModel, api) {
        this.ecModel = ecModel;
        this.api = api;
        this.visualMapModel;
      },
      /**
       * @protected
       */
      render: function(visualMapModel, ecModel, api, payload) {
        this.visualMapModel = visualMapModel;
        if (visualMapModel.get("show") === false) {
          this.group.removeAll();
          return;
        }
        this.doRender.apply(this, arguments);
      },
      /**
       * @protected
       */
      renderBackground: function(group) {
        var visualMapModel = this.visualMapModel;
        var padding = formatUtil.normalizeCssArray(visualMapModel.get("padding") || 0);
        var rect = group.getBoundingRect();
        group.add(new graphic.Rect({
          z2: -1,
          // Lay background rect on the lowest layer.
          silent: true,
          shape: {
            x: rect.x - padding[3],
            y: rect.y - padding[0],
            width: rect.width + padding[3] + padding[1],
            height: rect.height + padding[0] + padding[2]
          },
          style: {
            fill: visualMapModel.get("backgroundColor"),
            stroke: visualMapModel.get("borderColor"),
            lineWidth: visualMapModel.get("borderWidth")
          }
        }));
      },
      /**
       * @protected
       * @param {number} targetValue can be Infinity or -Infinity
       * @param {string=} visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
       * @param {Object} [opts]
       * @param {string=} [opts.forceState] Specify state, instead of using getValueState method.
       * @param {string=} [opts.convertOpacityToAlpha=false] For color gradient in controller widget.
       * @return {*} Visual value.
       */
      getControllerVisual: function(targetValue, visualCluster, opts) {
        opts = opts || {};
        var forceState = opts.forceState;
        var visualMapModel = this.visualMapModel;
        var visualObj = {};
        if (visualCluster === "symbol") {
          visualObj.symbol = visualMapModel.get("itemSymbol");
        }
        if (visualCluster === "color") {
          var defaultColor = visualMapModel.get("contentColor");
          visualObj.color = defaultColor;
        }
        function getter(key) {
          return visualObj[key];
        }
        function setter(key, value) {
          visualObj[key] = value;
        }
        var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
        var visualTypes = VisualMapping.prepareVisualTypes(mappings);
        zrUtil.each(visualTypes, function(type) {
          var visualMapping = mappings[type];
          if (opts.convertOpacityToAlpha && type === "opacity") {
            type = "colorAlpha";
            visualMapping = mappings.__alphaForOpacity;
          }
          if (VisualMapping.dependsOn(type, visualCluster)) {
            visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
          }
        });
        return visualObj[visualCluster];
      },
      /**
       * @protected
       */
      positionGroup: function(group) {
        var model = this.visualMapModel;
        var api = this.api;
        layout.positionElement(group, model.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        });
      },
      /**
       * @protected
       * @abstract
       */
      doRender: zrUtil.noop
    });
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/helper.js
var require_helper6 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/helper.js"(exports) {
    var zrUtil = require_util();
    var _layout = require_layout();
    var getLayoutRect = _layout.getLayoutRect;
    function getItemAlign(visualMapModel, api, itemSize) {
      var modelOption = visualMapModel.option;
      var itemAlign = modelOption.align;
      if (itemAlign != null && itemAlign !== "auto") {
        return itemAlign;
      }
      var ecSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
      var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
      var reals = paramsSet[realIndex];
      var fakeValue = [0, null, 10];
      var layoutInput = {};
      for (var i = 0; i < 3; i++) {
        layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
        layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
      }
      var rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
      var rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
      return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
    }
    function makeHighDownBatch(batch, visualMapModel) {
      zrUtil.each(batch || [], function(batchItem) {
        if (batchItem.dataIndex != null) {
          batchItem.dataIndexInside = batchItem.dataIndex;
          batchItem.dataIndex = null;
        }
        batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
      });
      return batch;
    }
    exports.getItemAlign = getItemAlign;
    exports.makeHighDownBatch = makeHighDownBatch;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousView.js
var require_ContinuousView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/ContinuousView.js"(exports, module) {
    var zrUtil = require_util();
    var LinearGradient = require_LinearGradient();
    var eventTool = require_event();
    var VisualMapView = require_VisualMapView();
    var graphic = require_graphic();
    var numberUtil = require_number();
    var sliderMove = require_sliderMove();
    var helper = require_helper6();
    var modelUtil = require_model();
    var linearMap = numberUtil.linearMap;
    var each = zrUtil.each;
    var mathMin = Math.min;
    var mathMax = Math.max;
    var HOVER_LINK_SIZE = 12;
    var HOVER_LINK_OUT = 6;
    var ContinuousView = VisualMapView.extend({
      type: "visualMap.continuous",
      /**
       * @override
       */
      init: function() {
        ContinuousView.superApply(this, "init", arguments);
        this._shapes = {};
        this._dataInterval = [];
        this._handleEnds = [];
        this._orient;
        this._useHandle;
        this._hoverLinkDataIndices = [];
        this._dragging;
        this._hovering;
      },
      /**
       * @protected
       * @override
       */
      doRender: function(visualMapModel, ecModel, api, payload) {
        if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
          this._buildView();
        }
      },
      /**
       * @private
       */
      _buildView: function() {
        this.group.removeAll();
        var visualMapModel = this.visualMapModel;
        var thisGroup = this.group;
        this._orient = visualMapModel.get("orient");
        this._useHandle = visualMapModel.get("calculable");
        this._resetInterval();
        this._renderBar(thisGroup);
        var dataRangeText = visualMapModel.get("text");
        this._renderEndsText(thisGroup, dataRangeText, 0);
        this._renderEndsText(thisGroup, dataRangeText, 1);
        this._updateView(true);
        this.renderBackground(thisGroup);
        this._updateView();
        this._enableHoverLinkToSeries();
        this._enableHoverLinkFromSeries();
        this.positionGroup(thisGroup);
      },
      /**
       * @private
       */
      _renderEndsText: function(group, dataRangeText, endsIndex) {
        if (!dataRangeText) {
          return;
        }
        var text = dataRangeText[1 - endsIndex];
        text = text != null ? text + "" : "";
        var visualMapModel = this.visualMapModel;
        var textGap = visualMapModel.get("textGap");
        var itemSize = visualMapModel.itemSize;
        var barGroup = this._shapes.barGroup;
        var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
        var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
        var orient = this._orient;
        var textStyleModel = this.visualMapModel.textStyleModel;
        this.group.add(new graphic.Text({
          style: {
            x: position[0],
            y: position[1],
            textVerticalAlign: orient === "horizontal" ? "middle" : align,
            textAlign: orient === "horizontal" ? align : "center",
            text,
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        }));
      },
      /**
       * @private
       */
      _renderBar: function(targetGroup) {
        var visualMapModel = this.visualMapModel;
        var shapes = this._shapes;
        var itemSize = visualMapModel.itemSize;
        var orient = this._orient;
        var useHandle = this._useHandle;
        var itemAlign = helper.getItemAlign(visualMapModel, this.api, itemSize);
        var barGroup = shapes.barGroup = this._createBarGroup(itemAlign);
        barGroup.add(shapes.outOfRange = createPolygon());
        barGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, zrUtil.bind(this._dragHandle, this, "all", false), zrUtil.bind(this._dragHandle, this, "all", true)));
        var textRect = visualMapModel.textStyleModel.getTextRect("国");
        var textSize = mathMax(textRect.width, textRect.height);
        if (useHandle) {
          shapes.handleThumbs = [];
          shapes.handleLabels = [];
          shapes.handleLabelPoints = [];
          this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign);
          this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign);
        }
        this._createIndicator(barGroup, itemSize, textSize, orient);
        targetGroup.add(barGroup);
      },
      /**
       * @private
       */
      _createHandle: function(barGroup, handleIndex, itemSize, textSize, orient) {
        var onDrift = zrUtil.bind(this._dragHandle, this, handleIndex, false);
        var onDragEnd = zrUtil.bind(this._dragHandle, this, handleIndex, true);
        var handleThumb = createPolygon(createHandlePoints(handleIndex, textSize), getCursor(this._orient), onDrift, onDragEnd);
        handleThumb.position[0] = itemSize[0];
        barGroup.add(handleThumb);
        var textStyleModel = this.visualMapModel.textStyleModel;
        var handleLabel = new graphic.Text({
          draggable: true,
          drift: onDrift,
          onmousemove: function(e) {
            eventTool.stop(e.event);
          },
          ondragend: onDragEnd,
          style: {
            x: 0,
            y: 0,
            text: "",
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        });
        this.group.add(handleLabel);
        var handleLabelPoint = [orient === "horizontal" ? textSize / 2 : textSize * 1.5, orient === "horizontal" ? handleIndex === 0 ? -(textSize * 1.5) : textSize * 1.5 : handleIndex === 0 ? -textSize / 2 : textSize / 2];
        var shapes = this._shapes;
        shapes.handleThumbs[handleIndex] = handleThumb;
        shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
        shapes.handleLabels[handleIndex] = handleLabel;
      },
      /**
       * @private
       */
      _createIndicator: function(barGroup, itemSize, textSize, orient) {
        var indicator = createPolygon([[0, 0]], "move");
        indicator.position[0] = itemSize[0];
        indicator.attr({
          invisible: true,
          silent: true
        });
        barGroup.add(indicator);
        var textStyleModel = this.visualMapModel.textStyleModel;
        var indicatorLabel = new graphic.Text({
          silent: true,
          invisible: true,
          style: {
            x: 0,
            y: 0,
            text: "",
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        });
        this.group.add(indicatorLabel);
        var indicatorLabelPoint = [orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT + 3, 0];
        var shapes = this._shapes;
        shapes.indicator = indicator;
        shapes.indicatorLabel = indicatorLabel;
        shapes.indicatorLabelPoint = indicatorLabelPoint;
      },
      /**
       * @private
       */
      _dragHandle: function(handleIndex, isEnd, dx, dy) {
        if (!this._useHandle) {
          return;
        }
        this._dragging = !isEnd;
        if (!isEnd) {
          var vertex = this._applyTransform([dx, dy], this._shapes.barGroup, true);
          this._updateInterval(handleIndex, vertex[1]);
          this._updateView();
        }
        if (isEnd === !this.visualMapModel.get("realtime")) {
          this.api.dispatchAction({
            type: "selectDataRange",
            from: this.uid,
            visualMapId: this.visualMapModel.id,
            selected: this._dataInterval.slice()
          });
        }
        if (isEnd) {
          !this._hovering && this._clearHoverLinkToSeries();
        } else if (useHoverLinkOnHandle(this.visualMapModel)) {
          this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
        }
      },
      /**
       * @private
       */
      _resetInterval: function() {
        var visualMapModel = this.visualMapModel;
        var dataInterval = this._dataInterval = visualMapModel.getSelected();
        var dataExtent = visualMapModel.getExtent();
        var sizeExtent = [0, visualMapModel.itemSize[1]];
        this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
      },
      /**
       * @private
       * @param {(number|string)} handleIndex 0 or 1 or 'all'
       * @param {number} dx
       * @param {number} dy
       */
      _updateInterval: function(handleIndex, delta) {
        delta = delta || 0;
        var visualMapModel = this.visualMapModel;
        var handleEnds = this._handleEnds;
        var sizeExtent = [0, visualMapModel.itemSize[1]];
        sliderMove(
          delta,
          handleEnds,
          sizeExtent,
          handleIndex,
          // cross is forbiden
          0
        );
        var dataExtent = visualMapModel.getExtent();
        this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
      },
      /**
       * @private
       */
      _updateView: function(forSketch) {
        var visualMapModel = this.visualMapModel;
        var dataExtent = visualMapModel.getExtent();
        var shapes = this._shapes;
        var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
        var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
        var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
        var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
        shapes.inRange.setStyle({
          fill: visualInRange.barColor,
          opacity: visualInRange.opacity
        }).setShape("points", visualInRange.barPoints);
        shapes.outOfRange.setStyle({
          fill: visualOutOfRange.barColor,
          opacity: visualOutOfRange.opacity
        }).setShape("points", visualOutOfRange.barPoints);
        this._updateHandle(inRangeHandleEnds, visualInRange);
      },
      /**
       * @private
       */
      _createBarVisual: function(dataInterval, dataExtent, handleEnds, forceState) {
        var opts = {
          forceState,
          convertOpacityToAlpha: true
        };
        var colorStops = this._makeColorGradient(dataInterval, opts);
        var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
        var barPoints = this._createBarPoints(handleEnds, symbolSizes);
        return {
          barColor: new LinearGradient(0, 0, 0, 1, colorStops),
          barPoints,
          handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
        };
      },
      /**
       * @private
       */
      _makeColorGradient: function(dataInterval, opts) {
        var sampleNumber = 100;
        var colorStops = [];
        var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
        colorStops.push({
          color: this.getControllerVisual(dataInterval[0], "color", opts),
          offset: 0
        });
        for (var i = 1; i < sampleNumber; i++) {
          var currValue = dataInterval[0] + step * i;
          if (currValue > dataInterval[1]) {
            break;
          }
          colorStops.push({
            color: this.getControllerVisual(currValue, "color", opts),
            offset: i / sampleNumber
          });
        }
        colorStops.push({
          color: this.getControllerVisual(dataInterval[1], "color", opts),
          offset: 1
        });
        return colorStops;
      },
      /**
       * @private
       */
      _createBarPoints: function(handleEnds, symbolSizes) {
        var itemSize = this.visualMapModel.itemSize;
        return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
      },
      /**
       * @private
       */
      _createBarGroup: function(itemAlign) {
        var orient = this._orient;
        var inverse = this.visualMapModel.get("inverse");
        return new graphic.Group(orient === "horizontal" && !inverse ? {
          scale: itemAlign === "bottom" ? [1, 1] : [-1, 1],
          rotation: Math.PI / 2
        } : orient === "horizontal" && inverse ? {
          scale: itemAlign === "bottom" ? [-1, 1] : [1, 1],
          rotation: -Math.PI / 2
        } : orient === "vertical" && !inverse ? {
          scale: itemAlign === "left" ? [1, -1] : [-1, -1]
        } : {
          scale: itemAlign === "left" ? [1, 1] : [-1, 1]
        });
      },
      /**
       * @private
       */
      _updateHandle: function(handleEnds, visualInRange) {
        if (!this._useHandle) {
          return;
        }
        var shapes = this._shapes;
        var visualMapModel = this.visualMapModel;
        var handleThumbs = shapes.handleThumbs;
        var handleLabels = shapes.handleLabels;
        each([0, 1], function(handleIndex) {
          var handleThumb = handleThumbs[handleIndex];
          handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
          handleThumb.position[1] = handleEnds[handleIndex];
          var textPoint = graphic.applyTransform(shapes.handleLabelPoints[handleIndex], graphic.getTransform(handleThumb, this.group));
          handleLabels[handleIndex].setStyle({
            x: textPoint[0],
            y: textPoint[1],
            text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
            textVerticalAlign: "middle",
            textAlign: this._applyTransform(this._orient === "horizontal" ? handleIndex === 0 ? "bottom" : "top" : "left", shapes.barGroup)
          });
        }, this);
      },
      /**
       * @private
       * @param {number} cursorValue
       * @param {number} textValue
       * @param {string} [rangeSymbol]
       * @param {number} [halfHoverLinkSize]
       */
      _showIndicator: function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
        var visualMapModel = this.visualMapModel;
        var dataExtent = visualMapModel.getExtent();
        var itemSize = visualMapModel.itemSize;
        var sizeExtent = [0, itemSize[1]];
        var pos = linearMap(cursorValue, dataExtent, sizeExtent, true);
        var shapes = this._shapes;
        var indicator = shapes.indicator;
        if (!indicator) {
          return;
        }
        indicator.position[1] = pos;
        indicator.attr("invisible", false);
        indicator.setShape("points", createIndicatorPoints(!!rangeSymbol, halfHoverLinkSize, pos, itemSize[1]));
        var opts = {
          convertOpacityToAlpha: true
        };
        var color = this.getControllerVisual(cursorValue, "color", opts);
        indicator.setStyle("fill", color);
        var textPoint = graphic.applyTransform(shapes.indicatorLabelPoint, graphic.getTransform(indicator, this.group));
        var indicatorLabel = shapes.indicatorLabel;
        indicatorLabel.attr("invisible", false);
        var align = this._applyTransform("left", shapes.barGroup);
        var orient = this._orient;
        indicatorLabel.setStyle({
          text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
          textVerticalAlign: orient === "horizontal" ? align : "middle",
          textAlign: orient === "horizontal" ? "center" : align,
          x: textPoint[0],
          y: textPoint[1]
        });
      },
      /**
       * @private
       */
      _enableHoverLinkToSeries: function() {
        var self2 = this;
        this._shapes.barGroup.on("mousemove", function(e) {
          self2._hovering = true;
          if (!self2._dragging) {
            var itemSize = self2.visualMapModel.itemSize;
            var pos = self2._applyTransform([e.offsetX, e.offsetY], self2._shapes.barGroup, true, true);
            pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);
            self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
          }
        }).on("mouseout", function() {
          self2._hovering = false;
          !self2._dragging && self2._clearHoverLinkToSeries();
        });
      },
      /**
       * @private
       */
      _enableHoverLinkFromSeries: function() {
        var zr = this.api.getZr();
        if (this.visualMapModel.option.hoverLink) {
          zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
          zr.on("mouseout", this._hideIndicator, this);
        } else {
          this._clearHoverLinkFromSeries();
        }
      },
      /**
       * @private
       */
      _doHoverLinkToSeries: function(cursorPos, hoverOnBar) {
        var visualMapModel = this.visualMapModel;
        var itemSize = visualMapModel.itemSize;
        if (!visualMapModel.option.hoverLink) {
          return;
        }
        var sizeExtent = [0, itemSize[1]];
        var dataExtent = visualMapModel.getExtent();
        cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);
        var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
        var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
        var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
        var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
        hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
        hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
        if (hoverOnBar) {
          if (valueRange[0] === -Infinity) {
            this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
          } else if (valueRange[1] === Infinity) {
            this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
          } else {
            this._showIndicator(cursorValue, cursorValue, "≈ ", halfHoverLinkSize);
          }
        }
        var oldBatch = this._hoverLinkDataIndices;
        var newBatch = [];
        if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
          newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
        }
        var resultBatches = modelUtil.compressBatches(oldBatch, newBatch);
        this._dispatchHighDown("downplay", helper.makeHighDownBatch(resultBatches[0], visualMapModel));
        this._dispatchHighDown("highlight", helper.makeHighDownBatch(resultBatches[1], visualMapModel));
      },
      /**
       * @private
       */
      _hoverLinkFromSeriesMouseOver: function(e) {
        var el = e.target;
        var visualMapModel = this.visualMapModel;
        if (!el || el.dataIndex == null) {
          return;
        }
        var dataModel = this.ecModel.getSeriesByIndex(el.seriesIndex);
        if (!visualMapModel.isTargetSeries(dataModel)) {
          return;
        }
        var data = dataModel.getData(el.dataType);
        var value = data.get(visualMapModel.getDataDimension(data), el.dataIndex, true);
        if (!isNaN(value)) {
          this._showIndicator(value, value);
        }
      },
      /**
       * @private
       */
      _hideIndicator: function() {
        var shapes = this._shapes;
        shapes.indicator && shapes.indicator.attr("invisible", true);
        shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
      },
      /**
       * @private
       */
      _clearHoverLinkToSeries: function() {
        this._hideIndicator();
        var indices = this._hoverLinkDataIndices;
        this._dispatchHighDown("downplay", helper.makeHighDownBatch(indices, this.visualMapModel));
        indices.length = 0;
      },
      /**
       * @private
       */
      _clearHoverLinkFromSeries: function() {
        this._hideIndicator();
        var zr = this.api.getZr();
        zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
        zr.off("mouseout", this._hideIndicator);
      },
      /**
       * @private
       */
      _applyTransform: function(vertex, element, inverse, global2) {
        var transform = graphic.getTransform(element, global2 ? null : this.group);
        return graphic[zrUtil.isArray(vertex) ? "applyTransform" : "transformDirection"](vertex, transform, inverse);
      },
      /**
       * @private
       */
      _dispatchHighDown: function(type, batch) {
        batch && batch.length && this.api.dispatchAction({
          type,
          batch
        });
      },
      /**
       * @override
       */
      dispose: function() {
        this._clearHoverLinkFromSeries();
        this._clearHoverLinkToSeries();
      },
      /**
       * @override
       */
      remove: function() {
        this._clearHoverLinkFromSeries();
        this._clearHoverLinkToSeries();
      }
    });
    function createPolygon(points, cursor, onDrift, onDragEnd) {
      return new graphic.Polygon({
        shape: {
          points
        },
        draggable: !!onDrift,
        cursor,
        drift: onDrift,
        onmousemove: function(e) {
          eventTool.stop(e.event);
        },
        ondragend: onDragEnd
      });
    }
    function createHandlePoints(handleIndex, textSize) {
      return handleIndex === 0 ? [[0, 0], [textSize, 0], [textSize, -textSize]] : [[0, 0], [textSize, 0], [textSize, textSize]];
    }
    function createIndicatorPoints(isRange, halfHoverLinkSize, pos, extentMax) {
      return isRange ? [
        // indicate range
        [0, -mathMin(halfHoverLinkSize, mathMax(pos, 0))],
        [HOVER_LINK_OUT, 0],
        [0, mathMin(halfHoverLinkSize, mathMax(extentMax - pos, 0))]
      ] : [
        // indicate single value
        [0, 0],
        [5, -5],
        [5, 5]
      ];
    }
    function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
      var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
      var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
      if (hoverLinkDataSize) {
        halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
      }
      return halfHoverLinkSize;
    }
    function useHoverLinkOnHandle(visualMapModel) {
      var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
      return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
    }
    function getCursor(orient) {
      return orient === "vertical" ? "ns-resize" : "ew-resize";
    }
    var _default = ContinuousView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualMapAction.js
var require_visualMapAction = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/visualMapAction.js"() {
    var echarts = require_echarts();
    var actionInfo = {
      type: "selectDataRange",
      event: "dataRangeSelected",
      // FIXME use updateView appears wrong
      update: "update"
    };
    echarts.registerAction(actionInfo, function(payload, ecModel) {
      ecModel.eachComponent({
        mainType: "visualMap",
        query: payload
      }, function(model) {
        model.setSelected(payload.selected);
      });
    });
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapContinuous.js
var require_visualMapContinuous = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapContinuous.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor4();
    require_typeDefaulter3();
    require_visualEncoding2();
    require_ContinuousModel();
    require_ContinuousView();
    require_visualMapAction();
    echarts.registerPreprocessor(preprocessor);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseModel.js
var require_PiecewiseModel = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseModel.js"(exports, module) {
    var _config = require_config();
    var __DEV__ = _config.__DEV__;
    var zrUtil = require_util();
    var VisualMapModel = require_VisualMapModel();
    var VisualMapping = require_VisualMapping();
    var visualDefault = require_visualDefault();
    var _number = require_number();
    var reformIntervals = _number.reformIntervals;
    var PiecewiseModel = VisualMapModel.extend({
      type: "visualMap.piecewise",
      /**
       * Order Rule:
       *
       * option.categories / option.pieces / option.text / option.selected:
       *     If !option.inverse,
       *     Order when vertical: ['top', ..., 'bottom'].
       *     Order when horizontal: ['left', ..., 'right'].
       *     If option.inverse, the meaning of
       *     the order should be reversed.
       *
       * this._pieceList:
       *     The order is always [low, ..., high].
       *
       * Mapping from location to low-high:
       *     If !option.inverse
       *     When vertical, top is high.
       *     When horizontal, right is high.
       *     If option.inverse, reverse.
       */
      /**
       * @protected
       */
      defaultOption: {
        selected: null,
        // Object. If not specified, means selected.
        // When pieces and splitNumber: {'0': true, '5': true}
        // When categories: {'cate1': false, 'cate3': true}
        // When selected === false, means all unselected.
        minOpen: false,
        // Whether include values that smaller than `min`.
        maxOpen: false,
        // Whether include values that bigger than `max`.
        align: "auto",
        // 'auto', 'left', 'right'
        itemWidth: 20,
        // When put the controller vertically, it is the length of
        // horizontal side of each item. Otherwise, vertical side.
        itemHeight: 14,
        // When put the controller vertically, it is the length of
        // vertical side of each item. Otherwise, horizontal side.
        itemSymbol: "roundRect",
        pieceList: null,
        // Each item is Object, with some of those attrs:
        // {min, max, lt, gt, lte, gte, value,
        // color, colorSaturation, colorAlpha, opacity,
        // symbol, symbolSize}, which customize the range or visual
        // coding of the certain piece. Besides, see "Order Rule".
        categories: null,
        // category names, like: ['some1', 'some2', 'some3'].
        // Attr min/max are ignored when categories set. See "Order Rule"
        splitNumber: 5,
        // If set to 5, auto split five pieces equally.
        // If set to 0 and component type not set, component type will be
        // determined as "continuous". (It is less reasonable but for ec2
        // compatibility, see echarts/component/visualMap/typeDefaulter)
        selectedMode: "multiple",
        // Can be 'multiple' or 'single'.
        itemGap: 10,
        // The gap between two items, in px.
        hoverLink: true,
        // Enable hover highlight.
        showLabel: null
        // By default, when text is used, label will hide (the logic
        // is remained for compatibility reason)
      },
      /**
       * @override
       */
      optionUpdated: function(newOption, isInit) {
        PiecewiseModel.superApply(this, "optionUpdated", arguments);
        this._pieceList = [];
        this.resetExtent();
        var mode = this._mode = this._determineMode();
        resetMethods[this._mode].call(this);
        this._resetSelected(newOption, isInit);
        var categories = this.option.categories;
        this.resetVisual(function(mappingOption, state) {
          if (mode === "categories") {
            mappingOption.mappingMethod = "category";
            mappingOption.categories = zrUtil.clone(categories);
          } else {
            mappingOption.dataExtent = this.getExtent();
            mappingOption.mappingMethod = "piecewise";
            mappingOption.pieceList = zrUtil.map(this._pieceList, function(piece) {
              var piece = zrUtil.clone(piece);
              if (state !== "inRange") {
                piece.visual = null;
              }
              return piece;
            });
          }
        });
      },
      /**
       * @protected
       * @override
       */
      completeVisualOption: function() {
        var option = this.option;
        var visualTypesInPieces = {};
        var visualTypes = VisualMapping.listVisualTypes();
        var isCategory = this.isCategory();
        zrUtil.each(option.pieces, function(piece) {
          zrUtil.each(visualTypes, function(visualType) {
            if (piece.hasOwnProperty(visualType)) {
              visualTypesInPieces[visualType] = 1;
            }
          });
        });
        zrUtil.each(visualTypesInPieces, function(v, visualType) {
          var exists = 0;
          zrUtil.each(this.stateList, function(state) {
            exists |= has(option, state, visualType) || has(option.target, state, visualType);
          }, this);
          !exists && zrUtil.each(this.stateList, function(state) {
            (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === "inRange" ? "active" : "inactive", isCategory);
          });
        }, this);
        function has(obj, state, visualType) {
          return obj && obj[state] && (zrUtil.isObject(obj[state]) ? obj[state].hasOwnProperty(visualType) : obj[state] === visualType);
        }
        VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
      },
      _resetSelected: function(newOption, isInit) {
        var thisOption = this.option;
        var pieceList = this._pieceList;
        var selected = (isInit ? thisOption : newOption).selected || {};
        thisOption.selected = selected;
        zrUtil.each(pieceList, function(piece, index) {
          var key = this.getSelectedMapKey(piece);
          if (!selected.hasOwnProperty(key)) {
            selected[key] = true;
          }
        }, this);
        if (thisOption.selectedMode === "single") {
          var hasSel = false;
          zrUtil.each(pieceList, function(piece, index) {
            var key = this.getSelectedMapKey(piece);
            if (selected[key]) {
              hasSel ? selected[key] = false : hasSel = true;
            }
          }, this);
        }
      },
      /**
       * @public
       */
      getSelectedMapKey: function(piece) {
        return this._mode === "categories" ? piece.value + "" : piece.index + "";
      },
      /**
       * @public
       */
      getPieceList: function() {
        return this._pieceList;
      },
      /**
       * @private
       * @return {string}
       */
      _determineMode: function() {
        var option = this.option;
        return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
      },
      /**
       * @public
       * @override
       */
      setSelected: function(selected) {
        this.option.selected = zrUtil.clone(selected);
      },
      /**
       * @public
       * @override
       */
      getValueState: function(value) {
        var index = VisualMapping.findPieceIndex(value, this._pieceList);
        return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange" : "outOfRange";
      },
      /**
       * @public
       * @params {number} pieceIndex piece index in visualMapModel.getPieceList()
       * @return {Array.<Object>} [{seriesId, dataIndex: <Array.<number>>}, ...]
       */
      findTargetDataIndices: function(pieceIndex) {
        var result = [];
        this.eachTargetSeries(function(seriesModel) {
          var dataIndices = [];
          var data = seriesModel.getData();
          data.each(this.getDataDimension(data), function(value, dataIndex) {
            var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);
            pIdx === pieceIndex && dataIndices.push(dataIndex);
          }, this);
          result.push({
            seriesId: seriesModel.id,
            dataIndex: dataIndices
          });
        }, this);
        return result;
      },
      /**
       * @private
       * @param {Object} piece piece.value or piece.interval is required.
       * @return {number} Can be Infinity or -Infinity
       */
      getRepresentValue: function(piece) {
        var representValue;
        if (this.isCategory()) {
          representValue = piece.value;
        } else {
          if (piece.value != null) {
            representValue = piece.value;
          } else {
            var pieceInterval = piece.interval || [];
            representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
          }
        }
        return representValue;
      },
      getVisualMeta: function(getColorVisual) {
        if (this.isCategory()) {
          return;
        }
        var stops = [];
        var outerColors = [];
        var visualMapModel = this;
        function setStop(interval, valueState) {
          var representValue = visualMapModel.getRepresentValue({
            interval
          });
          if (!valueState) {
            valueState = visualMapModel.getValueState(representValue);
          }
          var color = getColorVisual(representValue, valueState);
          if (interval[0] === -Infinity) {
            outerColors[0] = color;
          } else if (interval[1] === Infinity) {
            outerColors[1] = color;
          } else {
            stops.push({
              value: interval[0],
              color
            }, {
              value: interval[1],
              color
            });
          }
        }
        var pieceList = this._pieceList.slice();
        if (!pieceList.length) {
          pieceList.push({
            interval: [-Infinity, Infinity]
          });
        } else {
          var edge = pieceList[0].interval[0];
          edge !== -Infinity && pieceList.unshift({
            interval: [-Infinity, edge]
          });
          edge = pieceList[pieceList.length - 1].interval[1];
          edge !== Infinity && pieceList.push({
            interval: [edge, Infinity]
          });
        }
        var curr = -Infinity;
        zrUtil.each(pieceList, function(piece) {
          var interval = piece.interval;
          if (interval) {
            interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
            setStop(interval.slice());
            curr = interval[1];
          }
        }, this);
        return {
          stops,
          outerColors
        };
      }
    });
    var resetMethods = {
      splitNumber: function() {
        var thisOption = this.option;
        var pieceList = this._pieceList;
        var precision = Math.min(thisOption.precision, 20);
        var dataExtent = this.getExtent();
        var splitNumber = thisOption.splitNumber;
        splitNumber = Math.max(parseInt(splitNumber, 10), 1);
        thisOption.splitNumber = splitNumber;
        var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
        while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
          precision++;
        }
        thisOption.precision = precision;
        splitStep = +splitStep.toFixed(precision);
        if (thisOption.minOpen) {
          pieceList.push({
            interval: [-Infinity, dataExtent[0]],
            close: [0, 0]
          });
        }
        for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
          var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
          pieceList.push({
            interval: [curr, max],
            close: [1, 1]
          });
        }
        if (thisOption.maxOpen) {
          pieceList.push({
            interval: [dataExtent[1], Infinity],
            close: [0, 0]
          });
        }
        reformIntervals(pieceList);
        zrUtil.each(pieceList, function(piece, index2) {
          piece.index = index2;
          piece.text = this.formatValueText(piece.interval);
        }, this);
      },
      categories: function() {
        var thisOption = this.option;
        zrUtil.each(thisOption.categories, function(cate) {
          this._pieceList.push({
            text: this.formatValueText(cate, true),
            value: cate
          });
        }, this);
        normalizeReverse(thisOption, this._pieceList);
      },
      pieces: function() {
        var thisOption = this.option;
        var pieceList = this._pieceList;
        zrUtil.each(thisOption.pieces, function(pieceListItem, index) {
          if (!zrUtil.isObject(pieceListItem)) {
            pieceListItem = {
              value: pieceListItem
            };
          }
          var item = {
            text: "",
            index
          };
          if (pieceListItem.label != null) {
            item.text = pieceListItem.label;
          }
          if (pieceListItem.hasOwnProperty("value")) {
            var value = item.value = pieceListItem.value;
            item.interval = [value, value];
            item.close = [1, 1];
          } else {
            var interval = item.interval = [];
            var close = item.close = [0, 0];
            var closeList = [1, 0, 1];
            var infinityList = [-Infinity, Infinity];
            var useMinMax = [];
            for (var lg = 0; lg < 2; lg++) {
              var names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
              for (var i = 0; i < 3 && interval[lg] == null; i++) {
                interval[lg] = pieceListItem[names[i]];
                close[lg] = closeList[i];
                useMinMax[lg] = i === 2;
              }
              interval[lg] == null && (interval[lg] = infinityList[lg]);
            }
            useMinMax[0] && interval[1] === Infinity && (close[0] = 0);
            useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);
            if (interval[0] === interval[1] && close[0] && close[1]) {
              item.value = interval[0];
            }
          }
          item.visual = VisualMapping.retrieveVisuals(pieceListItem);
          pieceList.push(item);
        }, this);
        normalizeReverse(thisOption, pieceList);
        reformIntervals(pieceList);
        zrUtil.each(pieceList, function(piece) {
          var close = piece.close;
          var edgeSymbols = [["<", "≤"][close[1]], [">", "≥"][close[0]]];
          piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
        }, this);
      }
    };
    function normalizeReverse(thisOption, pieceList) {
      var inverse = thisOption.inverse;
      if (thisOption.orient === "vertical" ? !inverse : inverse) {
        pieceList.reverse();
      }
    }
    var _default = PiecewiseModel;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseView.js
var require_PiecewiseView = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap/PiecewiseView.js"(exports, module) {
    var zrUtil = require_util();
    var VisualMapView = require_VisualMapView();
    var graphic = require_graphic();
    var _symbol = require_symbol();
    var createSymbol = _symbol.createSymbol;
    var layout = require_layout();
    var helper = require_helper6();
    var PiecewiseVisualMapView = VisualMapView.extend({
      type: "visualMap.piecewise",
      /**
       * @protected
       * @override
       */
      doRender: function() {
        var thisGroup = this.group;
        thisGroup.removeAll();
        var visualMapModel = this.visualMapModel;
        var textGap = visualMapModel.get("textGap");
        var textStyleModel = visualMapModel.textStyleModel;
        var textFont = textStyleModel.getFont();
        var textFill = textStyleModel.getTextColor();
        var itemAlign = this._getItemAlign();
        var itemSize = visualMapModel.itemSize;
        var viewData = this._getViewData();
        var endsText = viewData.endsText;
        var showLabel = zrUtil.retrieve(visualMapModel.get("showLabel", true), !endsText);
        endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
        zrUtil.each(viewData.viewPieceList, renderItem, this);
        endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
        layout.box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
        this.renderBackground(thisGroup);
        this.positionGroup(thisGroup);
        function renderItem(item) {
          var piece = item.piece;
          var itemGroup = new graphic.Group();
          itemGroup.onclick = zrUtil.bind(this._onItemClick, this, piece);
          this._enableHoverLink(itemGroup, item.indexInModelPieceList);
          var representValue = visualMapModel.getRepresentValue(piece);
          this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
          if (showLabel) {
            var visualState = this.visualMapModel.getValueState(representValue);
            itemGroup.add(new graphic.Text({
              style: {
                x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
                y: itemSize[1] / 2,
                text: piece.text,
                textVerticalAlign: "middle",
                textAlign: itemAlign,
                textFont,
                textFill,
                opacity: visualState === "outOfRange" ? 0.5 : 1
              }
            }));
          }
          thisGroup.add(itemGroup);
        }
      },
      /**
       * @private
       */
      _enableHoverLink: function(itemGroup, pieceIndex) {
        itemGroup.on("mouseover", zrUtil.bind(onHoverLink, this, "highlight")).on("mouseout", zrUtil.bind(onHoverLink, this, "downplay"));
        function onHoverLink(method) {
          var visualMapModel = this.visualMapModel;
          visualMapModel.option.hoverLink && this.api.dispatchAction({
            type: method,
            batch: helper.makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
          });
        }
      },
      /**
       * @private
       */
      _getItemAlign: function() {
        var visualMapModel = this.visualMapModel;
        var modelOption = visualMapModel.option;
        if (modelOption.orient === "vertical") {
          return helper.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
        } else {
          var align = modelOption.align;
          if (!align || align === "auto") {
            align = "left";
          }
          return align;
        }
      },
      /**
       * @private
       */
      _renderEndsText: function(group, text, itemSize, showLabel, itemAlign) {
        if (!text) {
          return;
        }
        var itemGroup = new graphic.Group();
        var textStyleModel = this.visualMapModel.textStyleModel;
        itemGroup.add(new graphic.Text({
          style: {
            x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
            y: itemSize[1] / 2,
            textVerticalAlign: "middle",
            textAlign: showLabel ? itemAlign : "center",
            text,
            textFont: textStyleModel.getFont(),
            textFill: textStyleModel.getTextColor()
          }
        }));
        group.add(itemGroup);
      },
      /**
       * @private
       * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
       */
      _getViewData: function() {
        var visualMapModel = this.visualMapModel;
        var viewPieceList = zrUtil.map(visualMapModel.getPieceList(), function(piece, index) {
          return {
            piece,
            indexInModelPieceList: index
          };
        });
        var endsText = visualMapModel.get("text");
        var orient = visualMapModel.get("orient");
        var inverse = visualMapModel.get("inverse");
        if (orient === "horizontal" ? inverse : !inverse) {
          viewPieceList.reverse();
        } else if (endsText) {
          endsText = endsText.slice().reverse();
        }
        return {
          viewPieceList,
          endsText
        };
      },
      /**
       * @private
       */
      _createItemSymbol: function(group, representValue, shapeParam) {
        group.add(createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
      },
      /**
       * @private
       */
      _onItemClick: function(piece) {
        var visualMapModel = this.visualMapModel;
        var option = visualMapModel.option;
        var selected = zrUtil.clone(option.selected);
        var newKey = visualMapModel.getSelectedMapKey(piece);
        if (option.selectedMode === "single") {
          selected[newKey] = true;
          zrUtil.each(selected, function(o, key) {
            selected[key] = key === newKey;
          });
        } else {
          selected[newKey] = !selected[newKey];
        }
        this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected
        });
      }
    });
    var _default = PiecewiseVisualMapView;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapPiecewise.js
var require_visualMapPiecewise = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMapPiecewise.js"() {
    var echarts = require_echarts();
    var preprocessor = require_preprocessor4();
    require_typeDefaulter3();
    require_visualEncoding2();
    require_PiecewiseModel();
    require_PiecewiseView();
    require_visualMapAction();
    echarts.registerPreprocessor(preprocessor);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap.js
var require_visualMap = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/lib/component/visualMap.js"() {
    require_visualMapContinuous();
    require_visualMapPiecewise();
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/core.js
var require_core = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/core.js"(exports) {
    var env = require_env();
    var urn = "urn:schemas-microsoft-com:vml";
    var win = typeof window === "undefined" ? null : window;
    var vmlInited = false;
    var doc = win && win.document;
    function createNode(tagName) {
      return doCreateNode(tagName);
    }
    var doCreateNode;
    if (doc && !env.canvasSupported) {
      try {
        !doc.namespaces.zrvml && doc.namespaces.add("zrvml", urn);
        doCreateNode = function(tagName) {
          return doc.createElement("<zrvml:" + tagName + ' class="zrvml">');
        };
      } catch (e) {
        doCreateNode = function(tagName) {
          return doc.createElement("<" + tagName + ' xmlns="' + urn + '" class="zrvml">');
        };
      }
    }
    function initVML() {
      if (vmlInited || !doc) {
        return;
      }
      vmlInited = true;
      var styleSheets = doc.styleSheets;
      if (styleSheets.length < 31) {
        doc.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)");
      } else {
        styleSheets[0].addRule(".zrvml", "behavior:url(#default#VML)");
      }
    }
    exports.doc = doc;
    exports.createNode = createNode;
    exports.initVML = initVML;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/graphic.js
var require_graphic3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/graphic.js"() {
    var env = require_env();
    var _vector = require_vector();
    var applyTransform = _vector.applyTransform;
    var BoundingRect = require_BoundingRect();
    var colorTool = require_color();
    var textContain = require_text();
    var textHelper = require_text2();
    var RectText = require_RectText();
    var Displayable = require_Displayable();
    var ZImage = require_Image();
    var Text = require_Text();
    var Path = require_Path();
    var PathProxy = require_PathProxy();
    var Gradient = require_Gradient();
    var vmlCore = require_core();
    var CMD = PathProxy.CMD;
    var round = Math.round;
    var sqrt = Math.sqrt;
    var abs = Math.abs;
    var cos = Math.cos;
    var sin = Math.sin;
    var mathMax = Math.max;
    if (!env.canvasSupported) {
      comma = ",";
      imageTransformPrefix = "progid:DXImageTransform.Microsoft";
      Z = 21600;
      Z2 = Z / 2;
      ZLEVEL_BASE = 1e5;
      Z_BASE = 1e3;
      initRootElStyle = function(el) {
        el.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;";
        el.coordsize = Z + "," + Z;
        el.coordorigin = "0,0";
      };
      encodeHtmlAttribute = function(s) {
        return String(s).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
      };
      rgb2Str = function(r, g, b) {
        return "rgb(" + [r, g, b].join(",") + ")";
      };
      append = function(parent, child) {
        if (child && parent && child.parentNode !== parent) {
          parent.appendChild(child);
        }
      };
      remove = function(parent, child) {
        if (child && parent && child.parentNode === parent) {
          parent.removeChild(child);
        }
      };
      getZIndex = function(zlevel, z, z2) {
        return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
      };
      parsePercent = textHelper.parsePercent;
      setColorAndOpacity = function(el, color, opacity) {
        var colorArr = colorTool.parse(color);
        opacity = +opacity;
        if (isNaN(opacity)) {
          opacity = 1;
        }
        if (colorArr) {
          el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
          el.opacity = opacity * colorArr[3];
        }
      };
      getColorAndAlpha = function(color) {
        var colorArr = colorTool.parse(color);
        return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
      };
      updateFillNode = function(el, style, zrEl) {
        var fill = style.fill;
        if (fill != null) {
          if (fill instanceof Gradient) {
            var gradientType;
            var angle = 0;
            var focus = [0, 0];
            var shift = 0;
            var expansion = 1;
            var rect = zrEl.getBoundingRect();
            var rectWidth = rect.width;
            var rectHeight = rect.height;
            if (fill.type === "linear") {
              gradientType = "gradient";
              var transform = zrEl.transform;
              var p0 = [fill.x * rectWidth, fill.y * rectHeight];
              var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
              if (transform) {
                applyTransform(p0, p0, transform);
                applyTransform(p1, p1, transform);
              }
              var dx = p1[0] - p0[0];
              var dy = p1[1] - p0[1];
              angle = Math.atan2(dx, dy) * 180 / Math.PI;
              if (angle < 0) {
                angle += 360;
              }
              if (angle < 1e-6) {
                angle = 0;
              }
            } else {
              gradientType = "gradientradial";
              var p0 = [fill.x * rectWidth, fill.y * rectHeight];
              var transform = zrEl.transform;
              var scale = zrEl.scale;
              var width = rectWidth;
              var height = rectHeight;
              focus = [
                // Percent in bounding rect
                (p0[0] - rect.x) / width,
                (p0[1] - rect.y) / height
              ];
              if (transform) {
                applyTransform(p0, p0, transform);
              }
              width /= scale[0] * Z;
              height /= scale[1] * Z;
              var dimension = mathMax(width, height);
              shift = 2 * 0 / dimension;
              expansion = 2 * fill.r / dimension - shift;
            }
            var stops = fill.colorStops.slice();
            stops.sort(function(cs1, cs2) {
              return cs1.offset - cs2.offset;
            });
            var length = stops.length;
            var colorAndAlphaList = [];
            var colors = [];
            for (var i2 = 0; i2 < length; i2++) {
              var stop = stops[i2];
              var colorAndAlpha = getColorAndAlpha(stop.color);
              colors.push(stop.offset * expansion + shift + " " + colorAndAlpha[0]);
              if (i2 === 0 || i2 === length - 1) {
                colorAndAlphaList.push(colorAndAlpha);
              }
            }
            if (length >= 2) {
              var color1 = colorAndAlphaList[0][0];
              var color2 = colorAndAlphaList[1][0];
              var opacity1 = colorAndAlphaList[0][1] * style.opacity;
              var opacity2 = colorAndAlphaList[1][1] * style.opacity;
              el.type = gradientType;
              el.method = "none";
              el.focus = "100%";
              el.angle = angle;
              el.color = color1;
              el.color2 = color2;
              el.colors = colors.join(",");
              el.opacity = opacity2;
              el.opacity2 = opacity1;
            }
            if (gradientType === "radial") {
              el.focusposition = focus.join(",");
            }
          } else {
            setColorAndOpacity(el, fill, style.opacity);
          }
        }
      };
      updateStrokeNode = function(el, style) {
        if (style.lineDash) {
          el.dashstyle = style.lineDash.join(" ");
        }
        if (style.stroke != null && !(style.stroke instanceof Gradient)) {
          setColorAndOpacity(el, style.stroke, style.opacity);
        }
      };
      updateFillAndStroke = function(vmlEl, type, style, zrEl) {
        var isFill = type === "fill";
        var el = vmlEl.getElementsByTagName(type)[0];
        if (style[type] != null && style[type] !== "none" && (isFill || !isFill && style.lineWidth)) {
          vmlEl[isFill ? "filled" : "stroked"] = "true";
          if (style[type] instanceof Gradient) {
            remove(vmlEl, el);
          }
          if (!el) {
            el = vmlCore.createNode(type);
          }
          isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
          append(vmlEl, el);
        } else {
          vmlEl[isFill ? "filled" : "stroked"] = "false";
          remove(vmlEl, el);
        }
      };
      points = [[], [], []];
      pathDataToString = function(path, m) {
        var M = CMD.M;
        var C = CMD.C;
        var L = CMD.L;
        var A = CMD.A;
        var Q = CMD.Q;
        var str = [];
        var nPoint;
        var cmdStr;
        var cmd;
        var i2;
        var xi;
        var yi;
        var data = path.data;
        var dataLength = path.len();
        for (i2 = 0; i2 < dataLength; ) {
          cmd = data[i2++];
          cmdStr = "";
          nPoint = 0;
          switch (cmd) {
            case M:
              cmdStr = " m ";
              nPoint = 1;
              xi = data[i2++];
              yi = data[i2++];
              points[0][0] = xi;
              points[0][1] = yi;
              break;
            case L:
              cmdStr = " l ";
              nPoint = 1;
              xi = data[i2++];
              yi = data[i2++];
              points[0][0] = xi;
              points[0][1] = yi;
              break;
            case Q:
            case C:
              cmdStr = " c ";
              nPoint = 3;
              var x1 = data[i2++];
              var y1 = data[i2++];
              var x2 = data[i2++];
              var y2 = data[i2++];
              var x3;
              var y3;
              if (cmd === Q) {
                x3 = x2;
                y3 = y2;
                x2 = (x2 + 2 * x1) / 3;
                y2 = (y2 + 2 * y1) / 3;
                x1 = (xi + 2 * x1) / 3;
                y1 = (yi + 2 * y1) / 3;
              } else {
                x3 = data[i2++];
                y3 = data[i2++];
              }
              points[0][0] = x1;
              points[0][1] = y1;
              points[1][0] = x2;
              points[1][1] = y2;
              points[2][0] = x3;
              points[2][1] = y3;
              xi = x3;
              yi = y3;
              break;
            case A:
              var x = 0;
              var y = 0;
              var sx = 1;
              var sy = 1;
              var angle = 0;
              if (m) {
                x = m[4];
                y = m[5];
                sx = sqrt(m[0] * m[0] + m[1] * m[1]);
                sy = sqrt(m[2] * m[2] + m[3] * m[3]);
                angle = Math.atan2(-m[1] / sy, m[0] / sx);
              }
              var cx = data[i2++];
              var cy = data[i2++];
              var rx = data[i2++];
              var ry = data[i2++];
              var startAngle = data[i2++] + angle;
              var endAngle = data[i2++] + startAngle + angle;
              i2++;
              var clockwise = data[i2++];
              var x0 = cx + cos(startAngle) * rx;
              var y0 = cy + sin(startAngle) * ry;
              var x1 = cx + cos(endAngle) * rx;
              var y1 = cy + sin(endAngle) * ry;
              var type = clockwise ? " wa " : " at ";
              if (Math.abs(x0 - x1) < 1e-4) {
                if (Math.abs(endAngle - startAngle) > 0.01) {
                  if (clockwise) {
                    x0 += 270 / Z;
                  }
                } else {
                  if (Math.abs(y0 - cy) < 1e-4) {
                    if (clockwise && x0 < cx || !clockwise && x0 > cx) {
                      y1 -= 270 / Z;
                    } else {
                      y1 += 270 / Z;
                    }
                  } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
                    x1 += 270 / Z;
                  } else {
                    x1 -= 270 / Z;
                  }
                }
              }
              str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
              xi = x1;
              yi = y1;
              break;
            case CMD.R:
              var p0 = points[0];
              var p1 = points[1];
              p0[0] = data[i2++];
              p0[1] = data[i2++];
              p1[0] = p0[0] + data[i2++];
              p1[1] = p0[1] + data[i2++];
              if (m) {
                applyTransform(p0, p0, m);
                applyTransform(p1, p1, m);
              }
              p0[0] = round(p0[0] * Z - Z2);
              p1[0] = round(p1[0] * Z - Z2);
              p0[1] = round(p0[1] * Z - Z2);
              p1[1] = round(p1[1] * Z - Z2);
              str.push(
                // x0, y0
                " m ",
                p0[0],
                comma,
                p0[1],
                // x1, y0
                " l ",
                p1[0],
                comma,
                p0[1],
                // x1, y1
                " l ",
                p1[0],
                comma,
                p1[1],
                // x0, y1
                " l ",
                p0[0],
                comma,
                p1[1]
              );
              break;
            case CMD.Z:
              str.push(" x ");
          }
          if (nPoint > 0) {
            str.push(cmdStr);
            for (var k = 0; k < nPoint; k++) {
              var p = points[k];
              m && applyTransform(p, p, m);
              str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : "");
            }
          }
        }
        return str.join("");
      };
      Path.prototype.brushVML = function(vmlRoot) {
        var style = this.style;
        var vmlEl = this._vmlEl;
        if (!vmlEl) {
          vmlEl = vmlCore.createNode("shape");
          initRootElStyle(vmlEl);
          this._vmlEl = vmlEl;
        }
        updateFillAndStroke(vmlEl, "fill", style, this);
        updateFillAndStroke(vmlEl, "stroke", style, this);
        var m = this.transform;
        var needTransform = m != null;
        var strokeEl = vmlEl.getElementsByTagName("stroke")[0];
        if (strokeEl) {
          var lineWidth = style.lineWidth;
          if (needTransform && !style.strokeNoScale) {
            var det = m[0] * m[3] - m[1] * m[2];
            lineWidth *= sqrt(abs(det));
          }
          strokeEl.weight = lineWidth + "px";
        }
        var path = this.path || (this.path = new PathProxy());
        if (this.__dirtyPath) {
          path.beginPath();
          path.subPixelOptimize = false;
          this.buildPath(path, this.shape);
          path.toStatic();
          this.__dirtyPath = false;
        }
        vmlEl.path = pathDataToString(path, this.transform);
        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
        append(vmlRoot, vmlEl);
        if (style.text != null) {
          this.drawRectText(vmlRoot, this.getBoundingRect());
        } else {
          this.removeRectText(vmlRoot);
        }
      };
      Path.prototype.onRemove = function(vmlRoot) {
        remove(vmlRoot, this._vmlEl);
        this.removeRectText(vmlRoot);
      };
      Path.prototype.onAdd = function(vmlRoot) {
        append(vmlRoot, this._vmlEl);
        this.appendRectText(vmlRoot);
      };
      isImage = function(img) {
        return typeof img === "object" && img.tagName && img.tagName.toUpperCase() === "IMG";
      };
      ZImage.prototype.brushVML = function(vmlRoot) {
        var style = this.style;
        var image = style.image;
        var ow;
        var oh;
        if (isImage(image)) {
          var src = image.src;
          if (src === this._imageSrc) {
            ow = this._imageWidth;
            oh = this._imageHeight;
          } else {
            var imageRuntimeStyle = image.runtimeStyle;
            var oldRuntimeWidth = imageRuntimeStyle.width;
            var oldRuntimeHeight = imageRuntimeStyle.height;
            imageRuntimeStyle.width = "auto";
            imageRuntimeStyle.height = "auto";
            ow = image.width;
            oh = image.height;
            imageRuntimeStyle.width = oldRuntimeWidth;
            imageRuntimeStyle.height = oldRuntimeHeight;
            this._imageSrc = src;
            this._imageWidth = ow;
            this._imageHeight = oh;
          }
          image = src;
        } else {
          if (image === this._imageSrc) {
            ow = this._imageWidth;
            oh = this._imageHeight;
          }
        }
        if (!image) {
          return;
        }
        var x = style.x || 0;
        var y = style.y || 0;
        var dw = style.width;
        var dh = style.height;
        var sw = style.sWidth;
        var sh = style.sHeight;
        var sx = style.sx || 0;
        var sy = style.sy || 0;
        var hasCrop = sw && sh;
        var vmlEl = this._vmlEl;
        if (!vmlEl) {
          vmlEl = vmlCore.doc.createElement("div");
          initRootElStyle(vmlEl);
          this._vmlEl = vmlEl;
        }
        var vmlElStyle = vmlEl.style;
        var hasRotation = false;
        var m;
        var scaleX = 1;
        var scaleY = 1;
        if (this.transform) {
          m = this.transform;
          scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
          scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
          hasRotation = m[1] || m[2];
        }
        if (hasRotation) {
          var p0 = [x, y];
          var p1 = [x + dw, y];
          var p2 = [x, y + dh];
          var p3 = [x + dw, y + dh];
          applyTransform(p0, p0, m);
          applyTransform(p1, p1, m);
          applyTransform(p2, p2, m);
          applyTransform(p3, p3, m);
          var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
          var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
          var transformFilter = [];
          transformFilter.push("M11=", m[0] / scaleX, comma, "M12=", m[2] / scaleY, comma, "M21=", m[1] / scaleX, comma, "M22=", m[3] / scaleY, comma, "Dx=", round(x * scaleX + m[4]), comma, "Dy=", round(y * scaleY + m[5]));
          vmlElStyle.padding = "0 " + round(maxX) + "px " + round(maxY) + "px 0";
          vmlElStyle.filter = imageTransformPrefix + ".Matrix(" + transformFilter.join("") + ", SizingMethod=clip)";
        } else {
          if (m) {
            x = x * scaleX + m[4];
            y = y * scaleY + m[5];
          }
          vmlElStyle.filter = "";
          vmlElStyle.left = round(x) + "px";
          vmlElStyle.top = round(y) + "px";
        }
        var imageEl = this._imageEl;
        var cropEl = this._cropEl;
        if (!imageEl) {
          imageEl = vmlCore.doc.createElement("div");
          this._imageEl = imageEl;
        }
        var imageELStyle = imageEl.style;
        if (hasCrop) {
          if (!(ow && oh)) {
            var tmpImage = new Image();
            var self2 = this;
            tmpImage.onload = function() {
              tmpImage.onload = null;
              ow = tmpImage.width;
              oh = tmpImage.height;
              imageELStyle.width = round(scaleX * ow * dw / sw) + "px";
              imageELStyle.height = round(scaleY * oh * dh / sh) + "px";
              self2._imageWidth = ow;
              self2._imageHeight = oh;
              self2._imageSrc = image;
            };
            tmpImage.src = image;
          } else {
            imageELStyle.width = round(scaleX * ow * dw / sw) + "px";
            imageELStyle.height = round(scaleY * oh * dh / sh) + "px";
          }
          if (!cropEl) {
            cropEl = vmlCore.doc.createElement("div");
            cropEl.style.overflow = "hidden";
            this._cropEl = cropEl;
          }
          var cropElStyle = cropEl.style;
          cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
          cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
          cropElStyle.filter = imageTransformPrefix + ".Matrix(Dx=" + -sx * dw / sw * scaleX + ",Dy=" + -sy * dh / sh * scaleY + ")";
          if (!cropEl.parentNode) {
            vmlEl.appendChild(cropEl);
          }
          if (imageEl.parentNode !== cropEl) {
            cropEl.appendChild(imageEl);
          }
        } else {
          imageELStyle.width = round(scaleX * dw) + "px";
          imageELStyle.height = round(scaleY * dh) + "px";
          vmlEl.appendChild(imageEl);
          if (cropEl && cropEl.parentNode) {
            vmlEl.removeChild(cropEl);
            this._cropEl = null;
          }
        }
        var filterStr = "";
        var alpha = style.opacity;
        if (alpha < 1) {
          filterStr += ".Alpha(opacity=" + round(alpha * 100) + ") ";
        }
        filterStr += imageTransformPrefix + ".AlphaImageLoader(src=" + image + ", SizingMethod=scale)";
        imageELStyle.filter = filterStr;
        vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
        append(vmlRoot, vmlEl);
        if (style.text != null) {
          this.drawRectText(vmlRoot, this.getBoundingRect());
        }
      };
      ZImage.prototype.onRemove = function(vmlRoot) {
        remove(vmlRoot, this._vmlEl);
        this._vmlEl = null;
        this._cropEl = null;
        this._imageEl = null;
        this.removeRectText(vmlRoot);
      };
      ZImage.prototype.onAdd = function(vmlRoot) {
        append(vmlRoot, this._vmlEl);
        this.appendRectText(vmlRoot);
      };
      DEFAULT_STYLE_NORMAL = "normal";
      fontStyleCache = {};
      fontStyleCacheCount = 0;
      MAX_FONT_CACHE_SIZE = 100;
      fontEl = document.createElement("div");
      getFontStyle = function(fontString) {
        var fontStyle = fontStyleCache[fontString];
        if (!fontStyle) {
          if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
            fontStyleCacheCount = 0;
            fontStyleCache = {};
          }
          var style = fontEl.style;
          var fontFamily;
          try {
            style.font = fontString;
            fontFamily = style.fontFamily.split(",")[0];
          } catch (e) {
          }
          fontStyle = {
            style: style.fontStyle || DEFAULT_STYLE_NORMAL,
            variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
            weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
            size: parseFloat(style.fontSize || 12) | 0,
            family: fontFamily || "Microsoft YaHei"
          };
          fontStyleCache[fontString] = fontStyle;
          fontStyleCacheCount++;
        }
        return fontStyle;
      };
      textContain.$override("measureText", function(text, textFont) {
        var doc = vmlCore.doc;
        if (!textMeasureEl) {
          textMeasureEl = doc.createElement("div");
          textMeasureEl.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;";
          vmlCore.doc.body.appendChild(textMeasureEl);
        }
        try {
          textMeasureEl.style.font = textFont;
        } catch (ex) {
        }
        textMeasureEl.innerHTML = "";
        textMeasureEl.appendChild(doc.createTextNode(text));
        return {
          width: textMeasureEl.offsetWidth
        };
      });
      tmpRect = new BoundingRect();
      drawRectText = function(vmlRoot, rect, textRect, fromTextEl) {
        var style = this.style;
        this.__dirty && textHelper.normalizeTextStyle(style, true);
        var text = style.text;
        text != null && (text += "");
        if (!text) {
          return;
        }
        if (style.rich) {
          var contentBlock = textContain.parseRichText(text, style);
          text = [];
          for (var i2 = 0; i2 < contentBlock.lines.length; i2++) {
            var tokens = contentBlock.lines[i2].tokens;
            var textLine = [];
            for (var j = 0; j < tokens.length; j++) {
              textLine.push(tokens[j].text);
            }
            text.push(textLine.join(""));
          }
          text = text.join("\n");
        }
        var x;
        var y;
        var align = style.textAlign;
        var verticalAlign = style.textVerticalAlign;
        var fontStyle = getFontStyle(style.font);
        var font = fontStyle.style + " " + fontStyle.variant + " " + fontStyle.weight + " " + fontStyle.size + 'px "' + fontStyle.family + '"';
        textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight);
        var m = this.transform;
        if (m && !fromTextEl) {
          tmpRect.copy(rect);
          tmpRect.applyTransform(m);
          rect = tmpRect;
        }
        if (!fromTextEl) {
          var textPosition = style.textPosition;
          if (textPosition instanceof Array) {
            x = rect.x + parsePercent(textPosition[0], rect.width);
            y = rect.y + parsePercent(textPosition[1], rect.height);
            align = align || "left";
          } else {
            var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);
            x = res.x;
            y = res.y;
            align = align || res.textAlign;
            verticalAlign = verticalAlign || res.textVerticalAlign;
          }
        } else {
          x = rect.x;
          y = rect.y;
        }
        x = textContain.adjustTextX(x, textRect.width, align);
        y = textContain.adjustTextY(y, textRect.height, verticalAlign);
        y += textRect.height / 2;
        var createNode = vmlCore.createNode;
        var textVmlEl = this._textVmlEl;
        var pathEl;
        var textPathEl;
        var skewEl;
        if (!textVmlEl) {
          textVmlEl = createNode("line");
          pathEl = createNode("path");
          textPathEl = createNode("textpath");
          skewEl = createNode("skew");
          textPathEl.style["v-text-align"] = "left";
          initRootElStyle(textVmlEl);
          pathEl.textpathok = true;
          textPathEl.on = true;
          textVmlEl.from = "0 0";
          textVmlEl.to = "1000 0.05";
          append(textVmlEl, skewEl);
          append(textVmlEl, pathEl);
          append(textVmlEl, textPathEl);
          this._textVmlEl = textVmlEl;
        } else {
          skewEl = textVmlEl.firstChild;
          pathEl = skewEl.nextSibling;
          textPathEl = pathEl.nextSibling;
        }
        var coords = [x, y];
        var textVmlElStyle = textVmlEl.style;
        if (m && fromTextEl) {
          applyTransform(coords, coords, m);
          skewEl.on = true;
          skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ",0,0";
          skewEl.offset = (round(coords[0]) || 0) + "," + (round(coords[1]) || 0);
          skewEl.origin = "0 0";
          textVmlElStyle.left = "0px";
          textVmlElStyle.top = "0px";
        } else {
          skewEl.on = false;
          textVmlElStyle.left = round(x) + "px";
          textVmlElStyle.top = round(y) + "px";
        }
        textPathEl.string = encodeHtmlAttribute(text);
        try {
          textPathEl.style.font = font;
        } catch (e) {
        }
        updateFillAndStroke(textVmlEl, "fill", {
          fill: style.textFill,
          opacity: style.opacity
        }, this);
        updateFillAndStroke(textVmlEl, "stroke", {
          stroke: style.textStroke,
          opacity: style.opacity,
          lineDash: style.lineDash || null
          // style.lineDash can be `false`.
        }, this);
        textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
        append(vmlRoot, textVmlEl);
      };
      removeRectText = function(vmlRoot) {
        remove(vmlRoot, this._textVmlEl);
        this._textVmlEl = null;
      };
      appendRectText = function(vmlRoot) {
        append(vmlRoot, this._textVmlEl);
      };
      list = [RectText, Displayable, ZImage, Path, Text];
      for (i = 0; i < list.length; i++) {
        proto = list[i].prototype;
        proto.drawRectText = drawRectText;
        proto.removeRectText = removeRectText;
        proto.appendRectText = appendRectText;
      }
      Text.prototype.brushVML = function(vmlRoot) {
        var style = this.style;
        if (style.text != null) {
          this.drawRectText(vmlRoot, {
            x: style.x || 0,
            y: style.y || 0,
            width: 0,
            height: 0
          }, this.getBoundingRect(), true);
        } else {
          this.removeRectText(vmlRoot);
        }
      };
      Text.prototype.onRemove = function(vmlRoot) {
        this.removeRectText(vmlRoot);
      };
      Text.prototype.onAdd = function(vmlRoot) {
        this.appendRectText(vmlRoot);
      };
    }
    var comma;
    var imageTransformPrefix;
    var Z;
    var Z2;
    var ZLEVEL_BASE;
    var Z_BASE;
    var initRootElStyle;
    var encodeHtmlAttribute;
    var rgb2Str;
    var append;
    var remove;
    var getZIndex;
    var parsePercent;
    var setColorAndOpacity;
    var getColorAndAlpha;
    var updateFillNode;
    var updateStrokeNode;
    var updateFillAndStroke;
    var points;
    var pathDataToString;
    var isImage;
    var DEFAULT_STYLE_NORMAL;
    var fontStyleCache;
    var fontStyleCacheCount;
    var MAX_FONT_CACHE_SIZE;
    var fontEl;
    var getFontStyle;
    var textMeasureEl;
    var tmpRect;
    var drawRectText;
    var removeRectText;
    var appendRectText;
    var list;
    var proto;
    var i;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/Painter.js
var require_Painter2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/Painter.js"(exports, module) {
    var logError = require_log();
    var vmlCore = require_core();
    var _util = require_util();
    var each = _util.each;
    function parseInt10(val) {
      return parseInt(val, 10);
    }
    function VMLPainter(root, storage) {
      vmlCore.initVML();
      this.root = root;
      this.storage = storage;
      var vmlViewport = document.createElement("div");
      var vmlRoot = document.createElement("div");
      vmlViewport.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;";
      vmlRoot.style.cssText = "position:absolute;left:0;top:0;";
      root.appendChild(vmlViewport);
      this._vmlRoot = vmlRoot;
      this._vmlViewport = vmlViewport;
      this.resize();
      var oldDelFromStorage = storage.delFromStorage;
      var oldAddToStorage = storage.addToStorage;
      storage.delFromStorage = function(el) {
        oldDelFromStorage.call(storage, el);
        if (el) {
          el.onRemove && el.onRemove(vmlRoot);
        }
      };
      storage.addToStorage = function(el) {
        el.onAdd && el.onAdd(vmlRoot);
        oldAddToStorage.call(storage, el);
      };
      this._firstPaint = true;
    }
    VMLPainter.prototype = {
      constructor: VMLPainter,
      getType: function() {
        return "vml";
      },
      /**
       * @return {HTMLDivElement}
       */
      getViewportRoot: function() {
        return this._vmlViewport;
      },
      getViewportRootOffset: function() {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },
      /**
       * 刷新
       */
      refresh: function() {
        var list = this.storage.getDisplayList(true, true);
        this._paintList(list);
      },
      _paintList: function(list) {
        var vmlRoot = this._vmlRoot;
        for (var i = 0; i < list.length; i++) {
          var el = list[i];
          if (el.invisible || el.ignore) {
            if (!el.__alreadyNotVisible) {
              el.onRemove(vmlRoot);
            }
            el.__alreadyNotVisible = true;
          } else {
            if (el.__alreadyNotVisible) {
              el.onAdd(vmlRoot);
            }
            el.__alreadyNotVisible = false;
            if (el.__dirty) {
              el.beforeBrush && el.beforeBrush();
              (el.brushVML || el.brush).call(el, vmlRoot);
              el.afterBrush && el.afterBrush();
            }
          }
          el.__dirty = false;
        }
        if (this._firstPaint) {
          this._vmlViewport.appendChild(vmlRoot);
          this._firstPaint = false;
        }
      },
      resize: function(width, height) {
        var width = width == null ? this._getWidth() : width;
        var height = height == null ? this._getHeight() : height;
        if (this._width !== width || this._height !== height) {
          this._width = width;
          this._height = height;
          var vmlViewportStyle = this._vmlViewport.style;
          vmlViewportStyle.width = width + "px";
          vmlViewportStyle.height = height + "px";
        }
      },
      dispose: function() {
        this.root.innerHTML = "";
        this._vmlRoot = this._vmlViewport = this.storage = null;
      },
      getWidth: function() {
        return this._width;
      },
      getHeight: function() {
        return this._height;
      },
      clear: function() {
        if (this._vmlViewport) {
          this.root.removeChild(this._vmlViewport);
        }
      },
      _getWidth: function() {
        var root = this.root;
        var stl = root.currentStyle;
        return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
      },
      _getHeight: function() {
        var root = this.root;
        var stl = root.currentStyle;
        return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
      }
    };
    function createMethodNotSupport(method) {
      return function() {
        logError('In IE8.0 VML mode painter not support method "' + method + '"');
      };
    }
    each(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(name2) {
      VMLPainter.prototype[name2] = createMethodNotSupport(name2);
    });
    var _default = VMLPainter;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/vml.js
var require_vml = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/vml/vml.js"() {
    require_graphic3();
    var _zrender = require_zrender();
    var registerPainter = _zrender.registerPainter;
    var Painter = require_Painter2();
    registerPainter("vml", Painter);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/core.js
var require_core2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/core.js"(exports) {
    var svgURI = "http://www.w3.org/2000/svg";
    function createElement(name2) {
      return document.createElementNS(svgURI, name2);
    }
    exports.createElement = createElement;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/graphic.js
var require_graphic4 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/graphic.js"(exports) {
    var _core = require_core2();
    var createElement = _core.createElement;
    var PathProxy = require_PathProxy();
    var BoundingRect = require_BoundingRect();
    var matrix = require_matrix();
    var textContain = require_text();
    var textHelper = require_text2();
    var Text = require_Text();
    var CMD = PathProxy.CMD;
    var arrayJoin = Array.prototype.join;
    var NONE = "none";
    var mathRound = Math.round;
    var mathSin = Math.sin;
    var mathCos = Math.cos;
    var PI = Math.PI;
    var PI2 = Math.PI * 2;
    var degree = 180 / PI;
    var EPSILON = 1e-4;
    function round4(val) {
      return mathRound(val * 1e4) / 1e4;
    }
    function isAroundZero(val) {
      return val < EPSILON && val > -EPSILON;
    }
    function pathHasFill(style, isText) {
      var fill = isText ? style.textFill : style.fill;
      return fill != null && fill !== NONE;
    }
    function pathHasStroke(style, isText) {
      var stroke = isText ? style.textStroke : style.stroke;
      return stroke != null && stroke !== NONE;
    }
    function setTransform(svgEl, m) {
      if (m) {
        attr(svgEl, "transform", "matrix(" + arrayJoin.call(m, ",") + ")");
      }
    }
    function attr(el, key, val) {
      if (!val || val.type !== "linear" && val.type !== "radial") {
        el.setAttribute(key, val);
      }
    }
    function attrXLink(el, key, val) {
      el.setAttributeNS("http://www.w3.org/1999/xlink", key, val);
    }
    function bindStyle(svgEl, style, isText, el) {
      if (pathHasFill(style, isText)) {
        var fill = isText ? style.textFill : style.fill;
        fill = fill === "transparent" ? NONE : fill;
        attr(svgEl, "fill", fill);
        attr(svgEl, "fill-opacity", style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);
      } else {
        attr(svgEl, "fill", NONE);
      }
      if (pathHasStroke(style, isText)) {
        var stroke = isText ? style.textStroke : style.stroke;
        stroke = stroke === "transparent" ? NONE : stroke;
        attr(svgEl, "stroke", stroke);
        var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;
        var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;
        attr(svgEl, "stroke-width", strokeWidth / strokeScale);
        attr(svgEl, "paint-order", isText ? "stroke" : "fill");
        attr(svgEl, "stroke-opacity", style.strokeOpacity != null ? style.strokeOpacity : style.opacity);
        var lineDash = style.lineDash;
        if (lineDash) {
          attr(svgEl, "stroke-dasharray", style.lineDash.join(","));
          attr(svgEl, "stroke-dashoffset", mathRound(style.lineDashOffset || 0));
        } else {
          attr(svgEl, "stroke-dasharray", "");
        }
        style.lineCap && attr(svgEl, "stroke-linecap", style.lineCap);
        style.lineJoin && attr(svgEl, "stroke-linejoin", style.lineJoin);
        style.miterLimit && attr(svgEl, "stroke-miterlimit", style.miterLimit);
      } else {
        attr(svgEl, "stroke", NONE);
      }
    }
    function pathDataToString(path) {
      var str = [];
      var data = path.data;
      var dataLength = path.len();
      for (var i = 0; i < dataLength; ) {
        var cmd = data[i++];
        var cmdStr = "";
        var nData = 0;
        switch (cmd) {
          case CMD.M:
            cmdStr = "M";
            nData = 2;
            break;
          case CMD.L:
            cmdStr = "L";
            nData = 2;
            break;
          case CMD.Q:
            cmdStr = "Q";
            nData = 4;
            break;
          case CMD.C:
            cmdStr = "C";
            nData = 6;
            break;
          case CMD.A:
            var cx = data[i++];
            var cy = data[i++];
            var rx = data[i++];
            var ry = data[i++];
            var theta = data[i++];
            var dTheta = data[i++];
            var psi = data[i++];
            var clockwise = data[i++];
            var dThetaPositive = Math.abs(dTheta);
            var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2);
            var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;
            var large = false;
            if (isCircle) {
              large = true;
            } else if (isAroundZero(dThetaPositive)) {
              large = false;
            } else {
              large = unifiedTheta >= PI === !!clockwise;
            }
            var x0 = round4(cx + rx * mathCos(theta));
            var y0 = round4(cy + ry * mathSin(theta));
            if (isCircle) {
              if (clockwise) {
                dTheta = PI2 - 1e-4;
              } else {
                dTheta = -PI2 + 1e-4;
              }
              large = true;
              if (i === 9) {
                str.push("M", x0, y0);
              }
            }
            var x = round4(cx + rx * mathCos(theta + dTheta));
            var y = round4(cy + ry * mathSin(theta + dTheta));
            str.push("A", round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);
            break;
          case CMD.Z:
            cmdStr = "Z";
            break;
          case CMD.R:
            var x = round4(data[i++]);
            var y = round4(data[i++]);
            var w = round4(data[i++]);
            var h = round4(data[i++]);
            str.push("M", x, y, "L", x + w, y, "L", x + w, y + h, "L", x, y + h, "L", x, y);
            break;
        }
        cmdStr && str.push(cmdStr);
        for (var j = 0; j < nData; j++) {
          str.push(round4(data[i++]));
        }
      }
      return str.join(" ");
    }
    var svgPath = {};
    svgPath.brush = function(el) {
      var style = el.style;
      var svgEl = el.__svgEl;
      if (!svgEl) {
        svgEl = createElement("path");
        el.__svgEl = svgEl;
      }
      if (!el.path) {
        el.createPathProxy();
      }
      var path = el.path;
      if (el.__dirtyPath) {
        path.beginPath();
        path.subPixelOptimize = false;
        el.buildPath(path, el.shape);
        el.__dirtyPath = false;
        var pathStr = pathDataToString(path);
        if (pathStr.indexOf("NaN") < 0) {
          attr(svgEl, "d", pathStr);
        }
      }
      bindStyle(svgEl, style, false, el);
      setTransform(svgEl, el.transform);
      if (style.text != null) {
        svgTextDrawRectText(el, el.getBoundingRect());
      } else {
        removeOldTextNode(el);
      }
    };
    var svgImage = {};
    svgImage.brush = function(el) {
      var style = el.style;
      var image = style.image;
      if (image instanceof HTMLImageElement) {
        var src = image.src;
        image = src;
      }
      if (!image) {
        return;
      }
      var x = style.x || 0;
      var y = style.y || 0;
      var dw = style.width;
      var dh = style.height;
      var svgEl = el.__svgEl;
      if (!svgEl) {
        svgEl = createElement("image");
        el.__svgEl = svgEl;
      }
      if (image !== el.__imageSrc) {
        attrXLink(svgEl, "href", image);
        el.__imageSrc = image;
      }
      attr(svgEl, "width", dw);
      attr(svgEl, "height", dh);
      attr(svgEl, "x", x);
      attr(svgEl, "y", y);
      setTransform(svgEl, el.transform);
      if (style.text != null) {
        svgTextDrawRectText(el, el.getBoundingRect());
      } else {
        removeOldTextNode(el);
      }
    };
    var svgText = {};
    var _tmpTextHostRect = new BoundingRect();
    var _tmpTextBoxPos = {};
    var _tmpTextTransform = [];
    var TEXT_ALIGN_TO_ANCHRO = {
      left: "start",
      right: "end",
      center: "middle",
      middle: "middle"
    };
    var svgTextDrawRectText = function(el, hostRect) {
      var style = el.style;
      var elTransform = el.transform;
      var needTransformTextByHostEl = el instanceof Text || style.transformText;
      el.__dirty && textHelper.normalizeTextStyle(style, true);
      var text = style.text;
      text != null && (text += "");
      if (!textHelper.needDrawText(text, style)) {
        return;
      }
      text == null && (text = "");
      if (!needTransformTextByHostEl && elTransform) {
        _tmpTextHostRect.copy(hostRect);
        _tmpTextHostRect.applyTransform(elTransform);
        hostRect = _tmpTextHostRect;
      }
      var textSvgEl = el.__textSvgEl;
      if (!textSvgEl) {
        textSvgEl = createElement("text");
        el.__textSvgEl = textSvgEl;
      }
      var textSvgElStyle = textSvgEl.style;
      var font = style.font || textContain.DEFAULT_FONT;
      var computedFont = textSvgEl.__computedFont;
      if (font !== textSvgEl.__styleFont) {
        textSvgElStyle.font = textSvgEl.__styleFont = font;
        computedFont = textSvgEl.__computedFont = textSvgElStyle.font;
      }
      var textPadding = style.textPadding;
      var textLineHeight = style.textLineHeight;
      var contentBlock = el.__textCotentBlock;
      if (!contentBlock || el.__dirtyText) {
        contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);
      }
      var outerHeight = contentBlock.outerHeight;
      var lineHeight = contentBlock.lineHeight;
      textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);
      var baseX = _tmpTextBoxPos.baseX;
      var baseY = _tmpTextBoxPos.baseY;
      var textAlign = _tmpTextBoxPos.textAlign || "left";
      var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;
      setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);
      var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);
      var textX = baseX;
      var textY = boxY;
      if (textPadding) {
        textX = getTextXForPadding(baseX, textAlign, textPadding);
        textY += textPadding[0];
      }
      textY += lineHeight / 2;
      bindStyle(textSvgEl, style, true, el);
      var canCacheByTextString = contentBlock.canCacheByTextString;
      var tspanList = el.__tspanList || (el.__tspanList = []);
      var tspanOriginLen = tspanList.length;
      if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {
        if (el.__dirtyText && tspanOriginLen) {
          for (var idx = 0; idx < tspanOriginLen; ++idx) {
            updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);
          }
        }
      } else {
        el.__text = text;
        el.__canCacheByTextString = canCacheByTextString;
        var textLines = contentBlock.lines;
        var nTextLines = textLines.length;
        var idx = 0;
        for (; idx < nTextLines; idx++) {
          var tspan = tspanList[idx];
          var singleLineText = textLines[idx];
          if (!tspan) {
            tspan = tspanList[idx] = createElement("tspan");
            textSvgEl.appendChild(tspan);
            tspan.appendChild(document.createTextNode(singleLineText));
          } else if (tspan.__zrText !== singleLineText) {
            tspan.innerHTML = "";
            tspan.appendChild(document.createTextNode(singleLineText));
          }
          updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);
        }
        if (tspanOriginLen > nTextLines) {
          for (; idx < tspanOriginLen; idx++) {
            textSvgEl.removeChild(tspanList[idx]);
          }
          tspanList.length = nTextLines;
        }
      }
    };
    function setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {
      matrix.identity(_tmpTextTransform);
      if (needTransformTextByHostEl && elTransform) {
        matrix.copy(_tmpTextTransform, elTransform);
      }
      var textRotation = style.textRotation;
      if (hostRect && textRotation) {
        var origin = style.textOrigin;
        if (origin === "center") {
          baseX = hostRect.width / 2 + hostRect.x;
          baseY = hostRect.height / 2 + hostRect.y;
        } else if (origin) {
          baseX = origin[0] + hostRect.x;
          baseY = origin[1] + hostRect.y;
        }
        _tmpTextTransform[4] -= baseX;
        _tmpTextTransform[5] -= baseY;
        matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);
        _tmpTextTransform[4] += baseX;
        _tmpTextTransform[5] += baseY;
      }
      setTransform(textSvgEl, _tmpTextTransform);
    }
    function getTextXForPadding(x, textAlign, textPadding) {
      return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
    }
    function updateTextLocation(tspan, textAlign, x, y) {
      attr(tspan, "dominant-baseline", "middle");
      attr(tspan, "text-anchor", TEXT_ALIGN_TO_ANCHRO[textAlign]);
      attr(tspan, "x", x);
      attr(tspan, "y", y);
    }
    function removeOldTextNode(el) {
      if (el && el.__textSvgEl) {
        if (el.__textSvgEl.parentNode) {
          el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);
        }
        el.__textSvgEl = null;
        el.__tspanList = [];
        el.__text = null;
      }
    }
    svgText.drawRectText = svgTextDrawRectText;
    svgText.brush = function(el) {
      var style = el.style;
      if (style.text != null) {
        svgTextDrawRectText(el, false);
      } else {
        removeOldTextNode(el);
      }
    };
    exports.path = svgPath;
    exports.image = svgImage;
    exports.text = svgText;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/arrayDiff2.js
var require_arrayDiff2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/core/arrayDiff2.js"(exports, module) {
    function Diff() {
    }
    Diff.prototype = {
      diff: function(oldArr, newArr, equals) {
        if (!equals) {
          equals = function(a, b) {
            return a === b;
          };
        }
        this.equals = equals;
        var self2 = this;
        oldArr = oldArr.slice();
        newArr = newArr.slice();
        var newLen = newArr.length;
        var oldLen = oldArr.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          var indices = [];
          for (var i = 0; i < newArr.length; i++) {
            indices.push(i);
          }
          return [{
            indices,
            count: newArr.length
          }];
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath;
            var addPath = bestPath[diagonalPath - 1];
            var removePath = bestPath[diagonalPath + 1];
            var oldPos2 = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen;
            var canRemove = removePath && 0 <= oldPos2 && oldPos2 < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self2.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self2.pushComponent(basePath.components, true, void 0);
            }
            oldPos2 = self2.extractCommon(basePath, newArr, oldArr, diagonalPath);
            if (basePath.newPos + 1 >= newLen && oldPos2 + 1 >= oldLen) {
              return buildValues(self2, basePath.components, newArr, oldArr);
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        while (editLength <= maxEditLength) {
          var ret = execEditLength();
          if (ret) {
            return ret;
          }
        }
      },
      pushComponent: function(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      extractCommon: function(basePath, newArr, oldArr, diagonalPath) {
        var newLen = newArr.length;
        var oldLen = oldArr.length;
        var newPos = basePath.newPos;
        var oldPos = newPos - diagonalPath;
        var commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      tokenize: function(value) {
        return value.slice();
      },
      join: function(value) {
        return value.slice();
      }
    };
    function buildValues(diff, components, newArr, oldArr) {
      var componentPos = 0;
      var componentLen = components.length;
      var newPos = 0;
      var oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          var indices = [];
          for (var i = newPos; i < newPos + component.count; i++) {
            indices.push(i);
          }
          component.indices = indices;
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          var indices = [];
          for (var i = oldPos; i < oldPos + component.count; i++) {
            indices.push(i);
          }
          component.indices = indices;
          oldPos += component.count;
        }
      }
      return components;
    }
    function clonePath(path) {
      return {
        newPos: path.newPos,
        components: path.components.slice(0)
      };
    }
    var arrayDiff = new Diff();
    function _default(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/Definable.js
var require_Definable = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/Definable.js"(exports, module) {
    var _core = require_core2();
    var createElement = _core.createElement;
    var zrUtil = require_util();
    var Path = require_Path();
    var ZImage = require_Image();
    var ZText = require_Text();
    var _graphic = require_graphic4();
    var svgPath = _graphic.path;
    var svgImage = _graphic.image;
    var svgText = _graphic.text;
    var MARK_UNUSED = "0";
    var MARK_USED = "1";
    function Definable(zrId, svgRoot, tagNames, markLabel, domName) {
      this._zrId = zrId;
      this._svgRoot = svgRoot;
      this._tagNames = typeof tagNames === "string" ? [tagNames] : tagNames;
      this._markLabel = markLabel;
      this._domName = domName || "_dom";
      this.nextId = 0;
    }
    Definable.prototype.createElement = createElement;
    Definable.prototype.getDefs = function(isForceCreating) {
      var svgRoot = this._svgRoot;
      var defs = this._svgRoot.getElementsByTagName("defs");
      if (defs.length === 0) {
        if (isForceCreating) {
          defs = svgRoot.insertBefore(
            this.createElement("defs"),
            // Create new tag
            svgRoot.firstChild
            // Insert in the front of svg
          );
          if (!defs.contains) {
            defs.contains = function(el) {
              var children = defs.children;
              if (!children) {
                return false;
              }
              for (var i = children.length - 1; i >= 0; --i) {
                if (children[i] === el) {
                  return true;
                }
              }
              return false;
            };
          }
          return defs;
        } else {
          return null;
        }
      } else {
        return defs[0];
      }
    };
    Definable.prototype.update = function(element, onUpdate) {
      if (!element) {
        return;
      }
      var defs = this.getDefs(false);
      if (element[this._domName] && defs.contains(element[this._domName])) {
        if (typeof onUpdate === "function") {
          onUpdate(element);
        }
      } else {
        var dom = this.add(element);
        if (dom) {
          element[this._domName] = dom;
        }
      }
    };
    Definable.prototype.addDom = function(dom) {
      var defs = this.getDefs(true);
      defs.appendChild(dom);
    };
    Definable.prototype.removeDom = function(element) {
      var defs = this.getDefs(false);
      if (defs && element[this._domName]) {
        defs.removeChild(element[this._domName]);
        element[this._domName] = null;
      }
    };
    Definable.prototype.getDoms = function() {
      var defs = this.getDefs(false);
      if (!defs) {
        return [];
      }
      var doms = [];
      zrUtil.each(this._tagNames, function(tagName) {
        var tags = defs.getElementsByTagName(tagName);
        doms = doms.concat([].slice.call(tags));
      });
      return doms;
    };
    Definable.prototype.markAllUnused = function() {
      var doms = this.getDoms();
      var that = this;
      zrUtil.each(doms, function(dom) {
        dom[that._markLabel] = MARK_UNUSED;
      });
    };
    Definable.prototype.markUsed = function(dom) {
      if (dom) {
        dom[this._markLabel] = MARK_USED;
      }
    };
    Definable.prototype.removeUnused = function() {
      var defs = this.getDefs(false);
      if (!defs) {
        return;
      }
      var doms = this.getDoms();
      var that = this;
      zrUtil.each(doms, function(dom) {
        if (dom[that._markLabel] !== MARK_USED) {
          defs.removeChild(dom);
        }
      });
    };
    Definable.prototype.getSvgProxy = function(displayable) {
      if (displayable instanceof Path) {
        return svgPath;
      } else if (displayable instanceof ZImage) {
        return svgImage;
      } else if (displayable instanceof ZText) {
        return svgText;
      } else {
        return svgPath;
      }
    };
    Definable.prototype.getTextSvgElement = function(displayable) {
      return displayable.__textSvgEl;
    };
    Definable.prototype.getSvgElement = function(displayable) {
      return displayable.__svgEl;
    };
    var _default = Definable;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/GradientManager.js
var require_GradientManager = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/GradientManager.js"(exports, module) {
    var Definable = require_Definable();
    var zrUtil = require_util();
    var logError = require_log();
    var colorTool = require_color();
    function GradientManager(zrId, svgRoot) {
      Definable.call(this, zrId, svgRoot, ["linearGradient", "radialGradient"], "__gradient_in_use__");
    }
    zrUtil.inherits(GradientManager, Definable);
    GradientManager.prototype.addWithoutUpdate = function(svgElement, displayable) {
      if (displayable && displayable.style) {
        var that = this;
        zrUtil.each(["fill", "stroke"], function(fillOrStroke) {
          if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === "linear" || displayable.style[fillOrStroke].type === "radial")) {
            var gradient = displayable.style[fillOrStroke];
            var defs = that.getDefs(true);
            var dom;
            if (gradient._dom) {
              dom = gradient._dom;
              if (!defs.contains(gradient._dom)) {
                that.addDom(dom);
              }
            } else {
              dom = that.add(gradient);
            }
            that.markUsed(displayable);
            var id = dom.getAttribute("id");
            svgElement.setAttribute(fillOrStroke, "url(#" + id + ")");
          }
        });
      }
    };
    GradientManager.prototype.add = function(gradient) {
      var dom;
      if (gradient.type === "linear") {
        dom = this.createElement("linearGradient");
      } else if (gradient.type === "radial") {
        dom = this.createElement("radialGradient");
      } else {
        logError("Illegal gradient type.");
        return null;
      }
      gradient.id = gradient.id || this.nextId++;
      dom.setAttribute("id", "zr" + this._zrId + "-gradient-" + gradient.id);
      this.updateDom(gradient, dom);
      this.addDom(dom);
      return dom;
    };
    GradientManager.prototype.update = function(gradient) {
      var that = this;
      Definable.prototype.update.call(this, gradient, function() {
        var type = gradient.type;
        var tagName = gradient._dom.tagName;
        if (type === "linear" && tagName === "linearGradient" || type === "radial" && tagName === "radialGradient") {
          that.updateDom(gradient, gradient._dom);
        } else {
          that.removeDom(gradient);
          that.add(gradient);
        }
      });
    };
    GradientManager.prototype.updateDom = function(gradient, dom) {
      if (gradient.type === "linear") {
        dom.setAttribute("x1", gradient.x);
        dom.setAttribute("y1", gradient.y);
        dom.setAttribute("x2", gradient.x2);
        dom.setAttribute("y2", gradient.y2);
      } else if (gradient.type === "radial") {
        dom.setAttribute("cx", gradient.x);
        dom.setAttribute("cy", gradient.y);
        dom.setAttribute("r", gradient.r);
      } else {
        logError("Illegal gradient type.");
        return;
      }
      if (gradient.global) {
        dom.setAttribute("gradientUnits", "userSpaceOnUse");
      } else {
        dom.setAttribute("gradientUnits", "objectBoundingBox");
      }
      dom.innerHTML = "";
      var colors = gradient.colorStops;
      for (var i = 0, len = colors.length; i < len; ++i) {
        var stop = this.createElement("stop");
        stop.setAttribute("offset", colors[i].offset * 100 + "%");
        var color = colors[i].color;
        if (color.indexOf("rgba") > -1) {
          var opacity = colorTool.parse(color)[3];
          var hex = colorTool.toHex(color);
          stop.setAttribute("stop-color", "#" + hex);
          stop.setAttribute("stop-opacity", opacity);
        } else {
          stop.setAttribute("stop-color", colors[i].color);
        }
        dom.appendChild(stop);
      }
      gradient._dom = dom;
    };
    GradientManager.prototype.markUsed = function(displayable) {
      if (displayable.style) {
        var gradient = displayable.style.fill;
        if (gradient && gradient._dom) {
          Definable.prototype.markUsed.call(this, gradient._dom);
        }
        gradient = displayable.style.stroke;
        if (gradient && gradient._dom) {
          Definable.prototype.markUsed.call(this, gradient._dom);
        }
      }
    };
    var _default = GradientManager;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ClippathManager.js
var require_ClippathManager = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ClippathManager.js"(exports, module) {
    var Definable = require_Definable();
    var zrUtil = require_util();
    var matrix = require_matrix();
    function ClippathManager(zrId, svgRoot) {
      Definable.call(this, zrId, svgRoot, "clipPath", "__clippath_in_use__");
    }
    zrUtil.inherits(ClippathManager, Definable);
    ClippathManager.prototype.update = function(displayable) {
      var svgEl = this.getSvgElement(displayable);
      if (svgEl) {
        this.updateDom(svgEl, displayable.__clipPaths, false);
      }
      var textEl = this.getTextSvgElement(displayable);
      if (textEl) {
        this.updateDom(textEl, displayable.__clipPaths, true);
      }
      this.markUsed(displayable);
    };
    ClippathManager.prototype.updateDom = function(parentEl, clipPaths, isText) {
      if (clipPaths && clipPaths.length > 0) {
        var defs = this.getDefs(true);
        var clipPath = clipPaths[0];
        var clipPathEl;
        var id;
        var dom = isText ? "_textDom" : "_dom";
        if (clipPath[dom]) {
          id = clipPath[dom].getAttribute("id");
          clipPathEl = clipPath[dom];
          if (!defs.contains(clipPathEl)) {
            defs.appendChild(clipPathEl);
          }
        } else {
          id = "zr" + this._zrId + "-clip-" + this.nextId;
          ++this.nextId;
          clipPathEl = this.createElement("clipPath");
          clipPathEl.setAttribute("id", id);
          defs.appendChild(clipPathEl);
          clipPath[dom] = clipPathEl;
        }
        var svgProxy = this.getSvgProxy(clipPath);
        if (clipPath.transform && clipPath.parent.invTransform && !isText) {
          var transform = Array.prototype.slice.call(clipPath.transform);
          matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);
          svgProxy.brush(clipPath);
          clipPath.transform = transform;
        } else {
          svgProxy.brush(clipPath);
        }
        var pathEl = this.getSvgElement(clipPath);
        clipPathEl.innerHTML = "";
        clipPathEl.appendChild(pathEl.cloneNode());
        parentEl.setAttribute("clip-path", "url(#" + id + ")");
        if (clipPaths.length > 1) {
          this.updateDom(clipPathEl, clipPaths.slice(1), isText);
        }
      } else {
        if (parentEl) {
          parentEl.setAttribute("clip-path", "none");
        }
      }
    };
    ClippathManager.prototype.markUsed = function(displayable) {
      var that = this;
      if (displayable.__clipPaths) {
        zrUtil.each(displayable.__clipPaths, function(clipPath) {
          if (clipPath._dom) {
            Definable.prototype.markUsed.call(that, clipPath._dom);
          }
          if (clipPath._textDom) {
            Definable.prototype.markUsed.call(that, clipPath._textDom);
          }
        });
      }
    };
    var _default = ClippathManager;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ShadowManager.js
var require_ShadowManager = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/helper/ShadowManager.js"(exports, module) {
    var Definable = require_Definable();
    var zrUtil = require_util();
    function ShadowManager(zrId, svgRoot) {
      Definable.call(this, zrId, svgRoot, ["filter"], "__filter_in_use__", "_shadowDom");
    }
    zrUtil.inherits(ShadowManager, Definable);
    ShadowManager.prototype.addWithoutUpdate = function(svgElement, displayable) {
      if (displayable && hasShadow(displayable.style)) {
        var dom;
        if (displayable._shadowDom) {
          dom = displayable._shadowDom;
          var defs = this.getDefs(true);
          if (!defs.contains(displayable._shadowDom)) {
            this.addDom(dom);
          }
        } else {
          dom = this.add(displayable);
        }
        this.markUsed(displayable);
        var id = dom.getAttribute("id");
        svgElement.style.filter = "url(#" + id + ")";
      }
    };
    ShadowManager.prototype.add = function(displayable) {
      var dom = this.createElement("filter");
      displayable._shadowDomId = displayable._shadowDomId || this.nextId++;
      dom.setAttribute("id", "zr" + this._zrId + "-shadow-" + displayable._shadowDomId);
      this.updateDom(displayable, dom);
      this.addDom(dom);
      return dom;
    };
    ShadowManager.prototype.update = function(svgElement, displayable) {
      var style = displayable.style;
      if (hasShadow(style)) {
        var that = this;
        Definable.prototype.update.call(this, displayable, function() {
          that.updateDom(displayable, displayable._shadowDom);
        });
      } else {
        this.remove(svgElement, displayable);
      }
    };
    ShadowManager.prototype.remove = function(svgElement, displayable) {
      if (displayable._shadowDomId != null) {
        this.removeDom(svgElement);
        svgElement.style.filter = "";
      }
    };
    ShadowManager.prototype.updateDom = function(displayable, dom) {
      var domChild = dom.getElementsByTagName("feDropShadow");
      if (domChild.length === 0) {
        domChild = this.createElement("feDropShadow");
      } else {
        domChild = domChild[0];
      }
      var style = displayable.style;
      var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;
      var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1;
      var offsetX;
      var offsetY;
      var blur;
      var color;
      if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {
        offsetX = style.shadowOffsetX || 0;
        offsetY = style.shadowOffsetY || 0;
        blur = style.shadowBlur;
        color = style.shadowColor;
      } else if (style.textShadowBlur) {
        offsetX = style.textShadowOffsetX || 0;
        offsetY = style.textShadowOffsetY || 0;
        blur = style.textShadowBlur;
        color = style.textShadowColor;
      } else {
        this.removeDom(dom, style);
        return;
      }
      domChild.setAttribute("dx", offsetX / scaleX);
      domChild.setAttribute("dy", offsetY / scaleY);
      domChild.setAttribute("flood-color", color);
      var stdDx = blur / 2 / scaleX;
      var stdDy = blur / 2 / scaleY;
      var stdDeviation = stdDx + " " + stdDy;
      domChild.setAttribute("stdDeviation", stdDeviation);
      dom.setAttribute("x", "-100%");
      dom.setAttribute("y", "-100%");
      dom.setAttribute("width", Math.ceil(blur / 2 * 200) + "%");
      dom.setAttribute("height", Math.ceil(blur / 2 * 200) + "%");
      dom.appendChild(domChild);
      displayable._shadowDom = dom;
    };
    ShadowManager.prototype.markUsed = function(displayable) {
      if (displayable._shadowDom) {
        Definable.prototype.markUsed.call(this, displayable._shadowDom);
      }
    };
    function hasShadow(style) {
      return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);
    }
    var _default = ShadowManager;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/Painter.js
var require_Painter3 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/Painter.js"(exports, module) {
    var _core = require_core2();
    var createElement = _core.createElement;
    var util = require_util();
    var logError = require_log();
    var Path = require_Path();
    var ZImage = require_Image();
    var ZText = require_Text();
    var arrayDiff = require_arrayDiff2();
    var GradientManager = require_GradientManager();
    var ClippathManager = require_ClippathManager();
    var ShadowManager = require_ShadowManager();
    var _graphic = require_graphic4();
    var svgPath = _graphic.path;
    var svgImage = _graphic.image;
    var svgText = _graphic.text;
    function parseInt10(val) {
      return parseInt(val, 10);
    }
    function getSvgProxy(el) {
      if (el instanceof Path) {
        return svgPath;
      } else if (el instanceof ZImage) {
        return svgImage;
      } else if (el instanceof ZText) {
        return svgText;
      } else {
        return svgPath;
      }
    }
    function checkParentAvailable(parent, child) {
      return child && parent && child.parentNode !== parent;
    }
    function insertAfter(parent, child, prevSibling) {
      if (checkParentAvailable(parent, child) && prevSibling) {
        var nextSibling = prevSibling.nextSibling;
        nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);
      }
    }
    function prepend(parent, child) {
      if (checkParentAvailable(parent, child)) {
        var firstChild = parent.firstChild;
        firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);
      }
    }
    function remove(parent, child) {
      if (child && parent && child.parentNode === parent) {
        parent.removeChild(child);
      }
    }
    function getTextSvgElement(displayable) {
      return displayable.__textSvgEl;
    }
    function getSvgElement(displayable) {
      return displayable.__svgEl;
    }
    var SVGPainter = function(root, storage, opts, zrId) {
      this.root = root;
      this.storage = storage;
      this._opts = opts = util.extend({}, opts || {});
      var svgDom = createElement("svg");
      svgDom.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      svgDom.setAttribute("version", "1.1");
      svgDom.setAttribute("baseProfile", "full");
      svgDom.style.cssText = "user-select:none;position:absolute;left:0;top:0;";
      var bgRoot = createElement("g");
      svgDom.appendChild(bgRoot);
      var svgRoot = createElement("g");
      svgDom.appendChild(svgRoot);
      this.gradientManager = new GradientManager(zrId, svgRoot);
      this.clipPathManager = new ClippathManager(zrId, svgRoot);
      this.shadowManager = new ShadowManager(zrId, svgRoot);
      var viewport = document.createElement("div");
      viewport.style.cssText = "overflow:hidden;position:relative";
      this._svgDom = svgDom;
      this._svgRoot = svgRoot;
      this._backgroundRoot = bgRoot;
      this._viewport = viewport;
      root.appendChild(viewport);
      viewport.appendChild(svgDom);
      this.resize(opts.width, opts.height);
      this._visibleList = [];
    };
    SVGPainter.prototype = {
      constructor: SVGPainter,
      getType: function() {
        return "svg";
      },
      getViewportRoot: function() {
        return this._viewport;
      },
      getSvgDom: function() {
        return this._svgDom;
      },
      getSvgRoot: function() {
        return this._svgRoot;
      },
      getViewportRootOffset: function() {
        var viewportRoot = this.getViewportRoot();
        if (viewportRoot) {
          return {
            offsetLeft: viewportRoot.offsetLeft || 0,
            offsetTop: viewportRoot.offsetTop || 0
          };
        }
      },
      refresh: function() {
        var list = this.storage.getDisplayList(true);
        this._paintList(list);
      },
      setBackgroundColor: function(backgroundColor) {
        if (this._backgroundRoot && this._backgroundNode) {
          this._backgroundRoot.removeChild(this._backgroundNode);
        }
        var bgNode = createElement("rect");
        bgNode.setAttribute("width", this.getWidth());
        bgNode.setAttribute("height", this.getHeight());
        bgNode.setAttribute("x", 0);
        bgNode.setAttribute("y", 0);
        bgNode.setAttribute("id", 0);
        bgNode.style.fill = backgroundColor;
        this._backgroundRoot.appendChild(bgNode);
        this._backgroundNode = bgNode;
      },
      _paintList: function(list) {
        this.gradientManager.markAllUnused();
        this.clipPathManager.markAllUnused();
        this.shadowManager.markAllUnused();
        var svgRoot = this._svgRoot;
        var visibleList = this._visibleList;
        var listLen = list.length;
        var newVisibleList = [];
        var i;
        for (i = 0; i < listLen; i++) {
          var displayable = list[i];
          var svgProxy = getSvgProxy(displayable);
          var svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);
          if (!displayable.invisible) {
            if (displayable.__dirty) {
              svgProxy && svgProxy.brush(displayable);
              this.clipPathManager.update(displayable);
              if (displayable.style) {
                this.gradientManager.update(displayable.style.fill);
                this.gradientManager.update(displayable.style.stroke);
                this.shadowManager.update(svgElement, displayable);
              }
              displayable.__dirty = false;
            }
            newVisibleList.push(displayable);
          }
        }
        var diff = arrayDiff(visibleList, newVisibleList);
        var prevSvgElement;
        for (i = 0; i < diff.length; i++) {
          var item = diff[i];
          if (item.removed) {
            for (var k = 0; k < item.count; k++) {
              var displayable = visibleList[item.indices[k]];
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              remove(svgRoot, svgElement);
              remove(svgRoot, textSvgElement);
            }
          }
        }
        for (i = 0; i < diff.length; i++) {
          var item = diff[i];
          if (item.added) {
            for (var k = 0; k < item.count; k++) {
              var displayable = newVisibleList[item.indices[k]];
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);
              if (svgElement) {
                insertAfter(svgRoot, textSvgElement, svgElement);
              } else if (prevSvgElement) {
                insertAfter(svgRoot, textSvgElement, prevSvgElement);
              } else {
                prepend(svgRoot, textSvgElement);
              }
              insertAfter(svgRoot, textSvgElement, svgElement);
              prevSvgElement = textSvgElement || svgElement || prevSvgElement;
              this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.clipPathManager.markUsed(displayable);
            }
          } else if (!item.removed) {
            for (var k = 0; k < item.count; k++) {
              var displayable = newVisibleList[item.indices[k]];
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              var svgElement = getSvgElement(displayable);
              var textSvgElement = getTextSvgElement(displayable);
              this.gradientManager.markUsed(displayable);
              this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.shadowManager.markUsed(displayable);
              this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
              this.clipPathManager.markUsed(displayable);
              if (textSvgElement) {
                insertAfter(svgRoot, textSvgElement, svgElement);
              }
              prevSvgElement = svgElement || textSvgElement || prevSvgElement;
            }
          }
        }
        this.gradientManager.removeUnused();
        this.clipPathManager.removeUnused();
        this.shadowManager.removeUnused();
        this._visibleList = newVisibleList;
      },
      _getDefs: function(isForceCreating) {
        var svgRoot = this._svgDom;
        var defs = svgRoot.getElementsByTagName("defs");
        if (defs.length === 0) {
          if (isForceCreating) {
            var defs = svgRoot.insertBefore(
              createElement("defs"),
              // Create new tag
              svgRoot.firstChild
              // Insert in the front of svg
            );
            if (!defs.contains) {
              defs.contains = function(el) {
                var children = defs.children;
                if (!children) {
                  return false;
                }
                for (var i = children.length - 1; i >= 0; --i) {
                  if (children[i] === el) {
                    return true;
                  }
                }
                return false;
              };
            }
            return defs;
          } else {
            return null;
          }
        } else {
          return defs[0];
        }
      },
      resize: function(width, height) {
        var viewport = this._viewport;
        viewport.style.display = "none";
        var opts = this._opts;
        width != null && (opts.width = width);
        height != null && (opts.height = height);
        width = this._getSize(0);
        height = this._getSize(1);
        viewport.style.display = "";
        if (this._width !== width || this._height !== height) {
          this._width = width;
          this._height = height;
          var viewportStyle = viewport.style;
          viewportStyle.width = width + "px";
          viewportStyle.height = height + "px";
          var svgRoot = this._svgDom;
          svgRoot.setAttribute("width", width);
          svgRoot.setAttribute("height", height);
        }
        if (this._backgroundNode) {
          this._backgroundNode.setAttribute("width", width);
          this._backgroundNode.setAttribute("height", height);
        }
      },
      /**
       * 获取绘图区域宽度
       */
      getWidth: function() {
        return this._width;
      },
      /**
       * 获取绘图区域高度
       */
      getHeight: function() {
        return this._height;
      },
      _getSize: function(whIdx) {
        var opts = this._opts;
        var wh = ["width", "height"][whIdx];
        var cwh = ["clientWidth", "clientHeight"][whIdx];
        var plt = ["paddingLeft", "paddingTop"][whIdx];
        var prb = ["paddingRight", "paddingBottom"][whIdx];
        if (opts[wh] != null && opts[wh] !== "auto") {
          return parseFloat(opts[wh]);
        }
        var root = this.root;
        var stl = document.defaultView.getComputedStyle(root);
        return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
      },
      dispose: function() {
        this.root.innerHTML = "";
        this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;
      },
      clear: function() {
        if (this._viewport) {
          this.root.removeChild(this._viewport);
        }
      },
      toDataURL: function() {
        this.refresh();
        var html = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, ">\n\r<"));
        return "data:image/svg+xml;charset=UTF-8," + html;
      }
    };
    function createMethodNotSupport(method) {
      return function() {
        logError('In SVG mode painter not support method "' + method + '"');
      };
    }
    util.each(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "pathToImage"], function(name2) {
      SVGPainter.prototype[name2] = createMethodNotSupport(name2);
    });
    var _default = SVGPainter;
    module.exports = _default;
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/svg.js
var require_svg = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/zrender@4.3.2/node_modules/zrender/lib/svg/svg.js"() {
    require_graphic4();
    var _zrender = require_zrender();
    var registerPainter = _zrender.registerPainter;
    var Painter = require_Painter3();
    registerPainter("svg", Painter);
  }
});

// ../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/index.js
var require_echarts2 = __commonJS({
  "../../../../螺丝记账/螺丝记账/螺丝记账/node_modules/.pnpm/echarts@4.9.0/node_modules/echarts/index.js"(exports) {
    var _echarts = require_echarts();
    (function() {
      for (var key in _echarts) {
        if (_echarts == null || !_echarts.hasOwnProperty(key) || key === "default" || key === "__esModule")
          return;
        exports[key] = _echarts[key];
      }
    })();
    var _export = require_export();
    (function() {
      for (var key in _export) {
        if (_export == null || !_export.hasOwnProperty(key) || key === "default" || key === "__esModule")
          return;
        exports[key] = _export[key];
      }
    })();
    require_dataset();
    require_line2();
    require_bar();
    require_pie();
    require_scatter();
    require_radar2();
    require_map();
    require_tree();
    require_treemap();
    require_graph();
    require_gauge();
    require_funnel();
    require_parallel2();
    require_sankey();
    require_boxplot();
    require_candlestick();
    require_effectScatter();
    require_lines();
    require_heatmap();
    require_pictorialBar();
    require_themeRiver();
    require_sunburst();
    require_custom();
    require_grid();
    require_polar();
    require_geo();
    require_singleAxis();
    require_parallel();
    require_calendar();
    require_graphic2();
    require_toolbox();
    require_tooltip();
    require_axisPointer();
    require_brush();
    require_title();
    require_timeline();
    require_markPoint();
    require_markLine();
    require_markArea();
    require_legendScroll();
    require_legend();
    require_dataZoom();
    require_dataZoomInside();
    require_dataZoomSlider();
    require_visualMap();
    require_visualMapContinuous();
    require_visualMapPiecewise();
    require_vml();
    require_svg();
  }
});
export default require_echarts2();
/*! Bundled license information:

zrender/lib/zrender.js:
  (*!
  * ZRender, a high performance 2d drawing library.
  *
  * Copyright (c) 2013, Baidu Inc.
  * All rights reserved.
  *
  * LICENSE
  * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
  *)
*/
//# sourceMappingURL=echarts.js.map
