"use strict";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
const EMPTY_OBJ$1 = Object.freeze({});
const EMPTY_ARR = Object.freeze([]);
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$5 = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$6 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$4 = (val) => typeof val === "function";
const isString$6 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$8 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return (isObject$8(val) || isFunction$4(val)) && isFunction$4(val.then) && isFunction$4(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$6(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction((str) => {
  const s = str ? `on${capitalize(str)}` : ``;
  return s;
});
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns$1 = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toDisplayString = (val) => {
  return isString$6(val) ? val : val == null ? "" : isArray$6(val) || isObject$8(val) && (val.toString === objectToString || !isFunction$4(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i) => {
          entries[stringifySymbol(key, i) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$8(val) && !isArray$6(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v, i = "") => {
  var _a2;
  return isSymbol(v) ? `Symbol(${(_a2 = v.description) != null ? _a2 : i})` : v;
};
const LINEFEED = "\n";
const SLOT_DEFAULT_NAME = "d";
const ON_SHOW = "onShow";
const ON_HIDE = "onHide";
const ON_LAUNCH = "onLaunch";
const ON_ERROR = "onError";
const ON_THEME_CHANGE = "onThemeChange";
const ON_PAGE_NOT_FOUND = "onPageNotFound";
const ON_UNHANDLE_REJECTION = "onUnhandledRejection";
const ON_EXIT = "onExit";
const ON_LOAD = "onLoad";
const ON_READY = "onReady";
const ON_UNLOAD = "onUnload";
const ON_INIT = "onInit";
const ON_SAVE_EXIT_STATE = "onSaveExitState";
const ON_RESIZE = "onResize";
const ON_BACK_PRESS = "onBackPress";
const ON_PAGE_SCROLL = "onPageScroll";
const ON_TAB_ITEM_TAP = "onTabItemTap";
const ON_REACH_BOTTOM = "onReachBottom";
const ON_PULL_DOWN_REFRESH = "onPullDownRefresh";
const ON_SHARE_TIMELINE = "onShareTimeline";
const ON_ADD_TO_FAVORITES = "onAddToFavorites";
const ON_SHARE_APP_MESSAGE = "onShareAppMessage";
const ON_NAVIGATION_BAR_BUTTON_TAP = "onNavigationBarButtonTap";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED = "onNavigationBarSearchInputClicked";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED = "onNavigationBarSearchInputChanged";
const ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED = "onNavigationBarSearchInputConfirmed";
const ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED = "onNavigationBarSearchInputFocusChanged";
const customizeRE = /:/g;
function customizeEvent(str) {
  return camelize(str.replace(customizeRE, "-"));
}
function hasLeadingSlash(str) {
  return str.indexOf("/") === 0;
}
function addLeadingSlash(str) {
  return hasLeadingSlash(str) ? str : "/" + str;
}
const invokeArrayFns = (fns, arg) => {
  let ret;
  for (let i = 0; i < fns.length; i++) {
    ret = fns[i](arg);
  }
  return ret;
};
function once(fn, ctx = null) {
  let res;
  return (...args) => {
    if (fn) {
      res = fn.apply(ctx, args);
      fn = null;
    }
    return res;
  };
}
function getValueByDataPath(obj, path2) {
  if (!isString$6(path2)) {
    return;
  }
  path2 = path2.replace(/\[(\d+)\]/g, ".$1");
  const parts = path2.split(".");
  let key = parts[0];
  if (!obj) {
    obj = {};
  }
  if (parts.length === 1) {
    return obj[key];
  }
  return getValueByDataPath(obj[key], parts.slice(1).join("."));
}
function sortObject(obj) {
  let sortObj = {};
  if (isPlainObject(obj)) {
    Object.keys(obj).sort().forEach((key) => {
      const _key = key;
      sortObj[_key] = obj[_key];
    });
  }
  return !Object.keys(sortObj) ? obj : sortObj;
}
const encode = encodeURIComponent;
function stringifyQuery(obj, encodeStr = encode) {
  const res = obj ? Object.keys(obj).map((key) => {
    let val = obj[key];
    if (typeof val === void 0 || val === null) {
      val = "";
    } else if (isPlainObject(val)) {
      val = JSON.stringify(val);
    }
    return encodeStr(key) + "=" + encodeStr(val);
  }).filter((x) => x.length > 0).join("&") : null;
  return res ? `?${res}` : "";
}
const PAGE_HOOKS = [
  ON_INIT,
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_SHARE_APP_MESSAGE,
  ON_ADD_TO_FAVORITES,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
function isRootHook(name2) {
  return PAGE_HOOKS.indexOf(name2) > -1;
}
const UniLifecycleHooks = [
  ON_SHOW,
  ON_HIDE,
  ON_LAUNCH,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION,
  ON_EXIT,
  ON_INIT,
  ON_LOAD,
  ON_READY,
  ON_UNLOAD,
  ON_RESIZE,
  ON_BACK_PRESS,
  ON_PAGE_SCROLL,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_SHARE_TIMELINE,
  ON_ADD_TO_FAVORITES,
  ON_SHARE_APP_MESSAGE,
  ON_SAVE_EXIT_STATE,
  ON_NAVIGATION_BAR_BUTTON_TAP,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CLICKED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CHANGED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_CONFIRMED,
  ON_NAVIGATION_BAR_SEARCH_INPUT_FOCUS_CHANGED
];
const MINI_PROGRAM_PAGE_RUNTIME_HOOKS = /* @__PURE__ */ (() => {
  return {
    onPageScroll: 1,
    onShareAppMessage: 1 << 1,
    onShareTimeline: 1 << 2
  };
})();
function isUniLifecycleHook(name2, value, checkType = true) {
  if (checkType && !isFunction$4(value)) {
    return false;
  }
  if (UniLifecycleHooks.indexOf(name2) > -1) {
    return true;
  } else if (name2.indexOf("on") === 0) {
    return true;
  }
  return false;
}
let vueApp;
const createVueAppHooks = [];
function onCreateVueApp(hook) {
  if (vueApp) {
    return hook(vueApp);
  }
  createVueAppHooks.push(hook);
}
function invokeCreateVueAppHook(app) {
  vueApp = app;
  createVueAppHooks.forEach((hook) => hook(app));
}
const invokeCreateErrorHandler = once((app, createErrorHandler2) => {
  if (isFunction$4(app._component.onError)) {
    return createErrorHandler2(app);
  }
});
const E = function() {
};
E.prototype = {
  on: function(name2, callback, ctx) {
    var e2 = this.e || (this.e = {});
    (e2[name2] || (e2[name2] = [])).push({
      fn: callback,
      ctx
    });
    return this;
  },
  once: function(name2, callback, ctx) {
    var self2 = this;
    function listener() {
      self2.off(name2, listener);
      callback.apply(ctx, arguments);
    }
    listener._ = callback;
    return this.on(name2, listener, ctx);
  },
  emit: function(name2) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name2] || []).slice();
    var i = 0;
    var len = evtArr.length;
    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }
    return this;
  },
  off: function(name2, callback) {
    var e2 = this.e || (this.e = {});
    var evts = e2[name2];
    var liveEvents = [];
    if (evts && callback) {
      for (var i = evts.length - 1; i >= 0; i--) {
        if (evts[i].fn === callback || evts[i].fn._ === callback) {
          evts.splice(i, 1);
          break;
        }
      }
      liveEvents = evts;
    }
    liveEvents.length ? e2[name2] = liveEvents : delete e2[name2];
    return this;
  }
};
var E$1 = E;
const LOCALE_ZH_HANS = "zh-Hans";
const LOCALE_ZH_HANT = "zh-Hant";
const LOCALE_EN = "en";
const LOCALE_FR = "fr";
const LOCALE_ES = "es";
function include(str, parts) {
  return !!parts.find((part) => str.indexOf(part) !== -1);
}
function startsWith(str, parts) {
  return parts.find((part) => str.indexOf(part) === 0);
}
function normalizeLocale(locale, messages) {
  if (!locale) {
    return;
  }
  locale = locale.trim().replace(/_/g, "-");
  if (messages && messages[locale]) {
    return locale;
  }
  locale = locale.toLowerCase();
  if (locale === "chinese") {
    return LOCALE_ZH_HANS;
  }
  if (locale.indexOf("zh") === 0) {
    if (locale.indexOf("-hans") > -1) {
      return LOCALE_ZH_HANS;
    }
    if (locale.indexOf("-hant") > -1) {
      return LOCALE_ZH_HANT;
    }
    if (include(locale, ["-tw", "-hk", "-mo", "-cht"])) {
      return LOCALE_ZH_HANT;
    }
    return LOCALE_ZH_HANS;
  }
  let locales = [LOCALE_EN, LOCALE_FR, LOCALE_ES];
  if (messages && Object.keys(messages).length > 0) {
    locales = Object.keys(messages);
  }
  const lang2 = startsWith(locale, locales);
  if (lang2) {
    return lang2;
  }
}
function getBaseSystemInfo() {
  return wx.getSystemInfoSync();
}
function validateProtocolFail(name2, msg) {
  console.warn(`${name2}: ${msg}`);
}
function validateProtocol(name2, data, protocol, onFail) {
  if (!onFail) {
    onFail = validateProtocolFail;
  }
  for (const key in protocol) {
    const errMsg = validateProp$1(key, data[key], protocol[key], !hasOwn(data, key));
    if (isString$6(errMsg)) {
      onFail(name2, errMsg);
    }
  }
}
function validateProtocols(name2, args, protocol, onFail) {
  if (!protocol) {
    return;
  }
  if (!isArray$6(protocol)) {
    return validateProtocol(name2, args[0] || /* @__PURE__ */ Object.create(null), protocol, onFail);
  }
  const len = protocol.length;
  const argsLen = args.length;
  for (let i = 0; i < len; i++) {
    const opts = protocol[i];
    const data = /* @__PURE__ */ Object.create(null);
    if (argsLen > i) {
      data[opts.name] = args[i];
    }
    validateProtocol(name2, data, { [opts.name]: opts }, onFail);
  }
}
function validateProp$1(name2, value, prop, isAbsent) {
  if (!isPlainObject(prop)) {
    prop = { type: prop };
  }
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    return 'Missing required args: "' + name2 + '"';
  }
  if (value == null && !required) {
    return;
  }
  if (type != null) {
    let isValid = false;
    const types = isArray$6(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType$1(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      return getInvalidTypeMessage$1(name2, value, expectedTypes);
    }
  }
  if (validator) {
    return validator(value);
  }
}
const isSimpleType$1 = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol");
function assertType$1(value, type) {
  let valid;
  const expectedType = getType$1(type);
  if (isSimpleType$1(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$8(value);
  } else if (expectedType === "Array") {
    valid = isArray$6(value);
  } else {
    {
      valid = value instanceof type;
    }
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage$1(name2, value, expectedTypes) {
  let message = `Invalid args: type check failed for args "${name2}". Expected ${expectedTypes.map(capitalize).join(", ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue$1(value, expectedType);
  const receivedValue = styleValue$1(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable$1(expectedType) && !isBoolean$1(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable$1(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function getType$1(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : "";
}
function styleValue$1(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable$1(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean$1(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
function tryCatch(fn) {
  return function() {
    try {
      return fn.apply(fn, arguments);
    } catch (e2) {
      console.error(e2);
    }
  };
}
let invokeCallbackId = 1;
const invokeCallbacks = {};
function addInvokeCallback(id, name2, callback, keepAlive = false) {
  invokeCallbacks[id] = {
    name: name2,
    keepAlive,
    callback
  };
  return id;
}
function invokeCallback(id, res, extras) {
  if (typeof id === "number") {
    const opts = invokeCallbacks[id];
    if (opts) {
      if (!opts.keepAlive) {
        delete invokeCallbacks[id];
      }
      return opts.callback(res, extras);
    }
  }
  return res;
}
const API_SUCCESS = "success";
const API_FAIL = "fail";
const API_COMPLETE = "complete";
function getApiCallbacks(args) {
  const apiCallbacks = {};
  for (const name2 in args) {
    const fn = args[name2];
    if (isFunction$4(fn)) {
      apiCallbacks[name2] = tryCatch(fn);
      delete args[name2];
    }
  }
  return apiCallbacks;
}
function normalizeErrMsg$1(errMsg, name2) {
  if (!errMsg || errMsg.indexOf(":fail") === -1) {
    return name2 + ":ok";
  }
  return name2 + errMsg.substring(errMsg.indexOf(":fail"));
}
function createAsyncApiCallback(name2, args = {}, { beforeAll, beforeSuccess } = {}) {
  if (!isPlainObject(args)) {
    args = {};
  }
  const { success, fail, complete } = getApiCallbacks(args);
  const hasSuccess = isFunction$4(success);
  const hasFail = isFunction$4(fail);
  const hasComplete = isFunction$4(complete);
  const callbackId = invokeCallbackId++;
  addInvokeCallback(callbackId, name2, (res) => {
    res = res || {};
    res.errMsg = normalizeErrMsg$1(res.errMsg, name2);
    isFunction$4(beforeAll) && beforeAll(res);
    if (res.errMsg === name2 + ":ok") {
      isFunction$4(beforeSuccess) && beforeSuccess(res, args);
      hasSuccess && success(res);
    } else {
      hasFail && fail(res);
    }
    hasComplete && complete(res);
  });
  return callbackId;
}
const HOOK_SUCCESS = "success";
const HOOK_FAIL = "fail";
const HOOK_COMPLETE = "complete";
const globalInterceptors = {};
const scopedInterceptors = {};
function wrapperHook(hook, params) {
  return function(data) {
    return hook(data, params) || data;
  };
}
function queue$1(hooks, data, params) {
  let promise = false;
  for (let i = 0; i < hooks.length; i++) {
    const hook = hooks[i];
    if (promise) {
      promise = Promise.resolve(wrapperHook(hook, params));
    } else {
      const res = hook(data, params);
      if (isPromise(res)) {
        promise = Promise.resolve(res);
      }
      if (res === false) {
        return {
          then() {
          },
          catch() {
          }
        };
      }
    }
  }
  return promise || {
    then(callback) {
      return callback(data);
    },
    catch() {
    }
  };
}
function wrapperOptions(interceptors2, options = {}) {
  [HOOK_SUCCESS, HOOK_FAIL, HOOK_COMPLETE].forEach((name2) => {
    const hooks = interceptors2[name2];
    if (!isArray$6(hooks)) {
      return;
    }
    const oldCallback = options[name2];
    options[name2] = function callbackInterceptor(res) {
      queue$1(hooks, res, options).then((res2) => {
        return isFunction$4(oldCallback) && oldCallback(res2) || res2;
      });
    };
  });
  return options;
}
function wrapperReturnValue(method, returnValue) {
  const returnValueHooks = [];
  if (isArray$6(globalInterceptors.returnValue)) {
    returnValueHooks.push(...globalInterceptors.returnValue);
  }
  const interceptor = scopedInterceptors[method];
  if (interceptor && isArray$6(interceptor.returnValue)) {
    returnValueHooks.push(...interceptor.returnValue);
  }
  returnValueHooks.forEach((hook) => {
    returnValue = hook(returnValue) || returnValue;
  });
  return returnValue;
}
function getApiInterceptorHooks(method) {
  const interceptor = /* @__PURE__ */ Object.create(null);
  Object.keys(globalInterceptors).forEach((hook) => {
    if (hook !== "returnValue") {
      interceptor[hook] = globalInterceptors[hook].slice();
    }
  });
  const scopedInterceptor = scopedInterceptors[method];
  if (scopedInterceptor) {
    Object.keys(scopedInterceptor).forEach((hook) => {
      if (hook !== "returnValue") {
        interceptor[hook] = (interceptor[hook] || []).concat(scopedInterceptor[hook]);
      }
    });
  }
  return interceptor;
}
function invokeApi(method, api, options, params) {
  const interceptor = getApiInterceptorHooks(method);
  if (interceptor && Object.keys(interceptor).length) {
    if (isArray$6(interceptor.invoke)) {
      const res = queue$1(interceptor.invoke, options);
      return res.then((options2) => {
        return api(wrapperOptions(getApiInterceptorHooks(method), options2), ...params);
      });
    } else {
      return api(wrapperOptions(interceptor, options), ...params);
    }
  }
  return api(options, ...params);
}
function hasCallback(args) {
  if (isPlainObject(args) && [API_SUCCESS, API_FAIL, API_COMPLETE].find((cb) => isFunction$4(args[cb]))) {
    return true;
  }
  return false;
}
function handlePromise(promise) {
  return promise;
}
function promisify$1(name2, fn) {
  return (args = {}, ...rest) => {
    if (hasCallback(args)) {
      return wrapperReturnValue(name2, invokeApi(name2, fn, args, rest));
    }
    return wrapperReturnValue(name2, handlePromise(new Promise((resolve2, reject) => {
      invokeApi(name2, fn, extend$5(args, { success: resolve2, fail: reject }), rest);
    })));
  };
}
function formatApiArgs(args, options) {
  const params = args[0];
  if (!options || !isPlainObject(options.formatArgs) && isPlainObject(params)) {
    return;
  }
  const formatArgs = options.formatArgs;
  const keys = Object.keys(formatArgs);
  for (let i = 0; i < keys.length; i++) {
    const name2 = keys[i];
    const formatterOrDefaultValue = formatArgs[name2];
    if (isFunction$4(formatterOrDefaultValue)) {
      const errMsg = formatterOrDefaultValue(args[0][name2], params);
      if (isString$6(errMsg)) {
        return errMsg;
      }
    } else {
      if (!hasOwn(params, name2)) {
        params[name2] = formatterOrDefaultValue;
      }
    }
  }
}
function invokeSuccess(id, name2, res) {
  const result = {
    errMsg: name2 + ":ok"
  };
  return invokeCallback(id, extend$5(res || {}, result));
}
function invokeFail(id, name2, errMsg, errRes = {}) {
  const apiErrMsg = name2 + ":fail" + (errMsg ? " " + errMsg : "");
  delete errRes.errCode;
  return invokeCallback(id, typeof UniError !== "undefined" ? typeof errRes.errCode !== "undefined" ? new UniError(name2, errRes.errCode, apiErrMsg) : new UniError(apiErrMsg, errRes) : extend$5({ errMsg: apiErrMsg }, errRes));
}
function beforeInvokeApi(name2, args, protocol, options) {
  {
    validateProtocols(name2, args, protocol);
  }
  if (options && options.beforeInvoke) {
    const errMsg2 = options.beforeInvoke(args);
    if (isString$6(errMsg2)) {
      return errMsg2;
    }
  }
  const errMsg = formatApiArgs(args, options);
  if (errMsg) {
    return errMsg;
  }
}
function normalizeErrMsg(errMsg) {
  if (!errMsg || isString$6(errMsg)) {
    return errMsg;
  }
  if (errMsg.stack) {
    console.error(errMsg.message + LINEFEED + errMsg.stack);
    return errMsg.message;
  }
  return errMsg;
}
function wrapperTaskApi(name2, fn, protocol, options) {
  return (args) => {
    const id = createAsyncApiCallback(name2, args, options);
    const errMsg = beforeInvokeApi(name2, [args], protocol, options);
    if (errMsg) {
      return invokeFail(id, name2, errMsg);
    }
    return fn(args, {
      resolve: (res) => invokeSuccess(id, name2, res),
      reject: (errMsg2, errRes) => invokeFail(id, name2, normalizeErrMsg(errMsg2), errRes)
    });
  };
}
function wrapperSyncApi(name2, fn, protocol, options) {
  return (...args) => {
    const errMsg = beforeInvokeApi(name2, args, protocol, options);
    if (errMsg) {
      throw new Error(errMsg);
    }
    return fn.apply(null, args);
  };
}
function wrapperAsyncApi(name2, fn, protocol, options) {
  return wrapperTaskApi(name2, fn, protocol, options);
}
function defineSyncApi(name2, fn, protocol, options) {
  return wrapperSyncApi(name2, fn, protocol, options);
}
function defineAsyncApi(name2, fn, protocol, options) {
  return promisify$1(name2, wrapperAsyncApi(name2, fn, protocol, options));
}
const API_UPX2PX = "upx2px";
const Upx2pxProtocol = [
  {
    name: "upx",
    type: [Number, String],
    required: true
  }
];
const EPS = 1e-4;
const BASE_DEVICE_WIDTH = 750;
let isIOS = false;
let deviceWidth = 0;
let deviceDPR = 0;
function checkDeviceWidth() {
  const { platform: platform2, pixelRatio, windowWidth } = getBaseSystemInfo();
  deviceWidth = windowWidth;
  deviceDPR = pixelRatio;
  isIOS = platform2 === "ios";
}
const upx2px = defineSyncApi(API_UPX2PX, (number2, newDeviceWidth) => {
  if (deviceWidth === 0) {
    checkDeviceWidth();
  }
  number2 = Number(number2);
  if (number2 === 0) {
    return 0;
  }
  let width = newDeviceWidth || deviceWidth;
  let result = number2 / BASE_DEVICE_WIDTH * width;
  if (result < 0) {
    result = -result;
  }
  result = Math.floor(result + EPS);
  if (result === 0) {
    if (deviceDPR === 1 || !isIOS) {
      result = 1;
    } else {
      result = 0.5;
    }
  }
  return number2 < 0 ? -result : result;
}, Upx2pxProtocol);
const API_ADD_INTERCEPTOR = "addInterceptor";
const API_REMOVE_INTERCEPTOR = "removeInterceptor";
const AddInterceptorProtocol = [
  {
    name: "method",
    type: [String, Object],
    required: true
  }
];
const RemoveInterceptorProtocol = AddInterceptorProtocol;
function mergeInterceptorHook(interceptors2, interceptor) {
  Object.keys(interceptor).forEach((hook) => {
    if (isFunction$4(interceptor[hook])) {
      interceptors2[hook] = mergeHook(interceptors2[hook], interceptor[hook]);
    }
  });
}
function removeInterceptorHook(interceptors2, interceptor) {
  if (!interceptors2 || !interceptor) {
    return;
  }
  Object.keys(interceptor).forEach((name2) => {
    const hooks = interceptors2[name2];
    const hook = interceptor[name2];
    if (isArray$6(hooks) && isFunction$4(hook)) {
      remove(hooks, hook);
    }
  });
}
function mergeHook(parentVal, childVal) {
  const res = childVal ? parentVal ? parentVal.concat(childVal) : isArray$6(childVal) ? childVal : [childVal] : parentVal;
  return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
  const res = [];
  for (let i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res;
}
const addInterceptor = defineSyncApi(API_ADD_INTERCEPTOR, (method, interceptor) => {
  if (isString$6(method) && isPlainObject(interceptor)) {
    mergeInterceptorHook(scopedInterceptors[method] || (scopedInterceptors[method] = {}), interceptor);
  } else if (isPlainObject(method)) {
    mergeInterceptorHook(globalInterceptors, method);
  }
}, AddInterceptorProtocol);
const removeInterceptor = defineSyncApi(API_REMOVE_INTERCEPTOR, (method, interceptor) => {
  if (isString$6(method)) {
    if (isPlainObject(interceptor)) {
      removeInterceptorHook(scopedInterceptors[method], interceptor);
    } else {
      delete scopedInterceptors[method];
    }
  } else if (isPlainObject(method)) {
    removeInterceptorHook(globalInterceptors, method);
  }
}, RemoveInterceptorProtocol);
const interceptors = {};
const API_ON = "$on";
const OnProtocol = [
  {
    name: "event",
    type: String,
    required: true
  },
  {
    name: "callback",
    type: Function,
    required: true
  }
];
const API_ONCE = "$once";
const OnceProtocol = OnProtocol;
const API_OFF = "$off";
const OffProtocol = [
  {
    name: "event",
    type: [String, Array]
  },
  {
    name: "callback",
    type: Function
  }
];
const API_EMIT = "$emit";
const EmitProtocol = [
  {
    name: "event",
    type: String,
    required: true
  }
];
const emitter = new E$1();
const $on = defineSyncApi(API_ON, (name2, callback) => {
  emitter.on(name2, callback);
  return () => emitter.off(name2, callback);
}, OnProtocol);
const $once = defineSyncApi(API_ONCE, (name2, callback) => {
  emitter.once(name2, callback);
  return () => emitter.off(name2, callback);
}, OnceProtocol);
const $off = defineSyncApi(API_OFF, (name2, callback) => {
  if (!name2) {
    emitter.e = {};
    return;
  }
  if (!isArray$6(name2))
    name2 = [name2];
  name2.forEach((n) => emitter.off(n, callback));
}, OffProtocol);
const $emit = defineSyncApi(API_EMIT, (name2, ...args) => {
  emitter.emit(name2, ...args);
}, EmitProtocol);
let cid;
let cidErrMsg;
let enabled;
function normalizePushMessage(message) {
  try {
    return JSON.parse(message);
  } catch (e2) {
  }
  return message;
}
function invokePushCallback(args) {
  if (args.type === "enabled") {
    enabled = true;
  } else if (args.type === "clientId") {
    cid = args.cid;
    cidErrMsg = args.errMsg;
    invokeGetPushCidCallbacks(cid, args.errMsg);
  } else if (args.type === "pushMsg") {
    const message = {
      type: "receive",
      data: normalizePushMessage(args.message)
    };
    for (let i = 0; i < onPushMessageCallbacks.length; i++) {
      const callback = onPushMessageCallbacks[i];
      callback(message);
      if (message.stopped) {
        break;
      }
    }
  } else if (args.type === "click") {
    onPushMessageCallbacks.forEach((callback) => {
      callback({
        type: "click",
        data: normalizePushMessage(args.message)
      });
    });
  }
}
const getPushCidCallbacks = [];
function invokeGetPushCidCallbacks(cid2, errMsg) {
  getPushCidCallbacks.forEach((callback) => {
    callback(cid2, errMsg);
  });
  getPushCidCallbacks.length = 0;
}
const API_GET_PUSH_CLIENT_ID = "getPushClientId";
const getPushClientId = defineAsyncApi(API_GET_PUSH_CLIENT_ID, (_, { resolve: resolve2, reject }) => {
  Promise.resolve().then(() => {
    if (typeof enabled === "undefined") {
      enabled = false;
      cid = "";
      cidErrMsg = "uniPush is not enabled";
    }
    getPushCidCallbacks.push((cid2, errMsg) => {
      if (cid2) {
        resolve2({ cid: cid2 });
      } else {
        reject(errMsg);
      }
    });
    if (typeof cid !== "undefined") {
      invokeGetPushCidCallbacks(cid, cidErrMsg);
    }
  });
});
const onPushMessageCallbacks = [];
const onPushMessage = (fn) => {
  if (onPushMessageCallbacks.indexOf(fn) === -1) {
    onPushMessageCallbacks.push(fn);
  }
};
const offPushMessage = (fn) => {
  if (!fn) {
    onPushMessageCallbacks.length = 0;
  } else {
    const index2 = onPushMessageCallbacks.indexOf(fn);
    if (index2 > -1) {
      onPushMessageCallbacks.splice(index2, 1);
    }
  }
};
const SYNC_API_RE = /^\$|getLocale|setLocale|sendNativeEvent|restoreGlobal|requireGlobal|getCurrentSubNVue|getMenuButtonBoundingClientRect|^report|interceptors|Interceptor$|getSubNVueById|requireNativePlugin|upx2px|hideKeyboard|canIUse|^create|Sync$|Manager$|base64ToArrayBuffer|arrayBufferToBase64|getDeviceInfo|getAppBaseInfo|getWindowInfo|getSystemSetting|getAppAuthorizeSetting/;
const CONTEXT_API_RE = /^create|Manager$/;
const CONTEXT_API_RE_EXC = ["createBLEConnection"];
const ASYNC_API = ["createBLEConnection"];
const CALLBACK_API_RE = /^on|^off/;
function isContextApi(name2) {
  return CONTEXT_API_RE.test(name2) && CONTEXT_API_RE_EXC.indexOf(name2) === -1;
}
function isSyncApi(name2) {
  return SYNC_API_RE.test(name2) && ASYNC_API.indexOf(name2) === -1;
}
function isCallbackApi(name2) {
  return CALLBACK_API_RE.test(name2) && name2 !== "onPush";
}
function shouldPromise(name2) {
  if (isContextApi(name2) || isSyncApi(name2) || isCallbackApi(name2)) {
    return false;
  }
  return true;
}
if (!Promise.prototype.finally) {
  Promise.prototype.finally = function(onfinally) {
    const promise = this.constructor;
    return this.then((value) => promise.resolve(onfinally && onfinally()).then(() => value), (reason) => promise.resolve(onfinally && onfinally()).then(() => {
      throw reason;
    }));
  };
}
function promisify(name2, api) {
  if (!shouldPromise(name2)) {
    return api;
  }
  if (!isFunction$4(api)) {
    return api;
  }
  return function promiseApi(options = {}, ...rest) {
    if (isFunction$4(options.success) || isFunction$4(options.fail) || isFunction$4(options.complete)) {
      return wrapperReturnValue(name2, invokeApi(name2, api, options, rest));
    }
    return wrapperReturnValue(name2, handlePromise(new Promise((resolve2, reject) => {
      invokeApi(name2, api, extend$5({}, options, {
        success: resolve2,
        fail: reject
      }), rest);
    })));
  };
}
const CALLBACKS = ["success", "fail", "cancel", "complete"];
function initWrapper(protocols2) {
  function processCallback(methodName, method, returnValue) {
    return function(res) {
      return method(processReturnValue(methodName, res, returnValue));
    };
  }
  function processArgs(methodName, fromArgs, argsOption = {}, returnValue = {}, keepFromArgs = false) {
    if (isPlainObject(fromArgs)) {
      const toArgs = keepFromArgs === true ? fromArgs : {};
      if (isFunction$4(argsOption)) {
        argsOption = argsOption(fromArgs, toArgs) || {};
      }
      for (const key in fromArgs) {
        if (hasOwn(argsOption, key)) {
          let keyOption = argsOption[key];
          if (isFunction$4(keyOption)) {
            keyOption = keyOption(fromArgs[key], fromArgs, toArgs);
          }
          if (!keyOption) {
            console.warn(`微信小程序 ${methodName} 暂不支持 ${key}`);
          } else if (isString$6(keyOption)) {
            toArgs[keyOption] = fromArgs[key];
          } else if (isPlainObject(keyOption)) {
            toArgs[keyOption.name ? keyOption.name : key] = keyOption.value;
          }
        } else if (CALLBACKS.indexOf(key) !== -1) {
          const callback = fromArgs[key];
          if (isFunction$4(callback)) {
            toArgs[key] = processCallback(methodName, callback, returnValue);
          }
        } else {
          if (!keepFromArgs && !hasOwn(toArgs, key)) {
            toArgs[key] = fromArgs[key];
          }
        }
      }
      return toArgs;
    } else if (isFunction$4(fromArgs)) {
      fromArgs = processCallback(methodName, fromArgs, returnValue);
    }
    return fromArgs;
  }
  function processReturnValue(methodName, res, returnValue, keepReturnValue = false) {
    if (isFunction$4(protocols2.returnValue)) {
      res = protocols2.returnValue(methodName, res);
    }
    return processArgs(methodName, res, returnValue, {}, keepReturnValue);
  }
  return function wrapper(methodName, method) {
    if (!hasOwn(protocols2, methodName)) {
      return method;
    }
    const protocol = protocols2[methodName];
    if (!protocol) {
      return function() {
        console.error(`微信小程序 暂不支持${methodName}`);
      };
    }
    return function(arg1, arg2) {
      let options = protocol;
      if (isFunction$4(protocol)) {
        options = protocol(arg1);
      }
      arg1 = processArgs(methodName, arg1, options.args, options.returnValue);
      const args = [arg1];
      if (typeof arg2 !== "undefined") {
        args.push(arg2);
      }
      const returnValue = wx[options.name || methodName].apply(wx, args);
      if (isSyncApi(methodName)) {
        return processReturnValue(methodName, returnValue, options.returnValue, isContextApi(methodName));
      }
      return returnValue;
    };
  };
}
const getLocale = () => {
  const app = isFunction$4(getApp) && getApp({ allowDefault: true });
  if (app && app.$vm) {
    return app.$vm.$locale;
  }
  return normalizeLocale(wx.getSystemInfoSync().language) || LOCALE_EN;
};
const setLocale = (locale) => {
  const app = isFunction$4(getApp) && getApp();
  if (!app) {
    return false;
  }
  const oldLocale = app.$vm.$locale;
  if (oldLocale !== locale) {
    app.$vm.$locale = locale;
    onLocaleChangeCallbacks.forEach((fn) => fn({ locale }));
    return true;
  }
  return false;
};
const onLocaleChangeCallbacks = [];
const onLocaleChange = (fn) => {
  if (onLocaleChangeCallbacks.indexOf(fn) === -1) {
    onLocaleChangeCallbacks.push(fn);
  }
};
if (typeof global !== "undefined") {
  global.getLocale = getLocale;
}
const UUID_KEY = "__DC_STAT_UUID";
let deviceId;
function useDeviceId(global2 = wx) {
  return function addDeviceId(_, toRes) {
    deviceId = deviceId || global2.getStorageSync(UUID_KEY);
    if (!deviceId) {
      deviceId = Date.now() + "" + Math.floor(Math.random() * 1e7);
      wx.setStorage({
        key: UUID_KEY,
        data: deviceId
      });
    }
    toRes.deviceId = deviceId;
  };
}
function addSafeAreaInsets(fromRes, toRes) {
  if (fromRes.safeArea) {
    const safeArea = fromRes.safeArea;
    toRes.safeAreaInsets = {
      top: safeArea.top,
      left: safeArea.left,
      right: fromRes.windowWidth - safeArea.right,
      bottom: fromRes.screenHeight - safeArea.bottom
    };
  }
}
function populateParameters(fromRes, toRes) {
  const { brand = "", model: model2 = "", system = "", language = "", theme: theme2, version: version2, platform: platform2, fontSizeSetting, SDKVersion, pixelRatio, deviceOrientation } = fromRes;
  let osName = "";
  let osVersion = "";
  {
    osName = system.split(" ")[0] || "";
    osVersion = system.split(" ")[1] || "";
  }
  let hostVersion = version2;
  let deviceType = getGetDeviceType(fromRes, model2);
  let deviceBrand = getDeviceBrand(brand);
  let _hostName = getHostName(fromRes);
  let _deviceOrientation = deviceOrientation;
  let _devicePixelRatio = pixelRatio;
  let _SDKVersion = SDKVersion;
  const hostLanguage = language.replace(/_/g, "-");
  const parameters = {
    appId: "__UNI__2251D0F",
    appName: "螺丝记账",
    appVersion: "1.0.0",
    appVersionCode: "100",
    appLanguage: getAppLanguage(hostLanguage),
    uniCompileVersion: "4.08",
    uniRuntimeVersion: "4.08",
    uniPlatform: "mp-weixin",
    deviceBrand,
    deviceModel: model2,
    deviceType,
    devicePixelRatio: _devicePixelRatio,
    deviceOrientation: _deviceOrientation,
    osName: osName.toLocaleLowerCase(),
    osVersion,
    hostTheme: theme2,
    hostVersion,
    hostLanguage,
    hostName: _hostName,
    hostSDKVersion: _SDKVersion,
    hostFontSizeSetting: fontSizeSetting,
    windowTop: 0,
    windowBottom: 0,
    // TODO
    osLanguage: void 0,
    osTheme: void 0,
    ua: void 0,
    hostPackageName: void 0,
    browserName: void 0,
    browserVersion: void 0
  };
  extend$5(toRes, parameters);
}
function getGetDeviceType(fromRes, model2) {
  let deviceType = fromRes.deviceType || "phone";
  {
    const deviceTypeMaps = {
      ipad: "pad",
      windows: "pc",
      mac: "pc"
    };
    const deviceTypeMapsKeys = Object.keys(deviceTypeMaps);
    const _model2 = model2.toLocaleLowerCase();
    for (let index2 = 0; index2 < deviceTypeMapsKeys.length; index2++) {
      const _m = deviceTypeMapsKeys[index2];
      if (_model2.indexOf(_m) !== -1) {
        deviceType = deviceTypeMaps[_m];
        break;
      }
    }
  }
  return deviceType;
}
function getDeviceBrand(brand) {
  let deviceBrand = brand;
  if (deviceBrand) {
    deviceBrand = deviceBrand.toLocaleLowerCase();
  }
  return deviceBrand;
}
function getAppLanguage(defaultLanguage) {
  return getLocale ? getLocale() : defaultLanguage;
}
function getHostName(fromRes) {
  const _platform = "WeChat";
  let _hostName = fromRes.hostName || _platform;
  {
    if (fromRes.environment) {
      _hostName = fromRes.environment;
    } else if (fromRes.host && fromRes.host.env) {
      _hostName = fromRes.host.env;
    }
  }
  return _hostName;
}
const getSystemInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    useDeviceId()(fromRes, toRes);
    populateParameters(fromRes, toRes);
  }
};
const getSystemInfoSync = getSystemInfo;
const redirectTo = {};
const previewImage = {
  args(fromArgs, toArgs) {
    let currentIndex = parseInt(fromArgs.current);
    if (isNaN(currentIndex)) {
      return;
    }
    const urls = fromArgs.urls;
    if (!isArray$6(urls)) {
      return;
    }
    const len = urls.length;
    if (!len) {
      return;
    }
    if (currentIndex < 0) {
      currentIndex = 0;
    } else if (currentIndex >= len) {
      currentIndex = len - 1;
    }
    if (currentIndex > 0) {
      toArgs.current = urls[currentIndex];
      toArgs.urls = urls.filter((item, index2) => index2 < currentIndex ? item !== urls[currentIndex] : true);
    } else {
      toArgs.current = urls[0];
    }
    return {
      indicator: false,
      loop: false
    };
  }
};
const showActionSheet = {
  args(fromArgs, toArgs) {
    toArgs.alertText = fromArgs.title;
  }
};
const getDeviceInfo = {
  returnValue: (fromRes, toRes) => {
    const { brand, model: model2 } = fromRes;
    let deviceType = getGetDeviceType(fromRes, model2);
    let deviceBrand = getDeviceBrand(brand);
    useDeviceId()(fromRes, toRes);
    toRes = sortObject(extend$5(toRes, {
      deviceType,
      deviceBrand,
      deviceModel: model2
    }));
  }
};
const getAppBaseInfo = {
  returnValue: (fromRes, toRes) => {
    const { version: version2, language, SDKVersion, theme: theme2 } = fromRes;
    let _hostName = getHostName(fromRes);
    let hostLanguage = language.replace(/_/g, "-");
    toRes = sortObject(extend$5(toRes, {
      hostVersion: version2,
      hostLanguage,
      hostName: _hostName,
      hostSDKVersion: SDKVersion,
      hostTheme: theme2,
      appId: "__UNI__2251D0F",
      appName: "螺丝记账",
      appVersion: "1.0.0",
      appVersionCode: "100",
      appLanguage: getAppLanguage(hostLanguage)
    }));
  }
};
const getWindowInfo = {
  returnValue: (fromRes, toRes) => {
    addSafeAreaInsets(fromRes, toRes);
    toRes = sortObject(extend$5(toRes, {
      windowTop: 0,
      windowBottom: 0
    }));
  }
};
const getAppAuthorizeSetting = {
  returnValue: function(fromRes, toRes) {
    const { locationReducedAccuracy } = fromRes;
    toRes.locationAccuracy = "unsupported";
    if (locationReducedAccuracy === true) {
      toRes.locationAccuracy = "reduced";
    } else if (locationReducedAccuracy === false) {
      toRes.locationAccuracy = "full";
    }
  }
};
const baseApis = {
  $on,
  $off,
  $once,
  $emit,
  upx2px,
  interceptors,
  addInterceptor,
  removeInterceptor,
  onCreateVueApp,
  invokeCreateVueAppHook,
  getLocale,
  setLocale,
  onLocaleChange,
  getPushClientId,
  onPushMessage,
  offPushMessage,
  invokePushCallback
};
function initUni(api, protocols2, platform2 = wx) {
  const wrapper = initWrapper(protocols2);
  const UniProxyHandlers = {
    get(target, key) {
      if (hasOwn(target, key)) {
        return target[key];
      }
      if (hasOwn(api, key)) {
        return promisify(key, api[key]);
      }
      if (hasOwn(baseApis, key)) {
        return promisify(key, baseApis[key]);
      }
      return promisify(key, wrapper(key, platform2[key]));
    }
  };
  return new Proxy({}, UniProxyHandlers);
}
function initGetProvider(providers) {
  return function getProvider2({ service, success, fail, complete }) {
    let res;
    if (providers[service]) {
      res = {
        errMsg: "getProvider:ok",
        service,
        provider: providers[service]
      };
      isFunction$4(success) && success(res);
    } else {
      res = {
        errMsg: "getProvider:fail:服务[" + service + "]不存在"
      };
      isFunction$4(fail) && fail(res);
    }
    isFunction$4(complete) && complete(res);
  };
}
const objectKeys = [
  "qy",
  "env",
  "error",
  "version",
  "lanDebug",
  "cloud",
  "serviceMarket",
  "router",
  "worklet",
  "__webpack_require_UNI_MP_PLUGIN__"
];
const singlePageDisableKey = ["lanDebug", "router", "worklet"];
const launchOption = wx.getLaunchOptionsSync ? wx.getLaunchOptionsSync() : null;
function isWxKey(key) {
  if (launchOption && launchOption.scene === 1154 && singlePageDisableKey.includes(key)) {
    return false;
  }
  return objectKeys.indexOf(key) > -1 || typeof wx[key] === "function";
}
function initWx() {
  const newWx = {};
  for (const key in wx) {
    if (isWxKey(key)) {
      newWx[key] = wx[key];
    }
  }
  if (typeof globalThis !== "undefined" && typeof requireMiniProgram === "undefined") {
    globalThis.wx = newWx;
  }
  return newWx;
}
const mocks$1 = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
const getProvider = initGetProvider({
  oauth: ["weixin"],
  share: ["weixin"],
  payment: ["wxpay"],
  push: ["weixin"]
});
function initComponentMocks(component2) {
  const res = /* @__PURE__ */ Object.create(null);
  mocks$1.forEach((name2) => {
    res[name2] = component2[name2];
  });
  return res;
}
function createSelectorQuery() {
  const query = wx$2.createSelectorQuery();
  const oldIn = query.in;
  query.in = function newIn(component2) {
    return oldIn.call(this, initComponentMocks(component2));
  };
  return query;
}
const wx$2 = initWx();
let baseInfo = wx$2.getAppBaseInfo && wx$2.getAppBaseInfo();
if (!baseInfo) {
  baseInfo = wx$2.getSystemInfoSync();
}
const host = baseInfo ? baseInfo.host : null;
const shareVideoMessage = host && host.env === "SAAASDK" ? wx$2.miniapp.shareVideoMessage : wx$2.shareVideoMessage;
var shims = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createSelectorQuery,
  getProvider,
  shareVideoMessage
});
const compressImage = {
  args(fromArgs, toArgs) {
    if (fromArgs.compressedHeight && !toArgs.compressHeight) {
      toArgs.compressHeight = fromArgs.compressedHeight;
    }
    if (fromArgs.compressedWidth && !toArgs.compressWidth) {
      toArgs.compressWidth = fromArgs.compressedWidth;
    }
  }
};
var protocols = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  compressImage,
  getAppAuthorizeSetting,
  getAppBaseInfo,
  getDeviceInfo,
  getSystemInfo,
  getSystemInfoSync,
  getWindowInfo,
  previewImage,
  redirectTo,
  showActionSheet
});
const wx$1 = initWx();
var index = initUni(shims, protocols, wx$1);
function warn$1(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else {
      warn$1(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("iterate");
const MAP_KEY_ITERATE_KEY = Symbol("Map key iterate");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = { effect: activeEffect, target, type, key };
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$6(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$6(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = { target, type, key, newValue, oldValue, oldTarget };
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0], eventInfo);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects), eventInfo);
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$6(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.onTrigger) {
      effect.onTrigger(extend$5({ effect }, debuggerEventExtraInfo));
    }
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$6(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$8(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$6(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$6(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$6(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    {
      warn$1(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    {
      warn$1(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$5({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend$5({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$2(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$2(key, isReadonly2 = false) {
  const target = this[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto2 = getProto(target);
  const hadKey = proto2.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$2(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear$1() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = isMap(target) ? new Map(target) : new Set(target);
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$2(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$2,
    add,
    set: set$2,
    delete: deleteEntry,
    clear: clear$1,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$2(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$2,
    add,
    set: set$2,
    delete: deleteEntry,
    clear: clear$1,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$2.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$2(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$2.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$8(target)) {
    {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ] && !(isReadonly2 && target[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ]);
  }
  return !!(value && value[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ]);
}
function isReadonly(value) {
  return !!(value && value[
    "__v_isReadonly"
    /* ReactiveFlags.IS_READONLY */
  ]);
}
function isShallow(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$8(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$8(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var _a;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this[
      "__v_isReadonly"
      /* ReactiveFlags.IS_READONLY */
    ] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$4(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = () => {
      console.warn("Write operation failed: computed value is readonly");
    };
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$6(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$4(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  [
    "sp"
    /* LifecycleHooks.SERVER_PREFETCH */
  ]: "serverPrefetch hook",
  [
    "bc"
    /* LifecycleHooks.BEFORE_CREATE */
  ]: "beforeCreate hook",
  [
    "c"
    /* LifecycleHooks.CREATED */
  ]: "created hook",
  [
    "bm"
    /* LifecycleHooks.BEFORE_MOUNT */
  ]: "beforeMount hook",
  [
    "m"
    /* LifecycleHooks.MOUNTED */
  ]: "mounted hook",
  [
    "bu"
    /* LifecycleHooks.BEFORE_UPDATE */
  ]: "beforeUpdate hook",
  [
    "u"
    /* LifecycleHooks.UPDATED */
  ]: "updated",
  [
    "bum"
    /* LifecycleHooks.BEFORE_UNMOUNT */
  ]: "beforeUnmount hook",
  [
    "um"
    /* LifecycleHooks.UNMOUNTED */
  ]: "unmounted hook",
  [
    "a"
    /* LifecycleHooks.ACTIVATED */
  ]: "activated hook",
  [
    "da"
    /* LifecycleHooks.DEACTIVATED */
  ]: "deactivated hook",
  [
    "ec"
    /* LifecycleHooks.ERROR_CAPTURED */
  ]: "errorCaptured hook",
  [
    "rtc"
    /* LifecycleHooks.RENDER_TRACKED */
  ]: "renderTracked hook",
  [
    "rtg"
    /* LifecycleHooks.RENDER_TRIGGERED */
  ]: "renderTriggered hook",
  [
    0
    /* ErrorCodes.SETUP_FUNCTION */
  ]: "setup function",
  [
    1
    /* ErrorCodes.RENDER_FUNCTION */
  ]: "render function",
  [
    2
    /* ErrorCodes.WATCH_GETTER */
  ]: "watcher getter",
  [
    3
    /* ErrorCodes.WATCH_CALLBACK */
  ]: "watcher callback",
  [
    4
    /* ErrorCodes.WATCH_CLEANUP */
  ]: "watcher cleanup function",
  [
    5
    /* ErrorCodes.NATIVE_EVENT_HANDLER */
  ]: "native event handler",
  [
    6
    /* ErrorCodes.COMPONENT_EVENT_HANDLER */
  ]: "component event handler",
  [
    7
    /* ErrorCodes.VNODE_HOOK */
  ]: "vnode hook",
  [
    8
    /* ErrorCodes.DIRECTIVE_HOOK */
  ]: "directive hook",
  [
    9
    /* ErrorCodes.TRANSITION_HOOK */
  ]: "transition hook",
  [
    10
    /* ErrorCodes.APP_ERROR_HANDLER */
  ]: "app errorHandler",
  [
    11
    /* ErrorCodes.APP_WARN_HANDLER */
  ]: "app warnHandler",
  [
    12
    /* ErrorCodes.FUNCTION_REF */
  ]: "ref function",
  [
    13
    /* ErrorCodes.ASYNC_COMPONENT_LOADER */
  ]: "async component loader",
  [
    14
    /* ErrorCodes.SCHEDULER */
  ]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$4(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = ErrorTypeStrings[type] || type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError$3(err, type, contextVNode, throwInDev);
}
function logError$3(err, type, contextVNode, throwInDev = true) {
  {
    const info = ErrorTypeStrings[type] || type;
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      console.error(err);
    } else {
      console.error(err);
    }
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick$1(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function hasQueueJob(job) {
  return queue.indexOf(job) > -1;
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$6(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff2 = getId(a) - getId(b);
  if (diff2 === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff2;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = (job) => checkRecursiveUpdates(seen, job);
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (check(job)) {
          continue;
        }
        callWithErrorHandling(
          job,
          null,
          14
          /* ErrorCodes.SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event2, ...args) {
  if (devtools) {
    devtools.emit(event2, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event: event2, args });
  }
}
function setDevtoolsHook(hook, target) {
  var _a2, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event: event2, args }) => devtools.emit(event2, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    // eslint-disable-next-line no-restricted-globals
    window.HTMLElement && // also exclude jsdom
    // eslint-disable-next-line no-restricted-globals
    !((_b = (_a2 = window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit$1("app:init", app, version2, {
    Fragment,
    Text: Text$3,
    Comment,
    Static
  });
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* DevtoolsHooks.COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* DevtoolsHooks.COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* DevtoolsHooks.COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component2) => {
  if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools.cleanupBuffer(component2)) {
    _devtoolsComponentRemoved(component2);
  }
};
function createDevtoolsComponentHook(hook) {
  return (component2) => {
    emit$1(
      hook,
      component2.appContext.app,
      component2.uid,
      // fixed by xxxxxx
      // 为 0 是 App，无 parent 是 Page 指向 App
      component2.uid === 0 ? void 0 : component2.parent ? component2.parent.uid : 0,
      component2
    );
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* DevtoolsHooks.PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* DevtoolsHooks.PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component2, type, time) => {
    emit$1(hook, component2.appContext.app, component2.uid, component2, type, time);
  };
}
function devtoolsComponentEmit(component2, event2, params) {
  emit$1("component:emit", component2.appContext.app, component2, event2, params);
}
function emit(instance, event2, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ$1;
  {
    const { emitsOptions, propsOptions: [propsOptions] } = instance;
    if (emitsOptions) {
      if (!(event2 in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event2) in propsOptions)) {
          warn(`Component emitted event "${event2}" but it is neither declared in the emits option nor as an "${toHandlerKey(event2)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event2];
        if (isFunction$4(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn(`Invalid event arguments: event validation failed for event "${event2}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event2.startsWith("update:");
  const modelArg = isModelListener2 && event2.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number: number2, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ$1;
    if (trim2) {
      args = rawArgs.map((a) => isString$6(a) ? a.trim() : a);
    }
    if (number2) {
      args = rawArgs.map(looseToNumber);
    }
  }
  {
    devtoolsComponentEmit(instance, event2, args);
  }
  {
    const lowerCaseEvent = event2.toLowerCase();
    if (lowerCaseEvent !== event2 && props[toHandlerKey(lowerCaseEvent)]) {
      warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event2}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event2)}" instead of "${event2}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event2)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event2))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event2))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$5(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$8(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$6(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$5(normalized, raw);
  }
  if (isObject$8(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  instance && instance.type.__scopeId || null;
  return prev;
}
function provide(key, value) {
  if (!currentInstance) {
    {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
    if (currentInstance.type.mpType === "app") {
      currentInstance.appContext.app.provide(key, value);
    }
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$4(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else {
      warn(`injection "${String(key)}" not found.`);
    }
  } else {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (!isFunction$4(cb)) {
    warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ$1) {
  if (!cb) {
    if (immediate !== void 0) {
      warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s) => {
    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$6(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$4(s)) {
        return callWithErrorHandling(
          s,
          instance,
          2
          /* ErrorCodes.WATCH_GETTER */
        );
      } else {
        warnInvalidSource(s);
      }
    });
  } else if (isFunction$4(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(
        source,
        instance,
        2
        /* ErrorCodes.WATCH_GETTER */
      );
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(
        fn,
        instance,
        4
        /* ErrorCodes.WATCH_CLEANUP */
      );
    };
  };
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect$1(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect$1(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$6(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$4(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path2) {
  const segments = path2.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$8(value) || value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$6(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    if (isRootHook(type)) {
      target = target.root;
    }
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else {
    const apiName = toHandlerKey((ErrorTypeStrings[type] || type.replace(/^on/, "")).replace(/ hook$/, ""));
    warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().`);
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook(
  "bm"
  /* LifecycleHooks.BEFORE_MOUNT */
);
const onMounted = createHook(
  "m"
  /* LifecycleHooks.MOUNTED */
);
const onBeforeUpdate = createHook(
  "bu"
  /* LifecycleHooks.BEFORE_UPDATE */
);
const onUpdated = createHook(
  "u"
  /* LifecycleHooks.UPDATED */
);
const onBeforeUnmount = createHook(
  "bum"
  /* LifecycleHooks.BEFORE_UNMOUNT */
);
const onUnmounted = createHook(
  "um"
  /* LifecycleHooks.UNMOUNTED */
);
const onServerPrefetch = createHook(
  "sp"
  /* LifecycleHooks.SERVER_PREFETCH */
);
const onRenderTriggered = createHook(
  "rtg"
  /* LifecycleHooks.RENDER_TRIGGERED */
);
const onRenderTracked = createHook(
  "rtc"
  /* LifecycleHooks.RENDER_TRACKED */
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function validateDirectiveName(name2) {
  if (isBuiltInDirective(name2)) {
    warn("Do not use built-in directive ids as custom directive id: " + name2);
  }
}
const COMPONENTS = "components";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component2 = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(
        Component2,
        false
        /* do not include inferred name to avoid breaking existing code */
      );
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
        return Component2;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component2[type], name2) || // global registration
      resolve(instance.appContext[type], name2)
    );
    if (!res && maybeSelfReference) {
      return Component2;
    }
    if (warnMissing && !res) {
      const extra = type === COMPONENTS ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;
      warn(`Failed to resolve ${type.slice(0, -1)}: ${name2}${extra}`);
    }
    return res;
  } else {
    warn(`resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`);
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend$5(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    // fixed by xxxxxx vue-i18n 在 dev 模式，访问了 $el，故模拟一个假的
    // $el: i => i.vnode.el,
    $el: (i) => i.__$el || (i.__$el = {}),
    $data: (i) => i.data,
    $props: (i) => shallowReadonly(i.props),
    $attrs: (i) => shallowReadonly(i.attrs),
    $slots: (i) => shallowReadonly(i.slots),
    $refs: (i) => shallowReadonly(i.refs),
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    // $nextTick: i => i.n || (i.n = nextTick.bind(i.proxy!)),// fixed by xxxxxx
    $watch: (i) => instanceWatch.bind(i)
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ$1 && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ$1 && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ$1 && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ$1 && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (currentRenderingInstance && (!isString$6(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ$1 && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (setupState.__isScriptSetup && hasOwn(setupState, key)) {
      warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ$1 && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      warn(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
      return false;
    } else {
      if (key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ$1 && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
{
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const { ctx, propsOptions: [propsOptions] } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions$1(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(
      options.beforeCreate,
      instance,
      "bc"
      /* LifecycleHooks.BEFORE_CREATE */
    );
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods: methods2,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = createDuplicateChecker();
  {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods2) {
    for (const key in methods2) {
      const methodHandler = methods2[key];
      if (isFunction$4(methodHandler)) {
        {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        }
        {
          checkDuplicateProperties("Methods", key);
        }
      } else {
        warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (!isFunction$4(dataOptions)) {
      warn(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (isPromise(data)) {
      warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject$8(data)) {
      warn(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$4(opt) ? opt.bind(publicThis, publicThis) : isFunction$4(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (get2 === NOOP) {
        warn(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction$4(opt) && isFunction$4(opt.set) ? opt.set.bind(publicThis) : () => {
        warn(`Write operation failed: computed property "${key}" is readonly.`);
      };
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  {
    if (provideOptions) {
      const provides = isFunction$4(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
  }
  {
    if (created) {
      callHook$1(
        created,
        instance,
        "c"
        /* LifecycleHooks.CREATED */
      );
    }
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$6(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$6(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
  if (instance.ctx.$onApplyOptions) {
    instance.ctx.$onApplyOptions(options, instance, publicThis);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$6(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$8(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        {
          warn(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$6(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$6(raw)) {
    const handler = ctx[raw];
    if (isFunction$4(handler)) {
      watch(getter, handler);
    } else {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction$4(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$8(raw)) {
    if (isArray$6(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$4(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$4(handler)) {
        watch(getter, handler, raw);
      } else {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m2) => mergeOptions(resolved, m2, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  if (isObject$8(base2)) {
    cache.set(base2, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m2) => mergeOptions(to, m2, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray$1,
  created: mergeAsArray$1,
  beforeMount: mergeAsArray$1,
  mounted: mergeAsArray$1,
  beforeUpdate: mergeAsArray$1,
  updated: mergeAsArray$1,
  beforeDestroy: mergeAsArray$1,
  beforeUnmount: mergeAsArray$1,
  destroyed: mergeAsArray$1,
  unmounted: mergeAsArray$1,
  activated: mergeAsArray$1,
  deactivated: mergeAsArray$1,
  errorCaptured: mergeAsArray$1,
  serverPrefetch: mergeAsArray$1,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$5(isFunction$4(to) ? to.call(this, this) : to, isFunction$4(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$6(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray$1(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$5(extend$5(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$5(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray$1(to[key], from[key]);
  }
  return merged;
}
function initProps$2(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId)
      return true;
    instance = instance.parent;
  }
}
function updateProps$1(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !isInHmrContext(instance) && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ$1;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$4(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* BooleanFlags.shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* BooleanFlags.shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$4(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$5(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$8(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$6(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (!isString$6(raw[i])) {
        warn(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ$1;
      }
    }
  } else if (raw) {
    if (!isObject$8(raw)) {
      warn(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$6(opt) || isFunction$4(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* BooleanFlags.shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* BooleanFlags.shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$8(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$6(expectedTypes)) {
    return expectedTypes.findIndex((t2) => isSameType(t2, type));
  } else if (isFunction$4(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
  }
}
function validateProp(name2, value, prop, isAbsent) {
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    warn('Missing required prop: "' + name2 + '"');
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid = false;
    const types = isArray$6(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn(getInvalidTypeMessage(name2, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name2 + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t2 = typeof value;
    valid = t2 === expectedType.toLowerCase();
    if (!valid && t2 === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject$8(value);
  } else if (expectedType === "Array") {
    valid = isArray$6(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name2, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name2}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$4(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$8(rootProps)) {
      warn(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v) {
        {
          warn(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2)) {
          warn(`Plugin has already been applied to target app.`);
        } else if (plugin2 && isFunction$4(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app, ...options);
        } else if (isFunction$4(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app, ...options);
        } else {
          warn(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin2) {
        {
          if (!context.mixins.includes(mixin2)) {
            context.mixins.push(mixin2);
          } else {
            warn("Mixin has already been applied to target app" + (mixin2.name ? `: ${mixin2.name}` : ""));
          }
        }
        return app;
      },
      component(name2, component2) {
        {
          validateComponentName(name2, context.config);
        }
        if (!component2) {
          return context.components[name2];
        }
        if (context.components[name2]) {
          warn(`Component "${name2}" has already been registered in target app.`);
        }
        context.components[name2] = component2;
        return app;
      },
      directive(name2, directive) {
        {
          validateDirectiveName(name2);
        }
        if (!directive) {
          return context.directives[name2];
        }
        if (context.directives[name2]) {
          warn(`Directive "${name2}" has already been registered in target app.`);
        }
        context.directives[name2] = directive;
        return app;
      },
      // fixed by xxxxxx
      mount() {
      },
      // fixed by xxxxxx
      unmount() {
      },
      provide(key, value) {
        if (key in context.provides) {
          warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
const queuePostRenderEffect$1 = queuePostFlushCb;
const Fragment = Symbol("Fragment");
const Text$3 = Symbol("Text");
const Comment = Symbol("Comment");
const Static = Symbol("Static");
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
const InternalObjectKey = `__vInternal`;
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$5({}, props) : props;
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ$1,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ$1,
    data: EMPTY_OBJ$1,
    props: EMPTY_OBJ$1,
    attrs: EMPTY_OBJ$1,
    slots: EMPTY_OBJ$1,
    refs: EMPTY_OBJ$1,
    setupState: EMPTY_OBJ$1,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = createDevRenderContext(instance);
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name2, config2) {
  const appIsNativeTag = config2.isNativeTag || NO;
  if (isBuiltInTag(name2) || appIsNativeTag(name2)) {
    warn("Do not use built-in or reserved HTML elements as component id: " + name2);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const {
    props
    /*, children*/
  } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps$2(instance, props, isStateful, isSSR);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component2 = instance.type;
  {
    if (Component2.name) {
      validateComponentName(Component2.name, instance.appContext.config);
    }
    if (Component2.components) {
      const names = Object.keys(Component2.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component2.directives) {
      const names = Object.keys(Component2.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component2.compilerOptions && isRuntimeOnly()) {
      warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component2;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [shallowReadonly(instance.props), setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      {
        warn(`setup() returned a Promise, but the version of Vue you are using does not support it yet.`);
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$4(setupResult)) {
    {
      instance.render = setupResult;
    }
  } else if (isObject$8(setupResult)) {
    if (isVNode(setupResult)) {
      warn(`setup() should not return VNodes directly - return a render function instead.`);
    }
    {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (setupResult !== void 0) {
    warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component2 = instance.type;
  if (!instance.render) {
    instance.render = Component2.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions$1(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (!Component2.render && instance.render === NOOP && !isSSR) {
    if (Component2.template) {
      warn(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        /* should not happen */
      );
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance) {
  return new Proxy(
    instance.attrs,
    {
      get(target, key) {
        track(instance, "get", "$attrs");
        return target[key];
      },
      set() {
        warn(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn(`setupContext.attrs is readonly.`);
        return false;
      }
    }
  );
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    {
      if (instance.exposed) {
        warn(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray$6(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
      }
    }
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      get slots() {
        return shallowReadonly(instance.slots);
      },
      get emit() {
        return (event2, ...args) => instance.emit(event2, ...args);
      },
      expose
    });
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        }
        return instance.proxy[key];
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component2, includeInferred = true) {
  return isFunction$4(Component2) ? Component2.displayName || Component2.name : Component2.name || includeInferred && Component2.__name;
}
function formatComponentName(instance, Component2, isRoot = false) {
  let name2 = getComponentName(Component2);
  if (!name2 && Component2.__file) {
    const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name2 = match[1];
    }
  }
  if (!name2 && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component2) {
          return key;
        }
      }
    };
    name2 = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const version$1 = "3.2.47";
function unwrapper(target) {
  return unref(target);
}
const ARRAYTYPE = "[object Array]";
const OBJECTTYPE = "[object Object]";
function diff(current, pre) {
  const result = {};
  syncKeys(current, pre);
  _diff(current, pre, "", result);
  return result;
}
function syncKeys(current, pre) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {
    for (let key in pre) {
      const currentValue = current[key];
      if (currentValue === void 0) {
        current[key] = null;
      } else {
        syncKeys(currentValue, pre[key]);
      }
    }
  } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {
    if (current.length >= pre.length) {
      pre.forEach((item, index2) => {
        syncKeys(current[index2], item);
      });
    }
  }
}
function _diff(current, pre, path2, result) {
  current = unwrapper(current);
  if (current === pre)
    return;
  const rootCurrentType = toTypeString(current);
  const rootPreType = toTypeString(pre);
  if (rootCurrentType == OBJECTTYPE) {
    if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(pre).length) {
      setResult(result, path2, current);
    } else {
      for (let key in current) {
        const currentValue = unwrapper(current[key]);
        const preValue = pre[key];
        const currentType = toTypeString(currentValue);
        const preType = toTypeString(preValue);
        if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {
          if (currentValue != preValue) {
            setResult(result, (path2 == "" ? "" : path2 + ".") + key, currentValue);
          }
        } else if (currentType == ARRAYTYPE) {
          if (preType != ARRAYTYPE) {
            setResult(result, (path2 == "" ? "" : path2 + ".") + key, currentValue);
          } else {
            if (currentValue.length < preValue.length) {
              setResult(result, (path2 == "" ? "" : path2 + ".") + key, currentValue);
            } else {
              currentValue.forEach((item, index2) => {
                _diff(item, preValue[index2], (path2 == "" ? "" : path2 + ".") + key + "[" + index2 + "]", result);
              });
            }
          }
        } else if (currentType == OBJECTTYPE) {
          if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {
            setResult(result, (path2 == "" ? "" : path2 + ".") + key, currentValue);
          } else {
            for (let subKey in currentValue) {
              _diff(currentValue[subKey], preValue[subKey], (path2 == "" ? "" : path2 + ".") + key + "." + subKey, result);
            }
          }
        }
      }
    }
  } else if (rootCurrentType == ARRAYTYPE) {
    if (rootPreType != ARRAYTYPE) {
      setResult(result, path2, current);
    } else {
      if (current.length < pre.length) {
        setResult(result, path2, current);
      } else {
        current.forEach((item, index2) => {
          _diff(item, pre[index2], path2 + "[" + index2 + "]", result);
        });
      }
    }
  } else {
    setResult(result, path2, current);
  }
}
function setResult(result, k, v) {
  result[k] = v;
}
function hasComponentEffect(instance) {
  return queue.includes(instance.update);
}
function flushCallbacks(instance) {
  const ctx = instance.ctx;
  const callbacks = ctx.__next_tick_callbacks;
  if (callbacks && callbacks.length) {
    const copies = callbacks.slice(0);
    callbacks.length = 0;
    for (let i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }
}
function nextTick(instance, fn) {
  const ctx = instance.ctx;
  if (!ctx.__next_tick_pending && !hasComponentEffect(instance)) {
    return nextTick$1(fn && fn.bind(instance.proxy));
  }
  let _resolve;
  if (!ctx.__next_tick_callbacks) {
    ctx.__next_tick_callbacks = [];
  }
  ctx.__next_tick_callbacks.push(() => {
    if (fn) {
      callWithErrorHandling(
        fn.bind(instance.proxy),
        instance,
        14
        /* ErrorCodes.SCHEDULER */
      );
    } else if (_resolve) {
      _resolve(instance.proxy);
    }
  });
  return new Promise((resolve2) => {
    _resolve = resolve2;
  });
}
function clone$3(src, seen) {
  src = unwrapper(src);
  const type = typeof src;
  if (type === "object" && src !== null) {
    let copy = seen.get(src);
    if (typeof copy !== "undefined") {
      return copy;
    }
    if (isArray$6(src)) {
      const len = src.length;
      copy = new Array(len);
      seen.set(src, copy);
      for (let i = 0; i < len; i++) {
        copy[i] = clone$3(src[i], seen);
      }
    } else {
      copy = {};
      seen.set(src, copy);
      for (const name2 in src) {
        if (hasOwn(src, name2)) {
          copy[name2] = clone$3(src[name2], seen);
        }
      }
    }
    return copy;
  }
  if (type !== "symbol") {
    return src;
  }
}
function deepCopy(src) {
  return clone$3(src, typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : /* @__PURE__ */ new Map());
}
function getMPInstanceData(instance, keys) {
  const data = instance.data;
  const ret = /* @__PURE__ */ Object.create(null);
  keys.forEach((key) => {
    ret[key] = data[key];
  });
  return ret;
}
function patch(instance, data, oldData) {
  if (!data) {
    return;
  }
  data = deepCopy(data);
  const ctx = instance.ctx;
  const mpType = ctx.mpType;
  if (mpType === "page" || mpType === "component") {
    data.r0 = 1;
    const mpInstance = ctx.$scope;
    const keys = Object.keys(data);
    const diffData = diff(data, oldData || getMPInstanceData(mpInstance, keys));
    if (Object.keys(diffData).length) {
      ctx.__next_tick_pending = true;
      mpInstance.setData(diffData, () => {
        ctx.__next_tick_pending = false;
        flushCallbacks(instance);
      });
      flushPreFlushCbs();
    } else {
      flushCallbacks(instance);
    }
  }
}
function initAppConfig(appConfig) {
  appConfig.globalProperties.$nextTick = function $nextTick(fn) {
    return nextTick(this.$, fn);
  };
}
function onApplyOptions(options, instance, publicThis) {
  instance.appContext.config.globalProperties.$applyOptions(options, instance, publicThis);
  const computedOptions = options.computed;
  if (computedOptions) {
    const keys = Object.keys(computedOptions);
    if (keys.length) {
      const ctx = instance.ctx;
      if (!ctx.$computedKeys) {
        ctx.$computedKeys = [];
      }
      ctx.$computedKeys.push(...keys);
    }
  }
  delete instance.ctx.$onApplyOptions;
}
function setRef$1(instance, isUnmount = false) {
  const { setupState, $templateRefs, ctx: { $scope, $mpPlatform } } = instance;
  if ($mpPlatform === "mp-alipay") {
    return;
  }
  if (!$templateRefs || !$scope) {
    return;
  }
  if (isUnmount) {
    return $templateRefs.forEach((templateRef) => setTemplateRef(templateRef, null, setupState));
  }
  const check = $mpPlatform === "mp-baidu" || $mpPlatform === "mp-toutiao";
  const doSetByRefs = (refs) => {
    const mpComponents = (
      // 字节小程序 selectAllComponents 可能返回 null
      // https://github.com/dcloudio/uni-app/issues/3954
      ($scope.selectAllComponents(".r") || []).concat($scope.selectAllComponents(".r-i-f") || [])
    );
    return refs.filter((templateRef) => {
      const refValue = findComponentPublicInstance(mpComponents, templateRef.i);
      if (check && refValue === null) {
        return true;
      }
      setTemplateRef(templateRef, refValue, setupState);
      return false;
    });
  };
  const doSet = () => {
    const refs = doSetByRefs($templateRefs);
    if (refs.length && instance.proxy && instance.proxy.$scope) {
      instance.proxy.$scope.setData({ r1: 1 }, () => {
        doSetByRefs(refs);
      });
    }
  };
  if ($scope._$setRef) {
    $scope._$setRef(doSet);
  } else {
    nextTick(instance, doSet);
  }
}
function toSkip(value) {
  if (isObject$8(value)) {
    markRaw(value);
  }
  return value;
}
function findComponentPublicInstance(mpComponents, id) {
  const mpInstance = mpComponents.find((com) => com && (com.properties || com.props).uI === id);
  if (mpInstance) {
    const vm = mpInstance.$vm;
    if (vm) {
      return getExposeProxy(vm.$) || vm;
    }
    return toSkip(mpInstance);
  }
  return null;
}
function setTemplateRef({ r, f: f2 }, refValue, setupState) {
  if (isFunction$4(r)) {
    r(refValue, {});
  } else {
    const _isString = isString$6(r);
    const _isRef = isRef(r);
    if (_isString || _isRef) {
      if (f2) {
        if (!_isRef) {
          return;
        }
        if (!isArray$6(r.value)) {
          r.value = [];
        }
        const existing = r.value;
        if (existing.indexOf(refValue) === -1) {
          existing.push(refValue);
          if (!refValue) {
            return;
          }
          onBeforeUnmount(() => remove(existing, refValue), refValue.$);
        }
      } else if (_isString) {
        if (hasOwn(setupState, r)) {
          setupState[r] = refValue;
        }
      } else if (isRef(r)) {
        r.value = refValue;
      } else {
        warnRef(r);
      }
    } else {
      warnRef(r);
    }
  }
}
function warnRef(ref2) {
  warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
}
var MPType;
(function(MPType2) {
  MPType2["APP"] = "app";
  MPType2["PAGE"] = "page";
  MPType2["COMPONENT"] = "component";
})(MPType || (MPType = {}));
const queuePostRenderEffect = queuePostFlushCb;
function mountComponent(initialVNode, options) {
  const instance = initialVNode.component = createComponentInstance(initialVNode, options.parentComponent, null);
  {
    instance.ctx.$onApplyOptions = onApplyOptions;
    instance.ctx.$children = [];
  }
  if (options.mpType === "app") {
    instance.render = NOOP;
  }
  if (options.onBeforeSetup) {
    options.onBeforeSetup(instance, options);
  }
  {
    pushWarningContext(initialVNode);
    startMeasure(instance, `mount`);
  }
  {
    startMeasure(instance, `init`);
  }
  setupComponent(instance);
  {
    endMeasure(instance, `init`);
  }
  {
    if (options.parentComponent && instance.proxy) {
      options.parentComponent.ctx.$children.push(getExposeProxy(instance) || instance.proxy);
    }
  }
  setupRenderEffect(instance);
  {
    popWarningContext();
    endMeasure(instance, `mount`);
  }
  return instance.proxy;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
function renderComponentRoot(instance) {
  const { type: Component2, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx, uid: uid2, appContext: { app: { config: { globalProperties: { pruneComponentPropsCache: pruneComponentPropsCache2 } } } }, inheritAttrs } = instance;
  instance.$templateRefs = [];
  instance.$ei = 0;
  pruneComponentPropsCache2(uid2);
  instance.__counter = instance.__counter === 0 ? 1 : 0;
  let result;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      fallthroughAttrs(inheritAttrs, props, propsOptions, attrs);
      const proxyToUse = withProxy || proxy;
      result = render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx);
    } else {
      fallthroughAttrs(inheritAttrs, props, propsOptions, Component2.props ? attrs : getFunctionalFallthrough(attrs));
      const render2 = Component2;
      result = render2.length > 1 ? render2(props, { attrs, slots, emit: emit2 }) : render2(
        props,
        null
        /* we know it doesn't need it */
      );
    }
  } catch (err) {
    handleError(
      err,
      instance,
      1
      /* ErrorCodes.RENDER_FUNCTION */
    );
    result = false;
  }
  setRef$1(instance);
  setCurrentRenderingInstance(prev);
  return result;
}
function fallthroughAttrs(inheritAttrs, props, propsOptions, fallthroughAttrs2) {
  if (props && fallthroughAttrs2 && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs2).filter((key) => key !== "class" && key !== "style");
    if (!keys.length) {
      return;
    }
    if (propsOptions && keys.some(isModelListener)) {
      keys.forEach((key) => {
        if (!isModelListener(key) || !(key.slice(9) in propsOptions)) {
          props[key] = fallthroughAttrs2[key];
        }
      });
    } else {
      keys.forEach((key) => props[key] = fallthroughAttrs2[key]);
    }
  }
}
const updateComponentPreRender = (instance) => {
  pauseTracking();
  flushPreFlushCbs();
  resetTracking();
};
function componentUpdateScopedSlotsFn() {
  const scopedSlotsData = this.$scopedSlotsData;
  if (!scopedSlotsData || scopedSlotsData.length === 0) {
    return;
  }
  const mpInstance = this.ctx.$scope;
  const oldData = mpInstance.data;
  const diffData = /* @__PURE__ */ Object.create(null);
  scopedSlotsData.forEach(({ path: path2, index: index2, data }) => {
    const oldScopedSlotData = getValueByDataPath(oldData, path2);
    const diffPath = isString$6(index2) ? `${path2}.${index2}` : `${path2}[${index2}]`;
    if (typeof oldScopedSlotData === "undefined" || typeof oldScopedSlotData[index2] === "undefined") {
      diffData[diffPath] = data;
    } else {
      const diffScopedSlotData = diff(data, oldScopedSlotData[index2]);
      Object.keys(diffScopedSlotData).forEach((name2) => {
        diffData[diffPath + "." + name2] = diffScopedSlotData[name2];
      });
    }
  });
  scopedSlotsData.length = 0;
  if (Object.keys(diffData).length) {
    mpInstance.setData(diffData);
  }
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function setupRenderEffect(instance) {
  const updateScopedSlots = componentUpdateScopedSlotsFn.bind(instance);
  instance.$updateScopedSlots = () => nextTick$1(() => queueJob(updateScopedSlots));
  const componentUpdateFn = () => {
    if (!instance.isMounted) {
      onBeforeUnmount(() => {
        setRef$1(instance, true);
      }, instance);
      {
        startMeasure(instance, `patch`);
      }
      patch(instance, renderComponentRoot(instance));
      {
        endMeasure(instance, `patch`);
      }
      {
        devtoolsComponentAdded(instance);
      }
    } else {
      const { next, bu, u } = instance;
      {
        pushWarningContext(next || instance.vnode);
      }
      toggleRecurse(instance, false);
      updateComponentPreRender();
      if (bu) {
        invokeArrayFns$1(bu);
      }
      toggleRecurse(instance, true);
      {
        startMeasure(instance, `patch`);
      }
      patch(instance, renderComponentRoot(instance));
      {
        endMeasure(instance, `patch`);
      }
      if (u) {
        queuePostRenderEffect(u);
      }
      {
        devtoolsComponentUpdated(instance);
      }
      {
        popWarningContext();
      }
    }
  };
  const effect = instance.effect = new ReactiveEffect(
    componentUpdateFn,
    () => queueJob(instance.update),
    instance.scope
    // track it in component's effect scope
  );
  const update = instance.update = effect.run.bind(effect);
  update.id = instance.uid;
  toggleRecurse(instance, true);
  {
    effect.onTrack = instance.rtc ? (e2) => invokeArrayFns$1(instance.rtc, e2) : void 0;
    effect.onTrigger = instance.rtg ? (e2) => invokeArrayFns$1(instance.rtg, e2) : void 0;
    update.ownerInstance = instance;
  }
  update();
}
function unmountComponent(instance) {
  const { bum, scope, update, um } = instance;
  if (bum) {
    invokeArrayFns$1(bum);
  }
  scope.stop();
  if (update) {
    update.active = false;
  }
  if (um) {
    queuePostRenderEffect(um);
  }
  queuePostRenderEffect(() => {
    instance.isUnmounted = true;
  });
  {
    devtoolsComponentRemoved(instance);
  }
}
const oldCreateApp = createAppAPI();
function getTarget() {
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof my !== "undefined") {
    return my;
  }
}
function createVueApp(rootComponent, rootProps = null) {
  const target = getTarget();
  target.__VUE__ = true;
  {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const app = oldCreateApp(rootComponent, rootProps);
  const appContext = app._context;
  initAppConfig(appContext.config);
  const createVNode = (initialVNode) => {
    initialVNode.appContext = appContext;
    initialVNode.shapeFlag = 6;
    return initialVNode;
  };
  const createComponent2 = function createComponent3(initialVNode, options) {
    return mountComponent(createVNode(initialVNode), options);
  };
  const destroyComponent = function destroyComponent2(component2) {
    return component2 && unmountComponent(component2.$);
  };
  app.mount = function mount() {
    rootComponent.render = NOOP;
    const instance = mountComponent(createVNode({ type: rootComponent }), {
      mpType: MPType.APP,
      mpInstance: null,
      parentComponent: null,
      slots: [],
      props: null
    });
    app._instance = instance.$;
    {
      devtoolsInitApp(app, version$1);
    }
    instance.$app = app;
    instance.$createComponent = createComponent2;
    instance.$destroyComponent = destroyComponent;
    appContext.$appInstance = instance;
    return instance;
  };
  app.unmount = function unmount() {
    warn(`Cannot unmount an app.`);
  };
  return app;
}
function injectLifecycleHook(name2, hook, publicThis, instance) {
  if (isFunction$4(hook)) {
    injectHook(name2, hook.bind(publicThis), instance);
  }
}
function initHooks$1(options, instance, publicThis) {
  const mpType = options.mpType || publicThis.$mpType;
  if (!mpType || mpType === "component") {
    return;
  }
  Object.keys(options).forEach((name2) => {
    if (isUniLifecycleHook(name2, options[name2], false)) {
      const hooks = options[name2];
      if (isArray$6(hooks)) {
        hooks.forEach((hook) => injectLifecycleHook(name2, hook, publicThis, instance));
      } else {
        injectLifecycleHook(name2, hooks, publicThis, instance);
      }
    }
  });
}
function applyOptions$2(options, instance, publicThis) {
  initHooks$1(options, instance, publicThis);
}
function set$3(target, key, val) {
  return target[key] = val;
}
function $callMethod(method, ...args) {
  const fn = this[method];
  if (fn) {
    return fn(...args);
  }
  console.error(`method ${method} not found`);
  return null;
}
function createErrorHandler(app) {
  return function errorHandler(err, instance, _info) {
    if (!instance) {
      throw err;
    }
    const appInstance = app._instance;
    if (!appInstance || !appInstance.proxy) {
      throw err;
    }
    {
      appInstance.proxy.$callHook(ON_ERROR, err);
    }
  };
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function initOptionMergeStrategies(optionMergeStrategies) {
  UniLifecycleHooks.forEach((name2) => {
    optionMergeStrategies[name2] = mergeAsArray;
  });
}
let realAtob;
const b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64re = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;
if (typeof atob !== "function") {
  realAtob = function(str) {
    str = String(str).replace(/[\t\n\f\r ]+/g, "");
    if (!b64re.test(str)) {
      throw new Error("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    }
    str += "==".slice(2 - (str.length & 3));
    var bitmap;
    var result = "";
    var r1;
    var r2;
    var i = 0;
    for (; i < str.length; ) {
      bitmap = b64.indexOf(str.charAt(i++)) << 18 | b64.indexOf(str.charAt(i++)) << 12 | (r1 = b64.indexOf(str.charAt(i++))) << 6 | (r2 = b64.indexOf(str.charAt(i++)));
      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }
    return result;
  };
} else {
  realAtob = atob;
}
function b64DecodeUnicode(str) {
  return decodeURIComponent(realAtob(str).split("").map(function(c) {
    return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
  }).join(""));
}
function getCurrentUserInfo() {
  const token = index.getStorageSync("uni_id_token") || "";
  const tokenArr = token.split(".");
  if (!token || tokenArr.length !== 3) {
    return {
      uid: null,
      role: [],
      permission: [],
      tokenExpired: 0
    };
  }
  let userInfo;
  try {
    userInfo = JSON.parse(b64DecodeUnicode(tokenArr[1]));
  } catch (error) {
    throw new Error("获取当前用户信息出错，详细错误信息为：" + error.message);
  }
  userInfo.tokenExpired = userInfo.exp * 1e3;
  delete userInfo.exp;
  delete userInfo.iat;
  return userInfo;
}
function uniIdMixin(globalProperties) {
  globalProperties.uniIDHasRole = function(roleId) {
    const { role } = getCurrentUserInfo();
    return role.indexOf(roleId) > -1;
  };
  globalProperties.uniIDHasPermission = function(permissionId) {
    const { permission } = getCurrentUserInfo();
    return this.uniIDHasRole("admin") || permission.indexOf(permissionId) > -1;
  };
  globalProperties.uniIDTokenValid = function() {
    const { tokenExpired } = getCurrentUserInfo();
    return tokenExpired > Date.now();
  };
}
function initApp(app) {
  const appConfig = app._context.config;
  appConfig.errorHandler = invokeCreateErrorHandler(app, createErrorHandler);
  initOptionMergeStrategies(appConfig.optionMergeStrategies);
  const globalProperties = appConfig.globalProperties;
  {
    uniIdMixin(globalProperties);
  }
  {
    globalProperties.$set = set$3;
    globalProperties.$applyOptions = applyOptions$2;
    globalProperties.$callMethod = $callMethod;
  }
  {
    index.invokeCreateVueAppHook(app);
  }
}
const propsCaches = /* @__PURE__ */ Object.create(null);
function renderProps(props) {
  const { uid: uid2, __counter } = getCurrentInstance();
  const propsId = (propsCaches[uid2] || (propsCaches[uid2] = [])).push(guardReactiveProps(props)) - 1;
  return uid2 + "," + propsId + "," + __counter;
}
function pruneComponentPropsCache(uid2) {
  delete propsCaches[uid2];
}
function findComponentPropsData(up) {
  if (!up) {
    return;
  }
  const [uid2, propsId] = up.split(",");
  if (!propsCaches[uid2]) {
    return;
  }
  return propsCaches[uid2][parseInt(propsId)];
}
var plugin = {
  install(app) {
    initApp(app);
    app.config.globalProperties.pruneComponentPropsCache = pruneComponentPropsCache;
    const oldMount = app.mount;
    app.mount = function mount(rootContainer) {
      const instance = oldMount.call(app, rootContainer);
      const createApp2 = getCreateApp();
      if (createApp2) {
        createApp2(instance);
      } else {
        if (typeof createMiniProgramApp !== "undefined") {
          createMiniProgramApp(instance);
        }
      }
      return instance;
    };
  }
};
function getCreateApp() {
  const method = "createApp";
  if (typeof global !== "undefined" && typeof global[method] !== "undefined") {
    return global[method];
  } else if (typeof my !== "undefined") {
    return my[method];
  }
}
function vOn(value, key) {
  const instance = getCurrentInstance();
  const ctx = instance.ctx;
  const extraKey = typeof key !== "undefined" && (ctx.$mpPlatform === "mp-weixin" || ctx.$mpPlatform === "mp-qq") && (isString$6(key) || typeof key === "number") ? "_" + key : "";
  const name2 = "e" + instance.$ei++ + extraKey;
  const mpInstance = ctx.$scope;
  if (!value) {
    delete mpInstance[name2];
    return name2;
  }
  const existingInvoker = mpInstance[name2];
  if (existingInvoker) {
    existingInvoker.value = value;
  } else {
    mpInstance[name2] = createInvoker(value, instance);
  }
  return name2;
}
function createInvoker(initialValue, instance) {
  const invoker = (e2) => {
    patchMPEvent(e2);
    let args = [e2];
    if (e2.detail && e2.detail.__args__) {
      args = e2.detail.__args__;
    }
    const eventValue = invoker.value;
    const invoke = () => callWithAsyncErrorHandling(patchStopImmediatePropagation(e2, eventValue), instance, 5, args);
    const eventTarget = e2.target;
    const eventSync = eventTarget ? eventTarget.dataset ? String(eventTarget.dataset.eventsync) === "true" : false : false;
    if (bubbles.includes(e2.type) && !eventSync) {
      setTimeout(invoke);
    } else {
      const res = invoke();
      if (e2.type === "input" && (isArray$6(res) || isPromise(res))) {
        return;
      }
      return res;
    }
  };
  invoker.value = initialValue;
  return invoker;
}
const bubbles = [
  // touch事件暂不做延迟，否则在 Android 上会影响性能，比如一些拖拽跟手手势等
  // 'touchstart',
  // 'touchmove',
  // 'touchcancel',
  // 'touchend',
  "tap",
  "longpress",
  "longtap",
  "transitionend",
  "animationstart",
  "animationiteration",
  "animationend",
  "touchforcechange"
];
function patchMPEvent(event2) {
  if (event2.type && event2.target) {
    event2.preventDefault = NOOP;
    event2.stopPropagation = NOOP;
    event2.stopImmediatePropagation = NOOP;
    if (!hasOwn(event2, "detail")) {
      event2.detail = {};
    }
    if (hasOwn(event2, "markerId")) {
      event2.detail = typeof event2.detail === "object" ? event2.detail : {};
      event2.detail.markerId = event2.markerId;
    }
    if (isPlainObject(event2.detail) && hasOwn(event2.detail, "checked") && !hasOwn(event2.detail, "value")) {
      event2.detail.value = event2.detail.checked;
    }
    if (isPlainObject(event2.detail)) {
      event2.target = extend$5({}, event2.target, event2.detail);
    }
  }
}
function patchStopImmediatePropagation(e2, value) {
  if (isArray$6(value)) {
    const originalStop = e2.stopImmediatePropagation;
    e2.stopImmediatePropagation = () => {
      originalStop && originalStop.call(e2);
      e2._stopped = true;
    };
    return value.map((fn) => (e3) => !e3._stopped && fn(e3));
  } else {
    return value;
  }
}
function vFor(source, renderItem) {
  let ret;
  if (isArray$6(source) || isString$6(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, i);
    }
  } else if (typeof source === "number") {
    if (!Number.isInteger(source)) {
      warn(`The v-for range expect an integer value but got ${source}.`);
      return [];
    }
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, i);
    }
  } else if (isObject$8(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, i));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i = 0, l = keys.length; i < l; i++) {
        const key = keys[i];
        ret[i] = renderItem(source[key], key, i);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
const o = (value, key) => vOn(value, key);
const f = (source, renderItem) => vFor(source, renderItem);
const e = (target, ...sources) => extend$5(target, ...sources);
const t = (val) => toDisplayString(val);
const p = (props) => renderProps(props);
function createApp$1(rootComponent, rootProps = null) {
  rootComponent && (rootComponent.mpType = "app");
  return createVueApp(rootComponent, rootProps).use(plugin);
}
const createSSRApp = createApp$1;
const MP_METHODS = [
  "createSelectorQuery",
  "createIntersectionObserver",
  "selectAllComponents",
  "selectComponent"
];
function createEmitFn(oldEmit, ctx) {
  return function emit2(event2, ...args) {
    const scope = ctx.$scope;
    if (scope && event2) {
      const detail = { __args__: args };
      {
        scope.triggerEvent(event2, detail);
      }
    }
    return oldEmit.apply(this, [event2, ...args]);
  };
}
function initBaseInstance(instance, options) {
  const ctx = instance.ctx;
  ctx.mpType = options.mpType;
  ctx.$mpType = options.mpType;
  ctx.$mpPlatform = "mp-weixin";
  ctx.$scope = options.mpInstance;
  ctx.$mp = {};
  {
    ctx._self = {};
  }
  instance.slots = {};
  if (isArray$6(options.slots) && options.slots.length) {
    options.slots.forEach((name2) => {
      instance.slots[name2] = true;
    });
    if (instance.slots[SLOT_DEFAULT_NAME]) {
      instance.slots.default = true;
    }
  }
  ctx.getOpenerEventChannel = function() {
    {
      return options.mpInstance.getOpenerEventChannel();
    }
  };
  ctx.$hasHook = hasHook;
  ctx.$callHook = callHook;
  instance.emit = createEmitFn(instance.emit, ctx);
}
function initComponentInstance(instance, options) {
  initBaseInstance(instance, options);
  const ctx = instance.ctx;
  MP_METHODS.forEach((method) => {
    ctx[method] = function(...args) {
      const mpInstance = ctx.$scope;
      if (mpInstance && mpInstance[method]) {
        return mpInstance[method].apply(mpInstance, args);
      }
    };
  });
}
function initMocks(instance, mpInstance, mocks2) {
  const ctx = instance.ctx;
  mocks2.forEach((mock) => {
    if (hasOwn(mpInstance, mock)) {
      instance[mock] = ctx[mock] = mpInstance[mock];
    }
  });
}
function hasHook(name2) {
  const hooks = this.$[name2];
  if (hooks && hooks.length) {
    return true;
  }
  return false;
}
function callHook(name2, args) {
  if (name2 === "mounted") {
    callHook.call(this, "bm");
    this.$.isMounted = true;
    name2 = "m";
  }
  const hooks = this.$[name2];
  return hooks && invokeArrayFns(hooks, args);
}
const PAGE_INIT_HOOKS = [
  ON_LOAD,
  ON_SHOW,
  ON_HIDE,
  ON_UNLOAD,
  ON_RESIZE,
  ON_TAB_ITEM_TAP,
  ON_REACH_BOTTOM,
  ON_PULL_DOWN_REFRESH,
  ON_ADD_TO_FAVORITES
  // 'onReady', // lifetimes.ready
  // 'onPageScroll', // 影响性能，开发者手动注册
  // 'onShareTimeline', // 右上角菜单，开发者手动注册
  // 'onShareAppMessage' // 右上角菜单，开发者手动注册
];
function findHooks(vueOptions, hooks = /* @__PURE__ */ new Set()) {
  if (vueOptions) {
    Object.keys(vueOptions).forEach((name2) => {
      if (isUniLifecycleHook(name2, vueOptions[name2])) {
        hooks.add(name2);
      }
    });
    {
      const { extends: extendsOptions, mixins } = vueOptions;
      if (mixins) {
        mixins.forEach((mixin2) => findHooks(mixin2, hooks));
      }
      if (extendsOptions) {
        findHooks(extendsOptions, hooks);
      }
    }
  }
  return hooks;
}
function initHook(mpOptions, hook, excludes) {
  if (excludes.indexOf(hook) === -1 && !hasOwn(mpOptions, hook)) {
    mpOptions[hook] = function(args) {
      return this.$vm && this.$vm.$callHook(hook, args);
    };
  }
}
const EXCLUDE_HOOKS = [ON_READY];
function initHooks(mpOptions, hooks, excludes = EXCLUDE_HOOKS) {
  hooks.forEach((hook) => initHook(mpOptions, hook, excludes));
}
function initUnknownHooks(mpOptions, vueOptions, excludes = EXCLUDE_HOOKS) {
  findHooks(vueOptions).forEach((hook) => initHook(mpOptions, hook, excludes));
}
function initRuntimeHooks(mpOptions, runtimeHooks) {
  if (!runtimeHooks) {
    return;
  }
  const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
  hooks.forEach((hook) => {
    if (runtimeHooks & MINI_PROGRAM_PAGE_RUNTIME_HOOKS[hook]) {
      initHook(mpOptions, hook, []);
    }
  });
}
const findMixinRuntimeHooks = /* @__PURE__ */ once(() => {
  const runtimeHooks = [];
  const app = isFunction$4(getApp) && getApp({ allowDefault: true });
  if (app && app.$vm && app.$vm.$) {
    const mixins = app.$vm.$.appContext.mixins;
    if (isArray$6(mixins)) {
      const hooks = Object.keys(MINI_PROGRAM_PAGE_RUNTIME_HOOKS);
      mixins.forEach((mixin2) => {
        hooks.forEach((hook) => {
          if (hasOwn(mixin2, hook) && !runtimeHooks.includes(hook)) {
            runtimeHooks.push(hook);
          }
        });
      });
    }
  }
  return runtimeHooks;
});
function initMixinRuntimeHooks(mpOptions) {
  initHooks(mpOptions, findMixinRuntimeHooks());
}
const HOOKS = [
  ON_SHOW,
  ON_HIDE,
  ON_ERROR,
  ON_THEME_CHANGE,
  ON_PAGE_NOT_FOUND,
  ON_UNHANDLE_REJECTION
];
function parseApp(instance, parseAppOptions) {
  const internalInstance = instance.$;
  const appOptions = {
    globalData: instance.$options && instance.$options.globalData || {},
    $vm: instance,
    onLaunch(options) {
      this.$vm = instance;
      const ctx = internalInstance.ctx;
      if (this.$vm && ctx.$scope) {
        return;
      }
      initBaseInstance(internalInstance, {
        mpType: "app",
        mpInstance: this,
        slots: []
      });
      ctx.globalData = this.globalData;
      instance.$callHook(ON_LAUNCH, options);
    }
  };
  const { onError } = internalInstance;
  if (onError) {
    internalInstance.appContext.config.errorHandler = (err) => {
      instance.$callHook(ON_ERROR, err);
    };
  }
  initLocale(instance);
  const vueOptions = instance.$.type;
  initHooks(appOptions, HOOKS);
  initUnknownHooks(appOptions, vueOptions);
  {
    const methods2 = vueOptions.methods;
    methods2 && extend$5(appOptions, methods2);
  }
  if (parseAppOptions) {
    parseAppOptions.parse(appOptions);
  }
  return appOptions;
}
function initCreateApp(parseAppOptions) {
  return function createApp2(vm) {
    return App(parseApp(vm, parseAppOptions));
  };
}
function initCreateSubpackageApp(parseAppOptions) {
  return function createApp2(vm) {
    const appOptions = parseApp(vm, parseAppOptions);
    const app = isFunction$4(getApp) && getApp({
      allowDefault: true
    });
    if (!app)
      return;
    vm.$.ctx.$scope = app;
    const globalData = app.globalData;
    if (globalData) {
      Object.keys(appOptions.globalData).forEach((name2) => {
        if (!hasOwn(globalData, name2)) {
          globalData[name2] = appOptions.globalData[name2];
        }
      });
    }
    Object.keys(appOptions).forEach((name2) => {
      if (!hasOwn(app, name2)) {
        app[name2] = appOptions[name2];
      }
    });
    initAppLifecycle(appOptions, vm);
  };
}
function initAppLifecycle(appOptions, vm) {
  if (isFunction$4(appOptions.onLaunch)) {
    const args = wx.getLaunchOptionsSync && wx.getLaunchOptionsSync();
    appOptions.onLaunch(args);
  }
  if (isFunction$4(appOptions.onShow) && wx.onAppShow) {
    wx.onAppShow((args) => {
      vm.$callHook("onShow", args);
    });
  }
  if (isFunction$4(appOptions.onHide) && wx.onAppHide) {
    wx.onAppHide((args) => {
      vm.$callHook("onHide", args);
    });
  }
}
function initLocale(appVm) {
  const locale = ref(normalizeLocale(wx.getSystemInfoSync().language) || LOCALE_EN);
  Object.defineProperty(appVm, "$locale", {
    get() {
      return locale.value;
    },
    set(v) {
      locale.value = v;
    }
  });
}
function initVueIds(vueIds, mpInstance) {
  if (!vueIds) {
    return;
  }
  const ids = vueIds.split(",");
  const len = ids.length;
  if (len === 1) {
    mpInstance._$vueId = ids[0];
  } else if (len === 2) {
    mpInstance._$vueId = ids[0];
    mpInstance._$vuePid = ids[1];
  }
}
const EXTRAS = ["externalClasses"];
function initExtraOptions(miniProgramComponentOptions, vueOptions) {
  EXTRAS.forEach((name2) => {
    if (hasOwn(vueOptions, name2)) {
      miniProgramComponentOptions[name2] = vueOptions[name2];
    }
  });
}
const WORKLET_RE = /_(.*)_worklet_factory_/;
function initWorkletMethods(mpMethods, vueMethods) {
  if (vueMethods) {
    Object.keys(vueMethods).forEach((name2) => {
      const matches = name2.match(WORKLET_RE);
      if (matches) {
        const workletName = matches[1];
        mpMethods[name2] = vueMethods[name2];
        mpMethods[workletName] = vueMethods[workletName];
      }
    });
  }
}
function initWxsCallMethods(methods2, wxsCallMethods) {
  if (!isArray$6(wxsCallMethods)) {
    return;
  }
  wxsCallMethods.forEach((callMethod) => {
    methods2[callMethod] = function(args) {
      return this.$vm[callMethod](args);
    };
  });
}
function selectAllComponents(mpInstance, selector, $refs) {
  const components = mpInstance.selectAllComponents(selector);
  components.forEach((component2) => {
    const ref2 = component2.properties.uR;
    $refs[ref2] = component2.$vm || component2;
  });
}
function initRefs(instance, mpInstance) {
  Object.defineProperty(instance, "refs", {
    get() {
      const $refs = {};
      selectAllComponents(mpInstance, ".r", $refs);
      const forComponents = mpInstance.selectAllComponents(".r-i-f");
      forComponents.forEach((component2) => {
        const ref2 = component2.properties.uR;
        if (!ref2) {
          return;
        }
        if (!$refs[ref2]) {
          $refs[ref2] = [];
        }
        $refs[ref2].push(component2.$vm || component2);
      });
      return $refs;
    }
  });
}
function findVmByVueId(instance, vuePid) {
  const $children = instance.$children;
  for (let i = $children.length - 1; i >= 0; i--) {
    const childVm = $children[i];
    if (childVm.$scope._$vueId === vuePid) {
      return childVm;
    }
  }
  let parentVm;
  for (let i = $children.length - 1; i >= 0; i--) {
    parentVm = findVmByVueId($children[i], vuePid);
    if (parentVm) {
      return parentVm;
    }
  }
}
const builtInProps = [
  // 百度小程序,快手小程序自定义组件不支持绑定动态事件，动态dataset，故通过props传递事件信息
  // event-opts
  "eO",
  // 组件 ref
  "uR",
  // 组件 ref-in-for
  "uRIF",
  // 组件 id
  "uI",
  // 组件类型 m: 小程序组件
  "uT",
  // 组件 props
  "uP",
  // 小程序不能直接定义 $slots 的 props，所以通过 vueSlots 转换到 $slots
  "uS"
];
function initDefaultProps(options, isBehavior = false) {
  const properties = {};
  if (!isBehavior) {
    builtInProps.forEach((name2) => {
      properties[name2] = {
        type: null,
        value: ""
      };
    });
    properties.uS = {
      type: null,
      value: [],
      observer: function(newVal) {
        const $slots = /* @__PURE__ */ Object.create(null);
        newVal && newVal.forEach((slotName) => {
          $slots[slotName] = true;
        });
        this.setData({
          $slots
        });
      }
    };
  }
  if (options.behaviors) {
    if (options.behaviors.includes("wx://form-field")) {
      if (!options.properties || !options.properties.name) {
        properties.name = {
          type: null,
          value: ""
        };
      }
      if (!options.properties || !options.properties.value) {
        properties.value = {
          type: null,
          value: ""
        };
      }
    }
  }
  return properties;
}
function initVirtualHostProps(options) {
  const properties = {};
  {
    if (options && options.virtualHost) {
      properties.virtualHostStyle = {
        type: null,
        value: ""
      };
      properties.virtualHostClass = {
        type: null,
        value: ""
      };
    }
  }
  return properties;
}
function initProps$1(mpComponentOptions) {
  if (!mpComponentOptions.properties) {
    mpComponentOptions.properties = {};
  }
  extend$5(mpComponentOptions.properties, initDefaultProps(mpComponentOptions), initVirtualHostProps(mpComponentOptions.options));
}
const PROP_TYPES = [String, Number, Boolean, Object, Array, null];
function parsePropType(type, defaultValue) {
  if (isArray$6(type) && type.length === 1) {
    return type[0];
  }
  return type;
}
function normalizePropType(type, defaultValue) {
  const res = parsePropType(type);
  return PROP_TYPES.indexOf(res) !== -1 ? res : null;
}
function initPageProps({ properties }, rawProps) {
  if (isArray$6(rawProps)) {
    rawProps.forEach((key) => {
      properties[key] = {
        type: String,
        value: ""
      };
    });
  } else if (isPlainObject(rawProps)) {
    Object.keys(rawProps).forEach((key) => {
      const opts = rawProps[key];
      if (isPlainObject(opts)) {
        let value = opts.default;
        if (isFunction$4(value)) {
          value = value();
        }
        const type = opts.type;
        opts.type = normalizePropType(type);
        properties[key] = {
          type: opts.type,
          value
        };
      } else {
        properties[key] = {
          type: normalizePropType(opts)
        };
      }
    });
  }
}
function findPropsData(properties, isPage2) {
  return (isPage2 ? findPagePropsData(properties) : findComponentPropsData(properties.uP)) || {};
}
function findPagePropsData(properties) {
  const propsData = {};
  if (isPlainObject(properties)) {
    Object.keys(properties).forEach((name2) => {
      if (builtInProps.indexOf(name2) === -1) {
        propsData[name2] = properties[name2];
      }
    });
  }
  return propsData;
}
function initFormField(vm) {
  const vueOptions = vm.$options;
  if (isArray$6(vueOptions.behaviors) && vueOptions.behaviors.includes("uni://form-field")) {
    vm.$watch("modelValue", () => {
      vm.$scope && vm.$scope.setData({
        name: vm.name,
        value: vm.modelValue
      });
    }, {
      immediate: true
    });
  }
}
function initData(_) {
  return {};
}
function initPropsObserver(componentOptions) {
  const observe = function observe2() {
    const up = this.properties.uP;
    if (!up) {
      return;
    }
    if (this.$vm) {
      updateComponentProps(up, this.$vm.$);
    } else if (this.properties.uT === "m") {
      updateMiniProgramComponentProperties(up, this);
    }
  };
  {
    if (!componentOptions.observers) {
      componentOptions.observers = {};
    }
    componentOptions.observers.uP = observe;
  }
}
function updateMiniProgramComponentProperties(up, mpInstance) {
  const prevProps = mpInstance.properties;
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps, false)) {
    mpInstance.setData(nextProps);
  }
}
function updateComponentProps(up, instance) {
  const prevProps = toRaw(instance.props);
  const nextProps = findComponentPropsData(up) || {};
  if (hasPropsChanged(prevProps, nextProps)) {
    updateProps$1(instance, nextProps, prevProps, false);
    if (hasQueueJob(instance.update)) {
      invalidateJob(instance.update);
    }
    {
      instance.update();
    }
  }
}
function hasPropsChanged(prevProps, nextProps, checkLen = true) {
  const nextKeys = Object.keys(nextProps);
  if (checkLen && nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key]) {
      return true;
    }
  }
  return false;
}
function initBehaviors(vueOptions) {
  const vueBehaviors = vueOptions.behaviors;
  let vueProps = vueOptions.props;
  if (!vueProps) {
    vueOptions.props = vueProps = [];
  }
  const behaviors = [];
  if (isArray$6(vueBehaviors)) {
    vueBehaviors.forEach((behavior) => {
      behaviors.push(behavior.replace("uni://", "wx://"));
      if (behavior === "uni://form-field") {
        if (isArray$6(vueProps)) {
          vueProps.push("name");
          vueProps.push("modelValue");
        } else {
          vueProps.name = {
            type: String,
            default: ""
          };
          vueProps.modelValue = {
            type: [String, Number, Boolean, Array, Object, Date],
            default: ""
          };
        }
      }
    });
  }
  return behaviors;
}
function applyOptions(componentOptions, vueOptions) {
  componentOptions.data = initData();
  componentOptions.behaviors = initBehaviors(vueOptions);
}
function parseComponent(vueOptions, { parse: parse2, mocks: mocks2, isPage: isPage2, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 }) {
  vueOptions = vueOptions.default || vueOptions;
  const options = {
    multipleSlots: true,
    // styleIsolation: 'apply-shared',
    addGlobalClass: true,
    pureDataPattern: /^uP$/
  };
  if (isArray$6(vueOptions.mixins)) {
    vueOptions.mixins.forEach((item) => {
      if (isObject$8(item.options)) {
        extend$5(options, item.options);
      }
    });
  }
  if (vueOptions.options) {
    extend$5(options, vueOptions.options);
  }
  const mpComponentOptions = {
    options,
    lifetimes: initLifetimes2({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }),
    pageLifetimes: {
      show() {
        this.$vm && this.$vm.$callHook("onPageShow");
      },
      hide() {
        this.$vm && this.$vm.$callHook("onPageHide");
      },
      resize(size2) {
        this.$vm && this.$vm.$callHook("onPageResize", size2);
      }
    },
    methods: {
      __l: handleLink2
    }
  };
  {
    applyOptions(mpComponentOptions, vueOptions);
  }
  initProps$1(mpComponentOptions);
  initPropsObserver(mpComponentOptions);
  initExtraOptions(mpComponentOptions, vueOptions);
  initWxsCallMethods(mpComponentOptions.methods, vueOptions.wxsCallMethods);
  {
    initWorkletMethods(mpComponentOptions.methods, vueOptions.methods);
  }
  if (parse2) {
    parse2(mpComponentOptions, { handleLink: handleLink2 });
  }
  return mpComponentOptions;
}
function initCreateComponent(parseOptions2) {
  return function createComponent2(vueComponentOptions) {
    return Component(parseComponent(vueComponentOptions, parseOptions2));
  };
}
let $createComponentFn;
let $destroyComponentFn;
function getAppVm() {
  return getApp().$vm;
}
function $createComponent(initialVNode, options) {
  if (!$createComponentFn) {
    $createComponentFn = getAppVm().$createComponent;
  }
  const proxy = $createComponentFn(initialVNode, options);
  return getExposeProxy(proxy.$) || proxy;
}
function $destroyComponent(instance) {
  if (!$destroyComponentFn) {
    $destroyComponentFn = getAppVm().$destroyComponent;
  }
  return $destroyComponentFn(instance);
}
function parsePage(vueOptions, parseOptions2) {
  const { parse: parse2, mocks: mocks2, isPage: isPage2, initRelation: initRelation2, handleLink: handleLink2, initLifetimes: initLifetimes2 } = parseOptions2;
  const miniProgramPageOptions = parseComponent(vueOptions, {
    mocks: mocks2,
    isPage: isPage2,
    initRelation: initRelation2,
    handleLink: handleLink2,
    initLifetimes: initLifetimes2
  });
  initPageProps(miniProgramPageOptions, (vueOptions.default || vueOptions).props);
  const methods2 = miniProgramPageOptions.methods;
  methods2.onLoad = function(query) {
    this.options = query;
    this.$page = {
      fullPath: addLeadingSlash(this.route + stringifyQuery(query))
    };
    return this.$vm && this.$vm.$callHook(ON_LOAD, query);
  };
  initHooks(methods2, PAGE_INIT_HOOKS);
  {
    initUnknownHooks(methods2, vueOptions);
  }
  initRuntimeHooks(methods2, vueOptions.__runtimeHooks);
  initMixinRuntimeHooks(methods2);
  parse2 && parse2(miniProgramPageOptions, { handleLink: handleLink2 });
  return miniProgramPageOptions;
}
function initCreatePage(parseOptions2) {
  return function createPage2(vuePageOptions) {
    return Component(parsePage(vuePageOptions, parseOptions2));
  };
}
function initCreatePluginApp(parseAppOptions) {
  return function createApp2(vm) {
    initAppLifecycle(parseApp(vm, parseAppOptions), vm);
  };
}
const MPPage = Page;
const MPComponent = Component;
function initTriggerEvent(mpInstance) {
  const oldTriggerEvent = mpInstance.triggerEvent;
  const newTriggerEvent = function(event2, ...args) {
    return oldTriggerEvent.apply(mpInstance, [customizeEvent(event2), ...args]);
  };
  try {
    mpInstance.triggerEvent = newTriggerEvent;
  } catch (error) {
    mpInstance._triggerEvent = newTriggerEvent;
  }
}
function initMiniProgramHook(name2, options, isComponent) {
  const oldHook = options[name2];
  if (!oldHook) {
    options[name2] = function() {
      initTriggerEvent(this);
    };
  } else {
    options[name2] = function(...args) {
      initTriggerEvent(this);
      return oldHook.apply(this, args);
    };
  }
}
Page = function(options) {
  initMiniProgramHook(ON_LOAD, options);
  return MPPage(options);
};
Component = function(options) {
  initMiniProgramHook("created", options);
  const isVueComponent = options.properties && options.properties.uP;
  if (!isVueComponent) {
    initProps$1(options);
    initPropsObserver(options);
  }
  return MPComponent(options);
};
function initLifetimes({ mocks: mocks2, isPage: isPage2, initRelation: initRelation2, vueOptions }) {
  return {
    attached() {
      let properties = this.properties;
      initVueIds(properties.uI, this);
      const relationOptions = {
        vuePid: this._$vuePid
      };
      initRelation2(this, relationOptions);
      const mpInstance = this;
      const isMiniProgramPage = isPage2(mpInstance);
      let propsData = properties;
      this.$vm = $createComponent({
        type: vueOptions,
        props: findPropsData(propsData, isMiniProgramPage)
      }, {
        mpType: isMiniProgramPage ? "page" : "component",
        mpInstance,
        slots: properties.uS || {},
        parentComponent: relationOptions.parent && relationOptions.parent.$,
        onBeforeSetup(instance, options) {
          initRefs(instance, mpInstance);
          initMocks(instance, mpInstance, mocks2);
          initComponentInstance(instance, options);
        }
      });
      if (!isMiniProgramPage) {
        initFormField(this.$vm);
      }
    },
    ready() {
      if (this.$vm) {
        {
          this.$vm.$callHook("mounted");
          this.$vm.$callHook(ON_READY);
        }
      }
    },
    detached() {
      if (this.$vm) {
        pruneComponentPropsCache(this.$vm.$.uid);
        $destroyComponent(this.$vm);
      }
    }
  };
}
const mocks = ["__route__", "__wxExparserNodeId__", "__wxWebviewId__"];
function isPage(mpInstance) {
  return !!mpInstance.route;
}
function initRelation(mpInstance, detail) {
  mpInstance.triggerEvent("__l", detail);
}
function handleLink(event2) {
  const detail = event2.detail || event2.value;
  const vuePid = detail.vuePid;
  let parentVm;
  if (vuePid) {
    parentVm = findVmByVueId(this.$vm, vuePid);
  }
  if (!parentVm) {
    parentVm = this.$vm;
  }
  detail.parent = parentVm;
}
var parseOptions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  handleLink,
  initLifetimes,
  initRelation,
  isPage,
  mocks
});
const createApp = initCreateApp();
const createPage = initCreatePage(parseOptions);
const createComponent = initCreateComponent(parseOptions);
const createPluginApp = initCreatePluginApp();
const createSubpackageApp = initCreateSubpackageApp();
{
  wx.createApp = global.createApp = createApp;
  wx.createPage = createPage;
  wx.createComponent = createComponent;
  wx.createPluginApp = global.createPluginApp = createPluginApp;
  wx.createSubpackageApp = global.createSubpackageApp = createSubpackageApp;
}
var echarts$1 = {};
var echarts = {};
var zrender = {};
var idStart = 2311;
function _default$19() {
  return idStart++;
}
var guid$2 = _default$19;
var env$9 = {};
if (typeof wx$1 === "object" && typeof wx$1.getSystemInfoSync === "function") {
  env$9 = {
    browser: {},
    os: {},
    node: false,
    wxa: true,
    // Weixin Application
    canvasSupported: true,
    svgSupported: false,
    touchEventsSupported: true,
    domSupported: false
  };
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env$9 = {
    browser: {},
    os: {},
    node: false,
    worker: true,
    canvasSupported: true,
    domSupported: false
  };
} else if (typeof navigator === "undefined") {
  env$9 = {
    browser: {},
    os: {},
    node: true,
    worker: false,
    // Assume canvas is supported
    canvasSupported: true,
    svgSupported: true,
    domSupported: false
  };
} else {
  env$9 = detect(navigator.userAgent);
}
var _default$18 = env$9;
function detect(ua) {
  var os = {};
  var browser = {};
  var firefox = ua.match(/Firefox\/([\d.]+)/);
  var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  var edge = ua.match(/Edge\/([\d.]+)/);
  var weChat = /micromessenger/i.test(ua);
  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  }
  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }
  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
  }
  if (weChat) {
    browser.weChat = true;
  }
  return {
    browser,
    os,
    node: false,
    // 原生canvas支持，改极端点了
    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
    canvasSupported: !!document.createElement("canvas").getContext,
    svgSupported: typeof SVGRect !== "undefined",
    // works on most browsers
    // IE10/11 does not support touch event, and MS Edge supports them but not by
    // default, so we dont check navigator.maxTouchPoints for them here.
    touchEventsSupported: "ontouchstart" in window && !browser.ie && !browser.edge,
    // <http://caniuse.com/#search=pointer%20event>.
    pointerEventsSupported: (
      // (1) Firefox supports pointer but not by default, only MS browsers are reliable on pointer
      // events currently. So we dont use that on other browsers unless tested sufficiently.
      // For example, in iOS 13 Mobile Chromium 78, if the touching behavior starts page
      // scroll, the `pointermove` event can not be fired any more. That will break some
      // features like "pan horizontally to move something and pan vertically to page scroll".
      // The horizontal pan probably be interrupted by the casually triggered page scroll.
      // (2) Although IE 10 supports pointer event, it use old style and is different from the
      // standard. So we exclude that. (IE 10 is hardly used on touch device)
      "onpointerdown" in window && (browser.edge || browser.ie && browser.version >= 11)
    ),
    // passiveSupported: detectPassiveSupport()
    domSupported: typeof document !== "undefined"
  };
}
var env_1 = _default$18;
var util$6 = {};
var BUILTIN_OBJECT = {
  "[object Function]": 1,
  "[object RegExp]": 1,
  "[object Date]": 1,
  "[object Error]": 1,
  "[object CanvasGradient]": 1,
  "[object CanvasPattern]": 1,
  // For node-canvas
  "[object Image]": 1,
  "[object Canvas]": 1
};
var TYPED_ARRAY = {
  "[object Int8Array]": 1,
  "[object Uint8Array]": 1,
  "[object Uint8ClampedArray]": 1,
  "[object Int16Array]": 1,
  "[object Uint16Array]": 1,
  "[object Int32Array]": 1,
  "[object Uint32Array]": 1,
  "[object Float32Array]": 1,
  "[object Float64Array]": 1
};
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var nativeReduce = arrayProto.reduce;
var methods$1 = {};
function $override$1(name2, fn) {
  if (name2 === "createCanvas") {
    _ctx = null;
  }
  methods$1[name2] = fn;
}
function clone$2(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  var result = source;
  var typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (var i = 0, len = source.length; i < len; i++) {
        result[i] = clone$2(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      var Ctor = source.constructor;
      if (source.constructor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (var i = 0, len = source.length; i < len; i++) {
          result[i] = clone$2(source[i]);
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        result[key] = clone$2(source[key]);
      }
    }
  }
  return result;
}
function merge$2(target, source, overwrite) {
  if (!isObject$7(source) || !isObject$7(target)) {
    return overwrite ? clone$2(source) : target;
  }
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      var targetProp = target[key];
      var sourceProp = source[key];
      if (isObject$7(sourceProp) && isObject$7(targetProp) && !isArray$5(sourceProp) && !isArray$5(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge$2(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone$2(source[key]);
      }
    }
  }
  return target;
}
function mergeAll(targetAndSources, overwrite) {
  var result = targetAndSources[0];
  for (var i = 1, len = targetAndSources.length; i < len; i++) {
    result = merge$2(result, targetAndSources[i], overwrite);
  }
  return result;
}
function extend$4(target, source) {
  for (var key in source) {
    if (source.hasOwnProperty(key)) {
      target[key] = source[key];
    }
  }
  return target;
}
function defaults$1(target, source, overlay) {
  for (var key in source) {
    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
      target[key] = source[key];
    }
  }
  return target;
}
var createCanvas = function() {
  return methods$1.createCanvas();
};
methods$1.createCanvas = function() {
  return document.createElement("canvas");
};
var _ctx;
function getContext$1() {
  if (!_ctx) {
    _ctx = createCanvas().getContext("2d");
  }
  return _ctx;
}
function indexOf$2(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }
  return -1;
}
function inherits$1(clazz2, baseClazz) {
  var clazzPrototype = clazz2.prototype;
  function F() {
  }
  F.prototype = baseClazz.prototype;
  clazz2.prototype = new F();
  for (var prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz2.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz2.prototype.constructor = clazz2;
  clazz2.superClass = baseClazz;
}
function mixin$1(target, source, overlay) {
  target = "prototype" in target ? target.prototype : target;
  source = "prototype" in source ? source.prototype : source;
  defaults$1(target, source, overlay);
}
function isArrayLike$2(data) {
  if (!data) {
    return;
  }
  if (typeof data === "string") {
    return false;
  }
  return typeof data.length === "number";
}
function each$d(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }
  if (obj.forEach && obj.forEach === nativeForEach) {
    obj.forEach(cb, context);
  } else if (obj.length === +obj.length) {
    for (var i = 0, len = obj.length; i < len; i++) {
      cb.call(context, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        cb.call(context, obj[key], key, obj);
      }
    }
  }
}
function map$4(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }
  if (obj.map && obj.map === nativeMap) {
    return obj.map(cb, context);
  } else {
    var result = [];
    for (var i = 0, len = obj.length; i < len; i++) {
      result.push(cb.call(context, obj[i], i, obj));
    }
    return result;
  }
}
function reduce(obj, cb, memo, context) {
  if (!(obj && cb)) {
    return;
  }
  if (obj.reduce && obj.reduce === nativeReduce) {
    return obj.reduce(cb, memo, context);
  } else {
    for (var i = 0, len = obj.length; i < len; i++) {
      memo = cb.call(context, memo, obj[i], i, obj);
    }
    return memo;
  }
}
function filter$1(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }
  if (obj.filter && obj.filter === nativeFilter) {
    return obj.filter(cb, context);
  } else {
    var result = [];
    for (var i = 0, len = obj.length; i < len; i++) {
      if (cb.call(context, obj[i], i, obj)) {
        result.push(obj[i]);
      }
    }
    return result;
  }
}
function find(obj, cb, context) {
  if (!(obj && cb)) {
    return;
  }
  for (var i = 0, len = obj.length; i < len; i++) {
    if (cb.call(context, obj[i], i, obj)) {
      return obj[i];
    }
  }
}
function bind(func, context) {
  var args = nativeSlice.call(arguments, 2);
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
function curry(func) {
  var args = nativeSlice.call(arguments, 1);
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray$5(value) {
  return objToString.call(value) === "[object Array]";
}
function isFunction$3(value) {
  return typeof value === "function";
}
function isString$5(value) {
  return objToString.call(value) === "[object String]";
}
function isObject$7(value) {
  var type = typeof value;
  return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function eqNaN(value) {
  return value !== value;
}
function retrieve(values) {
  for (var i = 0, len = arguments.length; i < len; i++) {
    if (arguments[i] != null) {
      return arguments[i];
    }
  }
}
function retrieve2$2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3$2(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice() {
  return Function.call.apply(nativeSlice, arguments);
}
function normalizeCssArray$1(val) {
  if (typeof val === "number") {
    return [val, val, val, val];
  }
  var len = val.length;
  if (len === 2) {
    return [val[0], val[1], val[0], val[1]];
  } else if (len === 3) {
    return [val[0], val[1], val[2], val[1]];
  }
  return val;
}
function assert$1(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function trim$2(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
function HashMap(obj) {
  var isArr = isArray$5(obj);
  this.data = {};
  var thisMap = this;
  obj instanceof HashMap ? obj.each(visit) : obj && each$d(obj, visit);
  function visit(value, key) {
    isArr ? thisMap.set(value, key) : thisMap.set(key, value);
  }
}
HashMap.prototype = {
  constructor: HashMap,
  // Do not provide `has` method to avoid defining what is `has`.
  // (We usually treat `null` and `undefined` as the same, different
  // from ES6 Map).
  get: function(key) {
    return this.data.hasOwnProperty(key) ? this.data[key] : null;
  },
  set: function(key, value) {
    return this.data[key] = value;
  },
  // Although util.each can be performed on this hashMap directly, user
  // should not use the exposed keys, who are prefixed.
  each: function(cb, context) {
    context !== void 0 && (cb = bind(cb, context));
    for (var key in this.data) {
      this.data.hasOwnProperty(key) && cb(this.data[key], key);
    }
  },
  // Do not use this method if performance sensitive.
  removeKey: function(key) {
    delete this.data[key];
  }
};
function createHashMap$4(obj) {
  return new HashMap(obj);
}
function concatArray(a, b) {
  var newArray = new a.constructor(a.length + b.length);
  for (var i = 0; i < a.length; i++) {
    newArray[i] = a[i];
  }
  var offset = a.length;
  for (i = 0; i < b.length; i++) {
    newArray[i + offset] = b[i];
  }
  return newArray;
}
function noop$1() {
}
util$6.$override = $override$1;
util$6.clone = clone$2;
util$6.merge = merge$2;
util$6.mergeAll = mergeAll;
util$6.extend = extend$4;
util$6.defaults = defaults$1;
util$6.createCanvas = createCanvas;
util$6.getContext = getContext$1;
util$6.indexOf = indexOf$2;
util$6.inherits = inherits$1;
util$6.mixin = mixin$1;
util$6.isArrayLike = isArrayLike$2;
util$6.each = each$d;
util$6.map = map$4;
util$6.reduce = reduce;
util$6.filter = filter$1;
util$6.find = find;
util$6.bind = bind;
util$6.curry = curry;
util$6.isArray = isArray$5;
util$6.isFunction = isFunction$3;
util$6.isString = isString$5;
util$6.isObject = isObject$7;
util$6.isBuiltInObject = isBuiltInObject;
util$6.isTypedArray = isTypedArray;
util$6.isDom = isDom;
util$6.eqNaN = eqNaN;
util$6.retrieve = retrieve;
util$6.retrieve2 = retrieve2$2;
util$6.retrieve3 = retrieve3$2;
util$6.slice = slice;
util$6.normalizeCssArray = normalizeCssArray$1;
util$6.assert = assert$1;
util$6.trim = trim$2;
util$6.setAsPrimitive = setAsPrimitive;
util$6.isPrimitive = isPrimitive;
util$6.createHashMap = createHashMap$4;
util$6.concatArray = concatArray;
util$6.noop = noop$1;
var vector$2 = {};
var hasRequiredVector;
function requireVector() {
  if (hasRequiredVector)
    return vector$2;
  hasRequiredVector = 1;
  var ArrayCtor = typeof Float32Array === "undefined" ? Array : Float32Array;
  function create(x, y) {
    var out2 = new ArrayCtor(2);
    if (x == null) {
      x = 0;
    }
    if (y == null) {
      y = 0;
    }
    out2[0] = x;
    out2[1] = y;
    return out2;
  }
  function copy(out2, v) {
    out2[0] = v[0];
    out2[1] = v[1];
    return out2;
  }
  function clone2(v) {
    var out2 = new ArrayCtor(2);
    out2[0] = v[0];
    out2[1] = v[1];
    return out2;
  }
  function set2(out2, a, b) {
    out2[0] = a;
    out2[1] = b;
    return out2;
  }
  function add2(out2, v1, v2) {
    out2[0] = v1[0] + v2[0];
    out2[1] = v1[1] + v2[1];
    return out2;
  }
  function scaleAndAdd(out2, v1, v2, a) {
    out2[0] = v1[0] + v2[0] * a;
    out2[1] = v1[1] + v2[1] * a;
    return out2;
  }
  function sub(out2, v1, v2) {
    out2[0] = v1[0] - v2[0];
    out2[1] = v1[1] - v2[1];
    return out2;
  }
  function len(v) {
    return Math.sqrt(lenSquare(v));
  }
  var length = len;
  function lenSquare(v) {
    return v[0] * v[0] + v[1] * v[1];
  }
  var lengthSquare = lenSquare;
  function mul(out2, v1, v2) {
    out2[0] = v1[0] * v2[0];
    out2[1] = v1[1] * v2[1];
    return out2;
  }
  function div(out2, v1, v2) {
    out2[0] = v1[0] / v2[0];
    out2[1] = v1[1] / v2[1];
    return out2;
  }
  function dot(v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1];
  }
  function scale(out2, v, s) {
    out2[0] = v[0] * s;
    out2[1] = v[1] * s;
    return out2;
  }
  function normalize(out2, v) {
    var d = len(v);
    if (d === 0) {
      out2[0] = 0;
      out2[1] = 0;
    } else {
      out2[0] = v[0] / d;
      out2[1] = v[1] / d;
    }
    return out2;
  }
  function distance(v1, v2) {
    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
  }
  var dist2 = distance;
  function distanceSquare(v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
  }
  var distSquare = distanceSquare;
  function negate(out2, v) {
    out2[0] = -v[0];
    out2[1] = -v[1];
    return out2;
  }
  function lerp2(out2, v1, v2, t2) {
    out2[0] = v1[0] + t2 * (v2[0] - v1[0]);
    out2[1] = v1[1] + t2 * (v2[1] - v1[1]);
    return out2;
  }
  function applyTransform2(out2, v, m2) {
    var x = v[0];
    var y = v[1];
    out2[0] = m2[0] * x + m2[2] * y + m2[4];
    out2[1] = m2[1] * x + m2[3] * y + m2[5];
    return out2;
  }
  function min3(out2, v1, v2) {
    out2[0] = Math.min(v1[0], v2[0]);
    out2[1] = Math.min(v1[1], v2[1]);
    return out2;
  }
  function max3(out2, v1, v2) {
    out2[0] = Math.max(v1[0], v2[0]);
    out2[1] = Math.max(v1[1], v2[1]);
    return out2;
  }
  vector$2.create = create;
  vector$2.copy = copy;
  vector$2.clone = clone2;
  vector$2.set = set2;
  vector$2.add = add2;
  vector$2.scaleAndAdd = scaleAndAdd;
  vector$2.sub = sub;
  vector$2.len = len;
  vector$2.length = length;
  vector$2.lenSquare = lenSquare;
  vector$2.lengthSquare = lengthSquare;
  vector$2.mul = mul;
  vector$2.div = div;
  vector$2.dot = dot;
  vector$2.scale = scale;
  vector$2.normalize = normalize;
  vector$2.distance = distance;
  vector$2.dist = dist2;
  vector$2.distanceSquare = distanceSquare;
  vector$2.distSquare = distSquare;
  vector$2.negate = negate;
  vector$2.lerp = lerp2;
  vector$2.applyTransform = applyTransform2;
  vector$2.min = min3;
  vector$2.max = max3;
  return vector$2;
}
function Draggable$1() {
  this.on("mousedown", this._dragStart, this);
  this.on("mousemove", this._drag, this);
  this.on("mouseup", this._dragEnd, this);
}
Draggable$1.prototype = {
  constructor: Draggable$1,
  _dragStart: function(e2) {
    var draggingTarget = e2.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e2.offsetX;
      this._y = e2.offsetY;
      this.dispatchToElement(param(draggingTarget, e2), "dragstart", e2.event);
    }
  },
  _drag: function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      var x = e2.offsetX;
      var y = e2.offsetY;
      var dx = x - this._x;
      var dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e2);
      this.dispatchToElement(param(draggingTarget, e2), "drag", e2.event);
      var dropTarget = this.findHover(x, y, draggingTarget).target;
      var lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(lastDropTarget, e2), "dragleave", e2.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.dispatchToElement(param(dropTarget, e2), "dragenter", e2.event);
        }
      }
    }
  },
  _dragEnd: function(e2) {
    var draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.dispatchToElement(param(draggingTarget, e2), "dragend", e2.event);
    if (this._dropTarget) {
      this.dispatchToElement(param(this._dropTarget, e2), "drop", e2.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  }
};
function param(target, e2) {
  return {
    target,
    topTarget: e2 && e2.topTarget
  };
}
var _default$17 = Draggable$1;
var Draggable_1 = _default$17;
var arrySlice = Array.prototype.slice;
var Eventful$4 = function(eventProcessor) {
  this._$handlers = {};
  this._$eventProcessor = eventProcessor;
};
Eventful$4.prototype = {
  constructor: Eventful$4,
  /**
   * The handler can only be triggered once, then removed.
   *
   * @param {string} event The event name.
   * @param {string|Object} [query] Condition used on event filter.
   * @param {Function} handler The event handler.
   * @param {Object} context
   */
  one: function(event2, query, handler, context) {
    return on(this, event2, query, handler, context, true);
  },
  /**
   * Bind a handler.
   *
   * @param {string} event The event name.
   * @param {string|Object} [query] Condition used on event filter.
   * @param {Function} handler The event handler.
   * @param {Object} [context]
   */
  on: function(event2, query, handler, context) {
    return on(this, event2, query, handler, context, false);
  },
  /**
   * Whether any handler has bound.
   *
   * @param  {string}  event
   * @return {boolean}
   */
  isSilent: function(event2) {
    var _h = this._$handlers;
    return !_h[event2] || !_h[event2].length;
  },
  /**
   * Unbind a event.
   *
   * @param {string} [event] The event name.
   *        If no `event` input, "off" all listeners.
   * @param {Function} [handler] The event handler.
   *        If no `handler` input, "off" all listeners of the `event`.
   */
  off: function(event2, handler) {
    var _h = this._$handlers;
    if (!event2) {
      this._$handlers = {};
      return this;
    }
    if (handler) {
      if (_h[event2]) {
        var newList = [];
        for (var i = 0, l = _h[event2].length; i < l; i++) {
          if (_h[event2][i].h !== handler) {
            newList.push(_h[event2][i]);
          }
        }
        _h[event2] = newList;
      }
      if (_h[event2] && _h[event2].length === 0) {
        delete _h[event2];
      }
    } else {
      delete _h[event2];
    }
    return this;
  },
  /**
   * Dispatch a event.
   *
   * @param {string} type The event name.
   */
  trigger: function(type) {
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var args = arguments;
      var argLen = args.length;
      if (argLen > 3) {
        args = arrySlice.call(args, 1);
      }
      var len = _h.length;
      for (var i = 0; i < len; ) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          i++;
          continue;
        }
        switch (argLen) {
          case 1:
            hItem.h.call(hItem.ctx);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[1]);
            break;
          case 3:
            hItem.h.call(hItem.ctx, args[1], args[2]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
        if (hItem.one) {
          _h.splice(i, 1);
          len--;
        } else {
          i++;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  },
  /**
   * Dispatch a event with context, which is specified at the last parameter.
   *
   * @param {string} type The event name.
   */
  triggerWithContext: function(type) {
    var _h = this._$handlers[type];
    var eventProcessor = this._$eventProcessor;
    if (_h) {
      var args = arguments;
      var argLen = args.length;
      if (argLen > 4) {
        args = arrySlice.call(args, 1, args.length - 1);
      }
      var ctx = args[args.length - 1];
      var len = _h.length;
      for (var i = 0; i < len; ) {
        var hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          i++;
          continue;
        }
        switch (argLen) {
          case 1:
            hItem.h.call(ctx);
            break;
          case 2:
            hItem.h.call(ctx, args[1]);
            break;
          case 3:
            hItem.h.call(ctx, args[1], args[2]);
            break;
          default:
            hItem.h.apply(ctx, args);
            break;
        }
        if (hItem.one) {
          _h.splice(i, 1);
          len--;
        } else {
          i++;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  }
};
function normalizeQuery(host2, query) {
  var eventProcessor = host2._$eventProcessor;
  if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
    query = eventProcessor.normalizeQuery(query);
  }
  return query;
}
function on(eventful, event2, query, handler, context, isOnce) {
  var _h = eventful._$handlers;
  if (typeof query === "function") {
    context = handler;
    handler = query;
    query = null;
  }
  if (!handler || !event2) {
    return eventful;
  }
  query = normalizeQuery(eventful, query);
  if (!_h[event2]) {
    _h[event2] = [];
  }
  for (var i = 0; i < _h[event2].length; i++) {
    if (_h[event2][i].h === handler) {
      return eventful;
    }
  }
  var wrap = {
    h: handler,
    one: isOnce,
    query,
    ctx: context || eventful,
    // FIXME
    // Do not publish this feature util it is proved that it makes sense.
    callAtLast: handler.zrEventfulCallAtLast
  };
  var lastIndex = _h[event2].length - 1;
  var lastWrap = _h[event2][lastIndex];
  lastWrap && lastWrap.callAtLast ? _h[event2].splice(lastIndex, 0, wrap) : _h[event2].push(wrap);
  return eventful;
}
var _default$16 = Eventful$4;
var Eventful_1 = _default$16;
var event = {};
var dom = {};
var fourPointsTransform = {};
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  var cacheKey = rowMask + "-" + colMask;
  var fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank === 1) {
    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  var subRowMask = rowMask | 1 << rowStart;
  var subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  var sum = 0;
  for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
    var colTag = 1 << j;
    if (!(colTag & colMask)) {
      sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum;
  return sum;
}
function buildTransformer$1(src, dest) {
  var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];
  var detCache = {};
  var det = determinant(mA, 8, 0, 0, 0, detCache);
  if (det === 0) {
    return;
  }
  var vh = [];
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      vh[j] == null && (vh[j] = 0);
      vh[j] += ((i + j) % 2 ? -1 : 1) * // det(subMatrix(i, j))
      determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}
fourPointsTransform.buildTransformer = buildTransformer$1;
var env$8 = env_1;
var _fourPointsTransform = fourPointsTransform;
var buildTransformer = _fourPointsTransform.buildTransformer;
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut$1 = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport$1(_calcOut$1, elFrom, inX, inY, true) && transformCoordWithViewport$1(out2, elTarget, _calcOut$1[0], _calcOut$1[1]);
}
function transformCoordWithViewport$1(out2, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env$8.domSupported && !isCanvasEl$1(el)) {
    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    var markers = prepareCoordMarkers(el, saved);
    var transformer = preparePointerTransformer(markers, saved, inverse);
    if (transformer) {
      transformer(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el, saved) {
  var markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  var propLR = ["left", "right"];
  var propTB = ["top", "bottom"];
  for (var i = 0; i < 4; i++) {
    var marker = document.createElement("div");
    var stl = marker.style;
    var idxLR = i % 2;
    var idxTB = (i >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      // 'width: 5px',
      // 'height: 5px',
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el.appendChild(marker);
    markers.push(marker);
  }
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  var transformerName = inverse ? "invTrans" : "trans";
  var transformer = saved[transformerName];
  var oldSrcCoords = saved.srcCoords;
  var oldCoordTheSame = true;
  var srcCoords = [];
  var destCoords = [];
  for (var i = 0; i < 4; i++) {
    var rect = markers[i].getBoundingClientRect();
    var ii = 2 * i;
    var x = rect.left;
    var y = rect.top;
    srcCoords.push(x, y);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
  }
  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl$1(el) {
  return el.nodeName.toUpperCase() === "CANVAS";
}
dom.transformLocalCoord = transformLocalCoord;
dom.transformCoordWithViewport = transformCoordWithViewport$1;
dom.isCanvasEl = isCanvasEl$1;
var Eventful$3 = Eventful_1;
event.Dispatcher = Eventful$3;
var env$7 = env_1;
var _dom = dom;
var isCanvasEl = _dom.isCanvasEl;
var transformCoordWithViewport = _dom.transformCoordWithViewport;
var isDomLevel2 = typeof window !== "undefined" && !!window.addEventListener;
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut = [];
function clientToLocal(el, e2, out2, calculate) {
  out2 = out2 || {};
  if (calculate || !env$7.canvasSupported) {
    calculateZrXY(el, e2, out2);
  } else if (env$7.browser.firefox && e2.layerX != null && e2.layerX !== e2.offsetX) {
    out2.zrX = e2.layerX;
    out2.zrY = e2.layerY;
  } else if (e2.offsetX != null) {
    out2.zrX = e2.offsetX;
    out2.zrY = e2.offsetY;
  } else {
    calculateZrXY(el, e2, out2);
  }
  return out2;
}
function calculateZrXY(el, e2, out2) {
  if (env$7.domSupported && el.getBoundingClientRect) {
    var ex = e2.clientX;
    var ey = e2.clientY;
    if (isCanvasEl(el)) {
      var box2 = el.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {
        out2.zrX = _calcOut[0];
        out2.zrY = _calcOut[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent$1(e2) {
  return e2 || window.event;
}
function normalizeEvent$1(el, e2, calculate) {
  e2 = getNativeEvent$1(e2);
  if (e2.zrX != null) {
    return e2;
  }
  var eventType = e2.type;
  var isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el, e2, e2, calculate);
    e2.zrDelta = e2.wheelDelta ? e2.wheelDelta / 120 : -(e2.detail || 0) / 3;
  } else {
    var touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
    touch && clientToLocal(el, touch, e2, calculate);
  }
  var button = e2.button;
  if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
    e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e2;
}
function addEventListener$1(el, name2, handler, opt) {
  if (isDomLevel2) {
    el.addEventListener(name2, handler, opt);
  } else {
    el.attachEvent("on" + name2, handler);
  }
}
function removeEventListener$1(el, name2, handler, opt) {
  if (isDomLevel2) {
    el.removeEventListener(name2, handler, opt);
  } else {
    el.detachEvent("on" + name2, handler);
  }
}
var stop = isDomLevel2 ? function(e2) {
  e2.preventDefault();
  e2.stopPropagation();
  e2.cancelBubble = true;
} : function(e2) {
  e2.returnValue = false;
  e2.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e2) {
  return e2.which === 2 || e2.which === 3;
}
function notLeftMouse(e2) {
  return e2.which > 1;
}
event.clientToLocal = clientToLocal;
event.getNativeEvent = getNativeEvent$1;
event.normalizeEvent = normalizeEvent$1;
event.addEventListener = addEventListener$1;
event.removeEventListener = removeEventListener$1;
event.stop = stop;
event.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;
event.notLeftMouse = notLeftMouse;
var eventUtil = event;
var GestureMgr$1 = function() {
  this._track = [];
};
GestureMgr$1.prototype = {
  constructor: GestureMgr$1,
  recognize: function(event2, target, root) {
    this._doTrack(event2, target, root);
    return this._recognize(event2);
  },
  clear: function() {
    this._track.length = 0;
    return this;
  },
  _doTrack: function(event2, target, root) {
    var touches = event2.touches;
    if (!touches) {
      return;
    }
    var trackItem = {
      points: [],
      touches: [],
      target,
      event: event2
    };
    for (var i = 0, len = touches.length; i < len; i++) {
      var touch = touches[i];
      var pos = eventUtil.clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  },
  _recognize: function(event2) {
    for (var eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        var gestureInfo = recognizers[eventName](this._track, event2);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  }
};
function dist(pointPair) {
  var dx = pointPair[1][0] - pointPair[0][0];
  var dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center(pointPair) {
  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];
}
var recognizers = {
  pinch: function(track2, event2) {
    var trackLen = track2.length;
    if (!trackLen) {
      return;
    }
    var pinchEnd = (track2[trackLen - 1] || {}).points;
    var pinchPre = (track2[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      var pinchScale = dist(pinchEnd) / dist(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event2.pinchScale = pinchScale;
      var pinchCenter = center(pinchEnd);
      event2.pinchX = pinchCenter[0];
      event2.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: track2[0].target,
        event: event2
      };
    }
  }
  // Only pinch currently.
};
var _default$15 = GestureMgr$1;
var GestureMgr_1 = _default$15;
var util$5 = util$6;
var vec2$3 = requireVector();
var Draggable = Draggable_1;
var Eventful$2 = Eventful_1;
var eventTool = event;
var GestureMgr = GestureMgr_1;
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event2) {
  return {
    type: eveType,
    event: event2,
    // target can only be an element that is not silent.
    target: targetInfo.target,
    // topTarget can be a silent element.
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event2.zrX,
    offsetY: event2.zrY,
    gestureEvent: event2.gestureEvent,
    pinchX: event2.pinchX,
    pinchY: event2.pinchY,
    pinchScale: event2.pinchScale,
    wheelDelta: event2.zrDelta,
    zrByTouch: event2.zrByTouch,
    which: event2.which,
    stop: stopEvent
  };
}
function stopEvent() {
  eventTool.stop(this.event);
}
function EmptyProxy() {
}
EmptyProxy.prototype.dispose = function() {
};
var handlerNames = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
var Handler$1 = function(storage2, painter, proxy, painterRoot) {
  Eventful$2.call(this);
  this.storage = storage2;
  this.painter = painter;
  this.painterRoot = painterRoot;
  proxy = proxy || new EmptyProxy();
  this.proxy = null;
  this._hovered = {};
  this._lastTouchMoment;
  this._lastX;
  this._lastY;
  this._gestureMgr;
  Draggable.call(this);
  this.setHandlerProxy(proxy);
};
Handler$1.prototype = {
  constructor: Handler$1,
  setHandlerProxy: function(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      util$5.each(handlerNames, function(name2) {
        proxy.on && proxy.on(name2, this[name2], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  },
  mousemove: function(event2) {
    var x = event2.zrX;
    var y = event2.zrY;
    var isOutside = isOutsideBoundary(this, x, y);
    var lastHovered = this._hovered;
    var lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    var hovered = this._hovered = isOutside ? {
      x,
      y
    } : this.findHover(x, y);
    var hoveredTarget = hovered.target;
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event2);
    }
    this.dispatchToElement(hovered, "mousemove", event2);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event2);
    }
  },
  mouseout: function(event2) {
    var eventControl = event2.zrEventControl;
    var zrIsToLocalDOM = event2.zrIsToLocalDOM;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event2);
    }
    if (eventControl !== "no_globalout") {
      !zrIsToLocalDOM && this.trigger("globalout", {
        type: "globalout",
        event: event2
      });
    }
  },
  /**
   * Resize
   */
  resize: function(event2) {
    this._hovered = {};
  },
  /**
   * Dispatch event
   * @param {string} eventName
   * @param {event=} eventArgs
   */
  dispatch: function(eventName, eventArgs) {
    var handler = this[eventName];
    handler && handler.call(this, eventArgs);
  },
  /**
   * Dispose
   */
  dispose: function() {
    this.proxy.dispose();
    this.storage = this.proxy = this.painter = null;
  },
  /**
   * 设置默认的cursor style
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function(cursorStyle) {
    var proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  },
  /**
   * 事件分发代理
   *
   * @private
   * @param {Object} targetInfo {target, topTarget} 目标图形元素
   * @param {string} eventName 事件名称
   * @param {Object} event 事件对象
   */
  dispatchToElement: function(targetInfo, eventName, event2) {
    targetInfo = targetInfo || {};
    var el = targetInfo.target;
    if (el && el.silent) {
      return;
    }
    var eventHandler = "on" + eventName;
    var eventPacket = makeEventPacket(eventName, targetInfo, event2);
    while (el) {
      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      this.painter && this.painter.eachOtherLayer(function(layer) {
        if (typeof layer[eventHandler] === "function") {
          layer[eventHandler].call(layer, eventPacket);
        }
        if (layer.trigger) {
          layer.trigger(eventName, eventPacket);
        }
      });
    }
  },
  /**
   * @private
   * @param {number} x
   * @param {number} y
   * @param {module:zrender/graphic/Displayable} exclude
   * @return {model:zrender/Element}
   * @method
   */
  findHover: function(x, y, exclude) {
    var list = this.storage.getDisplayList();
    var out2 = {
      x,
      y
    };
    for (var i = list.length - 1; i >= 0; i--) {
      var hoverCheckResult;
      if (list[i] !== exclude && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {
        !out2.topTarget && (out2.topTarget = list[i]);
        if (hoverCheckResult !== SILENT) {
          out2.target = list[i];
          break;
        }
      }
    }
    return out2;
  },
  processGesture: function(event2, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }
    var gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    var gestureInfo = gestureMgr.recognize(event2, this.findHover(event2.zrX, event2.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      var type = gestureInfo.type;
      event2.gestureEvent = type;
      this.dispatchToElement({
        target: gestureInfo.target
      }, type, gestureInfo.event);
    }
  }
};
util$5.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name2) {
  Handler$1.prototype[name2] = function(event2) {
    var x = event2.zrX;
    var y = event2.zrY;
    var isOutside = isOutsideBoundary(this, x, y);
    var hovered;
    var hoveredTarget;
    if (name2 !== "mouseup" || !isOutside) {
      hovered = this.findHover(x, y);
      hoveredTarget = hovered.target;
    }
    if (name2 === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event2.zrX, event2.zrY];
      this._upEl = hoveredTarget;
    } else if (name2 === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name2 === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || vec2$3.dist(this._downPoint, [event2.zrX, event2.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name2, event2);
  };
});
function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
    var el = displayable;
    var isSilent;
    while (el) {
      if (el.clipPath && !el.clipPath.contain(x, y)) {
        return false;
      }
      if (el.silent) {
        isSilent = true;
      }
      el = el.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function isOutsideBoundary(handlerInstance, x, y) {
  var painter = handlerInstance.painter;
  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
}
util$5.mixin(Handler$1, Eventful$2);
util$5.mixin(Handler$1, Draggable);
var _default$14 = Handler$1;
var Handler_1 = _default$14;
var matrix$4 = {};
var hasRequiredMatrix;
function requireMatrix() {
  if (hasRequiredMatrix)
    return matrix$4;
  hasRequiredMatrix = 1;
  var ArrayCtor = typeof Float32Array === "undefined" ? Array : Float32Array;
  function create() {
    var out2 = new ArrayCtor(6);
    identity(out2);
    return out2;
  }
  function identity(out2) {
    out2[0] = 1;
    out2[1] = 0;
    out2[2] = 0;
    out2[3] = 1;
    out2[4] = 0;
    out2[5] = 0;
    return out2;
  }
  function copy(out2, m2) {
    out2[0] = m2[0];
    out2[1] = m2[1];
    out2[2] = m2[2];
    out2[3] = m2[3];
    out2[4] = m2[4];
    out2[5] = m2[5];
    return out2;
  }
  function mul(out2, m1, m2) {
    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
    var out22 = m1[0] * m2[2] + m1[2] * m2[3];
    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
    out2[0] = out0;
    out2[1] = out1;
    out2[2] = out22;
    out2[3] = out3;
    out2[4] = out4;
    out2[5] = out5;
    return out2;
  }
  function translate(out2, a, v) {
    out2[0] = a[0];
    out2[1] = a[1];
    out2[2] = a[2];
    out2[3] = a[3];
    out2[4] = a[4] + v[0];
    out2[5] = a[5] + v[1];
    return out2;
  }
  function rotate(out2, a, rad) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var st = Math.sin(rad);
    var ct = Math.cos(rad);
    out2[0] = aa * ct + ab * st;
    out2[1] = -aa * st + ab * ct;
    out2[2] = ac * ct + ad * st;
    out2[3] = -ac * st + ct * ad;
    out2[4] = ct * atx + st * aty;
    out2[5] = ct * aty - st * atx;
    return out2;
  }
  function scale(out2, a, v) {
    var vx = v[0];
    var vy = v[1];
    out2[0] = a[0] * vx;
    out2[1] = a[1] * vy;
    out2[2] = a[2] * vx;
    out2[3] = a[3] * vy;
    out2[4] = a[4] * vx;
    out2[5] = a[5] * vy;
    return out2;
  }
  function invert(out2, a) {
    var aa = a[0];
    var ac = a[2];
    var atx = a[4];
    var ab = a[1];
    var ad = a[3];
    var aty = a[5];
    var det = aa * ad - ab * ac;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out2[0] = ad * det;
    out2[1] = -ab * det;
    out2[2] = -ac * det;
    out2[3] = aa * det;
    out2[4] = (ac * aty - ad * atx) * det;
    out2[5] = (ab * atx - aa * aty) * det;
    return out2;
  }
  function clone2(a) {
    var b = create();
    copy(b, a);
    return b;
  }
  matrix$4.create = create;
  matrix$4.identity = identity;
  matrix$4.copy = copy;
  matrix$4.mul = mul;
  matrix$4.translate = translate;
  matrix$4.rotate = rotate;
  matrix$4.scale = scale;
  matrix$4.invert = invert;
  matrix$4.clone = clone2;
  return matrix$4;
}
var matrix$3 = requireMatrix();
var vector$1 = requireVector();
var mIdentity = matrix$3.identity;
var EPSILON$2 = 5e-5;
function isNotAroundZero$1(val) {
  return val > EPSILON$2 || val < -EPSILON$2;
}
var Transformable$2 = function(opts) {
  opts = opts || {};
  if (!opts.position) {
    this.position = [0, 0];
  }
  if (opts.rotation == null) {
    this.rotation = 0;
  }
  if (!opts.scale) {
    this.scale = [1, 1];
  }
  this.origin = this.origin || null;
};
var transformableProto = Transformable$2.prototype;
transformableProto.transform = null;
transformableProto.needLocalTransform = function() {
  return isNotAroundZero$1(this.rotation) || isNotAroundZero$1(this.position[0]) || isNotAroundZero$1(this.position[1]) || isNotAroundZero$1(this.scale[0] - 1) || isNotAroundZero$1(this.scale[1] - 1);
};
var scaleTmp = [];
transformableProto.updateTransform = function() {
  var parent = this.parent;
  var parentHasTransform = parent && parent.transform;
  var needLocalTransform = this.needLocalTransform();
  var m2 = this.transform;
  if (!(needLocalTransform || parentHasTransform)) {
    m2 && mIdentity(m2);
    return;
  }
  m2 = m2 || matrix$3.create();
  if (needLocalTransform) {
    this.getLocalTransform(m2);
  } else {
    mIdentity(m2);
  }
  if (parentHasTransform) {
    if (needLocalTransform) {
      matrix$3.mul(m2, parent.transform, m2);
    } else {
      matrix$3.copy(m2, parent.transform);
    }
  }
  this.transform = m2;
  var globalScaleRatio = this.globalScaleRatio;
  if (globalScaleRatio != null && globalScaleRatio !== 1) {
    this.getGlobalScale(scaleTmp);
    var relX = scaleTmp[0] < 0 ? -1 : 1;
    var relY = scaleTmp[1] < 0 ? -1 : 1;
    var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
    var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
    m2[0] *= sx;
    m2[1] *= sx;
    m2[2] *= sy;
    m2[3] *= sy;
  }
  this.invTransform = this.invTransform || matrix$3.create();
  matrix$3.invert(this.invTransform, m2);
};
transformableProto.getLocalTransform = function(m2) {
  return Transformable$2.getLocalTransform(this, m2);
};
transformableProto.setTransform = function(ctx) {
  var m2 = this.transform;
  var dpr2 = ctx.dpr || 1;
  if (m2) {
    ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
};
transformableProto.restoreTransform = function(ctx) {
  var dpr2 = ctx.dpr || 1;
  ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
};
var tmpTransform = [];
var originTransform = matrix$3.create();
transformableProto.setLocalTransform = function(m2) {
  if (!m2) {
    return;
  }
  var sx = m2[0] * m2[0] + m2[1] * m2[1];
  var sy = m2[2] * m2[2] + m2[3] * m2[3];
  var position = this.position;
  var scale = this.scale;
  if (isNotAroundZero$1(sx - 1)) {
    sx = Math.sqrt(sx);
  }
  if (isNotAroundZero$1(sy - 1)) {
    sy = Math.sqrt(sy);
  }
  if (m2[0] < 0) {
    sx = -sx;
  }
  if (m2[3] < 0) {
    sy = -sy;
  }
  position[0] = m2[4];
  position[1] = m2[5];
  scale[0] = sx;
  scale[1] = sy;
  this.rotation = Math.atan2(-m2[1] / sy, m2[0] / sx);
};
transformableProto.decomposeTransform = function() {
  if (!this.transform) {
    return;
  }
  var parent = this.parent;
  var m2 = this.transform;
  if (parent && parent.transform) {
    matrix$3.mul(tmpTransform, parent.invTransform, m2);
    m2 = tmpTransform;
  }
  var origin = this.origin;
  if (origin && (origin[0] || origin[1])) {
    originTransform[4] = origin[0];
    originTransform[5] = origin[1];
    matrix$3.mul(tmpTransform, m2, originTransform);
    tmpTransform[4] -= origin[0];
    tmpTransform[5] -= origin[1];
    m2 = tmpTransform;
  }
  this.setLocalTransform(m2);
};
transformableProto.getGlobalScale = function(out2) {
  var m2 = this.transform;
  out2 = out2 || [];
  if (!m2) {
    out2[0] = 1;
    out2[1] = 1;
    return out2;
  }
  out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
  out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
  if (m2[0] < 0) {
    out2[0] = -out2[0];
  }
  if (m2[3] < 0) {
    out2[1] = -out2[1];
  }
  return out2;
};
transformableProto.transformCoordToLocal = function(x, y) {
  var v2 = [x, y];
  var invTransform = this.invTransform;
  if (invTransform) {
    vector$1.applyTransform(v2, v2, invTransform);
  }
  return v2;
};
transformableProto.transformCoordToGlobal = function(x, y) {
  var v2 = [x, y];
  var transform = this.transform;
  if (transform) {
    vector$1.applyTransform(v2, v2, transform);
  }
  return v2;
};
Transformable$2.getLocalTransform = function(target, m2) {
  m2 = m2 || [];
  mIdentity(m2);
  var origin = target.origin;
  var scale = target.scale || [1, 1];
  var rotation = target.rotation || 0;
  var position = target.position || [0, 0];
  if (origin) {
    m2[4] -= origin[0];
    m2[5] -= origin[1];
  }
  matrix$3.scale(m2, m2, scale);
  if (rotation) {
    matrix$3.rotate(m2, m2, rotation);
  }
  if (origin) {
    m2[4] += origin[0];
    m2[5] += origin[1];
  }
  m2[4] += position[0];
  m2[5] += position[1];
  return m2;
};
var _default$13 = Transformable$2;
var Transformable_1 = _default$13;
var easing = {
  /**
  * @param {number} k
  * @return {number}
  */
  linear: function(k) {
    return k;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  quadraticIn: function(k) {
    return k * k;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  quadraticOut: function(k) {
    return k * (2 - k);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  quadraticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  },
  // 三次方的缓动（t^3）
  /**
  * @param {number} k
  * @return {number}
  */
  cubicIn: function(k) {
    return k * k * k;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  cubicOut: function(k) {
    return --k * k * k + 1;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  cubicInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k + 2);
  },
  // 四次方的缓动（t^4）
  /**
  * @param {number} k
  * @return {number}
  */
  quarticIn: function(k) {
    return k * k * k * k;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  quarticOut: function(k) {
    return 1 - --k * k * k * k;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  quarticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }
    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  // 五次方的缓动（t^5）
  /**
  * @param {number} k
  * @return {number}
  */
  quinticIn: function(k) {
    return k * k * k * k * k;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  quinticOut: function(k) {
    return --k * k * k * k * k + 1;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  quinticInOut: function(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  // 正弦曲线的缓动（sin(t)）
  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalIn: function(k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalOut: function(k) {
    return Math.sin(k * Math.PI / 2);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  sinusoidalInOut: function(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  // 指数曲线的缓动（2^t）
  /**
  * @param {number} k
  * @return {number}
  */
  exponentialIn: function(k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  exponentialOut: function(k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  exponentialInOut: function(k) {
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  // 圆形曲线的缓动（sqrt(1-t^2)）
  /**
  * @param {number} k
  * @return {number}
  */
  circularIn: function(k) {
    return 1 - Math.sqrt(1 - k * k);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  circularOut: function(k) {
    return Math.sqrt(1 - --k * k);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  circularInOut: function(k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  // 创建类似于弹簧在停止前来回振荡的动画
  /**
  * @param {number} k
  * @return {number}
  */
  elasticIn: function(k) {
    var s;
    var a = 0.1;
    var p2 = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p2 / 4;
    } else {
      s = p2 * Math.asin(1 / a) / (2 * Math.PI);
    }
    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p2));
  },
  /**
  * @param {number} k
  * @return {number}
  */
  elasticOut: function(k) {
    var s;
    var a = 0.1;
    var p2 = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p2 / 4;
    } else {
      s = p2 * Math.asin(1 / a) / (2 * Math.PI);
    }
    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p2) + 1;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  elasticInOut: function(k) {
    var s;
    var a = 0.1;
    var p2 = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p2 / 4;
    } else {
      s = p2 * Math.asin(1 / a) / (2 * Math.PI);
    }
    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p2));
    }
    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p2) * 0.5 + 1;
  },
  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
  /**
  * @param {number} k
  * @return {number}
  */
  backIn: function(k) {
    var s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  backOut: function(k) {
    var s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },
  /**
  * @param {number} k
  * @return {number}
  */
  backInOut: function(k) {
    var s = 1.70158 * 1.525;
    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }
    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  // 创建弹跳效果
  /**
  * @param {number} k
  * @return {number}
  */
  bounceIn: function(k) {
    return 1 - easing.bounceOut(1 - k);
  },
  /**
  * @param {number} k
  * @return {number}
  */
  bounceOut: function(k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },
  /**
  * @param {number} k
  * @return {number}
  */
  bounceInOut: function(k) {
    if (k < 0.5) {
      return easing.bounceIn(k * 2) * 0.5;
    }
    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var _default$12 = easing;
var easing_1 = _default$12;
var easingFuncs = easing_1;
function Clip$1(options) {
  this._target = options.target;
  this._life = options.life || 1e3;
  this._delay = options.delay || 0;
  this._initialized = false;
  this.loop = options.loop == null ? false : options.loop;
  this.gap = options.gap || 0;
  this.easing = options.easing || "Linear";
  this.onframe = options.onframe;
  this.ondestroy = options.ondestroy;
  this.onrestart = options.onrestart;
  this._pausedTime = 0;
  this._paused = false;
}
Clip$1.prototype = {
  constructor: Clip$1,
  step: function(globalTime, deltaTime) {
    if (!this._initialized) {
      this._startTime = globalTime + this._delay;
      this._initialized = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    var percent = (globalTime - this._startTime - this._pausedTime) / this._life;
    if (percent < 0) {
      return;
    }
    percent = Math.min(percent, 1);
    var easing2 = this.easing;
    var easingFunc = typeof easing2 === "string" ? easingFuncs[easing2] : easing2;
    var schedule = typeof easingFunc === "function" ? easingFunc(percent) : percent;
    this.fire("frame", schedule);
    if (percent === 1) {
      if (this.loop) {
        this.restart(globalTime);
        return "restart";
      }
      this._needsRemove = true;
      return "destroy";
    }
    return null;
  },
  restart: function(globalTime) {
    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
    this._startTime = globalTime - remainder + this.gap;
    this._pausedTime = 0;
    this._needsRemove = false;
  },
  fire: function(eventType, arg) {
    eventType = "on" + eventType;
    if (this[eventType]) {
      this[eventType](this._target, arg);
    }
  },
  pause: function() {
    this._paused = true;
  },
  resume: function() {
    this._paused = false;
  }
};
var _default$11 = Clip$1;
var Clip_1 = _default$11;
var color$1 = {};
var LinkedList = function() {
  this.head = null;
  this.tail = null;
  this._len = 0;
};
var linkedListProto = LinkedList.prototype;
linkedListProto.insert = function(val) {
  var entry = new Entry(val);
  this.insertEntry(entry);
  return entry;
};
linkedListProto.insertEntry = function(entry) {
  if (!this.head) {
    this.head = this.tail = entry;
  } else {
    this.tail.next = entry;
    entry.prev = this.tail;
    entry.next = null;
    this.tail = entry;
  }
  this._len++;
};
linkedListProto.remove = function(entry) {
  var prev = entry.prev;
  var next = entry.next;
  if (prev) {
    prev.next = next;
  } else {
    this.head = next;
  }
  if (next) {
    next.prev = prev;
  } else {
    this.tail = prev;
  }
  entry.next = entry.prev = null;
  this._len--;
};
linkedListProto.len = function() {
  return this._len;
};
linkedListProto.clear = function() {
  this.head = this.tail = null;
  this._len = 0;
};
var Entry = function(val) {
  this.value = val;
  this.next;
  this.prev;
};
var LRU$2 = function(maxSize) {
  this._list = new LinkedList();
  this._map = {};
  this._maxSize = maxSize || 10;
  this._lastRemovedEntry = null;
};
var LRUProto = LRU$2.prototype;
LRUProto.put = function(key, value) {
  var list = this._list;
  var map2 = this._map;
  var removed = null;
  if (map2[key] == null) {
    var len = list.len();
    var entry = this._lastRemovedEntry;
    if (len >= this._maxSize && len > 0) {
      var leastUsedEntry = list.head;
      list.remove(leastUsedEntry);
      delete map2[leastUsedEntry.key];
      removed = leastUsedEntry.value;
      this._lastRemovedEntry = leastUsedEntry;
    }
    if (entry) {
      entry.value = value;
    } else {
      entry = new Entry(value);
    }
    entry.key = key;
    list.insertEntry(entry);
    map2[key] = entry;
  }
  return removed;
};
LRUProto.get = function(key) {
  var entry = this._map[key];
  var list = this._list;
  if (entry != null) {
    if (entry !== list.tail) {
      list.remove(entry);
      list.insertEntry(entry);
    }
    return entry.value;
  }
};
LRUProto.clear = function() {
  this._list.clear();
  this._map = {};
};
var _default$10 = LRU$2;
var LRU_1 = _default$10;
var LRU$1 = LRU_1;
var kCSSColorTable = {
  "transparent": [0, 0, 0, 0],
  "aliceblue": [240, 248, 255, 1],
  "antiquewhite": [250, 235, 215, 1],
  "aqua": [0, 255, 255, 1],
  "aquamarine": [127, 255, 212, 1],
  "azure": [240, 255, 255, 1],
  "beige": [245, 245, 220, 1],
  "bisque": [255, 228, 196, 1],
  "black": [0, 0, 0, 1],
  "blanchedalmond": [255, 235, 205, 1],
  "blue": [0, 0, 255, 1],
  "blueviolet": [138, 43, 226, 1],
  "brown": [165, 42, 42, 1],
  "burlywood": [222, 184, 135, 1],
  "cadetblue": [95, 158, 160, 1],
  "chartreuse": [127, 255, 0, 1],
  "chocolate": [210, 105, 30, 1],
  "coral": [255, 127, 80, 1],
  "cornflowerblue": [100, 149, 237, 1],
  "cornsilk": [255, 248, 220, 1],
  "crimson": [220, 20, 60, 1],
  "cyan": [0, 255, 255, 1],
  "darkblue": [0, 0, 139, 1],
  "darkcyan": [0, 139, 139, 1],
  "darkgoldenrod": [184, 134, 11, 1],
  "darkgray": [169, 169, 169, 1],
  "darkgreen": [0, 100, 0, 1],
  "darkgrey": [169, 169, 169, 1],
  "darkkhaki": [189, 183, 107, 1],
  "darkmagenta": [139, 0, 139, 1],
  "darkolivegreen": [85, 107, 47, 1],
  "darkorange": [255, 140, 0, 1],
  "darkorchid": [153, 50, 204, 1],
  "darkred": [139, 0, 0, 1],
  "darksalmon": [233, 150, 122, 1],
  "darkseagreen": [143, 188, 143, 1],
  "darkslateblue": [72, 61, 139, 1],
  "darkslategray": [47, 79, 79, 1],
  "darkslategrey": [47, 79, 79, 1],
  "darkturquoise": [0, 206, 209, 1],
  "darkviolet": [148, 0, 211, 1],
  "deeppink": [255, 20, 147, 1],
  "deepskyblue": [0, 191, 255, 1],
  "dimgray": [105, 105, 105, 1],
  "dimgrey": [105, 105, 105, 1],
  "dodgerblue": [30, 144, 255, 1],
  "firebrick": [178, 34, 34, 1],
  "floralwhite": [255, 250, 240, 1],
  "forestgreen": [34, 139, 34, 1],
  "fuchsia": [255, 0, 255, 1],
  "gainsboro": [220, 220, 220, 1],
  "ghostwhite": [248, 248, 255, 1],
  "gold": [255, 215, 0, 1],
  "goldenrod": [218, 165, 32, 1],
  "gray": [128, 128, 128, 1],
  "green": [0, 128, 0, 1],
  "greenyellow": [173, 255, 47, 1],
  "grey": [128, 128, 128, 1],
  "honeydew": [240, 255, 240, 1],
  "hotpink": [255, 105, 180, 1],
  "indianred": [205, 92, 92, 1],
  "indigo": [75, 0, 130, 1],
  "ivory": [255, 255, 240, 1],
  "khaki": [240, 230, 140, 1],
  "lavender": [230, 230, 250, 1],
  "lavenderblush": [255, 240, 245, 1],
  "lawngreen": [124, 252, 0, 1],
  "lemonchiffon": [255, 250, 205, 1],
  "lightblue": [173, 216, 230, 1],
  "lightcoral": [240, 128, 128, 1],
  "lightcyan": [224, 255, 255, 1],
  "lightgoldenrodyellow": [250, 250, 210, 1],
  "lightgray": [211, 211, 211, 1],
  "lightgreen": [144, 238, 144, 1],
  "lightgrey": [211, 211, 211, 1],
  "lightpink": [255, 182, 193, 1],
  "lightsalmon": [255, 160, 122, 1],
  "lightseagreen": [32, 178, 170, 1],
  "lightskyblue": [135, 206, 250, 1],
  "lightslategray": [119, 136, 153, 1],
  "lightslategrey": [119, 136, 153, 1],
  "lightsteelblue": [176, 196, 222, 1],
  "lightyellow": [255, 255, 224, 1],
  "lime": [0, 255, 0, 1],
  "limegreen": [50, 205, 50, 1],
  "linen": [250, 240, 230, 1],
  "magenta": [255, 0, 255, 1],
  "maroon": [128, 0, 0, 1],
  "mediumaquamarine": [102, 205, 170, 1],
  "mediumblue": [0, 0, 205, 1],
  "mediumorchid": [186, 85, 211, 1],
  "mediumpurple": [147, 112, 219, 1],
  "mediumseagreen": [60, 179, 113, 1],
  "mediumslateblue": [123, 104, 238, 1],
  "mediumspringgreen": [0, 250, 154, 1],
  "mediumturquoise": [72, 209, 204, 1],
  "mediumvioletred": [199, 21, 133, 1],
  "midnightblue": [25, 25, 112, 1],
  "mintcream": [245, 255, 250, 1],
  "mistyrose": [255, 228, 225, 1],
  "moccasin": [255, 228, 181, 1],
  "navajowhite": [255, 222, 173, 1],
  "navy": [0, 0, 128, 1],
  "oldlace": [253, 245, 230, 1],
  "olive": [128, 128, 0, 1],
  "olivedrab": [107, 142, 35, 1],
  "orange": [255, 165, 0, 1],
  "orangered": [255, 69, 0, 1],
  "orchid": [218, 112, 214, 1],
  "palegoldenrod": [238, 232, 170, 1],
  "palegreen": [152, 251, 152, 1],
  "paleturquoise": [175, 238, 238, 1],
  "palevioletred": [219, 112, 147, 1],
  "papayawhip": [255, 239, 213, 1],
  "peachpuff": [255, 218, 185, 1],
  "peru": [205, 133, 63, 1],
  "pink": [255, 192, 203, 1],
  "plum": [221, 160, 221, 1],
  "powderblue": [176, 224, 230, 1],
  "purple": [128, 0, 128, 1],
  "red": [255, 0, 0, 1],
  "rosybrown": [188, 143, 143, 1],
  "royalblue": [65, 105, 225, 1],
  "saddlebrown": [139, 69, 19, 1],
  "salmon": [250, 128, 114, 1],
  "sandybrown": [244, 164, 96, 1],
  "seagreen": [46, 139, 87, 1],
  "seashell": [255, 245, 238, 1],
  "sienna": [160, 82, 45, 1],
  "silver": [192, 192, 192, 1],
  "skyblue": [135, 206, 235, 1],
  "slateblue": [106, 90, 205, 1],
  "slategray": [112, 128, 144, 1],
  "slategrey": [112, 128, 144, 1],
  "snow": [255, 250, 250, 1],
  "springgreen": [0, 255, 127, 1],
  "steelblue": [70, 130, 180, 1],
  "tan": [210, 180, 140, 1],
  "teal": [0, 128, 128, 1],
  "thistle": [216, 191, 216, 1],
  "tomato": [255, 99, 71, 1],
  "turquoise": [64, 224, 208, 1],
  "violet": [238, 130, 238, 1],
  "wheat": [245, 222, 179, 1],
  "white": [255, 255, 255, 1],
  "whitesmoke": [245, 245, 245, 1],
  "yellow": [255, 255, 0, 1],
  "yellowgreen": [154, 205, 50, 1]
};
function clampCssByte(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat(f2) {
  return f2 < 0 ? 0 : f2 > 1 ? 1 : f2;
}
function parseCssInt(str) {
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(str) {
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }
  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }
  if (h * 2 < 1) {
    return m2;
  }
  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }
  return m1;
}
function lerpNumber(a, b, p2) {
  return a + (b - a) * p2;
}
function setRgba(out2, r, g, b, a) {
  out2[0] = r;
  out2[1] = g;
  out2[2] = b;
  out2[3] = a;
  return out2;
}
function copyRgba(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
}
var colorCache = new LRU$1(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  var cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  var str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  if (str.charAt(0) === "#") {
    if (str.length === 4) {
      var iv = parseInt(str.substr(1), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (str.length === 7) {
      var iv = parseInt(str.substr(1), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  var op = str.indexOf("(");
  var ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === str.length) {
    var fname = str.substr(0, op);
    var params = str.substr(op + 1, ep - (op + 1)).split(",");
    var alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba(hsla, rgba) {
  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  var s = parseCssFloat(hsla[1]);
  var l = parseCssFloat(hsla[2]);
  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  }
  var R = rgba[0] / 255;
  var G = rgba[1] / 255;
  var B = rgba[2] / 255;
  var vMin = Math.min(R, G, B);
  var vMax = Math.max(R, G, B);
  var delta = vMax - vMin;
  var L = (vMax + vMin) / 2;
  var H;
  var S;
  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }
    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }
    if (H < 0) {
      H += 1;
    }
    if (H > 1) {
      H -= 1;
    }
  }
  var hsla = [H * 360, S, L];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
function lift(color2, level) {
  var colorArr = parse(color2);
  if (colorArr) {
    for (var i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (color2[i] < 0) {
        colorArr[i] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function toHex(color2) {
  var colorArr = parse(color2);
  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
function fastLerp(normalizedValue, colors, out2) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = colors[leftIndex];
  var rightColor = colors[rightIndex];
  var dv = value - leftIndex;
  out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out2;
}
var fastMapToColor = fastLerp;
function lerp(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  var value = normalizedValue * (colors.length - 1);
  var leftIndex = Math.floor(value);
  var rightIndex = Math.ceil(value);
  var leftColor = parse(colors[leftIndex]);
  var rightColor = parse(colors[rightIndex]);
  var dv = value - leftIndex;
  var color2 = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], "rgba");
  return fullOutput ? {
    color: color2,
    leftIndex,
    rightIndex,
    value
  } : color2;
}
var mapToColor = lerp;
function modifyHSL(color2, h, s, l) {
  color2 = parse(color2);
  if (color2) {
    color2 = rgba2hsla(color2);
    h != null && (color2[0] = clampCssAngle(h));
    s != null && (color2[1] = parseCssFloat(s));
    l != null && (color2[2] = parseCssFloat(l));
    return stringify(hsla2rgba(color2), "rgba");
  }
}
function modifyAlpha(color2, alpha) {
  color2 = parse(color2);
  if (color2 && alpha != null) {
    color2[3] = clampCssFloat(alpha);
    return stringify(color2, "rgba");
  }
}
function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  var colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
}
color$1.parse = parse;
color$1.lift = lift;
color$1.toHex = toHex;
color$1.fastLerp = fastLerp;
color$1.fastMapToColor = fastMapToColor;
color$1.lerp = lerp;
color$1.mapToColor = mapToColor;
color$1.modifyHSL = modifyHSL;
color$1.modifyAlpha = modifyAlpha;
color$1.stringify = stringify;
var Clip = Clip_1;
var color = color$1;
var _util$g = util$6;
var isArrayLike$1 = _util$g.isArrayLike;
var arraySlice = Array.prototype.slice;
function defaultGetter(target, key) {
  return target[key];
}
function defaultSetter(target, key, value) {
  target[key] = value;
}
function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
function interpolateString(p0, p1, percent) {
  return percent > 0.5 ? p1 : p0;
}
function interpolateArray(p0, p1, percent, out2, arrDim) {
  var len = p0.length;
  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      out2[i] = interpolateNumber(p0[i], p1[i], percent);
    }
  } else {
    var len2 = len && p0[0].length;
    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out2[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
      }
    }
  }
}
function fillArr(arr0, arr1, arrDim) {
  var arr0Len = arr0.length;
  var arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    var isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (var i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  }
  var len2 = arr0[0] && arr0[0].length;
  for (var i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (var j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
function isArraySame(arr0, arr1, arrDim) {
  if (arr0 === arr1) {
    return true;
  }
  var len = arr0.length;
  if (len !== arr1.length) {
    return false;
  }
  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      if (arr0[i] !== arr1[i]) {
        return false;
      }
    }
  } else {
    var len2 = arr0[0].length;
    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        if (arr0[i][j] !== arr1[i][j]) {
          return false;
        }
      }
    }
  }
  return true;
}
function catmullRomInterpolateArray(p0, p1, p2, p3, t2, t22, t3, out2, arrDim) {
  var len = p0.length;
  if (arrDim === 1) {
    for (var i = 0; i < len; i++) {
      out2[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t2, t22, t3);
    }
  } else {
    var len2 = p0[0].length;
    for (var i = 0; i < len; i++) {
      for (var j = 0; j < len2; j++) {
        out2[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t2, t22, t3);
      }
    }
  }
}
function catmullRomInterpolate(p0, p1, p2, p3, t2, t22, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function cloneValue(value) {
  if (isArrayLike$1(value)) {
    var len = value.length;
    if (isArrayLike$1(value[0])) {
      var ret = [];
      for (var i = 0; i < len; i++) {
        ret.push(arraySlice.call(value[i]));
      }
      return ret;
    }
    return arraySlice.call(value);
  }
  return value;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]);
  rgba[1] = Math.floor(rgba[1]);
  rgba[2] = Math.floor(rgba[2]);
  return "rgba(" + rgba.join(",") + ")";
}
function getArrayDim(keyframes) {
  var lastValue = keyframes[keyframes.length - 1].value;
  return isArrayLike$1(lastValue && lastValue[0]) ? 2 : 1;
}
function createTrackClip(animator, easing2, oneTrackDone, keyframes, propName, forceAnimate) {
  var getter = animator._getter;
  var setter = animator._setter;
  var useSpline = easing2 === "spline";
  var trackLen = keyframes.length;
  if (!trackLen) {
    return;
  }
  var firstVal = keyframes[0].value;
  var isValueArray = isArrayLike$1(firstVal);
  var isValueColor = false;
  var isValueString = false;
  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;
  var trackMaxTime;
  keyframes.sort(function(a, b) {
    return a.time - b.time;
  });
  trackMaxTime = keyframes[trackLen - 1].time;
  var kfPercents = [];
  var kfValues = [];
  var prevValue = keyframes[0].value;
  var isAllValueEqual = true;
  for (var i = 0; i < trackLen; i++) {
    kfPercents.push(keyframes[i].time / trackMaxTime);
    var value = keyframes[i].value;
    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
      isAllValueEqual = false;
    }
    prevValue = value;
    if (typeof value === "string") {
      var colorArray = color.parse(value);
      if (colorArray) {
        value = colorArray;
        isValueColor = true;
      } else {
        isValueString = true;
      }
    }
    kfValues.push(value);
  }
  if (!forceAnimate && isAllValueEqual) {
    return;
  }
  var lastValue = kfValues[trackLen - 1];
  for (var i = 0; i < trackLen - 1; i++) {
    if (isValueArray) {
      fillArr(kfValues[i], lastValue, arrDim);
    } else {
      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
        kfValues[i] = lastValue;
      }
    }
  }
  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);
  var lastFrame = 0;
  var lastFramePercent = 0;
  var start;
  var w;
  var p0;
  var p1;
  var p2;
  var p3;
  if (isValueColor) {
    var rgba = [0, 0, 0, 0];
  }
  var onframe = function(target, percent) {
    var frame;
    if (percent < 0) {
      frame = 0;
    } else if (percent < lastFramePercent) {
      start = Math.min(lastFrame + 1, trackLen - 1);
      for (frame = start; frame >= 0; frame--) {
        if (kfPercents[frame] <= percent) {
          break;
        }
      }
      frame = Math.min(frame, trackLen - 2);
    } else {
      for (frame = lastFrame; frame < trackLen; frame++) {
        if (kfPercents[frame] > percent) {
          break;
        }
      }
      frame = Math.min(frame - 1, trackLen - 2);
    }
    lastFrame = frame;
    lastFramePercent = percent;
    var range = kfPercents[frame + 1] - kfPercents[frame];
    if (range === 0) {
      return;
    } else {
      w = (percent - kfPercents[frame]) / range;
    }
    if (useSpline) {
      p1 = kfValues[frame];
      p0 = kfValues[frame === 0 ? frame : frame - 1];
      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
      if (isValueArray) {
        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
      } else {
        var value2;
        if (isValueColor) {
          value2 = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
          value2 = rgba2String(rgba);
        } else if (isValueString) {
          return interpolateString(p1, p2, w);
        } else {
          value2 = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
        }
        setter(target, propName, value2);
      }
    } else {
      if (isValueArray) {
        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
      } else {
        var value2;
        if (isValueColor) {
          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
          value2 = rgba2String(rgba);
        } else if (isValueString) {
          return interpolateString(kfValues[frame], kfValues[frame + 1], w);
        } else {
          value2 = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
        }
        setter(target, propName, value2);
      }
    }
  };
  var clip = new Clip({
    target: animator._target,
    life: trackMaxTime,
    loop: animator._loop,
    delay: animator._delay,
    onframe,
    ondestroy: oneTrackDone
  });
  if (easing2 && easing2 !== "spline") {
    clip.easing = easing2;
  }
  return clip;
}
var Animator$2 = function(target, loop, getter, setter) {
  this._tracks = {};
  this._target = target;
  this._loop = loop || false;
  this._getter = getter || defaultGetter;
  this._setter = setter || defaultSetter;
  this._clipCount = 0;
  this._delay = 0;
  this._doneList = [];
  this._onframeList = [];
  this._clipList = [];
};
Animator$2.prototype = {
  /**
   * Set Animation keyframe
   * @param  {number} time 关键帧时间，单位是ms
   * @param  {Object} props 关键帧的属性值，key-value表示
   * @return {module:zrender/animation/Animator}
   */
  when: function(time, props) {
    var tracks = this._tracks;
    for (var propName in props) {
      if (!props.hasOwnProperty(propName)) {
        continue;
      }
      if (!tracks[propName]) {
        tracks[propName] = [];
        var value = this._getter(this._target, propName);
        if (value == null) {
          continue;
        }
        if (time !== 0) {
          tracks[propName].push({
            time: 0,
            value: cloneValue(value)
          });
        }
      }
      tracks[propName].push({
        time,
        value: props[propName]
      });
    }
    return this;
  },
  /**
   * 添加动画每一帧的回调函数
   * @param  {Function} callback
   * @return {module:zrender/animation/Animator}
   */
  during: function(callback) {
    this._onframeList.push(callback);
    return this;
  },
  pause: function() {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].pause();
    }
    this._paused = true;
  },
  resume: function() {
    for (var i = 0; i < this._clipList.length; i++) {
      this._clipList[i].resume();
    }
    this._paused = false;
  },
  isPaused: function() {
    return !!this._paused;
  },
  _doneCallback: function() {
    this._tracks = {};
    this._clipList.length = 0;
    var doneList = this._doneList;
    var len = doneList.length;
    for (var i = 0; i < len; i++) {
      doneList[i].call(this);
    }
  },
  /**
   * Start the animation
   * @param  {string|Function} [easing]
   *         动画缓动函数，详见{@link module:zrender/animation/easing}
   * @param  {boolean} forceAnimate
   * @return {module:zrender/animation/Animator}
   */
  start: function(easing2, forceAnimate) {
    var self2 = this;
    var clipCount = 0;
    var oneTrackDone = function() {
      clipCount--;
      if (!clipCount) {
        self2._doneCallback();
      }
    };
    var lastClip;
    for (var propName in this._tracks) {
      if (!this._tracks.hasOwnProperty(propName)) {
        continue;
      }
      var clip = createTrackClip(this, easing2, oneTrackDone, this._tracks[propName], propName, forceAnimate);
      if (clip) {
        this._clipList.push(clip);
        clipCount++;
        if (this.animation) {
          this.animation.addClip(clip);
        }
        lastClip = clip;
      }
    }
    if (lastClip) {
      var oldOnFrame = lastClip.onframe;
      lastClip.onframe = function(target, percent) {
        oldOnFrame(target, percent);
        for (var i = 0; i < self2._onframeList.length; i++) {
          self2._onframeList[i](target, percent);
        }
      };
    }
    if (!clipCount) {
      this._doneCallback();
    }
    return this;
  },
  /**
   * Stop animation
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stop: function(forwardToLast) {
    var clipList = this._clipList;
    var animation2 = this.animation;
    for (var i = 0; i < clipList.length; i++) {
      var clip = clipList[i];
      if (forwardToLast) {
        clip.onframe(this._target, 1);
      }
      animation2 && animation2.removeClip(clip);
    }
    clipList.length = 0;
  },
  /**
   * Set when animation delay starts
   * @param  {number} time 单位ms
   * @return {module:zrender/animation/Animator}
   */
  delay: function(time) {
    this._delay = time;
    return this;
  },
  /**
   * Add callback for animation end
   * @param  {Function} cb
   * @return {module:zrender/animation/Animator}
   */
  done: function(cb) {
    if (cb) {
      this._doneList.push(cb);
    }
    return this;
  },
  /**
   * @return {Array.<module:zrender/animation/Clip>}
   */
  getClips: function() {
    return this._clipList;
  }
};
var _default$$ = Animator$2;
var Animator_1 = _default$$;
var config = {};
var dpr$1 = 1;
if (typeof window !== "undefined") {
  dpr$1 = Math.max(window.devicePixelRatio || 1, 1);
}
var debugMode$1 = 0;
var devicePixelRatio$2 = dpr$1;
config.debugMode = debugMode$1;
config.devicePixelRatio = devicePixelRatio$2;
var _config$3 = config;
var debugMode = _config$3.debugMode;
var logError$2 = function() {
};
if (debugMode === 1) {
  logError$2 = console.error;
}
var _default$_ = logError$2;
var log = _default$_;
var Animator$1 = Animator_1;
var logError$1 = log;
var _util$f = util$6;
var isString$4 = _util$f.isString;
var isFunction$2 = _util$f.isFunction;
var isObject$6 = _util$f.isObject;
var isArrayLike = _util$f.isArrayLike;
var indexOf$1 = _util$f.indexOf;
var Animatable$1 = function() {
  this.animators = [];
};
Animatable$1.prototype = {
  constructor: Animatable$1,
  /**
   * 动画
   *
   * @param {string} path The path to fetch value from object, like 'a.b.c'.
   * @param {boolean} [loop] Whether to loop animation.
   * @return {module:zrender/animation/Animator}
   * @example:
   *     el.animate('style', false)
   *         .when(1000, {x: 10} )
   *         .done(function(){ // Animation done })
   *         .start()
   */
  animate: function(path2, loop) {
    var target;
    var animatingShape = false;
    var el = this;
    var zr = this.__zr;
    if (path2) {
      var pathSplitted = path2.split(".");
      var prop = el;
      animatingShape = pathSplitted[0] === "shape";
      for (var i = 0, l = pathSplitted.length; i < l; i++) {
        if (!prop) {
          continue;
        }
        prop = prop[pathSplitted[i]];
      }
      if (prop) {
        target = prop;
      }
    } else {
      target = el;
    }
    if (!target) {
      logError$1('Property "' + path2 + '" is not existed in element ' + el.id);
      return;
    }
    var animators = el.animators;
    var animator = new Animator$1(target, loop);
    animator.during(function(target2) {
      el.dirty(animatingShape);
    }).done(function() {
      animators.splice(indexOf$1(animators, animator), 1);
    });
    animators.push(animator);
    if (zr) {
      zr.animation.addAnimator(animator);
    }
    return animator;
  },
  /**
   * 停止动画
   * @param {boolean} forwardToLast If move to last frame before stop
   */
  stopAnimation: function(forwardToLast) {
    var animators = this.animators;
    var len = animators.length;
    for (var i = 0; i < len; i++) {
      animators[i].stop(forwardToLast);
    }
    animators.length = 0;
    return this;
  },
  /**
   * Caution: this method will stop previous animation.
   * So do not use this method to one element twice before
   * animation starts, unless you know what you are doing.
   * @param {Object} target
   * @param {number} [time=500] Time in ms
   * @param {string} [easing='linear']
   * @param {number} [delay=0]
   * @param {Function} [callback]
   * @param {Function} [forceAnimate] Prevent stop animation and callback
   *        immediently when target values are the same as current values.
   *
   * @example
   *  // Animate position
   *  el.animateTo({
   *      position: [10, 10]
   *  }, function () { // done })
   *
   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
   *  el.animateTo({
   *      shape: {
   *          width: 500
   *      },
   *      style: {
   *          fill: 'red'
   *      }
   *      position: [10, 10]
   *  }, 100, 100, 'cubicOut', function () { // done })
   */
  // TODO Return animation key
  animateTo: function(target, time, delay, easing2, callback, forceAnimate) {
    animateTo(this, target, time, delay, easing2, callback, forceAnimate);
  },
  /**
   * Animate from the target state to current state.
   * The params and the return value are the same as `this.animateTo`.
   */
  animateFrom: function(target, time, delay, easing2, callback, forceAnimate) {
    animateTo(this, target, time, delay, easing2, callback, forceAnimate, true);
  }
};
function animateTo(animatable, target, time, delay, easing2, callback, forceAnimate, reverse) {
  if (isString$4(delay)) {
    callback = easing2;
    easing2 = delay;
    delay = 0;
  } else if (isFunction$2(easing2)) {
    callback = easing2;
    easing2 = "linear";
    delay = 0;
  } else if (isFunction$2(delay)) {
    callback = delay;
    delay = 0;
  } else if (isFunction$2(time)) {
    callback = time;
    time = 500;
  } else if (!time) {
    time = 500;
  }
  animatable.stopAnimation();
  animateToShallow(animatable, "", animatable, target, time, delay, reverse);
  var animators = animatable.animators.slice();
  var count = animators.length;
  function done() {
    count--;
    if (!count) {
      callback && callback();
    }
  }
  if (!count) {
    callback && callback();
  }
  for (var i = 0; i < animators.length; i++) {
    animators[i].done(done).start(easing2, forceAnimate);
  }
}
function animateToShallow(animatable, path2, source, target, time, delay, reverse) {
  var objShallow = {};
  var propertyCount = 0;
  for (var name2 in target) {
    if (!target.hasOwnProperty(name2)) {
      continue;
    }
    if (source[name2] != null) {
      if (isObject$6(target[name2]) && !isArrayLike(target[name2])) {
        animateToShallow(animatable, path2 ? path2 + "." + name2 : name2, source[name2], target[name2], time, delay, reverse);
      } else {
        if (reverse) {
          objShallow[name2] = source[name2];
          setAttrByPath(animatable, path2, name2, target[name2]);
        } else {
          objShallow[name2] = target[name2];
        }
        propertyCount++;
      }
    } else if (target[name2] != null && !reverse) {
      setAttrByPath(animatable, path2, name2, target[name2]);
    }
  }
  if (propertyCount > 0) {
    animatable.animate(path2, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
  }
}
function setAttrByPath(el, path2, name2, value) {
  if (!path2) {
    el.attr(name2, value);
  } else {
    var props = {};
    props[path2] = {};
    props[path2][name2] = value;
    el.attr(props);
  }
}
var _default$Z = Animatable$1;
var Animatable_1 = _default$Z;
var guid$1 = guid$2;
var Eventful$1 = Eventful_1;
var Transformable$1 = Transformable_1;
var Animatable = Animatable_1;
var zrUtil$m = util$6;
var Element$2 = function(opts) {
  Transformable$1.call(this, opts);
  Eventful$1.call(this, opts);
  Animatable.call(this, opts);
  this.id = opts.id || guid$1();
};
Element$2.prototype = {
  /**
   * 元素类型
   * Element type
   * @type {string}
   */
  type: "element",
  /**
   * 元素名字
   * Element name
   * @type {string}
   */
  name: "",
  /**
   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
   * ZRender instance will be assigned when element is associated with zrender
   * @name module:/zrender/Element#__zr
   * @type {module:zrender/ZRender}
   */
  __zr: null,
  /**
   * 图形是否忽略，为true时忽略图形的绘制以及事件触发
   * If ignore drawing and events of the element object
   * @name module:/zrender/Element#ignore
   * @type {boolean}
   * @default false
   */
  ignore: false,
  /**
   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
   * 该路径会继承被裁减对象的变换
   * @type {module:zrender/graphic/Path}
   * @see http://www.w3.org/TR/2dcontext/#clipping-region
   * @readOnly
   */
  clipPath: null,
  /**
   * 是否是 Group
   * @type {boolean}
   */
  isGroup: false,
  /**
   * Drift element
   * @param  {number} dx dx on the global space
   * @param  {number} dy dy on the global space
   */
  drift: function(dx, dy) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    var m2 = this.transform;
    if (!m2) {
      m2 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m2[4] += dx;
    m2[5] += dy;
    this.decomposeTransform();
    this.dirty(false);
  },
  /**
   * Hook before update
   */
  beforeUpdate: function() {
  },
  /**
   * Hook after update
   */
  afterUpdate: function() {
  },
  /**
   * Update each frame
   */
  update: function() {
    this.updateTransform();
  },
  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function(cb, context) {
  },
  /**
   * @protected
   */
  attrKV: function(key, value) {
    if (key === "position" || key === "scale" || key === "origin") {
      if (value) {
        var target = this[key];
        if (!target) {
          target = this[key] = [];
        }
        target[0] = value[0];
        target[1] = value[1];
      }
    } else {
      this[key] = value;
    }
  },
  /**
   * Hide the element
   */
  hide: function() {
    this.ignore = true;
    this.__zr && this.__zr.refresh();
  },
  /**
   * Show the element
   */
  show: function() {
    this.ignore = false;
    this.__zr && this.__zr.refresh();
  },
  /**
   * @param {string|Object} key
   * @param {*} value
   */
  attr: function(key, value) {
    if (typeof key === "string") {
      this.attrKV(key, value);
    } else if (zrUtil$m.isObject(key)) {
      for (var name2 in key) {
        if (key.hasOwnProperty(name2)) {
          this.attrKV(name2, key[name2]);
        }
      }
    }
    this.dirty(false);
    return this;
  },
  /**
   * @param {module:zrender/graphic/Path} clipPath
   */
  setClipPath: function(clipPath) {
    var zr = this.__zr;
    if (zr) {
      clipPath.addSelfToZr(zr);
    }
    if (this.clipPath && this.clipPath !== clipPath) {
      this.removeClipPath();
    }
    this.clipPath = clipPath;
    clipPath.__zr = zr;
    clipPath.__clipTarget = this;
    this.dirty(false);
  },
  /**
   */
  removeClipPath: function() {
    var clipPath = this.clipPath;
    if (clipPath) {
      if (clipPath.__zr) {
        clipPath.removeSelfFromZr(clipPath.__zr);
      }
      clipPath.__zr = null;
      clipPath.__clipTarget = null;
      this.clipPath = null;
      this.dirty(false);
    }
  },
  /**
   * Add self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  addSelfToZr: function(zr) {
    this.__zr = zr;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }
    if (this.clipPath) {
      this.clipPath.addSelfToZr(zr);
    }
  },
  /**
   * Remove self from zrender instance.
   * Not recursively because it will be invoked when element added to storage.
   * @param {module:zrender/ZRender} zr
   */
  removeSelfFromZr: function(zr) {
    this.__zr = null;
    var animators = this.animators;
    if (animators) {
      for (var i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }
    if (this.clipPath) {
      this.clipPath.removeSelfFromZr(zr);
    }
  }
};
zrUtil$m.mixin(Element$2, Animatable);
zrUtil$m.mixin(Element$2, Transformable$1);
zrUtil$m.mixin(Element$2, Eventful$1);
var _default$Y = Element$2;
var Element_1 = _default$Y;
var vec2$2 = requireVector();
var matrix$2 = requireMatrix();
var v2ApplyTransform$1 = vec2$2.applyTransform;
var mathMin$2 = Math.min;
var mathMax$2 = Math.max;
function BoundingRect$9(x, y, width, height) {
  if (width < 0) {
    x = x + width;
    width = -width;
  }
  if (height < 0) {
    y = y + height;
    height = -height;
  }
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;
}
BoundingRect$9.prototype = {
  constructor: BoundingRect$9,
  /**
   * @param {module:echarts/core/BoundingRect} other
   */
  union: function(other) {
    var x = mathMin$2(other.x, this.x);
    var y = mathMin$2(other.y, this.y);
    this.width = mathMax$2(other.x + other.width, this.x + this.width) - x;
    this.height = mathMax$2(other.y + other.height, this.y + this.height) - y;
    this.x = x;
    this.y = y;
  },
  /**
   * @param {Array.<number>} m
   * @methods
   */
  applyTransform: function() {
    var lt = [];
    var rb = [];
    var lb = [];
    var rt = [];
    return function(m2) {
      if (!m2) {
        return;
      }
      lt[0] = lb[0] = this.x;
      lt[1] = rt[1] = this.y;
      rb[0] = rt[0] = this.x + this.width;
      rb[1] = lb[1] = this.y + this.height;
      v2ApplyTransform$1(lt, lt, m2);
      v2ApplyTransform$1(rb, rb, m2);
      v2ApplyTransform$1(lb, lb, m2);
      v2ApplyTransform$1(rt, rt, m2);
      this.x = mathMin$2(lt[0], rb[0], lb[0], rt[0]);
      this.y = mathMin$2(lt[1], rb[1], lb[1], rt[1]);
      var maxX = mathMax$2(lt[0], rb[0], lb[0], rt[0]);
      var maxY = mathMax$2(lt[1], rb[1], lb[1], rt[1]);
      this.width = maxX - this.x;
      this.height = maxY - this.y;
    };
  }(),
  /**
   * Calculate matrix of transforming from self to target rect
   * @param  {module:zrender/core/BoundingRect} b
   * @return {Array.<number>}
   */
  calculateTransform: function(b) {
    var a = this;
    var sx = b.width / a.width;
    var sy = b.height / a.height;
    var m2 = matrix$2.create();
    matrix$2.translate(m2, m2, [-a.x, -a.y]);
    matrix$2.scale(m2, m2, [sx, sy]);
    matrix$2.translate(m2, m2, [b.x, b.y]);
    return m2;
  },
  /**
   * @param {(module:echarts/core/BoundingRect|Object)} b
   * @return {boolean}
   */
  intersect: function(b) {
    if (!b) {
      return false;
    }
    if (!(b instanceof BoundingRect$9)) {
      b = BoundingRect$9.create(b);
    }
    var a = this;
    var ax0 = a.x;
    var ax1 = a.x + a.width;
    var ay0 = a.y;
    var ay1 = a.y + a.height;
    var bx0 = b.x;
    var bx1 = b.x + b.width;
    var by0 = b.y;
    var by1 = b.y + b.height;
    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
  },
  contain: function(x, y) {
    var rect = this;
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  },
  /**
   * @return {module:echarts/core/BoundingRect}
   */
  clone: function() {
    return new BoundingRect$9(this.x, this.y, this.width, this.height);
  },
  /**
   * Copy from another rect
   */
  copy: function(other) {
    this.x = other.x;
    this.y = other.y;
    this.width = other.width;
    this.height = other.height;
  },
  plain: function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
};
BoundingRect$9.create = function(rect) {
  return new BoundingRect$9(rect.x, rect.y, rect.width, rect.height);
};
var _default$X = BoundingRect$9;
var BoundingRect_1 = _default$X;
var zrUtil$l = util$6;
var Element$1 = Element_1;
var BoundingRect$8 = BoundingRect_1;
var Group$5 = function(opts) {
  opts = opts || {};
  Element$1.call(this, opts);
  for (var key in opts) {
    if (opts.hasOwnProperty(key)) {
      this[key] = opts[key];
    }
  }
  this._children = [];
  this.__storage = null;
  this.__dirty = true;
};
Group$5.prototype = {
  constructor: Group$5,
  isGroup: true,
  /**
   * @type {string}
   */
  type: "group",
  /**
   * 所有子孙元素是否响应鼠标事件
   * @name module:/zrender/container/Group#silent
   * @type {boolean}
   * @default false
   */
  silent: false,
  /**
   * @return {Array.<module:zrender/Element>}
   */
  children: function() {
    return this._children.slice();
  },
  /**
   * 获取指定 index 的儿子节点
   * @param  {number} idx
   * @return {module:zrender/Element}
   */
  childAt: function(idx) {
    return this._children[idx];
  },
  /**
   * 获取指定名字的儿子节点
   * @param  {string} name
   * @return {module:zrender/Element}
   */
  childOfName: function(name2) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      if (children[i].name === name2) {
        return children[i];
      }
    }
  },
  /**
   * @return {number}
   */
  childCount: function() {
    return this._children.length;
  },
  /**
   * 添加子节点到最后
   * @param {module:zrender/Element} child
   */
  add: function(child) {
    if (child && child !== this && child.parent !== this) {
      this._children.push(child);
      this._doAdd(child);
    }
    return this;
  },
  /**
   * 添加子节点在 nextSibling 之前
   * @param {module:zrender/Element} child
   * @param {module:zrender/Element} nextSibling
   */
  addBefore: function(child, nextSibling) {
    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
      var children = this._children;
      var idx = children.indexOf(nextSibling);
      if (idx >= 0) {
        children.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  },
  _doAdd: function(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    var storage2 = this.__storage;
    var zr = this.__zr;
    if (storage2 && storage2 !== child.__storage) {
      storage2.addToStorage(child);
      if (child instanceof Group$5) {
        child.addChildrenToStorage(storage2);
      }
    }
    zr && zr.refresh();
  },
  /**
   * 移除子节点
   * @param {module:zrender/Element} child
   */
  remove: function(child) {
    var zr = this.__zr;
    var storage2 = this.__storage;
    var children = this._children;
    var idx = zrUtil$l.indexOf(children, child);
    if (idx < 0) {
      return this;
    }
    children.splice(idx, 1);
    child.parent = null;
    if (storage2) {
      storage2.delFromStorage(child);
      if (child instanceof Group$5) {
        child.delChildrenFromStorage(storage2);
      }
    }
    zr && zr.refresh();
    return this;
  },
  /**
   * 移除所有子节点
   */
  removeAll: function() {
    var children = this._children;
    var storage2 = this.__storage;
    var child;
    var i;
    for (i = 0; i < children.length; i++) {
      child = children[i];
      if (storage2) {
        storage2.delFromStorage(child);
        if (child instanceof Group$5) {
          child.delChildrenFromStorage(storage2);
        }
      }
      child.parent = null;
    }
    children.length = 0;
    return this;
  },
  /**
   * 遍历所有子节点
   * @param  {Function} cb
   * @param  {}   context
   */
  eachChild: function(cb, context) {
    var children = this._children;
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      cb.call(context, child, i);
    }
    return this;
  },
  /**
   * 深度优先遍历所有子孙节点
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function(cb, context) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      cb.call(context, child);
      if (child.type === "group") {
        child.traverse(cb, context);
      }
    }
    return this;
  },
  addChildrenToStorage: function(storage2) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage2.addToStorage(child);
      if (child instanceof Group$5) {
        child.addChildrenToStorage(storage2);
      }
    }
  },
  delChildrenFromStorage: function(storage2) {
    for (var i = 0; i < this._children.length; i++) {
      var child = this._children[i];
      storage2.delFromStorage(child);
      if (child instanceof Group$5) {
        child.delChildrenFromStorage(storage2);
      }
    }
  },
  dirty: function() {
    this.__dirty = true;
    this.__zr && this.__zr.refresh();
    return this;
  },
  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function(includeChildren) {
    var rect = null;
    var tmpRect2 = new BoundingRect$8(0, 0, 0, 0);
    var children = includeChildren || this._children;
    var tmpMat = [];
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.ignore || child.invisible) {
        continue;
      }
      var childRect = child.getBoundingRect();
      var transform = child.getLocalTransform(tmpMat);
      if (transform) {
        tmpRect2.copy(childRect);
        tmpRect2.applyTransform(transform);
        rect = rect || tmpRect2.clone();
        rect.union(tmpRect2);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect2;
  }
};
zrUtil$l.inherits(Group$5, Element$1);
var _default$W = Group$5;
var Group_1 = _default$W;
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
  var r = 0;
  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }
  return n + r;
}
function makeAscendingRun(array, lo, hi, compare2) {
  var runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare2(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array, lo, hi) {
  hi--;
  while (lo < hi) {
    var t2 = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t2;
  }
}
function binaryInsertionSort(array, lo, hi, start, compare2) {
  if (start === lo) {
    start++;
  }
  for (; start < hi; start++) {
    var pivot = array[start];
    var left = lo;
    var right = start;
    var mid;
    while (left < right) {
      mid = left + right >>> 1;
      if (compare2(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    var n = start - left;
    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];
      case 2:
        array[left + 2] = array[left + 1];
      case 1:
        array[left + 1] = array[left];
        break;
      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }
    }
    array[left] = pivot;
  }
}
function gallopLeft(value, array, start, length, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start + hint]) > 0) {
    maxOffset = length - hint;
    while (offset < maxOffset && compare2(value, array[start + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start + m2]) > 0) {
      lastOffset = m2 + 1;
    } else {
      offset = m2;
    }
  }
  return offset;
}
function gallopRight(value, array, start, length, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length - hint;
    while (offset < maxOffset && compare2(value, array[start + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start + m2]) < 0) {
      offset = m2;
    } else {
      lastOffset = m2 + 1;
    }
  }
  return offset;
}
function TimSort(array, compare2) {
  var minGallop = DEFAULT_MIN_GALLOPING;
  var runStart;
  var runLength;
  var stackSize = 0;
  array.length;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }
      mergeAt(n);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }
      mergeAt(n);
    }
  }
  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;
    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }
    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare2);
    start1 += k;
    length1 -= k;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare2);
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }
  function mergeLow(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];
    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
      return;
    }
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;
    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;
      do {
        if (compare2(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error();
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;
      do {
        if (compare2(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array[dest--] = tmp[cursor2--];
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare2);
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error();
    } else {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }
  this.mergeRuns = mergeRuns;
  this.forceMergeRuns = forceMergeRuns;
  this.pushRun = pushRun;
}
function sort(array, compare2, lo, hi) {
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = array.length;
  }
  var remaining = hi - lo;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
    return;
  }
  var ts = new TimSort(array, compare2);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
}
var timsort$2 = sort;
var util$4 = util$6;
var env$6 = env_1;
var Group$4 = Group_1;
var timsort$1 = timsort$2;
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      return a.z2 - b.z2;
    }
    return a.z - b.z;
  }
  return a.zlevel - b.zlevel;
}
var Storage$1 = function() {
  this._roots = [];
  this._displayList = [];
  this._displayListLen = 0;
};
Storage$1.prototype = {
  constructor: Storage$1,
  /**
   * @param  {Function} cb
   *
   */
  traverse: function(cb, context) {
    for (var i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  },
  /**
   * 返回所有图形的绘制队列
   * @param {boolean} [update=false] 是否在返回前更新该数组
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
   *
   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
   * @return {Array.<module:zrender/graphic/Displayable>}
   */
  getDisplayList: function(update, includeIgnore) {
    includeIgnore = includeIgnore || false;
    if (update) {
      this.updateDisplayList(includeIgnore);
    }
    return this._displayList;
  },
  /**
   * 更新图形的绘制队列。
   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
   */
  updateDisplayList: function(includeIgnore) {
    this._displayListLen = 0;
    var roots2 = this._roots;
    var displayList = this._displayList;
    for (var i = 0, len = roots2.length; i < len; i++) {
      this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    env$6.canvasSupported && timsort$1(displayList, shapeCompareFunc);
  },
  _updateAndAddDisplayable: function(el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }
    el.beforeUpdate();
    if (el.__dirty) {
      el.update();
    }
    el.afterUpdate();
    var userSetClipPath = el.clipPath;
    if (userSetClipPath) {
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }
      var currentClipPath = userSetClipPath;
      var parentClipPath = el;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.clipPath;
      }
    }
    if (el.isGroup) {
      var children = el._children;
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (el.__dirty) {
          child.__dirty = true;
        }
        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      }
      el.__dirty = false;
    } else {
      el.__clipPaths = clipPaths;
      this._displayList[this._displayListLen++] = el;
    }
  },
  /**
   * 添加图形(Shape)或者组(Group)到根节点
   * @param {module:zrender/Element} el
   */
  addRoot: function(el) {
    if (el.__storage === this) {
      return;
    }
    if (el instanceof Group$4) {
      el.addChildrenToStorage(this);
    }
    this.addToStorage(el);
    this._roots.push(el);
  },
  /**
   * 删除指定的图形(Shape)或者组(Group)
   * @param {string|Array.<string>} [el] 如果为空清空整个Storage
   */
  delRoot: function(el) {
    if (el == null) {
      for (var i = 0; i < this._roots.length; i++) {
        var root = this._roots[i];
        if (root instanceof Group$4) {
          root.delChildrenFromStorage(this);
        }
      }
      this._roots = [];
      this._displayList = [];
      this._displayListLen = 0;
      return;
    }
    if (el instanceof Array) {
      for (var i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }
      return;
    }
    var idx = util$4.indexOf(this._roots, el);
    if (idx >= 0) {
      this.delFromStorage(el);
      this._roots.splice(idx, 1);
      if (el instanceof Group$4) {
        el.delChildrenFromStorage(this);
      }
    }
  },
  addToStorage: function(el) {
    if (el) {
      el.__storage = this;
      el.dirty(false);
    }
    return this;
  },
  delFromStorage: function(el) {
    if (el) {
      el.__storage = null;
    }
    return this;
  },
  /**
   * 清空并且释放Storage
   */
  dispose: function() {
    this._renderList = this._roots = null;
  },
  displayableSortFunc: shapeCompareFunc
};
var _default$V = Storage$1;
var Storage_1 = _default$V;
var SHADOW_PROPS = {
  "shadowBlur": 1,
  "shadowOffsetX": 1,
  "shadowOffsetY": 1,
  "textShadowBlur": 1,
  "textShadowOffsetX": 1,
  "textShadowOffsetY": 1,
  "textBoxShadowBlur": 1,
  "textBoxShadowOffsetX": 1,
  "textBoxShadowOffsetY": 1
};
function _default$U(ctx, propName, value) {
  if (SHADOW_PROPS.hasOwnProperty(propName)) {
    return value *= ctx.dpr;
  }
  return value;
}
var fixShadow$2 = _default$U;
var constant = {};
var ContextCachedBy$3 = {
  NONE: 0,
  STYLE_BIND: 1,
  PLAIN_TEXT: 2
};
var WILL_BE_RESTORED$2 = 9;
constant.ContextCachedBy = ContextCachedBy$3;
constant.WILL_BE_RESTORED = WILL_BE_RESTORED$2;
var fixShadow$1 = fixShadow$2;
var _constant$3 = constant;
var ContextCachedBy$2 = _constant$3.ContextCachedBy;
var STYLE_COMMON_PROPS = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]];
var Style$3 = function(opts) {
  this.extendFrom(opts, false);
};
function createLinearGradient(ctx, obj, rect) {
  var x = obj.x == null ? 0 : obj.x;
  var x2 = obj.x2 == null ? 1 : obj.x2;
  var y = obj.y == null ? 0 : obj.y;
  var y2 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }
  x = isNaN(x) ? 0 : x;
  x2 = isNaN(x2) ? 1 : x2;
  y = isNaN(y) ? 0 : y;
  y2 = isNaN(y2) ? 0 : y2;
  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  var width = rect.width;
  var height = rect.height;
  var min3 = Math.min(width, height);
  var x = obj.x == null ? 0.5 : obj.x;
  var y = obj.y == null ? 0.5 : obj.y;
  var r = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min3;
  }
  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}
Style$3.prototype = {
  constructor: Style$3,
  /**
   * @type {string}
   */
  fill: "#000",
  /**
   * @type {string}
   */
  stroke: null,
  /**
   * @type {number}
   */
  opacity: 1,
  /**
   * @type {number}
   */
  fillOpacity: null,
  /**
   * @type {number}
   */
  strokeOpacity: null,
  /**
   * `true` is not supported.
   * `false`/`null`/`undefined` are the same.
   * `false` is used to remove lineDash in some
   * case that `null`/`undefined` can not be set.
   * (e.g., emphasis.lineStyle in echarts)
   * @type {Array.<number>|boolean}
   */
  lineDash: null,
  /**
   * @type {number}
   */
  lineDashOffset: 0,
  /**
   * @type {number}
   */
  shadowBlur: 0,
  /**
   * @type {number}
   */
  shadowOffsetX: 0,
  /**
   * @type {number}
   */
  shadowOffsetY: 0,
  /**
   * @type {number}
   */
  lineWidth: 1,
  /**
   * If stroke ignore scale
   * @type {Boolean}
   */
  strokeNoScale: false,
  // Bounding rect text configuration
  // Not affected by element transform
  /**
   * @type {string}
   */
  text: null,
  /**
   * If `fontSize` or `fontFamily` exists, `font` will be reset by
   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.
   * So do not visit it directly in upper application (like echarts),
   * but use `contain/text#makeFont` instead.
   * @type {string}
   */
  font: null,
  /**
   * The same as font. Use font please.
   * @deprecated
   * @type {string}
   */
  textFont: null,
  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontStyle: null,
  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontWeight: null,
  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * Should be 12 but not '12px'.
   * @type {number}
   */
  fontSize: null,
  /**
   * It helps merging respectively, rather than parsing an entire font string.
   * @type {string}
   */
  fontFamily: null,
  /**
   * Reserved for special functinality, like 'hr'.
   * @type {string}
   */
  textTag: null,
  /**
   * @type {string}
   */
  textFill: "#000",
  /**
   * @type {string}
   */
  textStroke: null,
  /**
   * @type {number}
   */
  textWidth: null,
  /**
   * Only for textBackground.
   * @type {number}
   */
  textHeight: null,
  /**
   * textStroke may be set as some color as a default
   * value in upper applicaion, where the default value
   * of textStrokeWidth should be 0 to make sure that
   * user can choose to do not use text stroke.
   * @type {number}
   */
  textStrokeWidth: 0,
  /**
   * @type {number}
   */
  textLineHeight: null,
  /**
   * 'inside', 'left', 'right', 'top', 'bottom'
   * [x, y]
   * Based on x, y of rect.
   * @type {string|Array.<number>}
   * @default 'inside'
   */
  textPosition: "inside",
  /**
   * If not specified, use the boundingRect of a `displayable`.
   * @type {Object}
   */
  textRect: null,
  /**
   * [x, y]
   * @type {Array.<number>}
   */
  textOffset: null,
  /**
   * @type {string}
   */
  textAlign: null,
  /**
   * @type {string}
   */
  textVerticalAlign: null,
  /**
   * @type {number}
   */
  textDistance: 5,
  /**
   * @type {string}
   */
  textShadowColor: "transparent",
  /**
   * @type {number}
   */
  textShadowBlur: 0,
  /**
   * @type {number}
   */
  textShadowOffsetX: 0,
  /**
   * @type {number}
   */
  textShadowOffsetY: 0,
  /**
   * @type {string}
   */
  textBoxShadowColor: "transparent",
  /**
   * @type {number}
   */
  textBoxShadowBlur: 0,
  /**
   * @type {number}
   */
  textBoxShadowOffsetX: 0,
  /**
   * @type {number}
   */
  textBoxShadowOffsetY: 0,
  /**
   * Whether transform text.
   * Only available in Path and Image element,
   * where the text is called as `RectText`.
   * @type {boolean}
   */
  transformText: false,
  /**
   * Text rotate around position of Path or Image.
   * The origin of the rotation can be specified by `textOrigin`.
   * Only available in Path and Image element,
   * where the text is called as `RectText`.
   */
  textRotation: 0,
  /**
   * Text origin of text rotation.
   * Useful in the case like label rotation of circular symbol.
   * Only available in Path and Image element, where the text is called
   * as `RectText` and the element is called as "host element".
   * The value can be:
   * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`
   * base on the left-top corner of the rect of its host element.
   * + If specified as a string `center`, it is the center of the rect of
   * its host element.
   * + By default, this origin is the `textPosition`.
   * @type {string|Array.<number>}
   */
  textOrigin: null,
  /**
   * @type {string}
   */
  textBackgroundColor: null,
  /**
   * @type {string}
   */
  textBorderColor: null,
  /**
   * @type {number}
   */
  textBorderWidth: 0,
  /**
   * @type {number}
   */
  textBorderRadius: 0,
  /**
   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`
   * @type {number|Array.<number>}
   */
  textPadding: null,
  /**
   * Text styles for rich text.
   * @type {Object}
   */
  rich: null,
  /**
   * {outerWidth, outerHeight, ellipsis, placeholder}
   * @type {Object}
   */
  truncate: null,
  /**
   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
   * @type {string}
   */
  blend: null,
  /**
   * @param {CanvasRenderingContext2D} ctx
   */
  bind: function(ctx, el, prevEl) {
    var style = this;
    var prevStyle = prevEl && prevEl.style;
    var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy$2.STYLE_BIND;
    ctx.__attrCachedBy = ContextCachedBy$2.STYLE_BIND;
    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
      var prop = STYLE_COMMON_PROPS[i];
      var styleName = prop[0];
      if (notCheckCache || style[styleName] !== prevStyle[styleName]) {
        ctx[styleName] = fixShadow$1(ctx, styleName, style[styleName] || prop[1]);
      }
    }
    if (notCheckCache || style.fill !== prevStyle.fill) {
      ctx.fillStyle = style.fill;
    }
    if (notCheckCache || style.stroke !== prevStyle.stroke) {
      ctx.strokeStyle = style.stroke;
    }
    if (notCheckCache || style.opacity !== prevStyle.opacity) {
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
    }
    if (notCheckCache || style.blend !== prevStyle.blend) {
      ctx.globalCompositeOperation = style.blend || "source-over";
    }
    if (this.hasStroke()) {
      var lineWidth = style.lineWidth;
      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
    }
  },
  hasFill: function() {
    var fill = this.fill;
    return fill != null && fill !== "none";
  },
  hasStroke: function() {
    var stroke = this.stroke;
    return stroke != null && stroke !== "none" && this.lineWidth > 0;
  },
  /**
   * Extend from other style
   * @param {zrender/graphic/Style} otherStyle
   * @param {boolean} overwrite true: overwrirte any way.
   *                            false: overwrite only when !target.hasOwnProperty
   *                            others: overwrite when property is not null/undefined.
   */
  extendFrom: function(otherStyle, overwrite) {
    if (otherStyle) {
      for (var name2 in otherStyle) {
        if (otherStyle.hasOwnProperty(name2) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name2) : otherStyle[name2] != null))) {
          this[name2] = otherStyle[name2];
        }
      }
    }
  },
  /**
   * Batch setting style with a given object
   * @param {Object|string} obj
   * @param {*} [obj]
   */
  set: function(obj, value) {
    if (typeof obj === "string") {
      this[obj] = value;
    } else {
      this.extendFrom(obj, true);
    }
  },
  /**
   * Clone
   * @return {zrender/graphic/Style} [description]
   */
  clone: function() {
    var newStyle = new this.constructor();
    newStyle.extendFrom(this, true);
    return newStyle;
  },
  getGradient: function(ctx, obj, rect) {
    var method = obj.type === "radial" ? createRadialGradient : createLinearGradient;
    var canvasGradient = method(ctx, obj, rect);
    var colorStops = obj.colorStops;
    for (var i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
    }
    return canvasGradient;
  }
};
var styleProto = Style$3.prototype;
for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
  var prop = STYLE_COMMON_PROPS[i];
  if (!(prop[0] in styleProto)) {
    styleProto[prop[0]] = prop[1];
  }
}
Style$3.getGradient = styleProto.getGradient;
var _default$T = Style$3;
var Style_1 = _default$T;
var Pattern$2 = function(image2, repeat) {
  this.image = image2;
  this.repeat = repeat;
  this.type = "pattern";
};
Pattern$2.prototype.getCanvasPattern = function(ctx) {
  return ctx.createPattern(this.image, this.repeat || "repeat");
};
var _default$S = Pattern$2;
var Pattern_1 = _default$S;
var util$3 = util$6;
var _config$2 = config;
var devicePixelRatio$1 = _config$2.devicePixelRatio;
var Style$2 = Style_1;
var Pattern$1 = Pattern_1;
function returnFalse() {
  return false;
}
function createDom(id, painter, dpr2) {
  var newDom = util$3.createCanvas();
  var width = painter.getWidth();
  var height = painter.getHeight();
  var newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = 0;
    newDomStyle.top = 0;
    newDomStyle.width = width + "px";
    newDomStyle.height = height + "px";
    newDom.setAttribute("data-zr-dom-id", id);
  }
  newDom.width = width * dpr2;
  newDom.height = height * dpr2;
  return newDom;
}
var Layer$1 = function(id, painter, dpr2) {
  var dom2;
  dpr2 = dpr2 || devicePixelRatio$1;
  if (typeof id === "string") {
    dom2 = createDom(id, painter, dpr2);
  } else if (util$3.isObject(id)) {
    dom2 = id;
    id = dom2.id;
  }
  this.id = id;
  this.dom = dom2;
  var domStyle = dom2.style;
  if (domStyle) {
    dom2.onselectstart = returnFalse;
    domStyle["-webkit-user-select"] = "none";
    domStyle["user-select"] = "none";
    domStyle["-webkit-touch-callout"] = "none";
    domStyle["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)";
    domStyle["padding"] = 0;
    domStyle["margin"] = 0;
    domStyle["border-width"] = 0;
  }
  this.domBack = null;
  this.ctxBack = null;
  this.painter = painter;
  this.config = null;
  this.clearColor = 0;
  this.motionBlur = false;
  this.lastFrameAlpha = 0.7;
  this.dpr = dpr2;
};
Layer$1.prototype = {
  constructor: Layer$1,
  __dirty: true,
  __used: false,
  __drawIndex: 0,
  __startIndex: 0,
  __endIndex: 0,
  incremental: false,
  getElementCount: function() {
    return this.__endIndex - this.__startIndex;
  },
  initContext: function() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  },
  createBackBuffer: function() {
    var dpr2 = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr2);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr2 !== 1) {
      this.ctxBack.scale(dpr2, dpr2);
    }
  },
  /**
   * @param  {number} width
   * @param  {number} height
   */
  resize: function(width, height) {
    var dpr2 = this.dpr;
    var dom2 = this.dom;
    var domStyle = dom2.style;
    var domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width + "px";
      domStyle.height = height + "px";
    }
    dom2.width = width * dpr2;
    dom2.height = height * dpr2;
    if (domBack) {
      domBack.width = width * dpr2;
      domBack.height = height * dpr2;
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    }
  },
  /**
   * 清空该层画布
   * @param {boolean} [clearAll]=false Clear all with out motion blur
   * @param {Color} [clearColor]
   */
  clear: function(clearAll, clearColor) {
    var dom2 = this.dom;
    var ctx = this.ctx;
    var width = dom2.width;
    var height = dom2.height;
    var clearColor = clearColor || this.clearColor;
    var haveMotionBLur = this.motionBlur && !clearAll;
    var lastFrameAlpha = this.lastFrameAlpha;
    var dpr2 = this.dpr;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom2, 0, 0, width / dpr2, height / dpr2);
    }
    ctx.clearRect(0, 0, width, height);
    if (clearColor && clearColor !== "transparent") {
      var clearColorGradientOrPattern;
      if (clearColor.colorStops) {
        clearColorGradientOrPattern = clearColor.__canvasGradient || Style$2.getGradient(ctx, clearColor, {
          x: 0,
          y: 0,
          width,
          height
        });
        clearColor.__canvasGradient = clearColorGradientOrPattern;
      } else if (clearColor.image) {
        clearColorGradientOrPattern = Pattern$1.prototype.getCanvasPattern.call(clearColor, ctx);
      }
      ctx.save();
      ctx.fillStyle = clearColorGradientOrPattern || clearColor;
      ctx.fillRect(0, 0, width, height);
      ctx.restore();
    }
    if (haveMotionBLur) {
      var domBack = this.domBack;
      ctx.save();
      ctx.globalAlpha = lastFrameAlpha;
      ctx.drawImage(domBack, 0, 0, width, height);
      ctx.restore();
    }
  }
};
var _default$R = Layer$1;
var Layer_1 = _default$R;
var _default$Q = typeof window !== "undefined" && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809
window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  setTimeout(func, 16);
};
var requestAnimationFrame$2 = _default$Q;
var text$1 = {};
var text = {};
var image = {};
var LRU = LRU_1;
var globalImageCache = new LRU(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image2, hostEl, cb, cbPayload) {
  if (!newImageOrSrc) {
    return image2;
  } else if (typeof newImageOrSrc === "string") {
    if (image2 && image2.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image2;
    }
    var cachedImgObj = globalImageCache.get(newImageOrSrc);
    var pendingWrap = {
      hostEl,
      cb,
      cbPayload
    };
    if (cachedImgObj) {
      image2 = cachedImgObj.image;
      !isImageReady(image2) && cachedImgObj.pending.push(pendingWrap);
    } else {
      image2 = new Image();
      image2.onload = image2.onerror = imageOnLoad;
      globalImageCache.put(newImageOrSrc, image2.__cachedImgObj = {
        image: image2,
        pending: [pendingWrap]
      });
      image2.src = image2.__zrImageSrc = newImageOrSrc;
    }
    return image2;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  var cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var i = 0; i < cachedImgObj.pending.length; i++) {
    var pendingWrap = cachedImgObj.pending[i];
    var cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image2) {
  return image2 && image2.width && image2.height;
}
image.findExistImage = findExistImage;
image.createOrUpdateImage = createOrUpdateImage;
image.isImageReady = isImageReady;
var BoundingRect$7 = BoundingRect_1;
var imageHelper$2 = image;
var _util$e = util$6;
var getContext = _util$e.getContext;
var extend$3 = _util$e.extend;
var retrieve2$1 = _util$e.retrieve2;
var retrieve3$1 = _util$e.retrieve3;
var trim$1 = _util$e.trim;
var textWidthCache = {};
var textWidthCacheCounter = 0;
var TEXT_CACHE_MAX = 5e3;
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
var DEFAULT_FONT$1 = "12px sans-serif";
var methods = {};
function $override(name2, fn) {
  methods[name2] = fn;
}
function getWidth(text2, font) {
  font = font || DEFAULT_FONT$1;
  var key = text2 + ":" + font;
  if (textWidthCache[key]) {
    return textWidthCache[key];
  }
  var textLines = (text2 + "").split("\n");
  var width = 0;
  for (var i = 0, l = textLines.length; i < l; i++) {
    width = Math.max(measureText(textLines[i], font).width, width);
  }
  if (textWidthCacheCounter > TEXT_CACHE_MAX) {
    textWidthCacheCounter = 0;
    textWidthCache = {};
  }
  textWidthCacheCounter++;
  textWidthCache[key] = width;
  return width;
}
function getBoundingRect(text2, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
  return rich ? getRichTextRect(text2, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text2, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);
}
function getPlainTextRect(text2, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {
  var contentBlock = parsePlainText(text2, font, textPadding, textLineHeight, truncate);
  var outerWidth = getWidth(text2, font);
  if (textPadding) {
    outerWidth += textPadding[1] + textPadding[3];
  }
  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  var rect = new BoundingRect$7(x, y, outerWidth, outerHeight);
  rect.lineHeight = contentBlock.lineHeight;
  return rect;
}
function getRichTextRect(text2, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {
  var contentBlock = parseRichText(text2, {
    rich,
    truncate,
    font,
    textAlign,
    textPadding,
    textLineHeight
  });
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var x = adjustTextX(0, outerWidth, textAlign);
  var y = adjustTextY(0, outerHeight, textVerticalAlign);
  return new BoundingRect$7(x, y, outerWidth, outerHeight);
}
function adjustTextX(x, width, textAlign) {
  if (textAlign === "right") {
    x -= width;
  } else if (textAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function adjustTextY(y, height, textVerticalAlign) {
  if (textVerticalAlign === "middle") {
    y -= height / 2;
  } else if (textVerticalAlign === "bottom") {
    y -= height;
  }
  return y;
}
function calculateTextPosition(out2, style, rect) {
  var textPosition = style.textPosition;
  var distance = style.textDistance;
  var x = rect.x;
  var y = rect.y;
  distance = distance || 0;
  var height = rect.height;
  var width = rect.width;
  var halfHeight = height / 2;
  var textAlign = "left";
  var textVerticalAlign = "top";
  switch (textPosition) {
    case "left":
      x -= distance;
      y += halfHeight;
      textAlign = "right";
      textVerticalAlign = "middle";
      break;
    case "right":
      x += distance + width;
      y += halfHeight;
      textVerticalAlign = "middle";
      break;
    case "top":
      x += width / 2;
      y -= distance;
      textAlign = "center";
      textVerticalAlign = "bottom";
      break;
    case "bottom":
      x += width / 2;
      y += height + distance;
      textAlign = "center";
      break;
    case "inside":
      x += width / 2;
      y += halfHeight;
      textAlign = "center";
      textVerticalAlign = "middle";
      break;
    case "insideLeft":
      x += distance;
      y += halfHeight;
      textVerticalAlign = "middle";
      break;
    case "insideRight":
      x += width - distance;
      y += halfHeight;
      textAlign = "right";
      textVerticalAlign = "middle";
      break;
    case "insideTop":
      x += width / 2;
      y += distance;
      textAlign = "center";
      break;
    case "insideBottom":
      x += width / 2;
      y += height - distance;
      textAlign = "center";
      textVerticalAlign = "bottom";
      break;
    case "insideTopLeft":
      x += distance;
      y += distance;
      break;
    case "insideTopRight":
      x += width - distance;
      y += distance;
      textAlign = "right";
      break;
    case "insideBottomLeft":
      x += distance;
      y += height - distance;
      textVerticalAlign = "bottom";
      break;
    case "insideBottomRight":
      x += width - distance;
      y += height - distance;
      textAlign = "right";
      textVerticalAlign = "bottom";
      break;
  }
  out2 = out2 || {};
  out2.x = x;
  out2.y = y;
  out2.textAlign = textAlign;
  out2.textVerticalAlign = textVerticalAlign;
  return out2;
}
function adjustTextPositionOnRect(textPosition, rect, distance) {
  var dummyStyle = {
    textPosition,
    textDistance: distance
  };
  return calculateTextPosition({}, dummyStyle, rect);
}
function truncateText(text2, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return "";
  }
  var textLines = (text2 + "").split("\n");
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  for (var i = 0, len = textLines.length; i < len; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }
  return textLines.join("\n");
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = extend$3({}, options);
  options.font = font;
  var ellipsis = retrieve2$1(ellipsis, "...");
  options.maxIterations = retrieve2$1(options.maxIterations, 2);
  var minChar = options.minChar = retrieve2$1(options.minChar, 0);
  options.cnCharWidth = getWidth("国", font);
  var ascCharWidth = options.ascCharWidth = getWidth("a", font);
  options.placeholder = retrieve2$1(options.placeholder, "");
  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }
  var ellipsisWidth = getWidth(ellipsis, font);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  options.ellipsis = ellipsis;
  options.ellipsisWidth = ellipsisWidth;
  options.contentWidth = contentWidth;
  options.containerWidth = containerWidth;
  return options;
}
function truncateSingleLine(textLine, options) {
  var containerWidth = options.containerWidth;
  var font = options.font;
  var contentWidth = options.contentWidth;
  if (!containerWidth) {
    return "";
  }
  var lineWidth = getWidth(textLine, font);
  if (lineWidth <= containerWidth) {
    return textLine;
  }
  for (var j = 0; ; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  return textLine;
}
function estimateLength(text2, contentWidth, ascCharWidth, cnCharWidth) {
  var width = 0;
  var i = 0;
  for (var len = text2.length; i < len && width < contentWidth; i++) {
    var charCode = text2.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }
  return i;
}
function getLineHeight(font) {
  return getWidth("国", font);
}
function measureText(text2, font) {
  return methods.measureText(text2, font);
}
methods.measureText = function(text2, font) {
  var ctx = getContext();
  ctx.font = font || DEFAULT_FONT$1;
  return ctx.measureText(text2);
};
function parsePlainText(text2, font, padding, textLineHeight, truncate) {
  text2 != null && (text2 += "");
  var lineHeight = retrieve2$1(textLineHeight, getLineHeight(font));
  var lines2 = text2 ? text2.split("\n") : [];
  var height = lines2.length * lineHeight;
  var outerHeight = height;
  var canCacheByTextString = true;
  if (padding) {
    outerHeight += padding[0] + padding[2];
  }
  if (text2 && truncate) {
    canCacheByTextString = false;
    var truncOuterHeight = truncate.outerHeight;
    var truncOuterWidth = truncate.outerWidth;
    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {
      text2 = "";
      lines2 = [];
    } else if (truncOuterWidth != null) {
      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {
        minChar: truncate.minChar,
        placeholder: truncate.placeholder
      });
      for (var i = 0, len = lines2.length; i < len; i++) {
        lines2[i] = truncateSingleLine(lines2[i], options);
      }
    }
  }
  return {
    lines: lines2,
    height,
    outerHeight,
    lineHeight,
    canCacheByTextString
  };
}
function parseRichText(text2, style) {
  var contentBlock = {
    lines: [],
    width: 0,
    height: 0
  };
  text2 != null && (text2 += "");
  if (!text2) {
    return contentBlock;
  }
  var lastIndex = STYLE_REG.lastIndex = 0;
  var result;
  while ((result = STYLE_REG.exec(text2)) != null) {
    var matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text2.substring(lastIndex, matchedIndex));
    }
    pushTokens(contentBlock, result[2], result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text2.length) {
    pushTokens(contentBlock, text2.substring(lastIndex, text2.length));
  }
  var lines2 = contentBlock.lines;
  var contentHeight = 0;
  var contentWidth = 0;
  var pendingList = [];
  var stlPadding = style.textPadding;
  var truncate = style.truncate;
  var truncateWidth = truncate && truncate.outerWidth;
  var truncateHeight = truncate && truncate.outerHeight;
  if (stlPadding) {
    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);
    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);
  }
  for (var i = 0; i < lines2.length; i++) {
    var line2 = lines2[i];
    var lineHeight = 0;
    var lineWidth = 0;
    for (var j = 0; j < line2.tokens.length; j++) {
      var token = line2.tokens[j];
      var tokenStyle = token.styleName && style.rich[token.styleName] || {};
      var textPadding = token.textPadding = tokenStyle.textPadding;
      var font = token.font = tokenStyle.font || style.font;
      var tokenHeight = token.textHeight = retrieve2$1(
        // textHeight should not be inherited, consider it can be specified
        // as box height of the block.
        tokenStyle.textHeight,
        getLineHeight(font)
      );
      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
      token.height = tokenHeight;
      token.lineHeight = retrieve3$1(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);
      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;
      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || "middle";
      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {
        return {
          lines: [],
          width: 0,
          height: 0
        };
      }
      token.textWidth = getWidth(token.text, font);
      var tokenWidth = tokenStyle.textWidth;
      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === "auto";
      if (typeof tokenWidth === "string" && tokenWidth.charAt(tokenWidth.length - 1) === "%") {
        token.percentWidth = tokenWidth;
        pendingList.push(token);
        tokenWidth = 0;
      } else {
        if (tokenWidthNotSpecified) {
          tokenWidth = token.textWidth;
          var textBackgroundColor = tokenStyle.textBackgroundColor;
          var bgImg = textBackgroundColor && textBackgroundColor.image;
          if (bgImg) {
            bgImg = imageHelper$2.findExistImage(bgImg);
            if (imageHelper$2.isImageReady(bgImg)) {
              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);
            }
          }
        }
        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;
        tokenWidth += paddingW;
        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;
        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {
          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {
            token.text = "";
            token.textWidth = tokenWidth = 0;
          } else {
            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {
              minChar: truncate.minChar
            });
            token.textWidth = getWidth(token.text, font);
            tokenWidth = token.textWidth + paddingW;
          }
        }
      }
      lineWidth += token.width = tokenWidth;
      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
    }
    line2.width = lineWidth;
    line2.lineHeight = lineHeight;
    contentHeight += lineHeight;
    contentWidth = Math.max(contentWidth, lineWidth);
  }
  contentBlock.outerWidth = contentBlock.width = retrieve2$1(style.textWidth, contentWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2$1(style.textHeight, contentHeight);
  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }
  for (var i = 0; i < pendingList.length; i++) {
    var token = pendingList[i];
    var percentWidth = token.percentWidth;
    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;
  }
  return contentBlock;
}
function pushTokens(block, str, styleName) {
  var isEmptyStr = str === "";
  var strs = str.split("\n");
  var lines2 = block.lines;
  for (var i = 0; i < strs.length; i++) {
    var text2 = strs[i];
    var token = {
      styleName,
      text: text2,
      isLineHolder: !text2 && !isEmptyStr
    };
    if (!i) {
      var tokens = (lines2[lines2.length - 1] || (lines2[0] = {
        tokens: []
      })).tokens;
      var tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (
        // Consider text is '', only insert when it is the "lineHolder" or
        // "emptyStr". Otherwise a redundant '' will affect textAlign in line.
        (text2 || !tokensLen || isEmptyStr) && tokens.push(token)
      );
    } else {
      lines2.push({
        tokens: [token]
      });
    }
  }
}
function makeFont(style) {
  var font = (style.fontSize || style.fontFamily) && [
    style.fontStyle,
    style.fontWeight,
    (style.fontSize || 12) + "px",
    // If font properties are defined, `fontFamily` should not be ignored.
    style.fontFamily || "sans-serif"
  ].join(" ");
  return font && trim$1(font) || style.textFont || style.font;
}
text.DEFAULT_FONT = DEFAULT_FONT$1;
text.$override = $override;
text.getWidth = getWidth;
text.getBoundingRect = getBoundingRect;
text.adjustTextX = adjustTextX;
text.adjustTextY = adjustTextY;
text.calculateTextPosition = calculateTextPosition;
text.adjustTextPositionOnRect = adjustTextPositionOnRect;
text.truncateText = truncateText;
text.getLineHeight = getLineHeight;
text.measureText = measureText;
text.parsePlainText = parsePlainText;
text.parseRichText = parseRichText;
text.makeFont = makeFont;
var roundRect = {};
function buildPath$1(ctx, shape) {
  var x = shape.x;
  var y = shape.y;
  var width = shape.width;
  var height = shape.height;
  var r = shape.r;
  var r1;
  var r2;
  var r3;
  var r4;
  if (width < 0) {
    x = x + width;
    width = -width;
  }
  if (height < 0) {
    y = y + height;
    height = -height;
  }
  if (typeof r === "number") {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }
  var total;
  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }
  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }
  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }
  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }
  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}
roundRect.buildPath = buildPath$1;
var _util$d = util$6;
var retrieve2 = _util$d.retrieve2;
var retrieve3 = _util$d.retrieve3;
var each$c = _util$d.each;
var normalizeCssArray = _util$d.normalizeCssArray;
var isString$3 = _util$d.isString;
var isObject$5 = _util$d.isObject;
var textContain$2 = text;
var roundRectHelper$1 = roundRect;
var imageHelper$1 = image;
var fixShadow = fixShadow$2;
var _constant$2 = constant;
var ContextCachedBy$1 = _constant$2.ContextCachedBy;
var WILL_BE_RESTORED$1 = _constant$2.WILL_BE_RESTORED;
var DEFAULT_FONT = textContain$2.DEFAULT_FONT;
var VALID_TEXT_ALIGN = {
  left: 1,
  right: 1,
  center: 1
};
var VALID_TEXT_VERTICAL_ALIGN = {
  top: 1,
  bottom: 1,
  middle: 1
};
var SHADOW_STYLE_COMMON_PROPS = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]];
var _tmpTextPositionResult = {};
var _tmpBoxPositionResult = {};
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each$c(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = textContain$2.makeFont(style);
    var textAlign = style.textAlign;
    textAlign === "middle" && (textAlign = "center");
    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;
    textVerticalAlign === "center" && (textVerticalAlign = "middle");
    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : "top";
    var textPadding = style.textPadding;
    if (textPadding) {
      style.textPadding = normalizeCssArray(style.textPadding);
    }
  }
}
function renderText(hostEl, ctx, text2, style, rect, prevEl) {
  style.rich ? renderRichText(hostEl, ctx, text2, style, rect, prevEl) : renderPlainText(hostEl, ctx, text2, style, rect, prevEl);
}
function renderPlainText(hostEl, ctx, text2, style, rect, prevEl) {
  var needDrawBg = needDrawBackground(style);
  var prevStyle;
  var checkCache = false;
  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy$1.PLAIN_TEXT;
  if (prevEl !== WILL_BE_RESTORED$1) {
    if (prevEl) {
      prevStyle = prevEl.style;
      checkCache = !needDrawBg && cachedByMe && prevStyle;
    }
    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy$1.NONE : ContextCachedBy$1.PLAIN_TEXT;
  } else if (cachedByMe) {
    ctx.__attrCachedBy = ContextCachedBy$1.NONE;
  }
  var styleFont = style.font || DEFAULT_FONT;
  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {
    ctx.font = styleFont;
  }
  var computedFont = hostEl.__computedFont;
  if (hostEl.__styleFont !== styleFont) {
    hostEl.__styleFont = styleFont;
    computedFont = hostEl.__computedFont = ctx.font;
  }
  var textPadding = style.textPadding;
  var textLineHeight = style.textLineHeight;
  var contentBlock = hostEl.__textCotentBlock;
  if (!contentBlock || hostEl.__dirtyText) {
    contentBlock = hostEl.__textCotentBlock = textContain$2.parsePlainText(text2, computedFont, textPadding, textLineHeight, style.truncate);
  }
  var outerHeight = contentBlock.outerHeight;
  var textLines = contentBlock.lines;
  var lineHeight = contentBlock.lineHeight;
  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign || "left";
  var textVerticalAlign = boxPos.textVerticalAlign;
  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxY = textContain$2.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var textX = baseX;
  var textY = boxY;
  if (needDrawBg || textPadding) {
    var textWidth = textContain$2.getWidth(text2, computedFont);
    var outerWidth = textWidth;
    textPadding && (outerWidth += textPadding[1] + textPadding[3]);
    var boxX = textContain$2.adjustTextX(baseX, outerWidth, textAlign);
    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      textY += textPadding[0];
    }
  }
  ctx.textAlign = textAlign;
  ctx.textBaseline = "middle";
  ctx.globalAlpha = style.opacity || 1;
  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {
    var propItem = SHADOW_STYLE_COMMON_PROPS[i];
    var styleProp = propItem[0];
    var ctxProp = propItem[1];
    var val = style[styleProp];
    if (!checkCache || val !== prevStyle[styleProp]) {
      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);
    }
  }
  textY += lineHeight / 2;
  var textStrokeWidth = style.textStrokeWidth;
  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;
  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;
  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;
  var textStroke = getStroke(style.textStroke, textStrokeWidth);
  var textFill = getFill(style.textFill);
  if (textStroke) {
    if (strokeWidthChanged) {
      ctx.lineWidth = textStrokeWidth;
    }
    if (strokeChanged) {
      ctx.strokeStyle = textStroke;
    }
  }
  if (textFill) {
    if (!checkCache || style.textFill !== prevStyle.textFill) {
      ctx.fillStyle = textFill;
    }
  }
  if (textLines.length === 1) {
    textStroke && ctx.strokeText(textLines[0], textX, textY);
    textFill && ctx.fillText(textLines[0], textX, textY);
  } else {
    for (var i = 0; i < textLines.length; i++) {
      textStroke && ctx.strokeText(textLines[i], textX, textY);
      textFill && ctx.fillText(textLines[i], textX, textY);
      textY += lineHeight;
    }
  }
}
function renderRichText(hostEl, ctx, text2, style, rect, prevEl) {
  if (prevEl !== WILL_BE_RESTORED$1) {
    ctx.__attrCachedBy = ContextCachedBy$1.NONE;
  }
  var contentBlock = hostEl.__textCotentBlock;
  if (!contentBlock || hostEl.__dirtyText) {
    contentBlock = hostEl.__textCotentBlock = textContain$2.parseRichText(text2, style);
  }
  drawRichText(hostEl, ctx, contentBlock, style, rect);
}
function drawRichText(hostEl, ctx, contentBlock, style, rect) {
  var contentWidth = contentBlock.width;
  var outerWidth = contentBlock.outerWidth;
  var outerHeight = contentBlock.outerHeight;
  var textPadding = style.textPadding;
  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);
  var baseX = boxPos.baseX;
  var baseY = boxPos.baseY;
  var textAlign = boxPos.textAlign;
  var textVerticalAlign = boxPos.textVerticalAlign;
  applyTextRotation(ctx, style, rect, baseX, baseY);
  var boxX = textContain$2.adjustTextX(baseX, outerWidth, textAlign);
  var boxY = textContain$2.adjustTextY(baseY, outerHeight, textVerticalAlign);
  var xLeft = boxX;
  var lineTop = boxY;
  if (textPadding) {
    xLeft += textPadding[3];
    lineTop += textPadding[0];
  }
  var xRight = xLeft + contentWidth;
  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);
  for (var i = 0; i < contentBlock.lines.length; i++) {
    var line2 = contentBlock.lines[i];
    var tokens = line2.tokens;
    var tokenCount = tokens.length;
    var lineHeight = line2.lineHeight;
    var usedWidth = line2.width;
    var leftIndex = 0;
    var lineXLeft = xLeft;
    var lineXRight = xRight;
    var rightIndex = tokenCount - 1;
    var token;
    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === "left")) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, "left");
      usedWidth -= token.width;
      lineXLeft += token.width;
      leftIndex++;
    }
    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === "right")) {
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, "right");
      usedWidth -= token.width;
      lineXRight -= token.width;
      rightIndex--;
    }
    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;
    while (leftIndex <= rightIndex) {
      token = tokens[leftIndex];
      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center");
      lineXLeft += token.width;
      leftIndex++;
    }
    lineTop += lineHeight;
  }
}
function applyTextRotation(ctx, style, rect, x, y) {
  if (rect && style.textRotation) {
    var origin = style.textOrigin;
    if (origin === "center") {
      x = rect.width / 2 + rect.x;
      y = rect.height / 2 + rect.y;
    } else if (origin) {
      x = origin[0] + rect.x;
      y = origin[1] + rect.y;
    }
    ctx.translate(x, y);
    ctx.rotate(-style.textRotation);
    ctx.translate(-x, -y);
  }
}
function placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {
  var tokenStyle = style.rich[token.styleName] || {};
  tokenStyle.text = token.text;
  var textVerticalAlign = token.textVerticalAlign;
  var y = lineTop + lineHeight / 2;
  if (textVerticalAlign === "top") {
    y = lineTop + token.height / 2;
  } else if (textVerticalAlign === "bottom") {
    y = lineTop + lineHeight - token.height / 2;
  }
  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
  var textPadding = token.textPadding;
  if (textPadding) {
    x = getTextXForPadding(x, textAlign, textPadding);
    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;
  }
  setCtx(ctx, "shadowBlur", retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));
  setCtx(ctx, "shadowColor", tokenStyle.textShadowColor || style.textShadowColor || "transparent");
  setCtx(ctx, "shadowOffsetX", retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));
  setCtx(ctx, "shadowOffsetY", retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));
  setCtx(ctx, "textAlign", textAlign);
  setCtx(ctx, "textBaseline", "middle");
  setCtx(ctx, "font", token.font || DEFAULT_FONT);
  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);
  var textFill = getFill(tokenStyle.textFill || style.textFill);
  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth);
  if (textStroke) {
    setCtx(ctx, "lineWidth", textStrokeWidth);
    setCtx(ctx, "strokeStyle", textStroke);
    ctx.strokeText(token.text, x, y);
  }
  if (textFill) {
    setCtx(ctx, "fillStyle", textFill);
    ctx.fillText(token.text, x, y);
  }
}
function needDrawBackground(style) {
  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);
}
function drawBackground(hostEl, ctx, style, x, y, width, height) {
  var textBackgroundColor = style.textBackgroundColor;
  var textBorderWidth = style.textBorderWidth;
  var textBorderColor = style.textBorderColor;
  var isPlainBg = isString$3(textBackgroundColor);
  setCtx(ctx, "shadowBlur", style.textBoxShadowBlur || 0);
  setCtx(ctx, "shadowColor", style.textBoxShadowColor || "transparent");
  setCtx(ctx, "shadowOffsetX", style.textBoxShadowOffsetX || 0);
  setCtx(ctx, "shadowOffsetY", style.textBoxShadowOffsetY || 0);
  if (isPlainBg || textBorderWidth && textBorderColor) {
    ctx.beginPath();
    var textBorderRadius = style.textBorderRadius;
    if (!textBorderRadius) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper$1.buildPath(ctx, {
        x,
        y,
        width,
        height,
        r: textBorderRadius
      });
    }
    ctx.closePath();
  }
  if (isPlainBg) {
    setCtx(ctx, "fillStyle", textBackgroundColor);
    if (style.fillOpacity != null) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.fillOpacity * style.opacity;
      ctx.fill();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.fill();
    }
  } else if (isObject$5(textBackgroundColor)) {
    var image2 = textBackgroundColor.image;
    image2 = imageHelper$1.createOrUpdateImage(image2, null, hostEl, onBgImageLoaded, textBackgroundColor);
    if (image2 && imageHelper$1.isImageReady(image2)) {
      ctx.drawImage(image2, x, y, width, height);
    }
  }
  if (textBorderWidth && textBorderColor) {
    setCtx(ctx, "lineWidth", textBorderWidth);
    setCtx(ctx, "strokeStyle", textBorderColor);
    if (style.strokeOpacity != null) {
      var originalGlobalAlpha = ctx.globalAlpha;
      ctx.globalAlpha = style.strokeOpacity * style.opacity;
      ctx.stroke();
      ctx.globalAlpha = originalGlobalAlpha;
    } else {
      ctx.stroke();
    }
  }
}
function onBgImageLoaded(image2, textBackgroundColor) {
  textBackgroundColor.image = image2;
}
function getBoxPosition(out2, hostEl, style, rect) {
  var baseX = style.x || 0;
  var baseY = style.y || 0;
  var textAlign = style.textAlign;
  var textVerticalAlign = style.textVerticalAlign;
  if (rect) {
    var textPosition = style.textPosition;
    if (textPosition instanceof Array) {
      baseX = rect.x + parsePercent$1(textPosition[0], rect.width);
      baseY = rect.y + parsePercent$1(textPosition[1], rect.height);
    } else {
      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain$2.calculateTextPosition(_tmpTextPositionResult, style, rect);
      baseX = res.x;
      baseY = res.y;
      textAlign = textAlign || res.textAlign;
      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;
    }
    var textOffset = style.textOffset;
    if (textOffset) {
      baseX += textOffset[0];
      baseY += textOffset[1];
    }
  }
  out2 = out2 || {};
  out2.baseX = baseX;
  out2.baseY = baseY;
  out2.textAlign = textAlign;
  out2.textVerticalAlign = textVerticalAlign;
  return out2;
}
function setCtx(ctx, prop, value) {
  ctx[prop] = fixShadow(ctx, prop, value);
  return ctx[prop];
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function parsePercent$1(value, maxValue) {
  if (typeof value === "string") {
    if (value.lastIndexOf("%") >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }
    return parseFloat(value);
  }
  return value;
}
function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
function needDrawText(text2, style) {
  return text2 != null && (text2 || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);
}
text$1.normalizeTextStyle = normalizeTextStyle;
text$1.renderText = renderText;
text$1.getBoxPosition = getBoxPosition;
text$1.getStroke = getStroke;
text$1.getFill = getFill;
text$1.parsePercent = parsePercent$1;
text$1.needDrawText = needDrawText;
var textHelper$1 = text$1;
var BoundingRect$6 = BoundingRect_1;
var _constant$1 = constant;
var WILL_BE_RESTORED = _constant$1.WILL_BE_RESTORED;
var tmpRect$1 = new BoundingRect$6();
var RectText$1 = function() {
};
RectText$1.prototype = {
  constructor: RectText$1,
  /**
   * Draw text in a rect with specified position.
   * @param  {CanvasRenderingContext2D} ctx
   * @param  {Object} rect Displayable rect
   */
  drawRectText: function(ctx, rect) {
    var style = this.style;
    rect = style.textRect || rect;
    this.__dirty && textHelper$1.normalizeTextStyle(style, true);
    var text2 = style.text;
    text2 != null && (text2 += "");
    if (!textHelper$1.needDrawText(text2, style)) {
      return;
    }
    ctx.save();
    var transform = this.transform;
    if (!style.transformText) {
      if (transform) {
        tmpRect$1.copy(rect);
        tmpRect$1.applyTransform(transform);
        rect = tmpRect$1;
      }
    } else {
      this.setTransform(ctx);
    }
    textHelper$1.renderText(this, ctx, text2, style, rect, WILL_BE_RESTORED);
    ctx.restore();
  }
};
var _default$P = RectText$1;
var RectText_1 = _default$P;
var zrUtil$k = util$6;
var Style$1 = Style_1;
var Element = Element_1;
var RectText = RectText_1;
function Displayable$3(opts) {
  opts = opts || {};
  Element.call(this, opts);
  for (var name2 in opts) {
    if (opts.hasOwnProperty(name2) && name2 !== "style") {
      this[name2] = opts[name2];
    }
  }
  this.style = new Style$1(opts.style);
  this._rect = null;
  this.__clipPaths = null;
}
Displayable$3.prototype = {
  constructor: Displayable$3,
  type: "displayable",
  /**
   * Dirty flag. From which painter will determine if this displayable object needs brush.
   * @name module:zrender/graphic/Displayable#__dirty
   * @type {boolean}
   */
  __dirty: true,
  /**
   * Whether the displayable object is visible. when it is true, the displayable object
   * is not drawn, but the mouse event can still trigger the object.
   * @name module:/zrender/graphic/Displayable#invisible
   * @type {boolean}
   * @default false
   */
  invisible: false,
  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z: 0,
  /**
   * @name module:/zrender/graphic/Displayable#z
   * @type {number}
   * @default 0
   */
  z2: 0,
  /**
   * The z level determines the displayable object can be drawn in which layer canvas.
   * @name module:/zrender/graphic/Displayable#zlevel
   * @type {number}
   * @default 0
   */
  zlevel: 0,
  /**
   * Whether it can be dragged.
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  draggable: false,
  /**
   * Whether is it dragging.
   * @name module:/zrender/graphic/Displayable#draggable
   * @type {boolean}
   * @default false
   */
  dragging: false,
  /**
   * Whether to respond to mouse events.
   * @name module:/zrender/graphic/Displayable#silent
   * @type {boolean}
   * @default false
   */
  silent: false,
  /**
   * If enable culling
   * @type {boolean}
   * @default false
   */
  culling: false,
  /**
   * Mouse cursor when hovered
   * @name module:/zrender/graphic/Displayable#cursor
   * @type {string}
   */
  cursor: "pointer",
  /**
   * If hover area is bounding rect
   * @name module:/zrender/graphic/Displayable#rectHover
   * @type {string}
   */
  rectHover: false,
  /**
   * Render the element progressively when the value >= 0,
   * usefull for large data.
   * @type {boolean}
   */
  progressive: false,
  /**
   * @type {boolean}
   */
  incremental: false,
  /**
   * Scale ratio for global scale.
   * @type {boolean}
   */
  globalScaleRatio: 1,
  beforeBrush: function(ctx) {
  },
  afterBrush: function(ctx) {
  },
  /**
   * Graphic drawing method.
   * @param {CanvasRenderingContext2D} ctx
   */
  // Interface
  brush: function(ctx, prevEl) {
  },
  /**
   * Get the minimum bounding box.
   * @return {module:zrender/core/BoundingRect}
   */
  // Interface
  getBoundingRect: function() {
  },
  /**
   * If displayable element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  contain: function(x, y) {
    return this.rectContain(x, y);
  },
  /**
   * @param  {Function} cb
   * @param  {}   context
   */
  traverse: function(cb, context) {
    cb.call(context, this);
  },
  /**
   * If bounding rect of element contain coord x, y
   * @param  {number} x
   * @param  {number} y
   * @return {boolean}
   */
  rectContain: function(x, y) {
    var coord = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  },
  /**
   * Mark displayable element dirty and refresh next frame
   */
  dirty: function() {
    this.__dirty = this.__dirtyText = true;
    this._rect = null;
    this.__zr && this.__zr.refresh();
  },
  /**
   * If displayable object binded any event
   * @return {boolean}
   */
  // TODO, events bound by bind
  // isSilent: function () {
  //     return !(
  //         this.hoverable || this.draggable
  //         || this.onmousemove || this.onmouseover || this.onmouseout
  //         || this.onmousedown || this.onmouseup || this.onclick
  //         || this.ondragenter || this.ondragover || this.ondragleave
  //         || this.ondrop
  //     );
  // },
  /**
   * Alias for animate('style')
   * @param {boolean} loop
   */
  animateStyle: function(loop) {
    return this.animate("style", loop);
  },
  attrKV: function(key, value) {
    if (key !== "style") {
      Element.prototype.attrKV.call(this, key, value);
    } else {
      this.style.set(value);
    }
  },
  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setStyle: function(key, value) {
    this.style.set(key, value);
    this.dirty(false);
    return this;
  },
  /**
   * Use given style object
   * @param  {Object} obj
   */
  useStyle: function(obj) {
    this.style = new Style$1(obj);
    this.dirty(false);
    return this;
  },
  /**
   * The string value of `textPosition` needs to be calculated to a real postion.
   * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`
   * by default. See `contain/text.js#calculateTextPosition` for more details.
   * But some coutom shapes like "pin", "flag" have center that is not exactly
   * `[width/2, height/2]`. So we provide this hook to customize the calculation
   * for those shapes. It will be called if the `style.textPosition` is a string.
   * @param {Obejct} [out] Prepared out object. If not provided, this method should
   *        be responsible for creating one.
   * @param {module:zrender/graphic/Style} style
   * @param {Object} rect {x, y, width, height}
   * @return {Obejct} out The same as the input out.
   *         {
   *             x: number. mandatory.
   *             y: number. mandatory.
   *             textAlign: string. optional. use style.textAlign by default.
   *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.
   *         }
   */
  calculateTextPosition: null
};
zrUtil$k.inherits(Displayable$3, Element);
zrUtil$k.mixin(Displayable$3, RectText);
var _default$O = Displayable$3;
var Displayable_1 = _default$O;
var Displayable$2 = Displayable_1;
var BoundingRect$5 = BoundingRect_1;
var zrUtil$j = util$6;
var imageHelper = image;
function ZImage$2(opts) {
  Displayable$2.call(this, opts);
}
ZImage$2.prototype = {
  constructor: ZImage$2,
  type: "image",
  brush: function(ctx, prevEl) {
    var style = this.style;
    var src = style.image;
    style.bind(ctx, this, prevEl);
    var image2 = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);
    if (!image2 || !imageHelper.isImageReady(image2)) {
      return;
    }
    var x = style.x || 0;
    var y = style.y || 0;
    var width = style.width;
    var height = style.height;
    var aspect = image2.width / image2.height;
    if (width == null && height != null) {
      width = height * aspect;
    } else if (height == null && width != null) {
      height = width / aspect;
    } else if (width == null && height == null) {
      width = image2.width;
      height = image2.height;
    }
    this.setTransform(ctx);
    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      ctx.drawImage(image2, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
    } else if (style.sx && style.sy) {
      var sx = style.sx;
      var sy = style.sy;
      var sWidth = width - sx;
      var sHeight = height - sy;
      ctx.drawImage(image2, sx, sy, sWidth, sHeight, x, y, width, height);
    } else {
      ctx.drawImage(image2, x, y, width, height);
    }
    if (style.text != null) {
      this.restoreTransform(ctx);
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  getBoundingRect: function() {
    var style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect$5(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
    }
    return this._rect;
  }
};
zrUtil$j.inherits(ZImage$2, Displayable$2);
var _default$N = ZImage$2;
var Image$2 = _default$N;
var _config$1 = config;
var devicePixelRatio = _config$1.devicePixelRatio;
var util$2 = util$6;
var logError = log;
var BoundingRect$4 = BoundingRect_1;
var timsort = timsort$2;
var Layer = Layer_1;
var requestAnimationFrame$1 = requestAnimationFrame$2;
var Image$1 = Image$2;
var env$5 = env_1;
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 1e-3;
function parseInt10(val) {
  return parseInt(val, 10);
}
function isLayerValid(layer) {
  if (!layer) {
    return false;
  }
  if (layer.__builtin__) {
    return true;
  }
  if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
    return false;
  }
  return true;
}
var tmpRect = new BoundingRect$4(0, 0, 0, 0);
var viewRect = new BoundingRect$4(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
  tmpRect.copy(el.getBoundingRect());
  if (el.transform) {
    tmpRect.applyTransform(el.transform);
  }
  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect.intersect(viewRect);
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (var i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
  return false;
}
function doClip(clipPaths, ctx) {
  for (var i = 0; i < clipPaths.length; i++) {
    var clipPath = clipPaths[i];
    clipPath.setTransform(ctx);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
    clipPath.restoreTransform(ctx);
  }
}
function createRoot(width, height) {
  var domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent
    // dom does not act as expected) when some of the parent dom has
    // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and
    // the canvas is not at the top part of the page.
    // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove
    // this `overflow:hidden` to avoid the bug.
    // 'overflow:hidden',
    "width:" + width + "px",
    "height:" + height + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var Painter$3 = function(root, storage2, opts) {
  this.type = "canvas";
  var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
  this._opts = opts = util$2.extend({}, opts || {});
  this.dpr = opts.devicePixelRatio || devicePixelRatio;
  this._singleCanvas = singleCanvas;
  this.root = root;
  var rootStyle = root.style;
  if (rootStyle) {
    rootStyle["-webkit-tap-highlight-color"] = "transparent";
    rootStyle["-webkit-user-select"] = rootStyle["user-select"] = rootStyle["-webkit-touch-callout"] = "none";
    root.innerHTML = "";
  }
  this.storage = storage2;
  var zlevelList = this._zlevelList = [];
  var layers = this._layers = {};
  this._layerConfig = {};
  this._needsManuallyCompositing = false;
  if (!singleCanvas) {
    this._width = this._getSize(0);
    this._height = this._getSize(1);
    var domRoot = this._domRoot = createRoot(this._width, this._height);
    root.appendChild(domRoot);
  } else {
    var width = root.width;
    var height = root.height;
    if (opts.width != null) {
      width = opts.width;
    }
    if (opts.height != null) {
      height = opts.height;
    }
    this.dpr = opts.devicePixelRatio || 1;
    root.width = width * this.dpr;
    root.height = height * this.dpr;
    this._width = width;
    this._height = height;
    var mainLayer = new Layer(root, this, this.dpr);
    mainLayer.__builtin__ = true;
    mainLayer.initContext();
    layers[CANVAS_ZLEVEL] = mainLayer;
    mainLayer.zlevel = CANVAS_ZLEVEL;
    zlevelList.push(CANVAS_ZLEVEL);
    this._domRoot = root;
  }
  this._hoverlayer = null;
  this._hoverElements = [];
};
Painter$3.prototype = {
  constructor: Painter$3,
  getType: function() {
    return "canvas";
  },
  /**
   * If painter use a single canvas
   * @return {boolean}
   */
  isSingleCanvas: function() {
    return this._singleCanvas;
  },
  /**
   * @return {HTMLDivElement}
   */
  getViewportRoot: function() {
    return this._domRoot;
  },
  getViewportRootOffset: function() {
    var viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  },
  /**
   * 刷新
   * @param {boolean} [paintAll=false] 强制绘制所有displayable
   */
  refresh: function(paintAll) {
    var list = this.storage.getDisplayList(true);
    var zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, paintAll, this._redrawId);
    for (var i = 0; i < zlevelList.length; i++) {
      var z = zlevelList[i];
      var layer = this._layers[z];
      if (!layer.__builtin__ && layer.refresh) {
        var clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }
    this.refreshHover();
    return this;
  },
  addHover: function(el, hoverStyle) {
    if (el.__hoverMir) {
      return;
    }
    var elMirror = new el.constructor({
      style: el.style,
      shape: el.shape,
      z: el.z,
      z2: el.z2,
      silent: el.silent
    });
    elMirror.__from = el;
    el.__hoverMir = elMirror;
    hoverStyle && elMirror.setStyle(hoverStyle);
    this._hoverElements.push(elMirror);
    return elMirror;
  },
  removeHover: function(el) {
    var elMirror = el.__hoverMir;
    var hoverElements = this._hoverElements;
    var idx = util$2.indexOf(hoverElements, elMirror);
    if (idx >= 0) {
      hoverElements.splice(idx, 1);
    }
    el.__hoverMir = null;
  },
  clearHover: function(el) {
    var hoverElements = this._hoverElements;
    for (var i = 0; i < hoverElements.length; i++) {
      var from = hoverElements[i].__from;
      if (from) {
        from.__hoverMir = null;
      }
    }
    hoverElements.length = 0;
  },
  refreshHover: function() {
    var hoverElements = this._hoverElements;
    var len = hoverElements.length;
    var hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len) {
      return;
    }
    timsort(hoverElements, this.storage.displayableSortFunc);
    if (!hoverLayer) {
      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
    }
    var scope = {};
    hoverLayer.ctx.save();
    for (var i = 0; i < len; ) {
      var el = hoverElements[i];
      var originalEl = el.__from;
      if (!(originalEl && originalEl.__zr)) {
        hoverElements.splice(i, 1);
        originalEl.__hoverMir = null;
        len--;
        continue;
      }
      i++;
      if (!originalEl.invisible) {
        el.transform = originalEl.transform;
        el.invTransform = originalEl.invTransform;
        el.__clipPaths = originalEl.__clipPaths;
        this._doPaintEl(el, hoverLayer, true, scope);
      }
    }
    hoverLayer.ctx.restore();
  },
  getHoverLayer: function() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  },
  _paintList: function(list, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    var finished = this._doPaintList(list, paintAll);
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (!finished) {
      var self2 = this;
      requestAnimationFrame$1(function() {
        self2._paintList(list, paintAll, redrawId);
      });
    }
  },
  _compositeManually: function() {
    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    var width = this._domRoot.width;
    var height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height);
    this.eachBuiltinLayer(function(layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  },
  _doPaintList: function(list, paintAll) {
    var layerList = [];
    for (var zi = 0; zi < this._zlevelList.length; zi++) {
      var zlevel = this._zlevelList[zi];
      var layer = this._layers[zlevel];
      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }
    var finished = true;
    for (var k = 0; k < layerList.length; k++) {
      var layer = layerList[k];
      var ctx = layer.ctx;
      var scope = {};
      ctx.save();
      var start = paintAll ? layer.__startIndex : layer.__drawIndex;
      var useTimer = !paintAll && layer.incremental && Date.now;
      var startTime = useTimer && Date.now();
      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
      if (layer.__startIndex === layer.__endIndex) {
        layer.clear(false, clearColor);
      } else if (start === layer.__startIndex) {
        var firstEl = list[start];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer.clear(false, clearColor);
        }
      }
      if (start === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start = layer.__startIndex;
      }
      for (var i = start; i < layer.__endIndex; i++) {
        var el = list[i];
        this._doPaintEl(el, layer, paintAll, scope);
        el.__dirty = el.__dirtyText = false;
        if (useTimer) {
          var dTime = Date.now() - startTime;
          if (dTime > 15) {
            break;
          }
        }
      }
      layer.__drawIndex = i;
      if (layer.__drawIndex < layer.__endIndex) {
        finished = false;
      }
      if (scope.prevElClipPaths) {
        ctx.restore();
      }
      ctx.restore();
    }
    if (env$5.wxa) {
      util$2.each(this._layers, function(layer2) {
        if (layer2 && layer2.ctx && layer2.ctx.draw) {
          layer2.ctx.draw();
        }
      });
    }
    return finished;
  },
  _doPaintEl: function(el, currentLayer, forcePaint, scope) {
    var ctx = currentLayer.ctx;
    var m2 = el.transform;
    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element
    !el.invisible && el.style.opacity !== 0 && !(m2 && !m2[0] && !m2[3]) && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {
      var clipPaths = el.__clipPaths;
      var prevElClipPaths = scope.prevElClipPaths;
      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
        if (prevElClipPaths) {
          ctx.restore();
          scope.prevElClipPaths = null;
          scope.prevEl = null;
        }
        if (clipPaths) {
          ctx.save();
          doClip(clipPaths, ctx);
          scope.prevElClipPaths = clipPaths;
        }
      }
      el.beforeBrush && el.beforeBrush(ctx);
      el.brush(ctx, scope.prevEl || null);
      scope.prevEl = el;
      el.afterBrush && el.afterBrush(ctx);
    }
  },
  /**
   * 获取 zlevel 所在层，如果不存在则会创建一个新的层
   * @param {number} zlevel
   * @param {boolean} virtual Virtual layer will not be inserted into dom.
   * @return {module:zrender/Layer}
   */
  getLayer: function(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    var layer = this._layers[zlevel];
    if (!layer) {
      layer = new Layer("zr_" + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        util$2.merge(layer, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        util$2.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer.virtual = virtual;
      }
      this.insertLayer(zlevel, layer);
      layer.initContext();
    }
    return layer;
  },
  insertLayer: function(zlevel, layer) {
    var layersMap = this._layers;
    var zlevelList = this._zlevelList;
    var len = zlevelList.length;
    var prevLayer = null;
    var i = -1;
    var domRoot = this._domRoot;
    if (layersMap[zlevel]) {
      logError("ZLevel " + zlevel + " has been used already");
      return;
    }
    if (!isLayerValid(layer)) {
      logError("Layer of zlevel " + zlevel + " is not valid");
      return;
    }
    if (len > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i]];
    }
    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer;
    if (!layer.virtual) {
      if (prevLayer) {
        var prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
  },
  // Iterate each layer
  eachLayer: function(cb, context) {
    var zlevelList = this._zlevelList;
    var z;
    var i;
    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  },
  // Iterate each buildin layer
  eachBuiltinLayer: function(cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;
    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];
      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },
  // Iterate each other layer except buildin layer
  eachOtherLayer: function(cb, context) {
    var zlevelList = this._zlevelList;
    var layer;
    var z;
    var i;
    for (i = 0; i < zlevelList.length; i++) {
      z = zlevelList[i];
      layer = this._layers[z];
      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  },
  /**
   * 获取所有已创建的层
   * @param {Array.<module:zrender/Layer>} [prevLayer]
   */
  getLayers: function() {
    return this._layers;
  },
  _updateLayerStatus: function(list) {
    this.eachBuiltinLayer(function(layer2, z) {
      layer2.__dirty = layer2.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (var i = 1; i < list.length; i++) {
        var el = list[i];
        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    var prevLayer = null;
    var incrementalLayerCount = 0;
    var prevZlevel;
    for (var i = 0; i < list.length; i++) {
      var el = list[i];
      var zlevel = el.zlevel;
      var layer;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
      }
      if (layer !== prevLayer) {
        layer.__used = true;
        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }
        layer.__startIndex = i;
        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          layer.__drawIndex = -1;
        }
        updatePrevLayer(i);
        prevLayer = layer;
      }
      if (el.__dirty) {
        layer.__dirty = true;
        if (layer.incremental && layer.__drawIndex < 0) {
          layer.__drawIndex = i;
        }
      }
    }
    updatePrevLayer(i);
    this.eachBuiltinLayer(function(layer2, z) {
      if (!layer2.__used && layer2.getElementCount() > 0) {
        layer2.__dirty = true;
        layer2.__startIndex = layer2.__endIndex = layer2.__drawIndex = 0;
      }
      if (layer2.__dirty && layer2.__drawIndex < 0) {
        layer2.__drawIndex = layer2.__startIndex;
      }
    });
  },
  /**
   * 清除hover层外所有内容
   */
  clear: function() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  },
  _clearLayer: function(layer) {
    layer.clear();
  },
  setBackgroundColor: function(backgroundColor) {
    this._backgroundColor = backgroundColor;
  },
  /**
   * 修改指定zlevel的绘制参数
   *
   * @param {string} zlevel
   * @param {Object} config 配置对象
   * @param {string} [config.clearColor=0] 每次清空画布的颜色
   * @param {string} [config.motionBlur=false] 是否开启动态模糊
   * @param {number} [config.lastFrameAlpha=0.7]
   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
   */
  configLayer: function(zlevel, config2) {
    if (config2) {
      var layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config2;
      } else {
        util$2.merge(layerConfig[zlevel], config2, true);
      }
      for (var i = 0; i < this._zlevelList.length; i++) {
        var _zlevel = this._zlevelList[i];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          var layer = this._layers[_zlevel];
          util$2.merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  },
  /**
   * 删除指定层
   * @param {number} zlevel 层所在的zlevel
   */
  delLayer: function(zlevel) {
    var layers = this._layers;
    var zlevelList = this._zlevelList;
    var layer = layers[zlevel];
    if (!layer) {
      return;
    }
    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(util$2.indexOf(zlevelList, zlevel), 1);
  },
  /**
   * 区域大小变化后重绘
   */
  resize: function(width, height) {
    if (!this._domRoot.style) {
      if (width == null || height == null) {
        return;
      }
      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      var domRoot = this._domRoot;
      domRoot.style.display = "none";
      var opts = this._opts;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = this._getSize(0);
      height = this._getSize(1);
      domRoot.style.display = "";
      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + "px";
        domRoot.style.height = height + "px";
        for (var id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }
        util$2.each(this._progressiveLayers, function(layer) {
          layer.resize(width, height);
        });
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
    }
    return this;
  },
  /**
   * 清除单独的一个层
   * @param {number} zlevel
   */
  clearLayer: function(zlevel) {
    var layer = this._layers[zlevel];
    if (layer) {
      layer.clear();
    }
  },
  /**
   * 释放
   */
  dispose: function() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  },
  /**
   * Get canvas which has all thing rendered
   * @param {Object} opts
   * @param {string} [opts.backgroundColor]
   * @param {number} [opts.pixelRatio]
   */
  getRenderedCanvas: function(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    var imageLayer = new Layer("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      var width = imageLayer.dom.width;
      var height = imageLayer.dom.height;
      var ctx = imageLayer.ctx;
      this.eachLayer(function(layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        } else if (layer.renderToCanvas) {
          imageLayer.ctx.save();
          layer.renderToCanvas(imageLayer.ctx);
          imageLayer.ctx.restore();
        }
      });
    } else {
      var scope = {};
      var displayList = this.storage.getDisplayList(true);
      for (var i = 0; i < displayList.length; i++) {
        var el = displayList[i];
        this._doPaintEl(el, imageLayer, true, scope);
      }
    }
    return imageLayer.dom;
  },
  /**
   * 获取绘图区域宽度
   */
  getWidth: function() {
    return this._width;
  },
  /**
   * 获取绘图区域高度
   */
  getHeight: function() {
    return this._height;
  },
  _getSize: function(whIdx) {
    var opts = this._opts;
    var wh = ["width", "height"][whIdx];
    var cwh = ["clientWidth", "clientHeight"][whIdx];
    var plt = ["paddingLeft", "paddingTop"][whIdx];
    var prb = ["paddingRight", "paddingBottom"][whIdx];
    if (opts[wh] != null && opts[wh] !== "auto") {
      return parseFloat(opts[wh]);
    }
    var root = this.root;
    var stl = document.defaultView.getComputedStyle(root);
    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
  },
  pathToImage: function(path2, dpr2) {
    dpr2 = dpr2 || this.dpr;
    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext("2d");
    var rect = path2.getBoundingRect();
    var style = path2.style;
    var shadowBlurSize = style.shadowBlur * dpr2;
    var shadowOffsetX = style.shadowOffsetX * dpr2;
    var shadowOffsetY = style.shadowOffsetY * dpr2;
    var lineWidth = style.hasStroke() ? style.lineWidth : 0;
    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
    var width = rect.width + leftMargin + rightMargin;
    var height = rect.height + topMargin + bottomMargin;
    canvas.width = width * dpr2;
    canvas.height = height * dpr2;
    ctx.scale(dpr2, dpr2);
    ctx.clearRect(0, 0, width, height);
    ctx.dpr = dpr2;
    var pathTransform = {
      position: path2.position,
      rotation: path2.rotation,
      scale: path2.scale
    };
    path2.position = [leftMargin - rect.x, topMargin - rect.y];
    path2.rotation = 0;
    path2.scale = [1, 1];
    path2.updateTransform();
    if (path2) {
      path2.brush(ctx);
    }
    var ImageShape = Image$1;
    var imgShape = new ImageShape({
      style: {
        x: 0,
        y: 0,
        image: canvas
      }
    });
    if (pathTransform.position != null) {
      imgShape.position = path2.position = pathTransform.position;
    }
    if (pathTransform.rotation != null) {
      imgShape.rotation = path2.rotation = pathTransform.rotation;
    }
    if (pathTransform.scale != null) {
      imgShape.scale = path2.scale = pathTransform.scale;
    }
    return imgShape;
  }
};
var _default$M = Painter$3;
var Painter_1 = _default$M;
var util$1 = util$6;
var _event$1 = event;
var Dispatcher = _event$1.Dispatcher;
var requestAnimationFrame = requestAnimationFrame$2;
var Animator = Animator_1;
var Animation$1 = function(options) {
  options = options || {};
  this.stage = options.stage || {};
  this.onframe = options.onframe || function() {
  };
  this._clips = [];
  this._running = false;
  this._time;
  this._pausedTime;
  this._pauseStart;
  this._paused = false;
  Dispatcher.call(this);
};
Animation$1.prototype = {
  constructor: Animation$1,
  /**
   * Add clip
   * @param {module:zrender/animation/Clip} clip
   */
  addClip: function(clip) {
    this._clips.push(clip);
  },
  /**
   * Add animator
   * @param {module:zrender/animation/Animator} animator
   */
  addAnimator: function(animator) {
    animator.animation = this;
    var clips = animator.getClips();
    for (var i = 0; i < clips.length; i++) {
      this.addClip(clips[i]);
    }
  },
  /**
   * Delete animation clip
   * @param {module:zrender/animation/Clip} clip
   */
  removeClip: function(clip) {
    var idx = util$1.indexOf(this._clips, clip);
    if (idx >= 0) {
      this._clips.splice(idx, 1);
    }
  },
  /**
   * Delete animation clip
   * @param {module:zrender/animation/Animator} animator
   */
  removeAnimator: function(animator) {
    var clips = animator.getClips();
    for (var i = 0; i < clips.length; i++) {
      this.removeClip(clips[i]);
    }
    animator.animation = null;
  },
  _update: function() {
    var time = (/* @__PURE__ */ new Date()).getTime() - this._pausedTime;
    var delta = time - this._time;
    var clips = this._clips;
    var len = clips.length;
    var deferredEvents = [];
    var deferredClips = [];
    for (var i = 0; i < len; i++) {
      var clip = clips[i];
      var e2 = clip.step(time, delta);
      if (e2) {
        deferredEvents.push(e2);
        deferredClips.push(clip);
      }
    }
    for (var i = 0; i < len; ) {
      if (clips[i]._needsRemove) {
        clips[i] = clips[len - 1];
        clips.pop();
        len--;
      } else {
        i++;
      }
    }
    len = deferredEvents.length;
    for (var i = 0; i < len; i++) {
      deferredClips[i].fire(deferredEvents[i]);
    }
    this._time = time;
    this.onframe(delta);
    this.trigger("frame", delta);
    if (this.stage.update) {
      this.stage.update();
    }
  },
  _startLoop: function() {
    var self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame(step);
        !self2._paused && self2._update();
      }
    }
    requestAnimationFrame(step);
  },
  /**
   * Start animation.
   */
  start: function() {
    this._time = (/* @__PURE__ */ new Date()).getTime();
    this._pausedTime = 0;
    this._startLoop();
  },
  /**
   * Stop animation.
   */
  stop: function() {
    this._running = false;
  },
  /**
   * Pause animation.
   */
  pause: function() {
    if (!this._paused) {
      this._pauseStart = (/* @__PURE__ */ new Date()).getTime();
      this._paused = true;
    }
  },
  /**
   * Resume animation.
   */
  resume: function() {
    if (this._paused) {
      this._pausedTime += (/* @__PURE__ */ new Date()).getTime() - this._pauseStart;
      this._paused = false;
    }
  },
  /**
   * Clear animation.
   */
  clear: function() {
    this._clips = [];
  },
  /**
   * Whether animation finished.
   */
  isFinished: function() {
    return !this._clips.length;
  },
  /**
   * Creat animator for a target, whose props can be animated.
   *
   * @param  {Object} target
   * @param  {Object} options
   * @param  {boolean} [options.loop=false] Whether loop animation.
   * @param  {Function} [options.getter=null] Get value from target.
   * @param  {Function} [options.setter=null] Set value to target.
   * @return {module:zrender/animation/Animation~Animator}
   */
  // TODO Gap
  animate: function(target, options) {
    options = options || {};
    var animator = new Animator(target, options.loop, options.getter, options.setter);
    this.addAnimator(animator);
    return animator;
  }
};
util$1.mixin(Animation$1, Dispatcher);
var _default$L = Animation$1;
var Animation_1 = _default$L;
var _event = event;
var addEventListener = _event.addEventListener;
var removeEventListener = _event.removeEventListener;
var normalizeEvent = _event.normalizeEvent;
var getNativeEvent = _event.getNativeEvent;
var zrUtil$i = util$6;
var Eventful = Eventful_1;
var env$4 = env_1;
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env$4.domSupported;
var localNativeListenerNames = function() {
  var mouseHandlerNames = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
  var touchHandlerNames = ["touchstart", "touchend", "touchmove"];
  var pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  var pointerHandlerNames = zrUtil$i.map(mouseHandlerNames, function(name2) {
    var nm = name2.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name2;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
function eventNameFix(name2) {
  return name2 === "mousewheel" && env$4.browser.firefox ? "DOMMouseScroll" : name2;
}
function isPointerFromTouch(event2) {
  var pointerType = event2.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event2) {
  event2 && (event2.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event2) {
  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event2), true);
}
function isLocalEl(instance, el) {
  var elTmp = el;
  var isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
function FakeGlobalEvent(instance, event2) {
  this.type = event2.type;
  this.target = this.currentTarget = instance.dom;
  this.pointerType = event2.pointerType;
  this.clientX = event2.clientX;
  this.clientY = event2.clientY;
}
var fakeGlobalEventProto = FakeGlobalEvent.prototype;
fakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil$i.noop;
var localDOMHandlers = {
  mousedown: function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    this._mayPointerCapture = [event2.zrX, event2.zrY];
    this.trigger("mousedown", event2);
  },
  mousemove: function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    var downPoint = this._mayPointerCapture;
    if (downPoint && (event2.zrX !== downPoint[0] || event2.zrY !== downPoint[1])) {
      togglePointerCapture(this, true);
    }
    this.trigger("mousemove", event2);
  },
  mouseup: function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    togglePointerCapture(this, false);
    this.trigger("mouseup", event2);
  },
  mouseout: function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    if (this._pointerCapturing) {
      event2.zrEventControl = "no_globalout";
    }
    var element = event2.toElement || event2.relatedTarget;
    event2.zrIsToLocalDOM = isLocalEl(this, element);
    this.trigger("mouseout", event2);
  },
  touchstart: function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    markTouch(event2);
    this._lastTouchMoment = /* @__PURE__ */ new Date();
    this.handler.processGesture(event2, "start");
    localDOMHandlers.mousemove.call(this, event2);
    localDOMHandlers.mousedown.call(this, event2);
  },
  touchmove: function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    markTouch(event2);
    this.handler.processGesture(event2, "change");
    localDOMHandlers.mousemove.call(this, event2);
  },
  touchend: function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    markTouch(event2);
    this.handler.processGesture(event2, "end");
    localDOMHandlers.mouseup.call(this, event2);
    if (+/* @__PURE__ */ new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event2);
    }
  },
  pointerdown: function(event2) {
    localDOMHandlers.mousedown.call(this, event2);
  },
  pointermove: function(event2) {
    if (!isPointerFromTouch(event2)) {
      localDOMHandlers.mousemove.call(this, event2);
    }
  },
  pointerup: function(event2) {
    localDOMHandlers.mouseup.call(this, event2);
  },
  pointerout: function(event2) {
    if (!isPointerFromTouch(event2)) {
      localDOMHandlers.mouseout.call(this, event2);
    }
  }
};
zrUtil$i.each(["click", "mousewheel", "dblclick", "contextmenu"], function(name2) {
  localDOMHandlers[name2] = function(event2) {
    event2 = normalizeEvent(this.dom, event2);
    this.trigger(name2, event2);
  };
});
var globalDOMHandlers = {
  pointermove: function(event2) {
    if (!isPointerFromTouch(event2)) {
      globalDOMHandlers.mousemove.call(this, event2);
    }
  },
  pointerup: function(event2) {
    globalDOMHandlers.mouseup.call(this, event2);
  },
  mousemove: function(event2) {
    this.trigger("mousemove", event2);
  },
  mouseup: function(event2) {
    var pointerCaptureReleasing = this._pointerCapturing;
    togglePointerCapture(this, false);
    this.trigger("mouseup", event2);
    if (pointerCaptureReleasing) {
      event2.zrEventControl = "only_globalout";
      this.trigger("mouseout", event2);
    }
  }
};
function mountLocalDOMEventListeners(instance, scope) {
  var domHandlers = scope.domHandlers;
  if (env$4.pointerEventsSupported) {
    zrUtil$i.each(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event2) {
        domHandlers[nativeEventName].call(instance, event2);
      });
    });
  } else {
    if (env$4.touchEventsSupported) {
      zrUtil$i.each(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event2) {
          domHandlers[nativeEventName].call(instance, event2);
          setTouchTimer(scope);
        });
      });
    }
    zrUtil$i.each(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event2) {
        event2 = getNativeEvent(event2);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance, event2);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance, scope) {
  if (env$4.pointerEventsSupported) {
    zrUtil$i.each(globalNativeListenerNames.pointer, mount);
  } else if (!env$4.touchEventsSupported) {
    zrUtil$i.each(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event2) {
      event2 = getNativeEvent(event2);
      if (!isLocalEl(instance, event2.target)) {
        event2 = normalizeGlobalEvent(instance, event2);
        scope.domHandlers[nativeEventName].call(instance, event2);
      }
    }
    mountSingleDOMEventListener(
      scope,
      nativeEventName,
      nativeEventListener,
      {
        capture: true
      }
      // See [Drag Outside] in `Handler.js`
    );
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);
}
function unmountDOMEventListeners(scope) {
  var mounted = scope.mounted;
  for (var nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
function togglePointerCapture(instance, isPointerCapturing) {
  instance._mayPointerCapture = null;
  if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {
    instance._pointerCapturing = isPointerCapturing;
    var globalHandlerScope = instance._globalHandlerScope;
    isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
  }
}
function DOMHandlerScope(domTarget, domHandlers) {
  this.domTarget = domTarget;
  this.domHandlers = domHandlers;
  this.mounted = {};
  this.listenerOpts = {};
  this.touchTimer = null;
  this.touching = false;
}
function HandlerDomProxy(dom2, painterRoot) {
  Eventful.call(this);
  this.dom = dom2;
  this.painterRoot = painterRoot;
  this._localHandlerScope = new DOMHandlerScope(dom2, localDOMHandlers);
  if (globalEventSupported) {
    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
  }
  this._pointerCapturing = false;
  this._mayPointerCapture = null;
  mountLocalDOMEventListeners(this, this._localHandlerScope);
}
var handlerDomProxyProto = HandlerDomProxy.prototype;
handlerDomProxyProto.dispose = function() {
  unmountDOMEventListeners(this._localHandlerScope);
  if (globalEventSupported) {
    unmountDOMEventListeners(this._globalHandlerScope);
  }
};
handlerDomProxyProto.setCursor = function(cursorStyle) {
  this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
};
zrUtil$i.mixin(HandlerDomProxy, Eventful);
var _default$K = HandlerDomProxy;
var HandlerProxy$1 = _default$K;
var guid = guid$2;
var env$3 = env_1;
var zrUtil$h = util$6;
var Handler = Handler_1;
var Storage = Storage_1;
var Painter$2 = Painter_1;
var Animation = Animation_1;
var HandlerProxy = HandlerProxy$1;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var useVML = !env$3.canvasSupported;
var painterCtors = {
  canvas: Painter$2
};
var instances = {};
var version = "4.3.2";
function init(dom2, opts) {
  var zr = new ZRender(guid(), dom2, opts);
  instances[zr.id] = zr;
  return zr;
}
function dispose(zr) {
  if (zr) {
    zr.dispose();
  } else {
    for (var key in instances) {
      if (instances.hasOwnProperty(key)) {
        instances[key].dispose();
      }
    }
    instances = {};
  }
  return this;
}
function getInstance(id) {
  return instances[id];
}
function registerPainter(name2, Ctor) {
  painterCtors[name2] = Ctor;
}
function delInstance(id) {
  delete instances[id];
}
var ZRender = function(id, dom2, opts) {
  opts = opts || {};
  this.dom = dom2;
  this.id = id;
  var self2 = this;
  var storage2 = new Storage();
  var rendererType = opts.renderer;
  if (useVML) {
    if (!painterCtors.vml) {
      throw new Error("You need to require 'zrender/vml/vml' to support IE8");
    }
    rendererType = "vml";
  } else if (!rendererType || !painterCtors[rendererType]) {
    rendererType = "canvas";
  }
  var painter = new painterCtors[rendererType](dom2, storage2, opts, id);
  this.storage = storage2;
  this.painter = painter;
  var handerProxy = !env$3.node && !env$3.worker ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;
  this.handler = new Handler(storage2, painter, handerProxy, painter.root);
  this.animation = new Animation({
    stage: {
      update: zrUtil$h.bind(this.flush, this)
    }
  });
  this.animation.start();
  this._needsRefresh;
  var oldDelFromStorage = storage2.delFromStorage;
  var oldAddToStorage = storage2.addToStorage;
  storage2.delFromStorage = function(el) {
    oldDelFromStorage.call(storage2, el);
    el && el.removeSelfFromZr(self2);
  };
  storage2.addToStorage = function(el) {
    oldAddToStorage.call(storage2, el);
    el.addSelfToZr(self2);
  };
};
ZRender.prototype = {
  constructor: ZRender,
  /**
   * 获取实例唯一标识
   * @return {string}
   */
  getId: function() {
    return this.id;
  },
  /**
   * 添加元素
   * @param  {module:zrender/Element} el
   */
  add: function(el) {
    this.storage.addRoot(el);
    this._needsRefresh = true;
  },
  /**
   * 删除元素
   * @param  {module:zrender/Element} el
   */
  remove: function(el) {
    this.storage.delRoot(el);
    this._needsRefresh = true;
  },
  /**
   * Change configuration of layer
   * @param {string} zLevel
   * @param {Object} config
   * @param {string} [config.clearColor=0] Clear color
   * @param {string} [config.motionBlur=false] If enable motion blur
   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
  */
  configLayer: function(zLevel, config2) {
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config2);
    }
    this._needsRefresh = true;
  },
  /**
   * Set background color
   * @param {string} backgroundColor
   */
  setBackgroundColor: function(backgroundColor) {
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor);
    }
    this._needsRefresh = true;
  },
  /**
   * Repaint the canvas immediately
   */
  refreshImmediately: function() {
    this._needsRefresh = this._needsRefreshHover = false;
    this.painter.refresh();
    this._needsRefresh = this._needsRefreshHover = false;
  },
  /**
   * Mark and repaint the canvas in the next frame of browser
   */
  refresh: function() {
    this._needsRefresh = true;
  },
  /**
   * Perform all refresh
   */
  flush: function() {
    var triggerRendered;
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately();
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    triggerRendered && this.trigger("rendered");
  },
  /**
   * Add element to hover layer
   * @param  {module:zrender/Element} el
   * @param {Object} style
   */
  addHover: function(el, style) {
    if (this.painter.addHover) {
      var elMirror = this.painter.addHover(el, style);
      this.refreshHover();
      return elMirror;
    }
  },
  /**
   * Add element from hover layer
   * @param  {module:zrender/Element} el
   */
  removeHover: function(el) {
    if (this.painter.removeHover) {
      this.painter.removeHover(el);
      this.refreshHover();
    }
  },
  /**
   * Clear all hover elements in hover layer
   * @param  {module:zrender/Element} el
   */
  clearHover: function() {
    if (this.painter.clearHover) {
      this.painter.clearHover();
      this.refreshHover();
    }
  },
  /**
   * Refresh hover in next frame
   */
  refreshHover: function() {
    this._needsRefreshHover = true;
  },
  /**
   * Refresh hover immediately
   */
  refreshHoverImmediately: function() {
    this._needsRefreshHover = false;
    this.painter.refreshHover && this.painter.refreshHover();
  },
  /**
   * Resize the canvas.
   * Should be invoked when container size is changed
   * @param {Object} [opts]
   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
   */
  resize: function(opts) {
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  },
  /**
   * Stop and clear all animation immediately
   */
  clearAnimation: function() {
    this.animation.clear();
  },
  /**
   * Get container width
   */
  getWidth: function() {
    return this.painter.getWidth();
  },
  /**
   * Get container height
   */
  getHeight: function() {
    return this.painter.getHeight();
  },
  /**
   * Export the canvas as Base64 URL
   * @param {string} type
   * @param {string} [backgroundColor='#fff']
   * @return {string} Base64 URL
   */
  // toDataURL: function(type, backgroundColor) {
  //     return this.painter.getRenderedCanvas({
  //         backgroundColor: backgroundColor
  //     }).toDataURL(type);
  // },
  /**
   * Converting a path to image.
   * It has much better performance of drawing image rather than drawing a vector path.
   * @param {module:zrender/graphic/Path} e
   * @param {number} width
   * @param {number} height
   */
  pathToImage: function(e2, dpr2) {
    return this.painter.pathToImage(e2, dpr2);
  },
  /**
   * Set default cursor
   * @param {string} [cursorStyle='default'] 例如 crosshair
   */
  setCursorStyle: function(cursorStyle) {
    this.handler.setCursorStyle(cursorStyle);
  },
  /**
   * Find hovered element
   * @param {number} x
   * @param {number} y
   * @return {Object} {target, topTarget}
   */
  findHover: function(x, y) {
    return this.handler.findHover(x, y);
  },
  /**
   * Bind event
   *
   * @param {string} eventName Event name
   * @param {Function} eventHandler Handler function
   * @param {Object} [context] Context object
   */
  on: function(eventName, eventHandler, context) {
    this.handler.on(eventName, eventHandler, context);
  },
  /**
   * Unbind event
   * @param {string} eventName Event name
   * @param {Function} [eventHandler] Handler function
   */
  off: function(eventName, eventHandler) {
    this.handler.off(eventName, eventHandler);
  },
  /**
   * Trigger event manually
   *
   * @param {string} eventName Event name
   * @param {event=} event Event object
   */
  trigger: function(eventName, event2) {
    this.handler.trigger(eventName, event2);
  },
  /**
   * Clear all objects and the canvas.
   */
  clear: function() {
    this.storage.delRoot();
    this.painter.clear();
  },
  /**
   * Dispose self.
   */
  dispose: function() {
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    delInstance(this.id);
  }
};
zrender.version = version;
zrender.init = init;
zrender.dispose = dispose;
zrender.getInstance = getInstance;
zrender.registerPainter = registerPainter;
var model = {};
var zrUtil$g = util$6;
var env$2 = env_1;
var each$b = zrUtil$g.each;
var isObject$4 = zrUtil$g.isObject;
var isArray$4 = zrUtil$g.isArray;
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
function normalizeToArray$3(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
function defaultEmphasis(opt, key, subOpts) {
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {};
    for (var i = 0, len = subOpts.length; i < len; i++) {
      var subOptName = subOpts[i];
      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function getDataItemValue$1(dataItem) {
  return isObject$4(dataItem) && !isArray$4(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption$1(dataItem) {
  return isObject$4(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(exists, newCptOptions) {
  newCptOptions = (newCptOptions || []).slice();
  var result = zrUtil$g.map(exists || [], function(obj, index2) {
    return {
      exist: obj
    };
  });
  each$b(newCptOptions, function(cptOption, index2) {
    if (!isObject$4(cptOption)) {
      return;
    }
    for (var i = 0; i < result.length; i++) {
      if (!result[i].option && cptOption.id != null && result[i].exist.id === cptOption.id + "") {
        result[i].option = cptOption;
        newCptOptions[index2] = null;
        return;
      }
    }
    for (var i = 0; i < result.length; i++) {
      var exist = result[i].exist;
      if (!result[i].option && (exist.id == null || cptOption.id == null) && cptOption.name != null && !isIdInner(cptOption) && !isIdInner(exist) && exist.name === cptOption.name + "") {
        result[i].option = cptOption;
        newCptOptions[index2] = null;
        return;
      }
    }
  });
  each$b(newCptOptions, function(cptOption, index2) {
    if (!isObject$4(cptOption)) {
      return;
    }
    var i = 0;
    for (; i < result.length; i++) {
      var exist = result[i].exist;
      if (!result[i].option && !isIdInner(exist) && cptOption.id == null) {
        result[i].option = cptOption;
        break;
      }
    }
    if (i >= result.length) {
      result.push({
        option: cptOption
      });
    }
  });
  return result;
}
function makeIdAndName(mapResult) {
  var idMap = zrUtil$g.createHashMap();
  each$b(mapResult, function(item, index2) {
    var existCpt = item.exist;
    existCpt && idMap.set(existCpt.id, item);
  });
  each$b(mapResult, function(item, index2) {
    var opt = item.option;
    zrUtil$g.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each$b(mapResult, function(item, index2) {
    var existCpt = item.exist;
    var opt = item.option;
    var keyInfo = item.keyInfo;
    if (!isObject$4(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? opt.name + "" : existCpt ? existCpt.name : DUMMY_COMPONENT_NAME_PREFIX + index2;
    if (existCpt) {
      keyInfo.id = existCpt.id;
    } else if (opt.id != null) {
      keyInfo.id = opt.id + "";
    } else {
      var idNum = 0;
      do {
        keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function isNameSpecified(componentModel) {
  var name2 = componentModel.name;
  return !!(name2 && name2.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isIdInner(cptOption) {
  return isObject$4(cptOption) && cptOption.id && (cptOption.id + "").indexOf("\0_ec_\0") === 0;
}
function compressBatches(batchA, batchB) {
  var mapA = {};
  var mapB = {};
  makeMap2(batchA || [], mapA);
  makeMap2(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];
  function makeMap2(sourceBatch, map2, otherMap) {
    for (var i = 0, len = sourceBatch.length; i < len; i++) {
      var seriesId = sourceBatch[i].seriesId;
      var dataIndices = normalizeToArray$3(sourceBatch[i].dataIndex);
      var otherDataIndices = otherMap && otherMap[seriesId];
      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
        var dataIndex = dataIndices[j];
        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map2[seriesId] || (map2[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }
  function mapToArray(map2, isData) {
    var result = [];
    for (var i in map2) {
      if (map2.hasOwnProperty(i) && map2[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          var dataIndices = mapToArray(map2[i], true);
          dataIndices.length && result.push({
            seriesId: i,
            dataIndex: dataIndices
          });
        }
      }
    }
    return result;
  }
}
function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return zrUtil$g.isArray(payload.dataIndex) ? zrUtil$g.map(payload.dataIndex, function(value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return zrUtil$g.isArray(payload.name) ? zrUtil$g.map(payload.name, function(value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
function makeInner$3() {
  var key = "__\0ec_inner_" + innerUniqueIndex++ + "_" + Math.random().toFixed(5);
  return function(hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = 0;
function parseFinder(ecModel, finder, opt) {
  if (zrUtil$g.isString(finder)) {
    var obj = {};
    obj[finder + "Index"] = 0;
    finder = obj;
  }
  var defaultMainType = opt && opt.defaultMainType;
  if (defaultMainType && !has(finder, defaultMainType + "Index") && !has(finder, defaultMainType + "Id") && !has(finder, defaultMainType + "Name")) {
    finder[defaultMainType + "Index"] = 0;
  }
  var result = {};
  each$b(finder, function(value, key) {
    var value = finder[key];
    if (key === "dataIndex" || key === "dataIndexInside") {
      result[key] = value;
      return;
    }
    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    var mainType = parsedKey[1];
    var queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || value == null || queryType === "index" && value === "none" || opt && opt.includeMainTypes && zrUtil$g.indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    var queryParam = {
      mainType
    };
    if (queryType !== "index" || value !== "all") {
      queryParam[queryType] = value;
    }
    var models = ecModel.queryComponents(queryParam);
    result[mainType + "Models"] = models;
    result[mainType + "Model"] = models[0];
  });
  return result;
}
function has(obj, prop) {
  return obj && obj.hasOwnProperty(prop);
}
function setAttribute(dom2, key, value) {
  dom2.setAttribute ? dom2.setAttribute(key, value) : dom2[key] = value;
}
function getAttribute(dom2, key) {
  return dom2.getAttribute ? dom2.getAttribute(key) : dom2[key];
}
function getTooltipRenderMode$1(renderModeOption) {
  if (renderModeOption === "auto") {
    return env$2.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function groupData(array, getKey) {
  var buckets = zrUtil$g.createHashMap();
  var keys = [];
  zrUtil$g.each(array, function(item) {
    var key = getKey(item);
    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);
  });
  return {
    keys,
    buckets
  };
}
model.normalizeToArray = normalizeToArray$3;
model.defaultEmphasis = defaultEmphasis;
model.TEXT_STYLE_OPTIONS = TEXT_STYLE_OPTIONS;
model.getDataItemValue = getDataItemValue$1;
model.isDataItemOption = isDataItemOption$1;
model.mappingToExists = mappingToExists;
model.makeIdAndName = makeIdAndName;
model.isNameSpecified = isNameSpecified;
model.isIdInner = isIdInner;
model.compressBatches = compressBatches;
model.queryDataIndex = queryDataIndex;
model.makeInner = makeInner$3;
model.parseFinder = parseFinder;
model.setAttribute = setAttribute;
model.getAttribute = getAttribute;
model.getTooltipRenderMode = getTooltipRenderMode$1;
model.groupData = groupData;
var clazz = {};
var zrUtil$f = util$6;
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
function parseClassType$2(componentType) {
  var ret = {
    main: "",
    sub: ""
  };
  if (componentType) {
    componentType = componentType.split(TYPE_DELIMITER);
    ret.main = componentType[0] || "";
    ret.sub = componentType[1] || "";
  }
  return ret;
}
function checkClassType(componentType) {
  zrUtil$f.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function enableClassExtend(RootClass, mandatoryMethods) {
  RootClass.$constructor = RootClass;
  RootClass.extend = function(proto2) {
    var superClass = this;
    var ExtendedClass = function() {
      if (!proto2.$constructor) {
        superClass.apply(this, arguments);
      } else {
        proto2.$constructor.apply(this, arguments);
      }
    };
    zrUtil$f.extend(ExtendedClass.prototype, proto2);
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    zrUtil$f.inherits(ExtendedClass, this);
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
var classBase = 0;
function enableClassCheck(Clz) {
  var classAttr = ["__\0is_clz", classBase++, Math.random().toFixed(3)].join("_");
  Clz.prototype[classAttr] = true;
  Clz.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName) {
  var args = zrUtil$f.slice(arguments, 2);
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement$1(entity, options) {
  options = options || {};
  var storage2 = {};
  entity.registerClass = function(Clazz, componentType) {
    if (componentType) {
      checkClassType(componentType);
      componentType = parseClassType$2(componentType);
      if (!componentType.sub) {
        storage2[componentType.main] = Clazz;
      } else if (componentType.sub !== IS_CONTAINER) {
        var container = makeContainer(componentType);
        container[componentType.sub] = Clazz;
      }
    }
    return Clazz;
  };
  entity.getClass = function(componentMainType, subType, throwWhenNotFound) {
    var Clazz = storage2[componentMainType];
    if (Clazz && Clazz[IS_CONTAINER]) {
      Clazz = subType ? Clazz[subType] : null;
    }
    if (throwWhenNotFound && !Clazz) {
      throw new Error(!subType ? componentMainType + ".type should be specified." : "Component " + componentMainType + "." + (subType || "") + " not exists. Load it first.");
    }
    return Clazz;
  };
  entity.getClassesByMainType = function(componentType) {
    componentType = parseClassType$2(componentType);
    var result = [];
    var obj = storage2[componentType.main];
    if (obj && obj[IS_CONTAINER]) {
      zrUtil$f.each(obj, function(o2, type) {
        type !== IS_CONTAINER && result.push(o2);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  entity.hasClass = function(componentType) {
    componentType = parseClassType$2(componentType);
    return !!storage2[componentType.main];
  };
  entity.getAllClassMainTypes = function() {
    var types = [];
    zrUtil$f.each(storage2, function(obj, type) {
      types.push(type);
    });
    return types;
  };
  entity.hasSubTypes = function(componentType) {
    componentType = parseClassType$2(componentType);
    var obj = storage2[componentType.main];
    return obj && obj[IS_CONTAINER];
  };
  entity.parseClassType = parseClassType$2;
  function makeContainer(componentType) {
    var container = storage2[componentType.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage2[componentType.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
  if (options.registerWhenExtend) {
    var originalExtend = entity.extend;
    if (originalExtend) {
      entity.extend = function(proto2) {
        var ExtendedClass = originalExtend.call(this, proto2);
        return entity.registerClass(ExtendedClass, proto2.type);
      };
    }
  }
  return entity;
}
function setReadOnly(obj, properties) {
}
clazz.parseClassType = parseClassType$2;
clazz.enableClassExtend = enableClassExtend;
clazz.enableClassCheck = enableClassCheck;
clazz.enableClassManagement = enableClassManagement$1;
clazz.setReadOnly = setReadOnly;
var makeStyleMapper;
var hasRequiredMakeStyleMapper;
function requireMakeStyleMapper() {
  if (hasRequiredMakeStyleMapper)
    return makeStyleMapper;
  hasRequiredMakeStyleMapper = 1;
  var zrUtil2 = util$6;
  function _default2(properties) {
    for (var i = 0; i < properties.length; i++) {
      if (!properties[i][1]) {
        properties[i][1] = properties[i][0];
      }
    }
    return function(model2, excludes, includes) {
      var style = {};
      for (var i2 = 0; i2 < properties.length; i2++) {
        var propName = properties[i2][1];
        if (excludes && zrUtil2.indexOf(excludes, propName) >= 0 || includes && zrUtil2.indexOf(includes, propName) < 0) {
          continue;
        }
        var val = model2.getShallow(propName);
        if (val != null) {
          style[properties[i2][0]] = val;
        }
      }
      return style;
    };
  }
  makeStyleMapper = _default2;
  return makeStyleMapper;
}
var lineStyle;
var hasRequiredLineStyle;
function requireLineStyle() {
  if (hasRequiredLineStyle)
    return lineStyle;
  hasRequiredLineStyle = 1;
  var makeStyleMapper2 = requireMakeStyleMapper();
  var getLineStyle = makeStyleMapper2([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
  var _default2 = {
    getLineStyle: function(excludes) {
      var style = getLineStyle(this, excludes);
      style.lineDash = this.getLineDash(style.lineWidth);
      return style;
    },
    getLineDash: function(lineWidth) {
      if (lineWidth == null) {
        lineWidth = 1;
      }
      var lineType = this.get("type");
      var dotSize = Math.max(lineWidth, 2);
      var dashSize = lineWidth * 4;
      return lineType === "solid" || lineType == null ? (
        // Use `false` but not `null` for the solid line here, because `null` might be
        // ignored when assigning to `el.style`. e.g., when setting `lineStyle.type` as
        // `'dashed'` and `emphasis.lineStyle.type` as `'solid'` in graph series, the
        // `lineDash` gotten form the latter one is not able to erase that from the former
        // one if using `null` here according to the emhpsis strategy in `util/graphic.js`.
        false
      ) : lineType === "dashed" ? [dashSize, dashSize] : [dotSize, dotSize];
    }
  };
  lineStyle = _default2;
  return lineStyle;
}
var areaStyle;
var hasRequiredAreaStyle;
function requireAreaStyle() {
  if (hasRequiredAreaStyle)
    return areaStyle;
  hasRequiredAreaStyle = 1;
  var makeStyleMapper2 = requireMakeStyleMapper();
  var getAreaStyle = makeStyleMapper2([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]]);
  var _default2 = {
    getAreaStyle: function(excludes, includes) {
      return getAreaStyle(this, excludes, includes);
    }
  };
  areaStyle = _default2;
  return areaStyle;
}
var graphic$4 = {};
var path$1 = {};
var curve$3 = {};
var _vector$3 = requireVector();
var v2Create = _vector$3.create;
var v2DistSquare = _vector$3.distSquare;
var mathPow = Math.pow;
var mathSqrt$3 = Math.sqrt;
var EPSILON$1 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt$3(3);
var ONE_THIRD = 1 / 3;
var _v0 = v2Create();
var _v1 = v2Create();
var _v2 = v2Create();
function isAroundZero(val) {
  return val > -EPSILON$1 && val < EPSILON$1;
}
function isNotAroundZero(val) {
  return val > EPSILON$1 || val < -EPSILON$1;
}
function cubicAt$1(p0, p1, p2, p3, t2) {
  var onet = 1 - t2;
  return onet * onet * (onet * p0 + 3 * t2 * p1) + t2 * t2 * (t2 * p3 + 3 * onet * p2);
}
function cubicDerivativeAt$1(p0, p1, p2, p3, t2) {
  var onet = 1 - t2;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t2) * onet + (p3 - p2) * t2 * t2);
}
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  var a = p3 + 3 * (p1 - p2) - p0;
  var b = 3 * (p2 - p1 * 2 + p0);
  var c = 3 * (p1 - p0);
  var d = p0 - val;
  var A = b * b - 3 * a * c;
  var B = b * c - 9 * a * d;
  var C = c * c - 3 * b * d;
  var n = 0;
  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) {
      roots2[0] = 0;
    } else {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      var K = B / A;
      var t1 = -b / a + K;
      var t2 = -K / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var Y1 = A * b + 1.5 * a * (-B + discSqrt);
      var Y2 = A * b + 1.5 * a * (-B - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }
      var t1 = (-b - (Y1 + Y2)) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else {
      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt$3(A * A * A));
      var theta = Math.acos(T) / 3;
      var ASqrt = mathSqrt$3(A);
      var tmp = Math.cos(theta);
      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
      if (t3 >= 0 && t3 <= 1) {
        roots2[n++] = t3;
      }
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  var b = 6 * p2 - 12 * p1 + 6 * p0;
  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  var c = 3 * p1 - 3 * p0;
  var n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      extrema2[0] = -b / (2 * a);
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        extrema2[n++] = t2;
      }
    }
  }
  return n;
}
function cubicSubdivide$1(p0, p1, p2, p3, t2, out2) {
  var p01 = (p1 - p0) * t2 + p0;
  var p12 = (p2 - p1) * t2 + p1;
  var p23 = (p3 - p2) * t2 + p2;
  var p012 = (p12 - p01) * t2 + p01;
  var p123 = (p23 - p12) * t2 + p12;
  var p0123 = (p123 - p012) * t2 + p012;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p0123;
  out2[4] = p0123;
  out2[5] = p123;
  out2[6] = p23;
  out2[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out2) {
  var t2;
  var interval = 5e-3;
  var d = Infinity;
  var prev;
  var next;
  var d1;
  var d2;
  _v0[0] = x;
  _v0[1] = y;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt$1(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt$1(y0, y1, y2, y3, _t);
    d1 = v2DistSquare(_v0, _v1);
    if (d1 < d) {
      t2 = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev = t2 - interval;
    next = t2 + interval;
    _v1[0] = cubicAt$1(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt$1(y0, y1, y2, y3, prev);
    d1 = v2DistSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t2 = prev;
      d = d1;
    } else {
      _v2[0] = cubicAt$1(x0, x1, x2, x3, next);
      _v2[1] = cubicAt$1(y0, y1, y2, y3, next);
      d2 = v2DistSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t2 = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = cubicAt$1(x0, x1, x2, x3, t2);
    out2[1] = cubicAt$1(y0, y1, y2, y3, t2);
  }
  return mathSqrt$3(d);
}
function quadraticAt$1(p0, p1, p2, t2) {
  var onet = 1 - t2;
  return onet * (onet * p0 + 2 * t2 * p1) + t2 * t2 * p2;
}
function quadraticDerivativeAt$1(p0, p1, p2, t2) {
  return 2 * ((1 - t2) * (p1 - p0) + t2 * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  var a = p0 - 2 * p1 + p2;
  var b = 2 * (p1 - p0);
  var c = p0 - val;
  var n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      var t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      var t1 = -b / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else if (disc > 0) {
      var discSqrt = mathSqrt$3(disc);
      var t1 = (-b + discSqrt) / (2 * a);
      var t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  var divider = p0 + p2 - 2 * p1;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
function quadraticSubdivide$1(p0, p1, p2, t2, out2) {
  var p01 = (p1 - p0) * t2 + p0;
  var p12 = (p2 - p1) * t2 + p1;
  var p012 = (p12 - p01) * t2 + p01;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p012;
  out2[4] = p12;
  out2[5] = p2;
}
function quadraticProjectPoint$1(x0, y0, x1, y1, x2, y2, x, y, out2) {
  var t2;
  var interval = 5e-3;
  var d = Infinity;
  _v0[0] = x;
  _v0[1] = y;
  for (var _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt$1(x0, x1, x2, _t);
    _v1[1] = quadraticAt$1(y0, y1, y2, _t);
    var d1 = v2DistSquare(_v0, _v1);
    if (d1 < d) {
      t2 = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    var prev = t2 - interval;
    var next = t2 + interval;
    _v1[0] = quadraticAt$1(x0, x1, x2, prev);
    _v1[1] = quadraticAt$1(y0, y1, y2, prev);
    var d1 = v2DistSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t2 = prev;
      d = d1;
    } else {
      _v2[0] = quadraticAt$1(x0, x1, x2, next);
      _v2[1] = quadraticAt$1(y0, y1, y2, next);
      var d2 = v2DistSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t2 = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = quadraticAt$1(x0, x1, x2, t2);
    out2[1] = quadraticAt$1(y0, y1, y2, t2);
  }
  return mathSqrt$3(d);
}
curve$3.cubicAt = cubicAt$1;
curve$3.cubicDerivativeAt = cubicDerivativeAt$1;
curve$3.cubicRootAt = cubicRootAt;
curve$3.cubicExtrema = cubicExtrema;
curve$3.cubicSubdivide = cubicSubdivide$1;
curve$3.cubicProjectPoint = cubicProjectPoint;
curve$3.quadraticAt = quadraticAt$1;
curve$3.quadraticDerivativeAt = quadraticDerivativeAt$1;
curve$3.quadraticRootAt = quadraticRootAt;
curve$3.quadraticExtremum = quadraticExtremum;
curve$3.quadraticSubdivide = quadraticSubdivide$1;
curve$3.quadraticProjectPoint = quadraticProjectPoint$1;
var bbox$1 = {};
var hasRequiredBbox;
function requireBbox() {
  if (hasRequiredBbox)
    return bbox$1;
  hasRequiredBbox = 1;
  var vec22 = requireVector();
  var curve2 = curve$3;
  var mathMin2 = Math.min;
  var mathMax2 = Math.max;
  var mathSin2 = Math.sin;
  var mathCos2 = Math.cos;
  var PI22 = Math.PI * 2;
  var start = vec22.create();
  var end = vec22.create();
  var extremity = vec22.create();
  function fromPoints(points2, min3, max3) {
    if (points2.length === 0) {
      return;
    }
    var p2 = points2[0];
    var left = p2[0];
    var right = p2[0];
    var top = p2[1];
    var bottom = p2[1];
    var i;
    for (i = 1; i < points2.length; i++) {
      p2 = points2[i];
      left = mathMin2(left, p2[0]);
      right = mathMax2(right, p2[0]);
      top = mathMin2(top, p2[1]);
      bottom = mathMax2(bottom, p2[1]);
    }
    min3[0] = left;
    min3[1] = top;
    max3[0] = right;
    max3[1] = bottom;
  }
  function fromLine(x0, y0, x1, y1, min3, max3) {
    min3[0] = mathMin2(x0, x1);
    min3[1] = mathMin2(y0, y1);
    max3[0] = mathMax2(x0, x1);
    max3[1] = mathMax2(y0, y1);
  }
  var xDim = [];
  var yDim = [];
  function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
    var cubicExtrema2 = curve2.cubicExtrema;
    var cubicAt2 = curve2.cubicAt;
    var i;
    var n = cubicExtrema2(x0, x1, x2, x3, xDim);
    min3[0] = Infinity;
    min3[1] = Infinity;
    max3[0] = -Infinity;
    max3[1] = -Infinity;
    for (i = 0; i < n; i++) {
      var x = cubicAt2(x0, x1, x2, x3, xDim[i]);
      min3[0] = mathMin2(x, min3[0]);
      max3[0] = mathMax2(x, max3[0]);
    }
    n = cubicExtrema2(y0, y1, y2, y3, yDim);
    for (i = 0; i < n; i++) {
      var y = cubicAt2(y0, y1, y2, y3, yDim[i]);
      min3[1] = mathMin2(y, min3[1]);
      max3[1] = mathMax2(y, max3[1]);
    }
    min3[0] = mathMin2(x0, min3[0]);
    max3[0] = mathMax2(x0, max3[0]);
    min3[0] = mathMin2(x3, min3[0]);
    max3[0] = mathMax2(x3, max3[0]);
    min3[1] = mathMin2(y0, min3[1]);
    max3[1] = mathMax2(y0, max3[1]);
    min3[1] = mathMin2(y3, min3[1]);
    max3[1] = mathMax2(y3, max3[1]);
  }
  function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
    var quadraticExtremum2 = curve2.quadraticExtremum;
    var quadraticAt2 = curve2.quadraticAt;
    var tx = mathMax2(mathMin2(quadraticExtremum2(x0, x1, x2), 1), 0);
    var ty = mathMax2(mathMin2(quadraticExtremum2(y0, y1, y2), 1), 0);
    var x = quadraticAt2(x0, x1, x2, tx);
    var y = quadraticAt2(y0, y1, y2, ty);
    min3[0] = mathMin2(x0, x2, x);
    min3[1] = mathMin2(y0, y2, y);
    max3[0] = mathMax2(x0, x2, x);
    max3[1] = mathMax2(y0, y2, y);
  }
  function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
    var vec2Min = vec22.min;
    var vec2Max = vec22.max;
    var diff2 = Math.abs(startAngle - endAngle);
    if (diff2 % PI22 < 1e-4 && diff2 > 1e-4) {
      min3[0] = x - rx;
      min3[1] = y - ry;
      max3[0] = x + rx;
      max3[1] = y + ry;
      return;
    }
    start[0] = mathCos2(startAngle) * rx + x;
    start[1] = mathSin2(startAngle) * ry + y;
    end[0] = mathCos2(endAngle) * rx + x;
    end[1] = mathSin2(endAngle) * ry + y;
    vec2Min(min3, start, end);
    vec2Max(max3, start, end);
    startAngle = startAngle % PI22;
    if (startAngle < 0) {
      startAngle = startAngle + PI22;
    }
    endAngle = endAngle % PI22;
    if (endAngle < 0) {
      endAngle = endAngle + PI22;
    }
    if (startAngle > endAngle && !anticlockwise) {
      endAngle += PI22;
    } else if (startAngle < endAngle && anticlockwise) {
      startAngle += PI22;
    }
    if (anticlockwise) {
      var tmp = endAngle;
      endAngle = startAngle;
      startAngle = tmp;
    }
    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
      if (angle > startAngle) {
        extremity[0] = mathCos2(angle) * rx + x;
        extremity[1] = mathSin2(angle) * ry + y;
        vec2Min(min3, extremity, min3);
        vec2Max(max3, extremity, max3);
      }
    }
  }
  bbox$1.fromPoints = fromPoints;
  bbox$1.fromLine = fromLine;
  bbox$1.fromCubic = fromCubic;
  bbox$1.fromQuadratic = fromQuadratic;
  bbox$1.fromArc = fromArc;
  return bbox$1;
}
var curve$2 = curve$3;
var vec2$1 = requireVector();
var bbox = requireBbox();
var BoundingRect$3 = BoundingRect_1;
var _config = config;
var dpr = _config.devicePixelRatio;
var CMD$2 = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  // Rect
  R: 7
};
var min = [];
var max = [];
var min2 = [];
var max2 = [];
var mathMin$1 = Math.min;
var mathMax$1 = Math.max;
var mathCos$1 = Math.cos;
var mathSin$1 = Math.sin;
var mathSqrt$2 = Math.sqrt;
var mathAbs = Math.abs;
var hasTypedArray = typeof Float32Array !== "undefined";
var PathProxy$4 = function(notSaveData) {
  this._saveData = !(notSaveData || false);
  if (this._saveData) {
    this.data = [];
  }
  this._ctx = null;
};
PathProxy$4.prototype = {
  constructor: PathProxy$4,
  _xi: 0,
  _yi: 0,
  _x0: 0,
  _y0: 0,
  // Unit x, Unit y. Provide for avoiding drawing that too short line segment
  _ux: 0,
  _uy: 0,
  _len: 0,
  _lineDash: null,
  _dashOffset: 0,
  _dashIdx: 0,
  _dashSum: 0,
  /**
   * @readOnly
   */
  setScale: function(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;
    this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;
  },
  getContext: function() {
    return this._ctx;
  },
  /**
   * @param  {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  beginPath: function(ctx) {
    this._ctx = ctx;
    ctx && ctx.beginPath();
    ctx && (this.dpr = ctx.dpr);
    if (this._saveData) {
      this._len = 0;
    }
    if (this._lineDash) {
      this._lineDash = null;
      this._dashOffset = 0;
    }
    return this;
  },
  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  moveTo: function(x, y) {
    this.addData(CMD$2.M, x, y);
    this._ctx && this._ctx.moveTo(x, y);
    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  },
  /**
   * @param  {number} x
   * @param  {number} y
   * @return {module:zrender/core/PathProxy}
   */
  lineTo: function(x, y) {
    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy || this._len < 5;
    this.addData(CMD$2.L, x, y);
    if (this._ctx && exceedUnit) {
      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
    }
    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
    }
    return this;
  },
  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @param  {number} x3
   * @param  {number} y3
   * @return {module:zrender/core/PathProxy}
   */
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this.addData(CMD$2.C, x1, y1, x2, y2, x3, y3);
    if (this._ctx) {
      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  },
  /**
   * @param  {number} x1
   * @param  {number} y1
   * @param  {number} x2
   * @param  {number} y2
   * @return {module:zrender/core/PathProxy}
   */
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this.addData(CMD$2.Q, x1, y1, x2, y2);
    if (this._ctx) {
      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }
    this._xi = x2;
    this._yi = y2;
    return this;
  },
  /**
   * @param  {number} cx
   * @param  {number} cy
   * @param  {number} r
   * @param  {number} startAngle
   * @param  {number} endAngle
   * @param  {boolean} anticlockwise
   * @return {module:zrender/core/PathProxy}
   */
  arc: function(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.addData(CMD$2.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos$1(endAngle) * r + cx;
    this._yi = mathSin$1(endAngle) * r + cy;
    return this;
  },
  // TODO
  arcTo: function(x1, y1, x2, y2, radius) {
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }
    return this;
  },
  // TODO
  rect: function(x, y, w, h) {
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD$2.R, x, y, w, h);
    return this;
  },
  /**
   * @return {module:zrender/core/PathProxy}
   */
  closePath: function() {
    this.addData(CMD$2.Z);
    var ctx = this._ctx;
    var x0 = this._x0;
    var y0 = this._y0;
    if (ctx) {
      this._needsDash() && this._dashedLineTo(x0, y0);
      ctx.closePath();
    }
    this._xi = x0;
    this._yi = y0;
    return this;
  },
  /**
   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
   * stroke 同样
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  fill: function(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  },
  /**
   * @param {CanvasRenderingContext2D} ctx
   * @return {module:zrender/core/PathProxy}
   */
  stroke: function(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  },
  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDash: function(lineDash) {
    if (lineDash instanceof Array) {
      this._lineDash = lineDash;
      this._dashIdx = 0;
      var lineDashSum = 0;
      for (var i = 0; i < lineDash.length; i++) {
        lineDashSum += lineDash[i];
      }
      this._dashSum = lineDashSum;
    }
    return this;
  },
  /**
   * 必须在其它绘制命令前调用
   * Must be invoked before all other path drawing methods
   * @return {module:zrender/core/PathProxy}
   */
  setLineDashOffset: function(offset) {
    this._dashOffset = offset;
    return this;
  },
  /**
   *
   * @return {boolean}
   */
  len: function() {
    return this._len;
  },
  /**
   * 直接设置 Path 数据
   */
  setData: function(data) {
    var len = data.length;
    if (!(this.data && this.data.length === len) && hasTypedArray) {
      this.data = new Float32Array(len);
    }
    for (var i = 0; i < len; i++) {
      this.data[i] = data[i];
    }
    this._len = len;
  },
  /**
   * 添加子路径
   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
   */
  appendPath: function(path2) {
    if (!(path2 instanceof Array)) {
      path2 = [path2];
    }
    var len = path2.length;
    var appendSize = 0;
    var offset = this._len;
    for (var i = 0; i < len; i++) {
      appendSize += path2[i].len();
    }
    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }
    for (var i = 0; i < len; i++) {
      var appendPathData = path2[i].data;
      for (var k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }
    this._len = offset;
  },
  /**
   * 填充 Path 数据。
   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
   */
  addData: function(cmd) {
    if (!this._saveData) {
      return;
    }
    var data = this.data;
    if (this._len + arguments.length > data.length) {
      this._expandData();
      data = this.data;
    }
    for (var i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }
    this._prevCmd = cmd;
  },
  _expandData: function() {
    if (!(this.data instanceof Array)) {
      var newData = [];
      for (var i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }
  },
  /**
   * If needs js implemented dashed line
   * @return {boolean}
   * @private
   */
  _needsDash: function() {
    return this._lineDash;
  },
  _dashedLineTo: function(x1, y1) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var dx = x1 - x0;
    var dy = y1 - y0;
    var dist2 = mathSqrt$2(dx * dx + dy * dy);
    var x = x0;
    var y = y0;
    var dash;
    var nDash = lineDash.length;
    var idx;
    dx /= dist2;
    dy /= dist2;
    if (offset < 0) {
      offset = dashSum + offset;
    }
    offset %= dashSum;
    x -= offset * dx;
    y -= offset * dy;
    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {
      idx = this._dashIdx;
      dash = lineDash[idx];
      x += dx * dash;
      y += dy * dash;
      this._dashIdx = (idx + 1) % nDash;
      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {
        continue;
      }
      ctx[idx % 2 ? "moveTo" : "lineTo"](dx >= 0 ? mathMin$1(x, x1) : mathMax$1(x, x1), dy >= 0 ? mathMin$1(y, y1) : mathMax$1(y, y1));
    }
    dx = x - x1;
    dy = y - y1;
    this._dashOffset = -mathSqrt$2(dx * dx + dy * dy);
  },
  // Not accurate dashed line to
  _dashedBezierTo: function(x1, y1, x2, y2, x3, y3) {
    var dashSum = this._dashSum;
    var offset = this._dashOffset;
    var lineDash = this._lineDash;
    var ctx = this._ctx;
    var x0 = this._xi;
    var y0 = this._yi;
    var t2;
    var dx;
    var dy;
    var cubicAt2 = curve$2.cubicAt;
    var bezierLen = 0;
    var idx = this._dashIdx;
    var nDash = lineDash.length;
    var x;
    var y;
    var tmpLen = 0;
    if (offset < 0) {
      offset = dashSum + offset;
    }
    offset %= dashSum;
    for (t2 = 0; t2 < 1; t2 += 0.1) {
      dx = cubicAt2(x0, x1, x2, x3, t2 + 0.1) - cubicAt2(x0, x1, x2, x3, t2);
      dy = cubicAt2(y0, y1, y2, y3, t2 + 0.1) - cubicAt2(y0, y1, y2, y3, t2);
      bezierLen += mathSqrt$2(dx * dx + dy * dy);
    }
    for (; idx < nDash; idx++) {
      tmpLen += lineDash[idx];
      if (tmpLen > offset) {
        break;
      }
    }
    t2 = (tmpLen - offset) / bezierLen;
    while (t2 <= 1) {
      x = cubicAt2(x0, x1, x2, x3, t2);
      y = cubicAt2(y0, y1, y2, y3, t2);
      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      t2 += lineDash[idx] / bezierLen;
      idx = (idx + 1) % nDash;
    }
    idx % 2 !== 0 && ctx.lineTo(x3, y3);
    dx = x3 - x;
    dy = y3 - y;
    this._dashOffset = -mathSqrt$2(dx * dx + dy * dy);
  },
  _dashedQuadraticTo: function(x1, y1, x2, y2) {
    var x3 = x2;
    var y3 = y2;
    x2 = (x2 + 2 * x1) / 3;
    y2 = (y2 + 2 * y1) / 3;
    x1 = (this._xi + 2 * x1) / 3;
    y1 = (this._yi + 2 * y1) / 3;
    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
  },
  /**
   * 转成静态的 Float32Array 减少堆内存占用
   * Convert dynamic array to static Float32Array
   */
  toStatic: function() {
    var data = this.data;
    if (data instanceof Array) {
      data.length = this._len;
      if (hasTypedArray) {
        this.data = new Float32Array(data);
      }
    }
  },
  /**
   * @return {module:zrender/core/BoundingRect}
   */
  getBoundingRect: function() {
    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
    var data = this.data;
    var xi = 0;
    var yi = 0;
    var x0 = 0;
    var y0 = 0;
    for (var i = 0; i < data.length; ) {
      var cmd = data[i++];
      if (i === 1) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD$2.M:
          x0 = data[i++];
          y0 = data[i++];
          xi = x0;
          yi = y0;
          min2[0] = x0;
          min2[1] = y0;
          max2[0] = x0;
          max2[1] = y0;
          break;
        case CMD$2.L:
          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$2.C:
          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$2.Q:
          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD$2.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var startAngle = data[i++];
          var endAngle = data[i++] + startAngle;
          i += 1;
          var anticlockwise = 1 - data[i++];
          if (i === 1) {
            x0 = mathCos$1(startAngle) * rx + cx;
            y0 = mathSin$1(startAngle) * ry + cy;
          }
          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
          xi = mathCos$1(endAngle) * rx + cx;
          yi = mathSin$1(endAngle) * ry + cy;
          break;
        case CMD$2.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          var width = data[i++];
          var height = data[i++];
          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
          break;
        case CMD$2.Z:
          xi = x0;
          yi = y0;
          break;
      }
      vec2$1.min(min, min, min2);
      vec2$1.max(max, max, max2);
    }
    if (i === 0) {
      min[0] = min[1] = max[0] = max[1] = 0;
    }
    return new BoundingRect$3(min[0], min[1], max[0] - min[0], max[1] - min[1]);
  },
  /**
   * Rebuild path from current data
   * Rebuild path will not consider javascript implemented line dash.
   * @param {CanvasRenderingContext2D} ctx
   */
  rebuildPath: function(ctx) {
    var d = this.data;
    var x0;
    var y0;
    var xi;
    var yi;
    var x;
    var y;
    var ux = this._ux;
    var uy = this._uy;
    var len = this._len;
    for (var i = 0; i < len; ) {
      var cmd = d[i++];
      if (i === 1) {
        xi = d[i];
        yi = d[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD$2.M:
          x0 = xi = d[i++];
          y0 = yi = d[i++];
          ctx.moveTo(xi, yi);
          break;
        case CMD$2.L:
          x = d[i++];
          y = d[i++];
          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
            ctx.lineTo(x, y);
            xi = x;
            yi = y;
          }
          break;
        case CMD$2.C:
          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;
        case CMD$2.Q:
          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
          xi = d[i - 2];
          yi = d[i - 1];
          break;
        case CMD$2.A:
          var cx = d[i++];
          var cy = d[i++];
          var rx = d[i++];
          var ry = d[i++];
          var theta = d[i++];
          var dTheta = d[i++];
          var psi = d[i++];
          var fs = d[i++];
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          var isEllipse = Math.abs(rx - ry) > 1e-3;
          var endAngle = theta + dTheta;
          if (isEllipse) {
            ctx.translate(cx, cy);
            ctx.rotate(psi);
            ctx.scale(scaleX, scaleY);
            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
            ctx.scale(1 / scaleX, 1 / scaleY);
            ctx.rotate(-psi);
            ctx.translate(-cx, -cy);
          } else {
            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
          }
          if (i === 1) {
            x0 = mathCos$1(theta) * rx + cx;
            y0 = mathSin$1(theta) * ry + cy;
          }
          xi = mathCos$1(endAngle) * rx + cx;
          yi = mathSin$1(endAngle) * ry + cy;
          break;
        case CMD$2.R:
          x0 = xi = d[i];
          y0 = yi = d[i + 1];
          ctx.rect(d[i++], d[i++], d[i++], d[i++]);
          break;
        case CMD$2.Z:
          ctx.closePath();
          xi = x0;
          yi = y0;
      }
    }
  }
};
PathProxy$4.CMD = CMD$2;
var _default$J = PathProxy$4;
var PathProxy_1 = _default$J;
var path = {};
var line$2 = {};
function containStroke$4(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  var _a2 = 0;
  var _b = x0;
  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }
  if (x0 !== x1) {
    _a2 = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }
  var tmp = _a2 * x - y + _b;
  var _s = tmp * tmp / (_a2 * _a2 + 1);
  return _s <= _l / 2 * _l / 2;
}
line$2.containStroke = containStroke$4;
var cubic$1 = {};
var curve$1 = curve$3;
function containStroke$3(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }
  var d = curve$1.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}
cubic$1.containStroke = containStroke$3;
var quadratic$1 = {};
var _curve$1 = curve$3;
var quadraticProjectPoint = _curve$1.quadraticProjectPoint;
function containStroke$2(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }
  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}
quadratic$1.containStroke = containStroke$2;
var arc$1 = {};
var util = {};
var PI2$2 = Math.PI * 2;
function normalizeRadian$2(angle) {
  angle %= PI2$2;
  if (angle < 0) {
    angle += PI2$2;
  }
  return angle;
}
util.normalizeRadian = normalizeRadian$2;
var _util$c = util;
var normalizeRadian$1 = _util$c.normalizeRadian;
var PI2$1 = Math.PI * 2;
function containStroke$1(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  var _l = lineWidth;
  x -= cx;
  y -= cy;
  var d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI2$1 < 1e-4) {
    return true;
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian$1(endAngle);
    endAngle = normalizeRadian$1(tmp);
  } else {
    startAngle = normalizeRadian$1(startAngle);
    endAngle = normalizeRadian$1(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2$1;
  }
  var angle = Math.atan2(y, x);
  if (angle < 0) {
    angle += PI2$1;
  }
  return angle >= startAngle && angle <= endAngle || angle + PI2$1 >= startAngle && angle + PI2$1 <= endAngle;
}
arc$1.containStroke = containStroke$1;
function windingLine$1(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  }
  if (y1 === y0) {
    return 0;
  }
  var dir = y1 < y0 ? 1 : -1;
  var t2 = (y - y0) / (y1 - y0);
  if (t2 === 1 || t2 === 0) {
    dir = y1 < y0 ? 0.5 : -0.5;
  }
  var x_ = t2 * (x1 - x0) + x0;
  return x_ === x ? Infinity : x_ > x ? dir : 0;
}
var windingLine_1 = windingLine$1;
var PathProxy$3 = PathProxy_1;
var line$1 = line$2;
var cubic = cubic$1;
var quadratic = quadratic$1;
var arc = arc$1;
var _util$b = util;
var normalizeRadian = _util$b.normalizeRadian;
var curve = curve$3;
var windingLine = windingLine_1;
var CMD$1 = PathProxy$3.CMD;
var PI2 = Math.PI * 2;
var EPSILON = 1e-4;
function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  var tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }
  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var w = 0;
    var nExtrema = -1;
    var y0_;
    var y1_;
    for (var i = 0; i < nRoots; i++) {
      var t2 = roots[i];
      var unit = t2 === 0 || t2 === 1 ? 0.5 : 1;
      var x_ = curve.cubicAt(x0, x1, x2, x3, t2);
      if (x_ < x) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t2 < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t2 < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t2 < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w;
  }
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }
  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    var t2 = curve.quadraticExtremum(y0, y1, y2);
    if (t2 >= 0 && t2 <= 1) {
      var w = 0;
      var y_ = curve.quadraticAt(y0, y1, y2, t2);
      for (var i = 0; i < nRoots; i++) {
        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
        if (x_ < x) {
          continue;
        }
        if (roots[i] < t2) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }
      return w;
    } else {
      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
      if (x_ < x) {
        return 0;
      }
      return y2 < y0 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;
  if (y > r || y < -r) {
    return 0;
  }
  var tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  var diff2 = Math.abs(startAngle - endAngle);
  if (diff2 < 1e-4) {
    return 0;
  }
  if (diff2 % PI2 < 1e-4) {
    startAngle = 0;
    endAngle = PI2;
    var dir = anticlockwise ? 1 : -1;
    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir;
    } else {
      return 0;
    }
  }
  if (anticlockwise) {
    var tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI2;
  }
  var w = 0;
  for (var i = 0; i < 2; i++) {
    var x_ = roots[i];
    if (x_ + cx > x) {
      var angle = Math.atan2(y, x_);
      var dir = anticlockwise ? 1 : -1;
      if (angle < 0) {
        angle = PI2 + angle;
      }
      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir = -dir;
        }
        w += dir;
      }
    }
  }
  return w;
}
function containPath(data, lineWidth, isStroke, x, y) {
  var w = 0;
  var xi = 0;
  var yi = 0;
  var x0 = 0;
  var y0 = 0;
  for (var i = 0; i < data.length; ) {
    var cmd = data[i++];
    if (cmd === CMD$1.M && i > 1) {
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      }
    }
    if (i === 1) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    switch (cmd) {
      case CMD$1.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD$1.L:
        if (isStroke) {
          if (line$1.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.C:
        if (isStroke) {
          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.Q:
        if (isStroke) {
          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD$1.A:
        var cx = data[i++];
        var cy = data[i++];
        var rx = data[i++];
        var ry = data[i++];
        var theta = data[i++];
        var dTheta = data[i++];
        i += 1;
        var anticlockwise = 1 - data[i++];
        var x1 = Math.cos(theta) * rx + cx;
        var y1 = Math.sin(theta) * ry + cy;
        if (i > 1) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          x0 = x1;
          y0 = y1;
        }
        var _x = (x - cx) * ry / rx + cx;
        if (isStroke) {
          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD$1.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        var width = data[i++];
        var height = data[i++];
        var x1 = x0 + width;
        var y1 = y0 + height;
        if (isStroke) {
          if (line$1.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line$1.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line$1.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line$1.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }
        break;
      case CMD$1.Z:
        if (isStroke) {
          if (line$1.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, x0, y0, x, y);
        }
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (!isStroke && !isAroundEqual(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }
  return w !== 0;
}
function contain(pathData, x, y) {
  return containPath(pathData, 0, false, x, y);
}
function containStroke(pathData, lineWidth, x, y) {
  return containPath(pathData, lineWidth, true, x, y);
}
path.contain = contain;
path.containStroke = containStroke;
var Displayable$1 = Displayable_1;
var zrUtil$e = util$6;
var PathProxy$2 = PathProxy_1;
var pathContain = path;
var Pattern = Pattern_1;
var getCanvasPattern = Pattern.prototype.getCanvasPattern;
var abs = Math.abs;
var pathProxyForDraw = new PathProxy$2(true);
function Path$e(opts) {
  Displayable$1.call(this, opts);
  this.path = null;
}
Path$e.prototype = {
  constructor: Path$e,
  type: "path",
  __dirtyPath: true,
  strokeContainThreshold: 5,
  // This item default to be false. But in map series in echarts,
  // in order to improve performance, it should be set to true,
  // so the shorty segment won't draw.
  segmentIgnoreThreshold: 0,
  /**
   * See `module:zrender/src/graphic/helper/subPixelOptimize`.
   * @type {boolean}
   */
  subPixelOptimize: false,
  brush: function(ctx, prevEl) {
    var style = this.style;
    var path2 = this.path || pathProxyForDraw;
    var hasStroke = style.hasStroke();
    var hasFill = style.hasFill();
    var fill = style.fill;
    var stroke = style.stroke;
    var hasFillGradient = hasFill && !!fill.colorStops;
    var hasStrokeGradient = hasStroke && !!stroke.colorStops;
    var hasFillPattern = hasFill && !!fill.image;
    var hasStrokePattern = hasStroke && !!stroke.image;
    style.bind(ctx, this, prevEl);
    this.setTransform(ctx);
    if (this.__dirty) {
      var rect;
      if (hasFillGradient) {
        rect = rect || this.getBoundingRect();
        this._fillGradient = style.getGradient(ctx, fill, rect);
      }
      if (hasStrokeGradient) {
        rect = rect || this.getBoundingRect();
        this._strokeGradient = style.getGradient(ctx, stroke, rect);
      }
    }
    if (hasFillGradient) {
      ctx.fillStyle = this._fillGradient;
    } else if (hasFillPattern) {
      ctx.fillStyle = getCanvasPattern.call(fill, ctx);
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = this._strokeGradient;
    } else if (hasStrokePattern) {
      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
    }
    var lineDash = style.lineDash;
    var lineDashOffset = style.lineDashOffset;
    var ctxLineDash = !!ctx.setLineDash;
    var scale = this.getGlobalScale();
    path2.setScale(scale[0], scale[1], this.segmentIgnoreThreshold);
    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
      path2.beginPath(ctx);
      if (lineDash && !ctxLineDash) {
        path2.setLineDash(lineDash);
        path2.setLineDashOffset(lineDashOffset);
      }
      this.buildPath(path2, this.shape, false);
      if (this.path) {
        this.__dirtyPath = false;
      }
    } else {
      ctx.beginPath();
      this.path.rebuildPath(ctx);
    }
    if (hasFill) {
      if (style.fillOpacity != null) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.fillOpacity * style.opacity;
        path2.fill(ctx);
        ctx.globalAlpha = originalGlobalAlpha;
      } else {
        path2.fill(ctx);
      }
    }
    if (lineDash && ctxLineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (hasStroke) {
      if (style.strokeOpacity != null) {
        var originalGlobalAlpha = ctx.globalAlpha;
        ctx.globalAlpha = style.strokeOpacity * style.opacity;
        path2.stroke(ctx);
        ctx.globalAlpha = originalGlobalAlpha;
      } else {
        path2.stroke(ctx);
      }
    }
    if (lineDash && ctxLineDash) {
      ctx.setLineDash([]);
    }
    if (style.text != null) {
      this.restoreTransform(ctx);
      this.drawRectText(ctx, this.getBoundingRect());
    }
  },
  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
  // Like in circle
  buildPath: function(ctx, shapeCfg, inBundle) {
  },
  createPathProxy: function() {
    this.path = new PathProxy$2();
  },
  getBoundingRect: function() {
    var rect = this._rect;
    var style = this.style;
    var needsUpdateRect = !rect;
    if (needsUpdateRect) {
      var path2 = this.path;
      if (!path2) {
        path2 = this.path = new PathProxy$2();
      }
      if (this.__dirtyPath) {
        path2.beginPath();
        this.buildPath(path2, this.shape, false);
      }
      rect = path2.getBoundingRect();
    }
    this._rect = rect;
    if (style.hasStroke()) {
      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectWithStroke.copy(rect);
        var w = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (!style.hasFill()) {
          w = Math.max(w, this.strokeContainThreshold || 4);
        }
        if (lineScale > 1e-10) {
          rectWithStroke.width += w / lineScale;
          rectWithStroke.height += w / lineScale;
          rectWithStroke.x -= w / lineScale / 2;
          rectWithStroke.y -= w / lineScale / 2;
        }
      }
      return rectWithStroke;
    }
    return rect;
  },
  contain: function(x, y) {
    var localPos = this.transformCoordToLocal(x, y);
    var rect = this.getBoundingRect();
    var style = this.style;
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      var pathData = this.path.data;
      if (style.hasStroke()) {
        var lineWidth = style.lineWidth;
        var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 1e-10) {
          if (!style.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }
      if (style.hasFill()) {
        return pathContain.contain(pathData, x, y);
      }
    }
    return false;
  },
  /**
   * @param  {boolean} dirtyPath
   */
  dirty: function(dirtyPath) {
    if (dirtyPath == null) {
      dirtyPath = true;
    }
    if (dirtyPath) {
      this.__dirtyPath = dirtyPath;
      this._rect = null;
    }
    this.__dirty = this.__dirtyText = true;
    this.__zr && this.__zr.refresh();
    if (this.__clipTarget) {
      this.__clipTarget.dirty();
    }
  },
  /**
   * Alias for animate('shape')
   * @param {boolean} loop
   */
  animateShape: function(loop) {
    return this.animate("shape", loop);
  },
  // Overwrite attrKV
  attrKV: function(key, value) {
    if (key === "shape") {
      this.setShape(value);
      this.__dirtyPath = true;
      this._rect = null;
    } else {
      Displayable$1.prototype.attrKV.call(this, key, value);
    }
  },
  /**
   * @param {Object|string} key
   * @param {*} value
   */
  setShape: function(key, value) {
    var shape = this.shape;
    if (shape) {
      if (zrUtil$e.isObject(key)) {
        for (var name2 in key) {
          if (key.hasOwnProperty(name2)) {
            shape[name2] = key[name2];
          }
        }
      } else {
        shape[key] = value;
      }
      this.dirty(true);
    }
    return this;
  },
  getLineScale: function() {
    var m2 = this.transform;
    return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
  }
};
Path$e.extend = function(defaults2) {
  var Sub = function(opts) {
    Path$e.call(this, opts);
    if (defaults2.style) {
      this.style.extendFrom(defaults2.style, false);
    }
    var defaultShape = defaults2.shape;
    if (defaultShape) {
      this.shape = this.shape || {};
      var thisShape = this.shape;
      for (var name3 in defaultShape) {
        if (!thisShape.hasOwnProperty(name3) && defaultShape.hasOwnProperty(name3)) {
          thisShape[name3] = defaultShape[name3];
        }
      }
    }
    defaults2.init && defaults2.init.call(this, opts);
  };
  zrUtil$e.inherits(Sub, Path$e);
  for (var name2 in defaults2) {
    if (name2 !== "style" && name2 !== "shape") {
      Sub.prototype[name2] = defaults2[name2];
    }
  }
  return Sub;
};
zrUtil$e.inherits(Path$e, Displayable$1);
var _default$I = Path$e;
var Path_1 = _default$I;
var PathProxy$1 = PathProxy_1;
var _vector$2 = requireVector();
var v2ApplyTransform = _vector$2.applyTransform;
var CMD = PathProxy$1.CMD;
var points$1 = [[], [], []];
var mathSqrt$1 = Math.sqrt;
var mathAtan2 = Math.atan2;
function _default$H(path2, m2) {
  var data = path2.data;
  var cmd;
  var nPoint;
  var i;
  var j;
  var k;
  var p2;
  var M = CMD.M;
  var C = CMD.C;
  var L = CMD.L;
  var R = CMD.R;
  var A = CMD.A;
  var Q = CMD.Q;
  for (i = 0, j = 0; i < data.length; ) {
    cmd = data[i++];
    j = i;
    nPoint = 0;
    switch (cmd) {
      case M:
        nPoint = 1;
        break;
      case L:
        nPoint = 1;
        break;
      case C:
        nPoint = 3;
        break;
      case Q:
        nPoint = 2;
        break;
      case A:
        var x = m2[4];
        var y = m2[5];
        var sx = mathSqrt$1(m2[0] * m2[0] + m2[1] * m2[1]);
        var sy = mathSqrt$1(m2[2] * m2[2] + m2[3] * m2[3]);
        var angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
        data[i] *= sx;
        data[i++] += x;
        data[i] *= sy;
        data[i++] += y;
        data[i++] *= sx;
        data[i++] *= sy;
        data[i++] += angle;
        data[i++] += angle;
        i += 2;
        j = i;
        break;
      case R:
        p2[0] = data[i++];
        p2[1] = data[i++];
        v2ApplyTransform(p2, p2, m2);
        data[j++] = p2[0];
        data[j++] = p2[1];
        p2[0] += data[i++];
        p2[1] += data[i++];
        v2ApplyTransform(p2, p2, m2);
        data[j++] = p2[0];
        data[j++] = p2[1];
    }
    for (k = 0; k < nPoint; k++) {
      var p2 = points$1[k];
      p2[0] = data[i++];
      p2[1] = data[i++];
      v2ApplyTransform(p2, p2, m2);
      data[j++] = p2[0];
      data[j++] = p2[1];
    }
  }
}
var transformPath$1 = _default$H;
var Path$d = Path_1;
var PathProxy = PathProxy_1;
var transformPath = transformPath$1;
var mathSqrt = Math.sqrt;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI$1 = Math.PI;
var vMag = function(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
};
var vRatio = function(u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
};
var vAngle = function(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
};
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path2) {
  var psi = psiDeg * (PI$1 / 180);
  var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;
  var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt(lambda);
    ry *= mathSqrt(lambda);
  }
  var f2 = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  var cxp = f2 * rx * yp / ry;
  var cyp = f2 * -ry * xp / rx;
  var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;
  var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;
  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = PI$1;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (fs === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * PI$1;
  }
  if (fs === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * PI$1;
  }
  path2.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
  if (!data) {
    return new PathProxy();
  }
  var cpx = 0;
  var cpy = 0;
  var subpathX = cpx;
  var subpathY = cpy;
  var prevCmd;
  var path2 = new PathProxy();
  var CMD2 = PathProxy.CMD;
  var cmdList = data.match(commandReg);
  for (var l = 0; l < cmdList.length; l++) {
    var cmdText = cmdList[l];
    var cmdStr = cmdText.charAt(0);
    var cmd;
    var p2 = cmdText.match(numberReg) || [];
    var pLen = p2.length;
    for (var i = 0; i < pLen; i++) {
      p2[i] = parseFloat(p2[i]);
    }
    var off = 0;
    while (off < pLen) {
      var ctlPtx;
      var ctlPty;
      var rx;
      var ry;
      var psi;
      var fa;
      var fs;
      var x1 = cpx;
      var y1 = cpy;
      switch (cmdStr) {
        case "l":
          cpx += p2[off++];
          cpy += p2[off++];
          cmd = CMD2.L;
          path2.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p2[off++];
          cpy = p2[off++];
          cmd = CMD2.L;
          path2.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p2[off++];
          cpy += p2[off++];
          cmd = CMD2.M;
          path2.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p2[off++];
          cpy = p2[off++];
          cmd = CMD2.M;
          path2.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p2[off++];
          cmd = CMD2.L;
          path2.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p2[off++];
          cmd = CMD2.L;
          path2.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p2[off++];
          cmd = CMD2.L;
          path2.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p2[off++];
          cmd = CMD2.L;
          path2.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD2.C;
          path2.addData(cmd, p2[off++], p2[off++], p2[off++], p2[off++], p2[off++], p2[off++]);
          cpx = p2[off - 2];
          cpy = p2[off - 1];
          break;
        case "c":
          cmd = CMD2.C;
          path2.addData(cmd, p2[off++] + cpx, p2[off++] + cpy, p2[off++] + cpx, p2[off++] + cpy, p2[off++] + cpx, p2[off++] + cpy);
          cpx += p2[off - 2];
          cpy += p2[off - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path2.len();
          var pathData = path2.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }
          cmd = CMD2.C;
          x1 = p2[off++];
          y1 = p2[off++];
          cpx = p2[off++];
          cpy = p2[off++];
          path2.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path2.len();
          var pathData = path2.data;
          if (prevCmd === CMD2.C) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }
          cmd = CMD2.C;
          x1 = cpx + p2[off++];
          y1 = cpy + p2[off++];
          cpx += p2[off++];
          cpy += p2[off++];
          path2.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "Q":
          x1 = p2[off++];
          y1 = p2[off++];
          cpx = p2[off++];
          cpy = p2[off++];
          cmd = CMD2.Q;
          path2.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "q":
          x1 = p2[off++] + cpx;
          y1 = p2[off++] + cpy;
          cpx += p2[off++];
          cpy += p2[off++];
          cmd = CMD2.Q;
          path2.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path2.len();
          var pathData = path2.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }
          cpx = p2[off++];
          cpy = p2[off++];
          cmd = CMD2.Q;
          path2.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          var len = path2.len();
          var pathData = path2.data;
          if (prevCmd === CMD2.Q) {
            ctlPtx += cpx - pathData[len - 4];
            ctlPty += cpy - pathData[len - 3];
          }
          cpx += p2[off++];
          cpy += p2[off++];
          cmd = CMD2.Q;
          path2.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p2[off++];
          ry = p2[off++];
          psi = p2[off++];
          fa = p2[off++];
          fs = p2[off++];
          x1 = cpx, y1 = cpy;
          cpx = p2[off++];
          cpy = p2[off++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path2);
          break;
        case "a":
          rx = p2[off++];
          ry = p2[off++];
          psi = p2[off++];
          fa = p2[off++];
          fs = p2[off++];
          x1 = cpx, y1 = cpy;
          cpx += p2[off++];
          cpy += p2[off++];
          cmd = CMD2.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path2);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD2.Z;
      path2.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path2.toStatic();
  return path2;
}
function createPathOptions(str, opts) {
  var pathProxy = createPathProxyFromString(str);
  opts = opts || {};
  opts.buildPath = function(path2) {
    if (path2.setData) {
      path2.setData(pathProxy.data);
      var ctx = path2.getContext();
      if (ctx) {
        path2.rebuildPath(ctx);
      }
    } else {
      var ctx = path2;
      pathProxy.rebuildPath(ctx);
    }
  };
  opts.applyTransform = function(m2) {
    transformPath(pathProxy, m2);
    this.dirty(true);
  };
  return opts;
}
function createFromString$1(str, opts) {
  return new Path$d(createPathOptions(str, opts));
}
function extendFromString(str, opts) {
  return Path$d.extend(createPathOptions(str, opts));
}
function mergePath$1(pathEls, opts) {
  var pathList = [];
  var len = pathEls.length;
  for (var i = 0; i < len; i++) {
    var pathEl = pathEls[i];
    if (!pathEl.path) {
      pathEl.createPathProxy();
    }
    if (pathEl.__dirtyPath) {
      pathEl.buildPath(pathEl.path, pathEl.shape, true);
    }
    pathList.push(pathEl.path);
  }
  var pathBundle = new Path$d(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path2) {
    path2.appendPath(pathList);
    var ctx = path2.getContext();
    if (ctx) {
      path2.rebuildPath(ctx);
    }
  };
  return pathBundle;
}
path$1.createFromString = createFromString$1;
path$1.extendFromString = extendFromString;
path$1.mergePath = mergePath$1;
var Displayable = Displayable_1;
var zrUtil$d = util$6;
var textContain$1 = text;
var textHelper = text$1;
var _constant = constant;
var ContextCachedBy = _constant.ContextCachedBy;
var Text$2 = function(opts) {
  Displayable.call(this, opts);
};
Text$2.prototype = {
  constructor: Text$2,
  type: "text",
  brush: function(ctx, prevEl) {
    var style = this.style;
    this.__dirty && textHelper.normalizeTextStyle(style, true);
    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;
    var text2 = style.text;
    text2 != null && (text2 += "");
    if (!textHelper.needDrawText(text2, style)) {
      ctx.__attrCachedBy = ContextCachedBy.NONE;
      return;
    }
    this.setTransform(ctx);
    textHelper.renderText(this, ctx, text2, style, null, prevEl);
    this.restoreTransform(ctx);
  },
  getBoundingRect: function() {
    var style = this.style;
    this.__dirty && textHelper.normalizeTextStyle(style, true);
    if (!this._rect) {
      style.text;
      var rect = textContain$1.getBoundingRect(style.text + "", style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {
        var w = style.textStrokeWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }
      this._rect = rect;
    }
    return this._rect;
  }
};
zrUtil$d.inherits(Text$2, Displayable);
var _default$G = Text$2;
var Text_1 = _default$G;
var Path$c = Path_1;
var _default$F = Path$c.extend({
  type: "circle",
  shape: {
    cx: 0,
    cy: 0,
    r: 0
  },
  buildPath: function(ctx, shape, inBundle) {
    if (inBundle) {
      ctx.moveTo(shape.cx + shape.r, shape.cy);
    }
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
  }
});
var Circle$2 = _default$F;
var env$1 = env_1;
var shadowTemp = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]];
function _default$E(orignalBrush) {
  return env$1.browser.ie && env$1.browser.version >= 11 ? function() {
    var clipPaths = this.__clipPaths;
    var style = this.style;
    var modified;
    if (clipPaths) {
      for (var i = 0; i < clipPaths.length; i++) {
        var clipPath = clipPaths[i];
        var shape = clipPath && clipPath.shape;
        var type = clipPath && clipPath.type;
        if (shape && (type === "sector" && shape.startAngle === shape.endAngle || type === "rect" && (!shape.width || !shape.height))) {
          for (var j = 0; j < shadowTemp.length; j++) {
            shadowTemp[j][2] = style[shadowTemp[j][0]];
            style[shadowTemp[j][0]] = shadowTemp[j][1];
          }
          modified = true;
          break;
        }
      }
    }
    orignalBrush.apply(this, arguments);
    if (modified) {
      for (var j = 0; j < shadowTemp.length; j++) {
        style[shadowTemp[j][0]] = shadowTemp[j][2];
      }
    }
  } : orignalBrush;
}
var fixClipWithShadow$1 = _default$E;
var Path$b = Path_1;
var fixClipWithShadow = fixClipWithShadow$1;
var _default$D = Path$b.extend({
  type: "sector",
  shape: {
    cx: 0,
    cy: 0,
    r0: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  brush: fixClipWithShadow(Path$b.prototype.brush),
  buildPath: function(ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r0 = Math.max(shape.r0 || 0, 0);
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
    ctx.lineTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
    if (r0 !== 0) {
      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
    }
    ctx.closePath();
  }
});
var Sector$1 = _default$D;
var Path$a = Path_1;
var _default$C = Path$a.extend({
  type: "ring",
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    r0: 0
  },
  buildPath: function(ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var PI22 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI22, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI22, true);
  }
});
var Ring$1 = _default$C;
var poly$1 = {};
var _vector$1 = requireVector();
var v2Distance$1 = _vector$1.distance;
function interpolate(p0, p1, p2, p3, t2, t22, t3) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function _default$B(points2, isLoop) {
  var len = points2.length;
  var ret = [];
  var distance = 0;
  for (var i = 1; i < len; i++) {
    distance += v2Distance$1(points2[i - 1], points2[i]);
  }
  var segs = distance / 2;
  segs = segs < len ? len : segs;
  for (var i = 0; i < segs; i++) {
    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
    var idx = Math.floor(pos);
    var w = pos - idx;
    var p0;
    var p1 = points2[idx % len];
    var p2;
    var p3;
    if (!isLoop) {
      p0 = points2[idx === 0 ? idx : idx - 1];
      p2 = points2[idx > len - 2 ? len - 1 : idx + 1];
      p3 = points2[idx > len - 3 ? len - 1 : idx + 2];
    } else {
      p0 = points2[(idx - 1 + len) % len];
      p2 = points2[(idx + 1) % len];
      p3 = points2[(idx + 2) % len];
    }
    var w2 = w * w;
    var w3 = w * w2;
    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);
  }
  return ret;
}
var smoothSpline$1 = _default$B;
var _vector = requireVector();
var v2Min = _vector.min;
var v2Max = _vector.max;
var v2Scale = _vector.scale;
var v2Distance = _vector.distance;
var v2Add = _vector.add;
var v2Clone = _vector.clone;
var v2Sub = _vector.sub;
function _default$A(points2, smooth, isLoop, constraint) {
  var cps = [];
  var v = [];
  var v1 = [];
  var v2 = [];
  var prevPoint;
  var nextPoint;
  var min3;
  var max3;
  if (constraint) {
    min3 = [Infinity, Infinity];
    max3 = [-Infinity, -Infinity];
    for (var i = 0, len = points2.length; i < len; i++) {
      v2Min(min3, min3, points2[i]);
      v2Max(max3, max3, points2[i]);
    }
    v2Min(min3, min3, constraint[0]);
    v2Max(max3, max3, constraint[1]);
  }
  for (var i = 0, len = points2.length; i < len; i++) {
    var point = points2[i];
    if (isLoop) {
      prevPoint = points2[i ? i - 1 : len - 1];
      nextPoint = points2[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(v2Clone(points2[i]));
        continue;
      } else {
        prevPoint = points2[i - 1];
        nextPoint = points2[i + 1];
      }
    }
    v2Sub(v, nextPoint, prevPoint);
    v2Scale(v, v, smooth);
    var d0 = v2Distance(point, prevPoint);
    var d1 = v2Distance(point, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    v2Scale(v1, v, -d0);
    v2Scale(v2, v, d1);
    var cp0 = v2Add([], point, v1);
    var cp1 = v2Add([], point, v2);
    if (constraint) {
      v2Max(cp0, cp0, min3);
      v2Min(cp0, cp0, max3);
      v2Max(cp1, cp1, min3);
      v2Min(cp1, cp1, max3);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
var smoothBezier$1 = _default$A;
var smoothSpline = smoothSpline$1;
var smoothBezier = smoothBezier$1;
function buildPath(ctx, shape, closePath) {
  var points2 = shape.points;
  var smooth = shape.smooth;
  if (points2 && points2.length >= 2) {
    if (smooth && smooth !== "spline") {
      var controlPoints = smoothBezier(points2, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points2[0][0], points2[0][1]);
      var len = points2.length;
      for (var i = 0; i < (closePath ? len : len - 1); i++) {
        var cp1 = controlPoints[i * 2];
        var cp2 = controlPoints[i * 2 + 1];
        var p2 = points2[(i + 1) % len];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]);
      }
    } else {
      if (smooth === "spline") {
        points2 = smoothSpline(points2, closePath);
      }
      ctx.moveTo(points2[0][0], points2[0][1]);
      for (var i = 1, l = points2.length; i < l; i++) {
        ctx.lineTo(points2[i][0], points2[i][1]);
      }
    }
    closePath && ctx.closePath();
  }
}
poly$1.buildPath = buildPath;
var Path$9 = Path_1;
var polyHelper$1 = poly$1;
var _default$z = Path$9.extend({
  type: "polygon",
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  buildPath: function(ctx, shape) {
    polyHelper$1.buildPath(ctx, shape, true);
  }
});
var Polygon$2 = _default$z;
var Path$8 = Path_1;
var polyHelper = poly$1;
var _default$y = Path$8.extend({
  type: "polyline",
  shape: {
    points: null,
    smooth: false,
    smoothConstraint: null
  },
  style: {
    stroke: "#000",
    fill: null
  },
  buildPath: function(ctx, shape) {
    polyHelper.buildPath(ctx, shape, false);
  }
});
var Polyline$2 = _default$y;
var subPixelOptimize$2 = {};
var round = Math.round;
function subPixelOptimizeLine$2(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var x1 = inputShape.x1;
  var x2 = inputShape.x2;
  var y1 = inputShape.y1;
  var y2 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x2;
  outputShape.y1 = y1;
  outputShape.y2 = y2;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return;
  }
  if (round(x1 * 2) === round(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize$1(x1, lineWidth, true);
  }
  if (round(y1 * 2) === round(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize$1(y1, lineWidth, true);
  }
}
function subPixelOptimizeRect$2(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  var originX = inputShape.x;
  var originY = inputShape.y;
  var originWidth = inputShape.width;
  var originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  var lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return;
  }
  outputShape.x = subPixelOptimize$1(originX, lineWidth, true);
  outputShape.y = subPixelOptimize$1(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize$1(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize$1(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
}
function subPixelOptimize$1(position, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position;
  }
  var doubledPosition = round(position * 2);
  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}
subPixelOptimize$2.subPixelOptimizeLine = subPixelOptimizeLine$2;
subPixelOptimize$2.subPixelOptimizeRect = subPixelOptimizeRect$2;
subPixelOptimize$2.subPixelOptimize = subPixelOptimize$1;
var Path$7 = Path_1;
var roundRectHelper = roundRect;
var _subPixelOptimize$1 = subPixelOptimize$2;
var subPixelOptimizeRect$1 = _subPixelOptimize$1.subPixelOptimizeRect;
var subPixelOptimizeOutputShape$1 = {};
var _default$x = Path$7.extend({
  type: "rect",
  shape: {
    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
    // r缩写为1         相当于 [1, 1, 1, 1]
    // r缩写为[1]       相当于 [1, 1, 1, 1]
    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
    r: 0,
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    var x;
    var y;
    var width;
    var height;
    if (this.subPixelOptimize) {
      subPixelOptimizeRect$1(subPixelOptimizeOutputShape$1, shape, this.style);
      x = subPixelOptimizeOutputShape$1.x;
      y = subPixelOptimizeOutputShape$1.y;
      width = subPixelOptimizeOutputShape$1.width;
      height = subPixelOptimizeOutputShape$1.height;
      subPixelOptimizeOutputShape$1.r = shape.r;
      shape = subPixelOptimizeOutputShape$1;
    } else {
      x = shape.x;
      y = shape.y;
      width = shape.width;
      height = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      roundRectHelper.buildPath(ctx, shape);
    }
    ctx.closePath();
    return;
  }
});
var Rect$2 = _default$x;
var Path$6 = Path_1;
var _subPixelOptimize = subPixelOptimize$2;
var subPixelOptimizeLine$1 = _subPixelOptimize.subPixelOptimizeLine;
var subPixelOptimizeOutputShape = {};
var _default$w = Path$6.extend({
  type: "line",
  shape: {
    // Start point
    x1: 0,
    y1: 0,
    // End point
    x2: 0,
    y2: 0,
    percent: 1
  },
  style: {
    stroke: "#000",
    fill: null
  },
  buildPath: function(ctx, shape) {
    var x1;
    var y1;
    var x2;
    var y2;
    if (this.subPixelOptimize) {
      subPixelOptimizeLine$1(subPixelOptimizeOutputShape, shape, this.style);
      x1 = subPixelOptimizeOutputShape.x1;
      y1 = subPixelOptimizeOutputShape.y1;
      x2 = subPixelOptimizeOutputShape.x2;
      y2 = subPixelOptimizeOutputShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }
    ctx.lineTo(x2, y2);
  },
  /**
   * Get point at percent
   * @param  {number} percent
   * @return {Array.<number>}
   */
  pointAt: function(p2) {
    var shape = this.shape;
    return [shape.x1 * (1 - p2) + shape.x2 * p2, shape.y1 * (1 - p2) + shape.y2 * p2];
  }
});
var Line$2 = _default$w;
var Path$5 = Path_1;
var vec2 = requireVector();
var _curve = curve$3;
var quadraticSubdivide = _curve.quadraticSubdivide;
var cubicSubdivide = _curve.cubicSubdivide;
var quadraticAt = _curve.quadraticAt;
var cubicAt = _curve.cubicAt;
var quadraticDerivativeAt = _curve.quadraticDerivativeAt;
var cubicDerivativeAt = _curve.cubicDerivativeAt;
var out = [];
function someVectorAt(shape, t2, isTangent) {
  var cpx2 = shape.cpx2;
  var cpy2 = shape.cpy2;
  if (cpx2 === null || cpy2 === null) {
    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t2), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t2)];
  } else {
    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t2), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t2)];
  }
}
var _default$v = Path$5.extend({
  type: "bezier-curve",
  shape: {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    cpx1: 0,
    cpy1: 0,
    // cpx2: 0,
    // cpy2: 0
    // Curve show percent, for animating
    percent: 1
  },
  style: {
    stroke: "#000",
    fill: null
  },
  buildPath: function(ctx, shape) {
    var x1 = shape.x1;
    var y1 = shape.y1;
    var x2 = shape.x2;
    var y2 = shape.y2;
    var cpx1 = shape.cpx1;
    var cpy1 = shape.cpy1;
    var cpx2 = shape.cpx2;
    var cpy2 = shape.cpy2;
    var percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  },
  /**
   * Get point at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  pointAt: function(t2) {
    return someVectorAt(this.shape, t2, false);
  },
  /**
   * Get tangent at percent
   * @param  {number} t
   * @return {Array.<number>}
   */
  tangentAt: function(t2) {
    var p2 = someVectorAt(this.shape, t2, true);
    return vec2.normalize(p2, p2);
  }
});
var BezierCurve$1 = _default$v;
var Path$4 = Path_1;
var _default$u = Path$4.extend({
  type: "arc",
  shape: {
    cx: 0,
    cy: 0,
    r: 0,
    startAngle: 0,
    endAngle: Math.PI * 2,
    clockwise: true
  },
  style: {
    stroke: "#000",
    fill: null
  },
  buildPath: function(ctx, shape) {
    var x = shape.cx;
    var y = shape.cy;
    var r = Math.max(shape.r, 0);
    var startAngle = shape.startAngle;
    var endAngle = shape.endAngle;
    var clockwise = shape.clockwise;
    var unitX = Math.cos(startAngle);
    var unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  }
});
var Arc$1 = _default$u;
var Path$3 = Path_1;
var _default$t = Path$3.extend({
  type: "compound",
  shape: {
    paths: null
  },
  _updatePathDirty: function() {
    var dirtyPath = this.__dirtyPath;
    var paths = this.shape.paths;
    for (var i = 0; i < paths.length; i++) {
      dirtyPath = dirtyPath || paths[i].__dirtyPath;
    }
    this.__dirtyPath = dirtyPath;
    this.__dirty = this.__dirty || dirtyPath;
  },
  beforeBrush: function() {
    this._updatePathDirty();
    var paths = this.shape.paths || [];
    var scale = this.getGlobalScale();
    for (var i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }
      paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
    }
  },
  buildPath: function(ctx, shape) {
    var paths = shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  },
  afterBrush: function() {
    var paths = this.shape.paths || [];
    for (var i = 0; i < paths.length; i++) {
      paths[i].__dirtyPath = false;
    }
  },
  getBoundingRect: function() {
    this._updatePathDirty();
    return Path$3.prototype.getBoundingRect.call(this);
  }
});
var CompoundPath$1 = _default$t;
var Gradient$3 = function(colorStops) {
  this.colorStops = colorStops || [];
};
Gradient$3.prototype = {
  constructor: Gradient$3,
  addColorStop: function(offset, color2) {
    this.colorStops.push({
      offset,
      color: color2
    });
  }
};
var _default$s = Gradient$3;
var Gradient_1 = _default$s;
var zrUtil$c = util$6;
var Gradient$2 = Gradient_1;
var LinearGradient$2 = function(x, y, x2, y2, colorStops, globalCoord) {
  this.x = x == null ? 0 : x;
  this.y = y == null ? 0 : y;
  this.x2 = x2 == null ? 1 : x2;
  this.y2 = y2 == null ? 0 : y2;
  this.type = "linear";
  this.global = globalCoord || false;
  Gradient$2.call(this, colorStops);
};
LinearGradient$2.prototype = {
  constructor: LinearGradient$2
};
zrUtil$c.inherits(LinearGradient$2, Gradient$2);
var _default$r = LinearGradient$2;
var LinearGradient_1 = _default$r;
var zrUtil$b = util$6;
var Gradient$1 = Gradient_1;
var RadialGradient$1 = function(x, y, r, colorStops, globalCoord) {
  this.x = x == null ? 0.5 : x;
  this.y = y == null ? 0.5 : y;
  this.r = r == null ? 0.5 : r;
  this.type = "radial";
  this.global = globalCoord || false;
  Gradient$1.call(this, colorStops);
};
RadialGradient$1.prototype = {
  constructor: RadialGradient$1
};
zrUtil$b.inherits(RadialGradient$1, Gradient$1);
var _default$q = RadialGradient$1;
var RadialGradient_1 = _default$q;
var _util$a = util$6;
var inherits = _util$a.inherits;
var Displayble = Displayable_1;
var BoundingRect$2 = BoundingRect_1;
function IncrementalDisplayble(opts) {
  Displayble.call(this, opts);
  this._displayables = [];
  this._temporaryDisplayables = [];
  this._cursor = 0;
  this.notClear = true;
}
IncrementalDisplayble.prototype.incremental = true;
IncrementalDisplayble.prototype.clearDisplaybles = function() {
  this._displayables = [];
  this._temporaryDisplayables = [];
  this._cursor = 0;
  this.dirty();
  this.notClear = false;
};
IncrementalDisplayble.prototype.addDisplayable = function(displayable, notPersistent) {
  if (notPersistent) {
    this._temporaryDisplayables.push(displayable);
  } else {
    this._displayables.push(displayable);
  }
  this.dirty();
};
IncrementalDisplayble.prototype.addDisplayables = function(displayables, notPersistent) {
  notPersistent = notPersistent || false;
  for (var i = 0; i < displayables.length; i++) {
    this.addDisplayable(displayables[i], notPersistent);
  }
};
IncrementalDisplayble.prototype.eachPendingDisplayable = function(cb) {
  for (var i = this._cursor; i < this._displayables.length; i++) {
    cb && cb(this._displayables[i]);
  }
  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    cb && cb(this._temporaryDisplayables[i]);
  }
};
IncrementalDisplayble.prototype.update = function() {
  this.updateTransform();
  for (var i = this._cursor; i < this._displayables.length; i++) {
    var displayable = this._displayables[i];
    displayable.parent = this;
    displayable.update();
    displayable.parent = null;
  }
  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    var displayable = this._temporaryDisplayables[i];
    displayable.parent = this;
    displayable.update();
    displayable.parent = null;
  }
};
IncrementalDisplayble.prototype.brush = function(ctx, prevEl) {
  for (var i = this._cursor; i < this._displayables.length; i++) {
    var displayable = this._displayables[i];
    displayable.beforeBrush && displayable.beforeBrush(ctx);
    displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);
    displayable.afterBrush && displayable.afterBrush(ctx);
  }
  this._cursor = i;
  for (var i = 0; i < this._temporaryDisplayables.length; i++) {
    var displayable = this._temporaryDisplayables[i];
    displayable.beforeBrush && displayable.beforeBrush(ctx);
    displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);
    displayable.afterBrush && displayable.afterBrush(ctx);
  }
  this._temporaryDisplayables = [];
  this.notClear = true;
};
var m = [];
IncrementalDisplayble.prototype.getBoundingRect = function() {
  if (!this._rect) {
    var rect = new BoundingRect$2(Infinity, Infinity, -Infinity, -Infinity);
    for (var i = 0; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      var childRect = displayable.getBoundingRect().clone();
      if (displayable.needLocalTransform()) {
        childRect.applyTransform(displayable.getLocalTransform(m));
      }
      rect.union(childRect);
    }
    this._rect = rect;
  }
  return this._rect;
};
IncrementalDisplayble.prototype.contain = function(x, y) {
  var localPos = this.transformCoordToLocal(x, y);
  var rect = this.getBoundingRect();
  if (rect.contain(localPos[0], localPos[1])) {
    for (var i = 0; i < this._displayables.length; i++) {
      var displayable = this._displayables[i];
      if (displayable.contain(x, y)) {
        return true;
      }
    }
  }
  return false;
};
inherits(IncrementalDisplayble, Displayble);
var _default$p = IncrementalDisplayble;
var IncrementalDisplayable$1 = _default$p;
var zrUtil$a = util$6;
var pathTool = path$1;
var colorTool = color$1;
var matrix$1 = requireMatrix();
var vector = requireVector();
var Path$2 = Path_1;
var Transformable = Transformable_1;
var ZImage$1 = Image$2;
graphic$4.Image = ZImage$1;
var Group$3 = Group_1;
graphic$4.Group = Group$3;
var Text$1 = Text_1;
graphic$4.Text = Text$1;
var Circle$1 = Circle$2;
graphic$4.Circle = Circle$1;
var Sector = Sector$1;
graphic$4.Sector = Sector;
var Ring = Ring$1;
graphic$4.Ring = Ring;
var Polygon$1 = Polygon$2;
graphic$4.Polygon = Polygon$1;
var Polyline$1 = Polyline$2;
graphic$4.Polyline = Polyline$1;
var Rect$1 = Rect$2;
graphic$4.Rect = Rect$1;
var Line$1 = Line$2;
graphic$4.Line = Line$1;
var BezierCurve = BezierCurve$1;
graphic$4.BezierCurve = BezierCurve;
var Arc = Arc$1;
graphic$4.Arc = Arc;
var CompoundPath = CompoundPath$1;
graphic$4.CompoundPath = CompoundPath;
var LinearGradient$1 = LinearGradient_1;
graphic$4.LinearGradient = LinearGradient$1;
var RadialGradient = RadialGradient_1;
graphic$4.RadialGradient = RadialGradient;
var BoundingRect$1 = BoundingRect_1;
graphic$4.BoundingRect = BoundingRect$1;
var IncrementalDisplayable = IncrementalDisplayable$1;
graphic$4.IncrementalDisplayable = IncrementalDisplayable;
var subPixelOptimizeUtil = subPixelOptimize$2;
var mathMax = Math.max;
var mathMin = Math.min;
var EMPTY_OBJ = {};
var Z2_EMPHASIS_LIFT = 1;
var CACHED_LABEL_STYLE_PROPERTIES = {
  color: "textFill",
  textBorderColor: "textStroke",
  textBorderWidth: "textStrokeWidth"
};
var EMPHASIS = "emphasis";
var NORMAL = "normal";
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var _customShapeMap = {};
function extendShape(opts) {
  return Path$2.extend(opts);
}
function extendPath(pathData, opts) {
  return pathTool.extendFromString(pathData, opts);
}
function registerShape(name2, ShapeClass) {
  _customShapeMap[name2] = ShapeClass;
}
function getShapeClass(name2) {
  if (_customShapeMap.hasOwnProperty(name2)) {
    return _customShapeMap[name2];
  }
}
function makePath(pathData, opts, rect, layout2) {
  var path2 = pathTool.createFromString(pathData, opts);
  if (rect) {
    if (layout2 === "center") {
      rect = centerGraphic(rect, path2.getBoundingRect());
    }
    resizePath(path2, rect);
  }
  return path2;
}
function makeImage(imageUrl, rect, layout2) {
  var path2 = new ZImage$1({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload: function(img) {
      if (layout2 === "center") {
        var boundingRect = {
          width: img.width,
          height: img.height
        };
        path2.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return path2;
}
function centerGraphic(rect, boundingRect) {
  var aspect = boundingRect.width / boundingRect.height;
  var width = rect.height * aspect;
  var height;
  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }
  var cx = rect.x + rect.width / 2;
  var cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width,
    height
  };
}
var mergePath = pathTool.mergePath;
function resizePath(path2, rect) {
  if (!path2.applyTransform) {
    return;
  }
  var pathRect = path2.getBoundingRect();
  var m2 = pathRect.calculateTransform(rect);
  path2.applyTransform(m2);
}
function subPixelOptimizeLine(param2) {
  subPixelOptimizeUtil.subPixelOptimizeLine(param2.shape, param2.shape, param2.style);
  return param2;
}
function subPixelOptimizeRect(param2) {
  subPixelOptimizeUtil.subPixelOptimizeRect(param2.shape, param2.shape, param2.style);
  return param2;
}
var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
var liftedColorMap = zrUtil$a.createHashMap();
var liftedColorCount = 0;
function liftColor(color2) {
  if (typeof color2 !== "string") {
    return color2;
  }
  var liftedColor = liftedColorMap.get(color2);
  if (!liftedColor) {
    liftedColor = colorTool.lift(color2, -0.1);
    if (liftedColorCount < 1e4) {
      liftedColorMap.set(color2, liftedColor);
      liftedColorCount++;
    }
  }
  return liftedColor;
}
function cacheElementStl(el) {
  if (!el.__hoverStlDirty) {
    return;
  }
  el.__hoverStlDirty = false;
  var hoverStyle = el.__hoverStl;
  if (!hoverStyle) {
    el.__cachedNormalStl = el.__cachedNormalZ2 = null;
    return;
  }
  var normalStyle = el.__cachedNormalStl = {};
  el.__cachedNormalZ2 = el.z2;
  var elStyle = el.style;
  for (var name2 in hoverStyle) {
    if (hoverStyle[name2] != null) {
      normalStyle[name2] = elStyle[name2];
    }
  }
  normalStyle.fill = elStyle.fill;
  normalStyle.stroke = elStyle.stroke;
}
function singleEnterEmphasis(el) {
  var hoverStl = el.__hoverStl;
  if (!hoverStl || el.__highlighted) {
    return;
  }
  var zr = el.__zr;
  var useHoverLayer = el.useHoverLayer && zr && zr.painter.type === "canvas";
  el.__highlighted = useHoverLayer ? "layer" : "plain";
  if (el.isGroup || !zr && el.useHoverLayer) {
    return;
  }
  var elTarget = el;
  var targetStyle = el.style;
  if (useHoverLayer) {
    elTarget = zr.addHover(el);
    targetStyle = elTarget.style;
  }
  rollbackDefaultTextStyle(targetStyle);
  if (!useHoverLayer) {
    cacheElementStl(elTarget);
  }
  targetStyle.extendFrom(hoverStl);
  setDefaultHoverFillStroke(targetStyle, hoverStl, "fill");
  setDefaultHoverFillStroke(targetStyle, hoverStl, "stroke");
  applyDefaultTextStyle(targetStyle);
  if (!useHoverLayer) {
    el.dirty(false);
    el.z2 += Z2_EMPHASIS_LIFT;
  }
}
function setDefaultHoverFillStroke(targetStyle, hoverStyle, prop) {
  if (!hasFillOrStroke(hoverStyle[prop]) && hasFillOrStroke(targetStyle[prop])) {
    targetStyle[prop] = liftColor(targetStyle[prop]);
  }
}
function singleEnterNormal(el) {
  var highlighted = el.__highlighted;
  if (!highlighted) {
    return;
  }
  el.__highlighted = false;
  if (el.isGroup) {
    return;
  }
  if (highlighted === "layer") {
    el.__zr && el.__zr.removeHover(el);
  } else {
    var style = el.style;
    var normalStl = el.__cachedNormalStl;
    if (normalStl) {
      rollbackDefaultTextStyle(style);
      el.setStyle(normalStl);
      applyDefaultTextStyle(style);
    }
    var normalZ2 = el.__cachedNormalZ2;
    if (normalZ2 != null && el.z2 - normalZ2 === Z2_EMPHASIS_LIFT) {
      el.z2 = normalZ2;
    }
  }
}
function traverseUpdate(el, updater, commonParam) {
  var fromState = NORMAL;
  var toState = NORMAL;
  var trigger2;
  el.__highlighted && (fromState = EMPHASIS, trigger2 = true);
  updater(el, commonParam);
  el.__highlighted && (toState = EMPHASIS, trigger2 = true);
  el.isGroup && el.traverse(function(child) {
    !child.isGroup && updater(child, commonParam);
  });
  trigger2 && el.__highDownOnUpdate && el.__highDownOnUpdate(fromState, toState);
}
function setElementHoverStyle(el, hoverStl) {
  hoverStl = el.__hoverStl = hoverStl !== false && (el.hoverStyle || hoverStl || {});
  el.__hoverStlDirty = true;
  if (el.__highlighted) {
    el.__cachedNormalStl = null;
    singleEnterNormal(el);
    singleEnterEmphasis(el);
  }
}
function onElementMouseOver(e2) {
  !shouldSilent(this, e2) && !this.__highByOuter && traverseUpdate(this, singleEnterEmphasis);
}
function onElementMouseOut(e2) {
  !shouldSilent(this, e2) && !this.__highByOuter && traverseUpdate(this, singleEnterNormal);
}
function onElementEmphasisEvent(highlightDigit) {
  this.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdate(this, singleEnterEmphasis);
}
function onElementNormalEvent(highlightDigit) {
  !(this.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdate(this, singleEnterNormal);
}
function shouldSilent(el, e2) {
  return el.__highDownSilentOnTouch && e2.zrByTouch;
}
function setHoverStyle(el, hoverStyle) {
  setAsHighDownDispatcher(el, true);
  traverseUpdate(el, setElementHoverStyle, hoverStyle);
}
function setAsHighDownDispatcher(el, asDispatcher) {
  var disable = asDispatcher === false;
  el.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  el.__highDownOnUpdate = el.highDownOnUpdate;
  if (!disable || el.__highDownDispatcher) {
    var method = disable ? "off" : "on";
    el[method]("mouseover", onElementMouseOver)[method]("mouseout", onElementMouseOut);
    el[method]("emphasis", onElementEmphasisEvent)[method]("normal", onElementNormalEvent);
    el.__highByOuter = el.__highByOuter || 0;
    el.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
function getHighlightDigit(highlightKey) {
  var highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function setLabelStyle(normalStyle, emphasisStyle, normalModel, emphasisModel, opt, normalSpecified, emphasisSpecified) {
  opt = opt || EMPTY_OBJ;
  var labelFetcher = opt.labelFetcher;
  var labelDataIndex = opt.labelDataIndex;
  var labelDimIndex = opt.labelDimIndex;
  var labelProp = opt.labelProp;
  var showNormal = normalModel.getShallow("show");
  var showEmphasis = emphasisModel.getShallow("show");
  var baseText;
  if (showNormal || showEmphasis) {
    if (labelFetcher) {
      baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, labelProp);
    }
    if (baseText == null) {
      baseText = zrUtil$a.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt) : opt.defaultText;
    }
  }
  var normalStyleText = showNormal ? baseText : null;
  var emphasisStyleText = showEmphasis ? zrUtil$a.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, "emphasis", null, labelDimIndex, labelProp) : null, baseText) : null;
  if (normalStyleText != null || emphasisStyleText != null) {
    setTextStyle(normalStyle, normalModel, normalSpecified, opt);
    setTextStyle(emphasisStyle, emphasisModel, emphasisSpecified, opt, true);
  }
  normalStyle.text = normalStyleText;
  emphasisStyle.text = emphasisStyleText;
}
function modifyLabelStyle(el, normalStyleProps, emphasisStyleProps) {
  var elStyle = el.style;
  if (normalStyleProps) {
    rollbackDefaultTextStyle(elStyle);
    el.setStyle(normalStyleProps);
    applyDefaultTextStyle(elStyle);
  }
  elStyle = el.__hoverStl;
  if (emphasisStyleProps && elStyle) {
    rollbackDefaultTextStyle(elStyle);
    zrUtil$a.extend(elStyle, emphasisStyleProps);
    applyDefaultTextStyle(elStyle);
  }
}
function setTextStyle(textStyle2, textStyleModel, specifiedTextStyle, opt, isEmphasis) {
  setTextStyleCommon(textStyle2, textStyleModel, opt, isEmphasis);
  specifiedTextStyle && zrUtil$a.extend(textStyle2, specifiedTextStyle);
  return textStyle2;
}
function setText(textStyle2, labelModel, defaultColor) {
  var opt = {
    isRectText: true
  };
  var isEmphasis;
  if (defaultColor === false) {
    isEmphasis = true;
  } else {
    opt.autoColor = defaultColor;
  }
  setTextStyleCommon(textStyle2, labelModel, opt, isEmphasis);
}
function setTextStyleCommon(textStyle2, textStyleModel, opt, isEmphasis) {
  opt = opt || EMPTY_OBJ;
  if (opt.isRectText) {
    var textPosition;
    if (opt.getTextPosition) {
      textPosition = opt.getTextPosition(textStyleModel, isEmphasis);
    } else {
      textPosition = textStyleModel.getShallow("position") || (isEmphasis ? null : "inside");
      textPosition === "outside" && (textPosition = "top");
    }
    textStyle2.textPosition = textPosition;
    textStyle2.textOffset = textStyleModel.getShallow("offset");
    var labelRotate = textStyleModel.getShallow("rotate");
    labelRotate != null && (labelRotate *= Math.PI / 180);
    textStyle2.textRotation = labelRotate;
    textStyle2.textDistance = zrUtil$a.retrieve2(textStyleModel.getShallow("distance"), isEmphasis ? null : 5);
  }
  var ecModel = textStyleModel.ecModel;
  var globalTextStyle = ecModel && ecModel.option.textStyle;
  var richItemNames = getRichItemNames(textStyleModel);
  var richResult;
  if (richItemNames) {
    richResult = {};
    for (var name2 in richItemNames) {
      if (richItemNames.hasOwnProperty(name2)) {
        var richTextStyle = textStyleModel.getModel(["rich", name2]);
        setTokenTextStyle(richResult[name2] = {}, richTextStyle, globalTextStyle, opt, isEmphasis);
      }
    }
  }
  textStyle2.rich = richResult;
  setTokenTextStyle(textStyle2, textStyleModel, globalTextStyle, opt, isEmphasis, true);
  if (opt.forceRich && !opt.textStyle) {
    opt.textStyle = {};
  }
  return textStyle2;
}
function getRichItemNames(textStyleModel) {
  var richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      for (var name2 in rich) {
        if (rich.hasOwnProperty(name2)) {
          richItemNameMap[name2] = 1;
        }
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
function setTokenTextStyle(textStyle2, textStyleModel, globalTextStyle, opt, isEmphasis, isBlock) {
  globalTextStyle = !isEmphasis && globalTextStyle || EMPTY_OBJ;
  textStyle2.textFill = getAutoColor(textStyleModel.getShallow("color"), opt) || globalTextStyle.color;
  textStyle2.textStroke = getAutoColor(textStyleModel.getShallow("textBorderColor"), opt) || globalTextStyle.textBorderColor;
  textStyle2.textStrokeWidth = zrUtil$a.retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (!isEmphasis) {
    if (isBlock) {
      textStyle2.insideRollbackOpt = opt;
      applyDefaultTextStyle(textStyle2);
    }
    if (textStyle2.textFill == null) {
      textStyle2.textFill = opt.autoColor;
    }
  }
  textStyle2.fontStyle = textStyleModel.getShallow("fontStyle") || globalTextStyle.fontStyle;
  textStyle2.fontWeight = textStyleModel.getShallow("fontWeight") || globalTextStyle.fontWeight;
  textStyle2.fontSize = textStyleModel.getShallow("fontSize") || globalTextStyle.fontSize;
  textStyle2.fontFamily = textStyleModel.getShallow("fontFamily") || globalTextStyle.fontFamily;
  textStyle2.textAlign = textStyleModel.getShallow("align");
  textStyle2.textVerticalAlign = textStyleModel.getShallow("verticalAlign") || textStyleModel.getShallow("baseline");
  textStyle2.textLineHeight = textStyleModel.getShallow("lineHeight");
  textStyle2.textWidth = textStyleModel.getShallow("width");
  textStyle2.textHeight = textStyleModel.getShallow("height");
  textStyle2.textTag = textStyleModel.getShallow("tag");
  if (!isBlock || !opt.disableBox) {
    textStyle2.textBackgroundColor = getAutoColor(textStyleModel.getShallow("backgroundColor"), opt);
    textStyle2.textPadding = textStyleModel.getShallow("padding");
    textStyle2.textBorderColor = getAutoColor(textStyleModel.getShallow("borderColor"), opt);
    textStyle2.textBorderWidth = textStyleModel.getShallow("borderWidth");
    textStyle2.textBorderRadius = textStyleModel.getShallow("borderRadius");
    textStyle2.textBoxShadowColor = textStyleModel.getShallow("shadowColor");
    textStyle2.textBoxShadowBlur = textStyleModel.getShallow("shadowBlur");
    textStyle2.textBoxShadowOffsetX = textStyleModel.getShallow("shadowOffsetX");
    textStyle2.textBoxShadowOffsetY = textStyleModel.getShallow("shadowOffsetY");
  }
  textStyle2.textShadowColor = textStyleModel.getShallow("textShadowColor") || globalTextStyle.textShadowColor;
  textStyle2.textShadowBlur = textStyleModel.getShallow("textShadowBlur") || globalTextStyle.textShadowBlur;
  textStyle2.textShadowOffsetX = textStyleModel.getShallow("textShadowOffsetX") || globalTextStyle.textShadowOffsetX;
  textStyle2.textShadowOffsetY = textStyleModel.getShallow("textShadowOffsetY") || globalTextStyle.textShadowOffsetY;
}
function getAutoColor(color2, opt) {
  return color2 !== "auto" ? color2 : opt && opt.autoColor ? opt.autoColor : null;
}
function applyDefaultTextStyle(textStyle2) {
  var textPosition = textStyle2.textPosition;
  var opt = textStyle2.insideRollbackOpt;
  var insideRollback;
  if (opt && textStyle2.textFill == null) {
    var autoColor = opt.autoColor;
    var isRectText = opt.isRectText;
    var useInsideStyle = opt.useInsideStyle;
    var useInsideStyleCache = useInsideStyle !== false && (useInsideStyle === true || isRectText && textPosition && typeof textPosition === "string" && textPosition.indexOf("inside") >= 0);
    var useAutoColorCache = !useInsideStyleCache && autoColor != null;
    if (useInsideStyleCache || useAutoColorCache) {
      insideRollback = {
        textFill: textStyle2.textFill,
        textStroke: textStyle2.textStroke,
        textStrokeWidth: textStyle2.textStrokeWidth
      };
    }
    if (useInsideStyleCache) {
      textStyle2.textFill = "#fff";
      if (textStyle2.textStroke == null) {
        textStyle2.textStroke = autoColor;
        textStyle2.textStrokeWidth == null && (textStyle2.textStrokeWidth = 2);
      }
    }
    if (useAutoColorCache) {
      textStyle2.textFill = autoColor;
    }
  }
  textStyle2.insideRollback = insideRollback;
}
function rollbackDefaultTextStyle(style) {
  var insideRollback = style.insideRollback;
  if (insideRollback) {
    style.textFill = insideRollback.textFill;
    style.textStroke = insideRollback.textStroke;
    style.textStrokeWidth = insideRollback.textStrokeWidth;
    style.insideRollback = null;
  }
}
function getFont(opt, ecModel) {
  var gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return zrUtil$a.trim([
    // FIXME in node-canvas fontWeight is before fontStyle
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
  if (typeof dataIndex === "function") {
    cb = dataIndex;
    dataIndex = null;
  }
  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  if (animationEnabled) {
    var postfix = isUpdate ? "Update" : "";
    var duration = animatableModel.getShallow("animationDuration" + postfix);
    var animationEasing = animatableModel.getShallow("animationEasing" + postfix);
    var animationDelay = animatableModel.getShallow("animationDelay" + postfix);
    if (typeof animationDelay === "function") {
      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
    }
    if (typeof duration === "function") {
      duration = duration(dataIndex);
    }
    duration > 0 ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb, !!cb) : (el.stopAnimation(), el.attr(props), cb && cb());
  } else {
    el.stopAnimation();
    el.attr(props);
    cb && cb();
  }
}
function updateProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
}
function initProps(el, props, animatableModel, dataIndex, cb) {
  animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
}
function getTransform(target, ancestor) {
  var mat = matrix$1.identity([]);
  while (target && target !== ancestor) {
    matrix$1.mul(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform(target, transform, invert) {
  if (transform && !zrUtil$a.isArrayLike(transform)) {
    transform = Transformable.getLocalTransform(transform);
  }
  if (invert) {
    transform = matrix$1.invert([], transform);
  }
  return vector.applyTransform([], target, transform);
}
function transformDirection(direction, transform, invert) {
  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
  var vertex = [direction === "left" ? -hBase : direction === "right" ? hBase : 0, direction === "top" ? -vBase : direction === "bottom" ? vBase : 0];
  vertex = applyTransform(vertex, transform, invert);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function groupTransition(g1, g2, animatableModel, cb) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g) {
    var elMap = {};
    g.traverse(function(el) {
      if (!el.isGroup && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el) {
    var obj = {
      position: vector.clone(el.position),
      rotation: el.rotation
    };
    if (el.shape) {
      obj.shape = zrUtil$a.extend({}, el.shape);
    }
    return obj;
  }
  var elMap1 = getElMap(g1);
  g2.traverse(function(el) {
    if (!el.isGroup && el.anid) {
      var oldEl = elMap1[el.anid];
      if (oldEl) {
        var newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps(el, newProp, animatableModel, el.dataIndex);
      }
    }
  });
}
function clipPointsByRect(points2, rect) {
  return zrUtil$a.map(points2, function(point) {
    var x = point[0];
    x = mathMax(x, rect.x);
    x = mathMin(x, rect.x + rect.width);
    var y = point[1];
    y = mathMax(y, rect.y);
    y = mathMin(y, rect.y + rect.height);
    return [x, y];
  });
}
function clipRectByRect(targetRect, rect) {
  var x = mathMax(targetRect.x, rect.x);
  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
  var y = mathMax(targetRect.y, rect.y);
  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x2 >= x && y2 >= y) {
    return {
      x,
      y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
function createIcon(iconStr, opt, rect) {
  opt = zrUtil$a.extend({
    rectHover: true
  }, opt);
  var style = opt.style = {
    strokeNoScale: true
  };
  rect = rect || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  };
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), zrUtil$a.defaults(style, rect), new ZImage$1(opt)) : makePath(iconStr.replace("path://", ""), opt, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points2) {
  for (var i = 0, p2 = points2[points2.length - 1]; i < points2.length; i++) {
    var p3 = points2[i];
    if (lineLineIntersect(a1x, a1y, a2x, a2y, p3[0], p3[1], p2[0], p2[1])) {
      return true;
    }
    p2 = p3;
  }
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var mx = a2x - a1x;
  var my2 = a2y - a1y;
  var nx = b2x - b1x;
  var ny = b2y - b1y;
  var nmCrossProduct = crossProduct2d(nx, ny, mx, my2);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  var b1a1x = a1x - b1x;
  var b1a1y = a1y - b1y;
  var q = crossProduct2d(b1a1x, b1a1y, mx, my2) / nmCrossProduct;
  if (q < 0 || q > 1) {
    return false;
  }
  var p2 = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p2 < 0 || p2 > 1) {
    return false;
  }
  return true;
}
function crossProduct2d(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function nearZero(val) {
  return val <= 1e-6 && val >= -1e-6;
}
registerShape("circle", Circle$1);
registerShape("sector", Sector);
registerShape("ring", Ring);
registerShape("polygon", Polygon$1);
registerShape("polyline", Polyline$1);
registerShape("rect", Rect$1);
registerShape("line", Line$1);
registerShape("bezierCurve", BezierCurve);
registerShape("arc", Arc);
graphic$4.Z2_EMPHASIS_LIFT = Z2_EMPHASIS_LIFT;
graphic$4.CACHED_LABEL_STYLE_PROPERTIES = CACHED_LABEL_STYLE_PROPERTIES;
graphic$4.extendShape = extendShape;
graphic$4.extendPath = extendPath;
graphic$4.registerShape = registerShape;
graphic$4.getShapeClass = getShapeClass;
graphic$4.makePath = makePath;
graphic$4.makeImage = makeImage;
graphic$4.mergePath = mergePath;
graphic$4.resizePath = resizePath;
graphic$4.subPixelOptimizeLine = subPixelOptimizeLine;
graphic$4.subPixelOptimizeRect = subPixelOptimizeRect;
graphic$4.subPixelOptimize = subPixelOptimize;
graphic$4.setElementHoverStyle = setElementHoverStyle;
graphic$4.setHoverStyle = setHoverStyle;
graphic$4.setAsHighDownDispatcher = setAsHighDownDispatcher;
graphic$4.isHighDownDispatcher = isHighDownDispatcher;
graphic$4.getHighlightDigit = getHighlightDigit;
graphic$4.setLabelStyle = setLabelStyle;
graphic$4.modifyLabelStyle = modifyLabelStyle;
graphic$4.setTextStyle = setTextStyle;
graphic$4.setText = setText;
graphic$4.getFont = getFont;
graphic$4.updateProps = updateProps;
graphic$4.initProps = initProps;
graphic$4.getTransform = getTransform;
graphic$4.applyTransform = applyTransform;
graphic$4.transformDirection = transformDirection;
graphic$4.groupTransition = groupTransition;
graphic$4.clipPointsByRect = clipPointsByRect;
graphic$4.clipRectByRect = clipRectByRect;
graphic$4.createIcon = createIcon;
graphic$4.linePolygonIntersect = linePolygonIntersect;
graphic$4.lineLineIntersect = lineLineIntersect;
var textStyle;
var hasRequiredTextStyle;
function requireTextStyle() {
  if (hasRequiredTextStyle)
    return textStyle;
  hasRequiredTextStyle = 1;
  var textContain2 = text;
  var graphicUtil2 = graphic$4;
  var PATH_COLOR = ["textStyle", "color"];
  var _default2 = {
    /**
     * Get color property or get color from option.textStyle.color
     * @param {boolean} [isEmphasis]
     * @return {string}
     */
    getTextColor: function(isEmphasis) {
      var ecModel = this.ecModel;
      return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
    },
    /**
     * Create font string from fontStyle, fontWeight, fontSize, fontFamily
     * @return {string}
     */
    getFont: function() {
      return graphicUtil2.getFont({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    },
    getTextRect: function(text2) {
      return textContain2.getBoundingRect(text2, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText"));
    }
  };
  textStyle = _default2;
  return textStyle;
}
var itemStyle;
var hasRequiredItemStyle;
function requireItemStyle() {
  if (hasRequiredItemStyle)
    return itemStyle;
  hasRequiredItemStyle = 1;
  var makeStyleMapper2 = requireMakeStyleMapper();
  var getItemStyle = makeStyleMapper2([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]]);
  var _default2 = {
    getItemStyle: function(excludes, includes) {
      var style = getItemStyle(this, excludes, includes);
      var lineDash = this.getBorderLineDash();
      lineDash && (style.lineDash = lineDash);
      return style;
    },
    getBorderLineDash: function() {
      var lineType = this.get("borderType");
      return lineType === "solid" || lineType == null ? null : lineType === "dashed" ? [5, 5] : [1, 1];
    }
  };
  itemStyle = _default2;
  return itemStyle;
}
var Model_1;
var hasRequiredModel;
function requireModel() {
  if (hasRequiredModel)
    return Model_1;
  hasRequiredModel = 1;
  var zrUtil2 = util$6;
  var env2 = env_1;
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var _clazz2 = clazz;
  var enableClassExtend2 = _clazz2.enableClassExtend;
  var enableClassCheck2 = _clazz2.enableClassCheck;
  var lineStyleMixin = requireLineStyle();
  var areaStyleMixin = requireAreaStyle();
  var textStyleMixin = requireTextStyle();
  var itemStyleMixin = requireItemStyle();
  var mixin2 = zrUtil2.mixin;
  var inner2 = makeInner2();
  function Model2(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  Model2.prototype = {
    constructor: Model2,
    /**
     * Model 的初始化函数
     * @param {Object} option
     */
    init: null,
    /**
     * 从新的 Option merge
     */
    mergeOption: function(option) {
      zrUtil2.merge(this.option, option, true);
    },
    /**
     * @param {string|Array.<string>} path
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */
    get: function(path2, ignoreParent) {
      if (path2 == null) {
        return this.option;
      }
      return doGet(this.option, this.parsePath(path2), !ignoreParent && getParent(this, path2));
    },
    /**
     * @param {string} key
     * @param {boolean} [ignoreParent=false]
     * @return {*}
     */
    getShallow: function(key, ignoreParent) {
      var option = this.option;
      var val = option == null ? option : option[key];
      var parentModel = !ignoreParent && getParent(this, key);
      if (val == null && parentModel) {
        val = parentModel.getShallow(key);
      }
      return val;
    },
    /**
     * @param {string|Array.<string>} [path]
     * @param {module:echarts/model/Model} [parentModel]
     * @return {module:echarts/model/Model}
     */
    getModel: function(path2, parentModel) {
      var obj = path2 == null ? this.option : doGet(this.option, path2 = this.parsePath(path2));
      var thisParentModel;
      parentModel = parentModel || (thisParentModel = getParent(this, path2)) && thisParentModel.getModel(path2);
      return new Model2(obj, parentModel, this.ecModel);
    },
    /**
     * If model has option
     */
    isEmpty: function() {
      return this.option == null;
    },
    restoreData: function() {
    },
    // Pending
    clone: function() {
      var Ctor = this.constructor;
      return new Ctor(zrUtil2.clone(this.option));
    },
    setReadOnly: function(properties) {
    },
    // If path is null/undefined, return null/undefined.
    parsePath: function(path2) {
      if (typeof path2 === "string") {
        path2 = path2.split(".");
      }
      return path2;
    },
    /**
     * @param {Function} getParentMethod
     *        param {Array.<string>|string} path
     *        return {module:echarts/model/Model}
     */
    customizeGetParent: function(getParentMethod) {
      inner2(this).getParent = getParentMethod;
    },
    isAnimationEnabled: function() {
      if (!env2.node) {
        if (this.option.animation != null) {
          return !!this.option.animation;
        } else if (this.parentModel) {
          return this.parentModel.isAnimationEnabled();
        }
      }
    }
  };
  function doGet(obj, pathArr, parentModel) {
    for (var i = 0; i < pathArr.length; i++) {
      if (!pathArr[i]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel.get(pathArr);
    }
    return obj;
  }
  function getParent(model2, path2) {
    var getParentMethod = inner2(model2).getParent;
    return getParentMethod ? getParentMethod.call(model2, path2) : model2.parentModel;
  }
  enableClassExtend2(Model2);
  enableClassCheck2(Model2);
  mixin2(Model2, lineStyleMixin);
  mixin2(Model2, areaStyleMixin);
  mixin2(Model2, textStyleMixin);
  mixin2(Model2, itemStyleMixin);
  var _default2 = Model2;
  Model_1 = _default2;
  return Model_1;
}
var component = {};
var zrUtil$9 = util$6;
var _clazz$1 = clazz;
var parseClassType$1 = _clazz$1.parseClassType;
var base = 0;
function getUID$1(type) {
  return [type || "", base++, Math.random().toFixed(5)].join("_");
}
function enableSubTypeDefaulter(entity) {
  var subTypeDefaulters = {};
  entity.registerSubTypeDefaulter = function(componentType, defaulter) {
    componentType = parseClassType$1(componentType);
    subTypeDefaulters[componentType.main] = defaulter;
  };
  entity.determineSubType = function(componentType, option) {
    var type = option.type;
    if (!type) {
      var componentTypeMain = parseClassType$1(componentType).main;
      if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type;
  };
  return entity;
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    var result = makeDepndencyGraph(fullNameList);
    var graph2 = result.graph;
    var stack2 = result.noEntryList;
    var targetNameSet = {};
    zrUtil$9.each(targetNameList, function(name2) {
      targetNameSet[name2] = true;
    });
    while (stack2.length) {
      var currComponentType = stack2.pop();
      var currVertex = graph2[currComponentType];
      var isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      zrUtil$9.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    zrUtil$9.each(targetNameSet, function() {
      throw new Error("Circle dependency may exists");
    });
    function removeEdge(succComponentType) {
      graph2[succComponentType].entryCount--;
      if (graph2[succComponentType].entryCount === 0) {
        stack2.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    var graph2 = {};
    var noEntryList = [];
    zrUtil$9.each(fullNameList, function(name2) {
      var thisItem = createDependencyGraphItem(graph2, name2);
      var originalDeps = thisItem.originalDeps = dependencyGetter(name2);
      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name2);
      }
      zrUtil$9.each(availableDeps, function(dependentName) {
        if (zrUtil$9.indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        var thatItem = createDependencyGraphItem(graph2, dependentName);
        if (zrUtil$9.indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name2);
        }
      });
    });
    return {
      graph: graph2,
      noEntryList
    };
  }
  function createDependencyGraphItem(graph2, name2) {
    if (!graph2[name2]) {
      graph2[name2] = {
        predecessor: [],
        successor: []
      };
    }
    return graph2[name2];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    var availableDeps = [];
    zrUtil$9.each(originalDeps, function(dep) {
      zrUtil$9.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
component.getUID = getUID$1;
component.enableSubTypeDefaulter = enableSubTypeDefaulter;
component.enableTopologicalTravel = enableTopologicalTravel;
var layout$1 = {};
var number = {};
var hasRequiredNumber;
function requireNumber() {
  if (hasRequiredNumber)
    return number;
  hasRequiredNumber = 1;
  var zrUtil2 = util$6;
  var RADIAN_EPSILON = 1e-4;
  function _trim(str) {
    return str.replace(/^\s+|\s+$/g, "");
  }
  function linearMap(val, domain, range, clamp) {
    var subDomain = domain[1] - domain[0];
    var subRange = range[1] - range[0];
    if (subDomain === 0) {
      return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
    }
    if (clamp) {
      if (subDomain > 0) {
        if (val <= domain[0]) {
          return range[0];
        } else if (val >= domain[1]) {
          return range[1];
        }
      } else {
        if (val >= domain[0]) {
          return range[0];
        } else if (val <= domain[1]) {
          return range[1];
        }
      }
    } else {
      if (val === domain[0]) {
        return range[0];
      }
      if (val === domain[1]) {
        return range[1];
      }
    }
    return (val - domain[0]) / subDomain * subRange + range[0];
  }
  function parsePercent2(percent, all) {
    switch (percent) {
      case "center":
      case "middle":
        percent = "50%";
        break;
      case "left":
      case "top":
        percent = "0%";
        break;
      case "right":
      case "bottom":
        percent = "100%";
        break;
    }
    if (typeof percent === "string") {
      if (_trim(percent).match(/%$/)) {
        return parseFloat(percent) / 100 * all;
      }
      return parseFloat(percent);
    }
    return percent == null ? NaN : +percent;
  }
  function round2(x, precision, returnStr) {
    if (precision == null) {
      precision = 10;
    }
    precision = Math.min(Math.max(0, precision), 20);
    x = (+x).toFixed(precision);
    return returnStr ? x : +x;
  }
  function asc(arr) {
    arr.sort(function(a, b) {
      return a - b;
    });
    return arr;
  }
  function getPrecision(val) {
    val = +val;
    if (isNaN(val)) {
      return 0;
    }
    var e2 = 1;
    var count = 0;
    while (Math.round(val * e2) / e2 !== val) {
      e2 *= 10;
      count++;
    }
    return count;
  }
  function getPrecisionSafe(val) {
    var str = val.toString();
    var eIndex = str.indexOf("e");
    if (eIndex > 0) {
      var precision = +str.slice(eIndex + 1);
      return precision < 0 ? -precision : 0;
    } else {
      var dotIndex = str.indexOf(".");
      return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
    }
  }
  function getPixelPrecision(dataExtent, pixelExtent) {
    var log2 = Math.log;
    var LN10 = Math.LN10;
    var dataQuantity = Math.floor(log2(dataExtent[1] - dataExtent[0]) / LN10);
    var sizeQuantity = Math.round(log2(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
    var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
    return !isFinite(precision) ? 20 : precision;
  }
  function getPercentWithPrecision(valueList, idx, precision) {
    if (!valueList[idx]) {
      return 0;
    }
    var sum = zrUtil2.reduce(valueList, function(acc, val) {
      return acc + (isNaN(val) ? 0 : val);
    }, 0);
    if (sum === 0) {
      return 0;
    }
    var digits = Math.pow(10, precision);
    var votesPerQuota = zrUtil2.map(valueList, function(val) {
      return (isNaN(val) ? 0 : val) / sum * digits * 100;
    });
    var targetSeats = digits * 100;
    var seats = zrUtil2.map(votesPerQuota, function(votes) {
      return Math.floor(votes);
    });
    var currentSum = zrUtil2.reduce(seats, function(acc, val) {
      return acc + val;
    }, 0);
    var remainder = zrUtil2.map(votesPerQuota, function(votes, idx2) {
      return votes - seats[idx2];
    });
    while (currentSum < targetSeats) {
      var max3 = Number.NEGATIVE_INFINITY;
      var maxId = null;
      for (var i = 0, len = remainder.length; i < len; ++i) {
        if (remainder[i] > max3) {
          max3 = remainder[i];
          maxId = i;
        }
      }
      ++seats[maxId];
      remainder[maxId] = 0;
      ++currentSum;
    }
    return seats[idx] / digits;
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function remRadian(radian) {
    var pi2 = Math.PI * 2;
    return (radian % pi2 + pi2) % pi2;
  }
  function isRadianAroundZero(val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
  }
  var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
  function parseDate2(value) {
    if (value instanceof Date) {
      return value;
    } else if (typeof value === "string") {
      var match = TIME_REG.exec(value);
      if (!match) {
        return /* @__PURE__ */ new Date(NaN);
      }
      if (!match[8]) {
        return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
      } else {
        var hour = +match[4] || 0;
        if (match[8].toUpperCase() !== "Z") {
          hour -= match[8].slice(0, 3);
        }
        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
      }
    } else if (value == null) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return new Date(Math.round(value));
  }
  function quantity(val) {
    return Math.pow(10, quantityExponent(val));
  }
  function quantityExponent(val) {
    if (val === 0) {
      return 0;
    }
    var exp = Math.floor(Math.log(val) / Math.LN10);
    if (val / Math.pow(10, exp) >= 10) {
      exp++;
    }
    return exp;
  }
  function nice(val, round3) {
    var exponent = quantityExponent(val);
    var exp10 = Math.pow(10, exponent);
    var f2 = val / exp10;
    var nf;
    if (round3) {
      if (f2 < 1.5) {
        nf = 1;
      } else if (f2 < 2.5) {
        nf = 2;
      } else if (f2 < 4) {
        nf = 3;
      } else if (f2 < 7) {
        nf = 5;
      } else {
        nf = 10;
      }
    } else {
      if (f2 < 1) {
        nf = 1;
      } else if (f2 < 2) {
        nf = 2;
      } else if (f2 < 3) {
        nf = 3;
      } else if (f2 < 5) {
        nf = 5;
      } else {
        nf = 10;
      }
    }
    val = nf * exp10;
    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
  }
  function quantile(ascArr, p2) {
    var H = (ascArr.length - 1) * p2 + 1;
    var h = Math.floor(H);
    var v = +ascArr[h - 1];
    var e2 = H - h;
    return e2 ? v + e2 * (ascArr[h] - v) : v;
  }
  function reformIntervals(list) {
    list.sort(function(a, b) {
      return littleThan(a, b, 0) ? -1 : 1;
    });
    var curr = -Infinity;
    var currClose = 1;
    for (var i = 0; i < list.length; ) {
      var interval = list[i].interval;
      var close = list[i].close;
      for (var lg = 0; lg < 2; lg++) {
        if (interval[lg] <= curr) {
          interval[lg] = curr;
          close[lg] = !lg ? 1 - currClose : 1;
        }
        curr = interval[lg];
        currClose = close[lg];
      }
      if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
        list.splice(i, 1);
      } else {
        i++;
      }
    }
    return list;
    function littleThan(a, b, lg2) {
      return a.interval[lg2] < b.interval[lg2] || a.interval[lg2] === b.interval[lg2] && (a.close[lg2] - b.close[lg2] === (!lg2 ? 1 : -1) || !lg2 && littleThan(a, b, 1));
    }
  }
  function isNumeric(v) {
    return v - parseFloat(v) >= 0;
  }
  number.linearMap = linearMap;
  number.parsePercent = parsePercent2;
  number.round = round2;
  number.asc = asc;
  number.getPrecision = getPrecision;
  number.getPrecisionSafe = getPrecisionSafe;
  number.getPixelPrecision = getPixelPrecision;
  number.getPercentWithPrecision = getPercentWithPrecision;
  number.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
  number.remRadian = remRadian;
  number.isRadianAroundZero = isRadianAroundZero;
  number.parseDate = parseDate2;
  number.quantity = quantity;
  number.quantityExponent = quantityExponent;
  number.nice = nice;
  number.quantile = quantile;
  number.reformIntervals = reformIntervals;
  number.isNumeric = isNumeric;
  return number;
}
var format = {};
var hasRequiredFormat;
function requireFormat() {
  if (hasRequiredFormat)
    return format;
  hasRequiredFormat = 1;
  var zrUtil2 = util$6;
  var textContain2 = text;
  var numberUtil = requireNumber();
  function addCommas2(x) {
    if (isNaN(x)) {
      return "-";
    }
    x = (x + "").split(".");
    return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (x.length > 1 ? "." + x[1] : "");
  }
  function toCamelCase(str, upperCaseFirst) {
    str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
      return group1.toUpperCase();
    });
    if (upperCaseFirst && str) {
      str = str.charAt(0).toUpperCase() + str.slice(1);
    }
    return str;
  }
  var normalizeCssArray2 = zrUtil2.normalizeCssArray;
  var replaceReg = /([&<>"'])/g;
  var replaceMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  function encodeHTML2(source) {
    return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
      return replaceMap[c];
    });
  }
  var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
  var wrapVar = function(varName, seriesIdx) {
    return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
  };
  function formatTpl2(tpl, paramsList, encode2) {
    if (!zrUtil2.isArray(paramsList)) {
      paramsList = [paramsList];
    }
    var seriesLen = paramsList.length;
    if (!seriesLen) {
      return "";
    }
    var $vars = paramsList[0].$vars || [];
    for (var i = 0; i < $vars.length; i++) {
      var alias = TPL_VAR_ALIAS[i];
      tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
    }
    for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
      for (var k = 0; k < $vars.length; k++) {
        var val = paramsList[seriesIdx][$vars[k]];
        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode2 ? encodeHTML2(val) : val);
      }
    }
    return tpl;
  }
  function formatTplSimple(tpl, param2, encode2) {
    zrUtil2.each(param2, function(value, key) {
      tpl = tpl.replace("{" + key + "}", encode2 ? encodeHTML2(value) : value);
    });
    return tpl;
  }
  function getTooltipMarker2(opt, extraCssText) {
    opt = zrUtil2.isString(opt) ? {
      color: opt,
      extraCssText
    } : opt || {};
    var color2 = opt.color;
    var type = opt.type;
    var extraCssText = opt.extraCssText;
    var renderMode = opt.renderMode || "html";
    var markerId = opt.markerId || "X";
    if (!color2) {
      return "";
    }
    if (renderMode === "html") {
      return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML2(color2) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML2(color2) + ";" + (extraCssText || "") + '"></span>';
    } else {
      return {
        renderMode,
        content: "{marker" + markerId + "|}  ",
        style: {
          color: color2
        }
      };
    }
  }
  function pad(str, len) {
    str += "";
    return "0000".substr(0, len - str.length) + str;
  }
  function formatTime2(tpl, value, isUTC) {
    if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
      tpl = "MM-dd\nyyyy";
    }
    var date = numberUtil.parseDate(value);
    var utc = isUTC ? "UTC" : "";
    var y = date["get" + utc + "FullYear"]();
    var M = date["get" + utc + "Month"]() + 1;
    var d = date["get" + utc + "Date"]();
    var h = date["get" + utc + "Hours"]();
    var m2 = date["get" + utc + "Minutes"]();
    var s = date["get" + utc + "Seconds"]();
    var S = date["get" + utc + "Milliseconds"]();
    tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", y % 100).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m2, 2)).replace("m", m2).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
    return tpl;
  }
  function capitalFirst(str) {
    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
  }
  var truncateText2 = textContain2.truncateText;
  function getTextBoundingRect(opt) {
    return textContain2.getBoundingRect(opt.text, opt.font, opt.textAlign, opt.textVerticalAlign, opt.textPadding, opt.textLineHeight, opt.rich, opt.truncate);
  }
  function getTextRect(text2, font, textAlign, textVerticalAlign, textPadding, rich, truncate, textLineHeight) {
    return textContain2.getBoundingRect(text2, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate);
  }
  function windowOpen(link, target) {
    if (target === "_blank" || target === "blank") {
      var blank = window.open();
      blank.opener = null;
      blank.location = link;
    } else {
      window.open(link, target);
    }
  }
  format.addCommas = addCommas2;
  format.toCamelCase = toCamelCase;
  format.normalizeCssArray = normalizeCssArray2;
  format.encodeHTML = encodeHTML2;
  format.formatTpl = formatTpl2;
  format.formatTplSimple = formatTplSimple;
  format.getTooltipMarker = getTooltipMarker2;
  format.formatTime = formatTime2;
  format.capitalFirst = capitalFirst;
  format.truncateText = truncateText2;
  format.getTextBoundingRect = getTextBoundingRect;
  format.getTextRect = getTextRect;
  format.windowOpen = windowOpen;
  return format;
}
var zrUtil$8 = util$6;
var BoundingRect = BoundingRect_1;
var _number$1 = requireNumber();
var parsePercent = _number$1.parsePercent;
var formatUtil = requireFormat();
var each$a = zrUtil$8.each;
var LOCATION_PARAMS = ["left", "right", "top", "bottom", "width", "height"];
var HV_NAMES = [["width", "left", "right"], ["height", "top", "bottom"]];
function boxLayout$1(orient, group, gap, maxWidth, maxHeight) {
  var x = 0;
  var y = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  var currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    var position = child.position;
    var rect = child.getBoundingRect();
    var nextChild = group.childAt(idx + 1);
    var nextChildRect = nextChild && nextChild.getBoundingRect();
    var nextX;
    var nextY;
    if (orient === "horizontal") {
      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX;
      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY;
      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    position[0] = x;
    position[1] = y;
    orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
  });
}
var box = boxLayout$1;
var vbox = zrUtil$8.curry(boxLayout$1, "vertical");
var hbox = zrUtil$8.curry(boxLayout$1, "horizontal");
function getAvailableSize(positionInfo, containerRect, margin) {
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var x = parsePercent(positionInfo.x, containerWidth);
  var y = parsePercent(positionInfo.y, containerHeight);
  var x2 = parsePercent(positionInfo.x2, containerWidth);
  var y2 = parsePercent(positionInfo.y2, containerHeight);
  (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
  (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
  (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
  (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
  margin = formatUtil.normalizeCssArray(margin || 0);
  return {
    width: Math.max(x2 - x - margin[1] - margin[3], 0),
    height: Math.max(y2 - y - margin[0] - margin[2], 0)
  };
}
function getLayoutRect(positionInfo, containerRect, margin) {
  margin = formatUtil.normalizeCssArray(margin || 0);
  var containerWidth = containerRect.width;
  var containerHeight = containerRect.height;
  var left = parsePercent(positionInfo.left, containerWidth);
  var top = parsePercent(positionInfo.top, containerHeight);
  var right = parsePercent(positionInfo.right, containerWidth);
  var bottom = parsePercent(positionInfo.bottom, containerHeight);
  var width = parsePercent(positionInfo.width, containerWidth);
  var height = parsePercent(positionInfo.height, containerHeight);
  var verticalMargin = margin[2] + margin[0];
  var horizontalMargin = margin[1] + margin[3];
  var aspect = positionInfo.aspect;
  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }
  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }
  if (aspect != null) {
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (isNaN(width)) {
      width = aspect * height;
    }
    if (isNaN(height)) {
      height = width / aspect;
    }
  }
  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }
  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left = containerWidth / 2 - width / 2 - margin[3];
      break;
    case "right":
      left = containerWidth - width - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top = containerHeight / 2 - height / 2 - margin[0];
      break;
    case "bottom":
      top = containerHeight - height - verticalMargin;
      break;
  }
  left = left || 0;
  top = top || 0;
  if (isNaN(width)) {
    width = containerWidth - horizontalMargin - left - (right || 0);
  }
  if (isNaN(height)) {
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }
  var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
function positionElement(el, positionInfo, containerRect, margin, opt) {
  var h = !opt || !opt.hv || opt.hv[0];
  var v = !opt || !opt.hv || opt.hv[1];
  var boundingMode = opt && opt.boundingMode || "all";
  if (!h && !v) {
    return;
  }
  var rect;
  if (boundingMode === "raw") {
    rect = el.type === "group" ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();
    if (el.needLocalTransform()) {
      var transform = el.getLocalTransform();
      rect = rect.clone();
      rect.applyTransform(transform);
    }
  }
  positionInfo = getLayoutRect(zrUtil$8.defaults({
    width: rect.width,
    height: rect.height
  }, positionInfo), containerRect, margin);
  var elPos = el.position;
  var dx = h ? positionInfo.x - rect.x : 0;
  var dy = v ? positionInfo.y - rect.y : 0;
  el.attr("position", boundingMode === "raw" ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
}
function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function mergeLayoutParam$1(targetOption, newOption, opt) {
  !zrUtil$8.isObject(opt) && (opt = {});
  var ignoreSize = opt.ignoreSize;
  !zrUtil$8.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  var hResult = merge2(HV_NAMES[0], 0);
  var vResult = merge2(HV_NAMES[1], 1);
  copy(HV_NAMES[0], targetOption, hResult);
  copy(HV_NAMES[1], targetOption, vResult);
  function merge2(names, hvIdx) {
    var newParams = {};
    var newValueCount = 0;
    var merged = {};
    var mergedValueCount = 0;
    var enoughParamNumber = 2;
    each$a(names, function(name3) {
      merged[name3] = targetOption[name3];
    });
    each$a(names, function(name3) {
      hasProp(newOption, name3) && (newParams[name3] = merged[name3] = newOption[name3]);
      hasValue(newParams, name3) && newValueCount++;
      hasValue(merged, name3) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (var i = 0; i < names.length; i++) {
        var name2 = names[i];
        if (!hasProp(newParams, name2) && hasProp(targetOption, name2)) {
          newParams[name2] = targetOption[name2];
          break;
        }
      }
      return newParams;
    }
  }
  function hasProp(obj, name2) {
    return obj.hasOwnProperty(name2);
  }
  function hasValue(obj, name2) {
    return obj[name2] != null && obj[name2] !== "auto";
  }
  function copy(names, target, source) {
    each$a(names, function(name2) {
      target[name2] = source[name2];
    });
  }
}
function getLayoutParams$1(source) {
  return copyLayoutParams({}, source);
}
function copyLayoutParams(target, source) {
  source && target && each$a(LOCATION_PARAMS, function(name2) {
    source.hasOwnProperty(name2) && (target[name2] = source[name2]);
  });
  return target;
}
layout$1.LOCATION_PARAMS = LOCATION_PARAMS;
layout$1.HV_NAMES = HV_NAMES;
layout$1.box = box;
layout$1.vbox = vbox;
layout$1.hbox = hbox;
layout$1.getAvailableSize = getAvailableSize;
layout$1.getLayoutRect = getLayoutRect;
layout$1.positionElement = positionElement;
layout$1.sizeCalculable = sizeCalculable;
layout$1.mergeLayoutParam = mergeLayoutParam$1;
layout$1.getLayoutParams = getLayoutParams$1;
layout$1.copyLayoutParams = copyLayoutParams;
var _default$o = {
  getBoxLayoutParams: function() {
    return {
      left: this.get("left"),
      top: this.get("top"),
      right: this.get("right"),
      bottom: this.get("bottom"),
      width: this.get("width"),
      height: this.get("height")
    };
  }
};
var boxLayout = _default$o;
var zrUtil$7 = util$6;
var Model$1 = requireModel();
var componentUtil$2 = component;
var _clazz = clazz;
var enableClassManagement = _clazz.enableClassManagement;
var parseClassType = _clazz.parseClassType;
var _model$6 = model;
var makeInner$2 = _model$6.makeInner;
var layout = layout$1;
var boxLayoutMixin = boxLayout;
var inner$3 = makeInner$2();
var ComponentModel$3 = Model$1.extend({
  type: "component",
  /**
   * @readOnly
   * @type {string}
   */
  id: "",
  /**
   * Because simplified concept is probably better, series.name (or component.name)
   * has been having too many resposibilities:
   * (1) Generating id (which requires name in option should not be modified).
   * (2) As an index to mapping series when merging option or calling API (a name
   * can refer to more then one components, which is convinient is some case).
   * (3) Display.
   * @readOnly
   */
  name: "",
  /**
   * @readOnly
   * @type {string}
   */
  mainType: "",
  /**
   * @readOnly
   * @type {string}
   */
  subType: "",
  /**
   * @readOnly
   * @type {number}
   */
  componentIndex: 0,
  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,
  /**
   * @type {module:echarts/model/Global}
   * @readOnly
   */
  ecModel: null,
  /**
   * key: componentType
   * value:  Component model list, can not be null.
   * @type {Object.<string, Array.<module:echarts/model/Model>>}
   * @readOnly
   */
  dependentModels: [],
  /**
   * @type {string}
   * @readOnly
   */
  uid: null,
  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  $constructor: function(option, parentModel, ecModel, extraOpt) {
    Model$1.call(this, option, parentModel, ecModel, extraOpt);
    this.uid = componentUtil$2.getUID("ec_cpt_model");
  },
  init: function(option, parentModel, ecModel, extraOpt) {
    this.mergeDefaultAndTheme(option, ecModel);
  },
  mergeDefaultAndTheme: function(option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
    var themeModel = ecModel.getTheme();
    zrUtil$7.merge(option, themeModel.get(this.mainType));
    zrUtil$7.merge(option, this.getDefaultOption());
    if (layoutMode) {
      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function(option, extraOpt) {
    zrUtil$7.merge(this.option, option, true);
    var layoutMode = this.layoutMode;
    if (layoutMode) {
      layout.mergeLayoutParam(this.option, option, layoutMode);
    }
  },
  // Hooker after init or mergeOption
  optionUpdated: function(newCptOption, isInit) {
  },
  getDefaultOption: function() {
    var fields = inner$3(this);
    if (!fields.defaultOption) {
      var optList = [];
      var Class = this.constructor;
      while (Class) {
        var opt = Class.prototype.defaultOption;
        opt && optList.push(opt);
        Class = Class.superClass;
      }
      var defaultOption = {};
      for (var i = optList.length - 1; i >= 0; i--) {
        defaultOption = zrUtil$7.merge(defaultOption, optList[i], true);
      }
      fields.defaultOption = defaultOption;
    }
    return fields.defaultOption;
  },
  getReferringComponents: function(mainType) {
    return this.ecModel.queryComponents({
      mainType,
      index: this.get(mainType + "Index", true),
      id: this.get(mainType + "Id", true)
    });
  }
});
enableClassManagement(ComponentModel$3, {
  registerWhenExtend: true
});
componentUtil$2.enableSubTypeDefaulter(ComponentModel$3);
componentUtil$2.enableTopologicalTravel(ComponentModel$3, getDependencies);
function getDependencies(componentType) {
  var deps = [];
  zrUtil$7.each(ComponentModel$3.getClassesByMainType(componentType), function(Clazz) {
    deps = deps.concat(Clazz.prototype.dependencies || []);
  });
  deps = zrUtil$7.map(deps, function(type) {
    return parseClassType(type).main;
  });
  if (componentType !== "dataset" && zrUtil$7.indexOf(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
zrUtil$7.mixin(ComponentModel$3, boxLayoutMixin);
var _default$n = ComponentModel$3;
var Component$2 = _default$n;
var platform = "";
if (typeof navigator !== "undefined") {
  platform = navigator.platform || "";
}
var _default$m = {
  // backgroundColor: 'rgba(0,0,0,0)',
  // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
  // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
  // Light colors:
  // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
  // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
  // Dark colors:
  color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 300,
  animationEasing: "exponentialOut",
  animationEasingUpdate: "cubicOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: false
};
var globalDefault$1 = _default$m;
var _model$5 = model;
var makeInner$1 = _model$5.makeInner;
var normalizeToArray$2 = _model$5.normalizeToArray;
var inner$2 = makeInner$1();
function getNearestColorPalette(colors, requestColorNum) {
  var paletteNum = colors.length;
  for (var i = 0; i < paletteNum; i++) {
    if (colors[i].length > requestColorNum) {
      return colors[i];
    }
  }
  return colors[paletteNum - 1];
}
var _default$l = {
  clearColorPalette: function() {
    inner$2(this).colorIdx = 0;
    inner$2(this).colorNameMap = {};
  },
  /**
   * @param {string} name MUST NOT be null/undefined. Otherwise call this function
   *                 twise with the same parameters will get different result.
   * @param {Object} [scope=this]
   * @param {Object} [requestColorNum]
   * @return {string} color string.
   */
  getColorFromPalette: function(name2, scope, requestColorNum) {
    scope = scope || this;
    var scopeFields = inner$2(scope);
    var colorIdx = scopeFields.colorIdx || 0;
    var colorNameMap = scopeFields.colorNameMap = scopeFields.colorNameMap || {};
    if (colorNameMap.hasOwnProperty(name2)) {
      return colorNameMap[name2];
    }
    var defaultColorPalette = normalizeToArray$2(this.get("color", true));
    var layeredColorPalette = this.get("colorLayer", true);
    var colorPalette2 = requestColorNum == null || !layeredColorPalette ? defaultColorPalette : getNearestColorPalette(layeredColorPalette, requestColorNum);
    colorPalette2 = colorPalette2 || defaultColorPalette;
    if (!colorPalette2 || !colorPalette2.length) {
      return;
    }
    var color2 = colorPalette2[colorIdx];
    if (name2) {
      colorNameMap[name2] = color2;
    }
    scopeFields.colorIdx = (colorIdx + 1) % colorPalette2.length;
    return color2;
  }
};
var colorPalette$1 = _default$l;
var sourceHelper = {};
var sourceType = {};
var hasRequiredSourceType;
function requireSourceType() {
  if (hasRequiredSourceType)
    return sourceType;
  hasRequiredSourceType = 1;
  var SOURCE_FORMAT_ORIGINAL2 = "original";
  var SOURCE_FORMAT_ARRAY_ROWS2 = "arrayRows";
  var SOURCE_FORMAT_OBJECT_ROWS2 = "objectRows";
  var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
  var SOURCE_FORMAT_UNKNOWN = "unknown";
  var SOURCE_FORMAT_TYPED_ARRAY2 = "typedArray";
  var SERIES_LAYOUT_BY_COLUMN = "column";
  var SERIES_LAYOUT_BY_ROW = "row";
  sourceType.SOURCE_FORMAT_ORIGINAL = SOURCE_FORMAT_ORIGINAL2;
  sourceType.SOURCE_FORMAT_ARRAY_ROWS = SOURCE_FORMAT_ARRAY_ROWS2;
  sourceType.SOURCE_FORMAT_OBJECT_ROWS = SOURCE_FORMAT_OBJECT_ROWS2;
  sourceType.SOURCE_FORMAT_KEYED_COLUMNS = SOURCE_FORMAT_KEYED_COLUMNS;
  sourceType.SOURCE_FORMAT_UNKNOWN = SOURCE_FORMAT_UNKNOWN;
  sourceType.SOURCE_FORMAT_TYPED_ARRAY = SOURCE_FORMAT_TYPED_ARRAY2;
  sourceType.SERIES_LAYOUT_BY_COLUMN = SERIES_LAYOUT_BY_COLUMN;
  sourceType.SERIES_LAYOUT_BY_ROW = SERIES_LAYOUT_BY_ROW;
  return sourceType;
}
var Source_1;
var hasRequiredSource;
function requireSource() {
  if (hasRequiredSource)
    return Source_1;
  hasRequiredSource = 1;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  var isTypedArray2 = _util2.isTypedArray;
  var _clazz2 = clazz;
  var enableClassCheck2 = _clazz2.enableClassCheck;
  var _sourceType2 = requireSourceType();
  var SOURCE_FORMAT_ORIGINAL2 = _sourceType2.SOURCE_FORMAT_ORIGINAL;
  var SERIES_LAYOUT_BY_COLUMN = _sourceType2.SERIES_LAYOUT_BY_COLUMN;
  var SOURCE_FORMAT_UNKNOWN = _sourceType2.SOURCE_FORMAT_UNKNOWN;
  var SOURCE_FORMAT_TYPED_ARRAY2 = _sourceType2.SOURCE_FORMAT_TYPED_ARRAY;
  var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType2.SOURCE_FORMAT_KEYED_COLUMNS;
  function Source2(fields) {
    this.fromDataset = fields.fromDataset;
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.dimensionsDefine = fields.dimensionsDefine;
    this.encodeDefine = fields.encodeDefine && createHashMap2(fields.encodeDefine);
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectCount = fields.dimensionsDetectCount;
  }
  Source2.seriesDataToSource = function(data) {
    return new Source2({
      data,
      sourceFormat: isTypedArray2(data) ? SOURCE_FORMAT_TYPED_ARRAY2 : SOURCE_FORMAT_ORIGINAL2,
      fromDataset: false
    });
  };
  enableClassCheck2(Source2);
  var _default2 = Source2;
  Source_1 = _default2;
  return Source_1;
}
var hasRequiredSourceHelper;
function requireSourceHelper() {
  if (hasRequiredSourceHelper)
    return sourceHelper;
  hasRequiredSourceHelper = 1;
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var getDataItemValue2 = _model2.getDataItemValue;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  var each2 = _util2.each;
  var map2 = _util2.map;
  var isArray2 = _util2.isArray;
  var isString2 = _util2.isString;
  var isObject2 = _util2.isObject;
  var isTypedArray2 = _util2.isTypedArray;
  var isArrayLike2 = _util2.isArrayLike;
  var extend2 = _util2.extend;
  _util2.assert;
  var Source2 = requireSource();
  var _sourceType2 = requireSourceType();
  var SOURCE_FORMAT_ORIGINAL2 = _sourceType2.SOURCE_FORMAT_ORIGINAL;
  var SOURCE_FORMAT_ARRAY_ROWS2 = _sourceType2.SOURCE_FORMAT_ARRAY_ROWS;
  var SOURCE_FORMAT_OBJECT_ROWS2 = _sourceType2.SOURCE_FORMAT_OBJECT_ROWS;
  var SOURCE_FORMAT_KEYED_COLUMNS = _sourceType2.SOURCE_FORMAT_KEYED_COLUMNS;
  var SOURCE_FORMAT_UNKNOWN = _sourceType2.SOURCE_FORMAT_UNKNOWN;
  var SOURCE_FORMAT_TYPED_ARRAY2 = _sourceType2.SOURCE_FORMAT_TYPED_ARRAY;
  var SERIES_LAYOUT_BY_ROW = _sourceType2.SERIES_LAYOUT_BY_ROW;
  var BE_ORDINAL = {
    Must: 1,
    // Encounter string but not '-' and not number-like.
    Might: 2,
    // Encounter string but number-like.
    Not: 3
    // Other cases
  };
  var inner2 = makeInner2();
  function detectSourceFormat(datasetModel) {
    var data = datasetModel.option.source;
    var sourceFormat = SOURCE_FORMAT_UNKNOWN;
    if (isTypedArray2(data)) {
      sourceFormat = SOURCE_FORMAT_TYPED_ARRAY2;
    } else if (isArray2(data)) {
      if (data.length === 0) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS2;
      }
      for (var i = 0, len = data.length; i < len; i++) {
        var item = data[i];
        if (item == null) {
          continue;
        } else if (isArray2(item)) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS2;
          break;
        } else if (isObject2(item)) {
          sourceFormat = SOURCE_FORMAT_OBJECT_ROWS2;
          break;
        }
      }
    } else if (isObject2(data)) {
      for (var key in data) {
        if (data.hasOwnProperty(key) && isArrayLike2(data[key])) {
          sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
          break;
        }
      }
    } else if (data != null) {
      throw new Error("Invalid data");
    }
    inner2(datasetModel).sourceFormat = sourceFormat;
  }
  function getSource2(seriesModel) {
    return inner2(seriesModel).source;
  }
  function resetSourceDefaulter2(ecModel) {
    inner2(ecModel).datasetMap = createHashMap2();
  }
  function prepareSource2(seriesModel) {
    var seriesOption = seriesModel.option;
    var data = seriesOption.data;
    var sourceFormat = isTypedArray2(data) ? SOURCE_FORMAT_TYPED_ARRAY2 : SOURCE_FORMAT_ORIGINAL2;
    var fromDataset = false;
    var seriesLayoutBy = seriesOption.seriesLayoutBy;
    var sourceHeader = seriesOption.sourceHeader;
    var dimensionsDefine = seriesOption.dimensions;
    var datasetModel = getDatasetModel(seriesModel);
    if (datasetModel) {
      var datasetOption = datasetModel.option;
      data = datasetOption.source;
      sourceFormat = inner2(datasetModel).sourceFormat;
      fromDataset = true;
      seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;
      sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);
      dimensionsDefine = dimensionsDefine || datasetOption.dimensions;
    }
    var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine);
    inner2(seriesModel).source = new Source2({
      data,
      fromDataset,
      seriesLayoutBy,
      sourceFormat,
      dimensionsDefine: completeResult.dimensionsDefine,
      startIndex: completeResult.startIndex,
      dimensionsDetectCount: completeResult.dimensionsDetectCount,
      // Note: dataset option does not have `encode`.
      encodeDefine: seriesOption.encode
    });
  }
  function completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
    if (!data) {
      return {
        dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)
      };
    }
    var dimensionsDetectCount;
    var startIndex;
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS2) {
      if (sourceHeader === "auto" || sourceHeader == null) {
        arrayRowsTravelFirst(function(val) {
          if (val != null && val !== "-") {
            if (isString2(val)) {
              startIndex == null && (startIndex = 1);
            } else {
              startIndex = 0;
            }
          }
        }, seriesLayoutBy, data, 10);
      } else {
        startIndex = sourceHeader ? 1 : 0;
      }
      if (!dimensionsDefine && startIndex === 1) {
        dimensionsDefine = [];
        arrayRowsTravelFirst(function(val, index2) {
          dimensionsDefine[index2] = val != null ? val : "";
        }, seriesLayoutBy, data);
      }
      dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS2) {
      if (!dimensionsDefine) {
        dimensionsDefine = objectRowsCollectDimensions(data);
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      if (!dimensionsDefine) {
        dimensionsDefine = [];
        each2(data, function(colArr, key) {
          dimensionsDefine.push(key);
        });
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL2) {
      var value0 = getDataItemValue2(data[0]);
      dimensionsDetectCount = isArray2(value0) && value0.length || 1;
    } else
      ;
    return {
      startIndex,
      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),
      dimensionsDetectCount
    };
  }
  function normalizeDimensionsDefine(dimensionsDefine) {
    if (!dimensionsDefine) {
      return;
    }
    var nameMap = createHashMap2();
    return map2(dimensionsDefine, function(item, index2) {
      item = extend2({}, isObject2(item) ? item : {
        name: item
      });
      if (item.name == null) {
        return item;
      }
      item.name += "";
      if (item.displayName == null) {
        item.displayName = item.name;
      }
      var exist = nameMap.get(item.name);
      if (!exist) {
        nameMap.set(item.name, {
          count: 1
        });
      } else {
        item.name += "-" + exist.count++;
      }
      return item;
    });
  }
  function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
    maxLoop == null && (maxLoop = Infinity);
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        cb(data[i] ? data[i][0] : null, i);
      }
    } else {
      var value0 = data[0] || [];
      for (var i = 0; i < value0.length && i < maxLoop; i++) {
        cb(value0[i], i);
      }
    }
  }
  function objectRowsCollectDimensions(data) {
    var firstIndex = 0;
    var obj;
    while (firstIndex < data.length && !(obj = data[firstIndex++])) {
    }
    if (obj) {
      var dimensions = [];
      each2(obj, function(value, key) {
        dimensions.push(key);
      });
      return dimensions;
    }
  }
  function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
    var encode2 = {};
    var datasetModel = getDatasetModel(seriesModel);
    if (!datasetModel || !coordDimensions) {
      return encode2;
    }
    var encodeItemName = [];
    var encodeSeriesName = [];
    var ecModel = seriesModel.ecModel;
    var datasetMap = inner2(ecModel).datasetMap;
    var key = datasetModel.uid + "_" + source.seriesLayoutBy;
    var baseCategoryDimIndex;
    var categoryWayValueDimStart;
    coordDimensions = coordDimensions.slice();
    each2(coordDimensions, function(coordDimInfo, coordDimIdx) {
      !isObject2(coordDimInfo) && (coordDimensions[coordDimIdx] = {
        name: coordDimInfo
      });
      if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
        baseCategoryDimIndex = coordDimIdx;
        categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimensions[coordDimIdx]);
      }
      encode2[coordDimInfo.name] = [];
    });
    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
      categoryWayDim: categoryWayValueDimStart,
      valueWayDim: 0
    });
    each2(coordDimensions, function(coordDimInfo, coordDimIdx) {
      var coordDimName = coordDimInfo.name;
      var count = getDataDimCountOnCoordDim(coordDimInfo);
      if (baseCategoryDimIndex == null) {
        var start = datasetRecord.valueWayDim;
        pushDim(encode2[coordDimName], start, count);
        pushDim(encodeSeriesName, start, count);
        datasetRecord.valueWayDim += count;
      } else if (baseCategoryDimIndex === coordDimIdx) {
        pushDim(encode2[coordDimName], 0, count);
        pushDim(encodeItemName, 0, count);
      } else {
        var start = datasetRecord.categoryWayDim;
        pushDim(encode2[coordDimName], start, count);
        pushDim(encodeSeriesName, start, count);
        datasetRecord.categoryWayDim += count;
      }
    });
    function pushDim(dimIdxArr, idxFrom, idxCount) {
      for (var i = 0; i < idxCount; i++) {
        dimIdxArr.push(idxFrom + i);
      }
    }
    function getDataDimCountOnCoordDim(coordDimInfo) {
      var dimsDef = coordDimInfo.dimsDef;
      return dimsDef ? dimsDef.length : 1;
    }
    encodeItemName.length && (encode2.itemName = encodeItemName);
    encodeSeriesName.length && (encode2.seriesName = encodeSeriesName);
    return encode2;
  }
  function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
    var encode2 = {};
    var datasetModel = getDatasetModel(seriesModel);
    if (!datasetModel) {
      return encode2;
    }
    var sourceFormat = source.sourceFormat;
    var dimensionsDefine = source.dimensionsDefine;
    var potentialNameDimIndex;
    if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS2 || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      each2(dimensionsDefine, function(dim, idx) {
        if ((isObject2(dim) ? dim.name : dim) === "name") {
          potentialNameDimIndex = idx;
        }
      });
    }
    var idxResult = function() {
      var idxRes0 = {};
      var idxRes1 = {};
      var guessRecords = [];
      for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
        var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
        guessRecords.push(guessResult);
        var isPureNumber = guessResult === BE_ORDINAL.Not;
        if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
          idxRes0.v = i;
        }
        if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
          idxRes0.n = i;
        }
        if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
          return idxRes0;
        }
        if (!isPureNumber) {
          if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
            idxRes1.v = i;
          }
          if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
            idxRes1.n = i;
          }
        }
      }
      function fulfilled(idxResult2) {
        return idxResult2.v != null && idxResult2.n != null;
      }
      return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
    }();
    if (idxResult) {
      encode2.value = idxResult.v;
      var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
      encode2.itemName = [nameDimIndex];
      encode2.seriesName = [nameDimIndex];
    }
    return encode2;
  }
  function getDatasetModel(seriesModel) {
    var option = seriesModel.option;
    var thisData = option.data;
    if (!thisData) {
      return seriesModel.ecModel.getComponent("dataset", option.datasetIndex || 0);
    }
  }
  function guessOrdinal(source, dimIndex) {
    return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
  }
  function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
    var result;
    var maxLoop = 5;
    if (isTypedArray2(data)) {
      return BE_ORDINAL.Not;
    }
    var dimName;
    var dimType;
    if (dimensionsDefine) {
      var dimDefItem = dimensionsDefine[dimIndex];
      if (isObject2(dimDefItem)) {
        dimName = dimDefItem.name;
        dimType = dimDefItem.type;
      } else if (isString2(dimDefItem)) {
        dimName = dimDefItem;
      }
    }
    if (dimType != null) {
      return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
    }
    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS2) {
      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
        var sample = data[dimIndex];
        for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
          if ((result = detectValue(sample[startIndex + i])) != null) {
            return result;
          }
        }
      } else {
        for (var i = 0; i < data.length && i < maxLoop; i++) {
          var row = data[startIndex + i];
          if (row && (result = detectValue(row[dimIndex])) != null) {
            return result;
          }
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS2) {
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        var item = data[i];
        if (item && (result = detectValue(item[dimName])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      if (!dimName) {
        return BE_ORDINAL.Not;
      }
      var sample = data[dimName];
      if (!sample || isTypedArray2(sample)) {
        return BE_ORDINAL.Not;
      }
      for (var i = 0; i < sample.length && i < maxLoop; i++) {
        if ((result = detectValue(sample[i])) != null) {
          return result;
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL2) {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        var item = data[i];
        var val = getDataItemValue2(item);
        if (!isArray2(val)) {
          return BE_ORDINAL.Not;
        }
        if ((result = detectValue(val[dimIndex])) != null) {
          return result;
        }
      }
    }
    function detectValue(val2) {
      var beStr = isString2(val2);
      if (val2 != null && isFinite(val2) && val2 !== "") {
        return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
      } else if (beStr && val2 !== "-") {
        return BE_ORDINAL.Must;
      }
    }
    return BE_ORDINAL.Not;
  }
  sourceHelper.BE_ORDINAL = BE_ORDINAL;
  sourceHelper.detectSourceFormat = detectSourceFormat;
  sourceHelper.getSource = getSource2;
  sourceHelper.resetSourceDefaulter = resetSourceDefaulter2;
  sourceHelper.prepareSource = prepareSource2;
  sourceHelper.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;
  sourceHelper.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;
  sourceHelper.guessOrdinal = guessOrdinal;
  return sourceHelper;
}
var _util$9 = util$6;
var each$9 = _util$9.each;
var filter = _util$9.filter;
var map$3 = _util$9.map;
var isArray$3 = _util$9.isArray;
var indexOf = _util$9.indexOf;
var isObject$3 = _util$9.isObject;
var isString$2 = _util$9.isString;
var createHashMap$3 = _util$9.createHashMap;
var assert = _util$9.assert;
var clone$1 = _util$9.clone;
var merge$1 = _util$9.merge;
var extend$2 = _util$9.extend;
var mixin = _util$9.mixin;
var modelUtil$4 = model;
var Model = requireModel();
var ComponentModel$2 = Component$2;
var globalDefault = globalDefault$1;
var colorPaletteMixin$1 = colorPalette$1;
var _sourceHelper$1 = requireSourceHelper();
var resetSourceDefaulter = _sourceHelper$1.resetSourceDefaulter;
var OPTION_INNER_KEY = "\0_ec_inner";
var GlobalModel$1 = Model.extend({
  init: function(option, parentModel, theme2, optionManager) {
    theme2 = theme2 || {};
    this.option = null;
    this._theme = new Model(theme2);
    this._optionManager = optionManager;
  },
  setOption: function(option, optionPreprocessorFuncs) {
    assert(!(OPTION_INNER_KEY in option), "please use chart.getOption()");
    this._optionManager.setOption(option, optionPreprocessorFuncs);
    this.resetOption(null);
  },
  /**
   * @param {string} type null/undefined: reset all.
   *                      'recreate': force recreate all.
   *                      'timeline': only reset timeline option
   *                      'media': only reset media query option
   * @return {boolean} Whether option changed.
   */
  resetOption: function(type) {
    var optionChanged = false;
    var optionManager = this._optionManager;
    if (!type || type === "recreate") {
      var baseOption = optionManager.mountOption(type === "recreate");
      if (!this.option || type === "recreate") {
        initBase.call(this, baseOption);
      } else {
        this.restoreData();
        this.mergeOption(baseOption);
      }
      optionChanged = true;
    }
    if (type === "timeline" || type === "media") {
      this.restoreData();
    }
    if (!type || type === "recreate" || type === "timeline") {
      var timelineOption = optionManager.getTimelineOption(this);
      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
    }
    if (!type || type === "recreate" || type === "media") {
      var mediaOptions = optionManager.getMediaOption(this, this._api);
      if (mediaOptions.length) {
        each$9(mediaOptions, function(mediaOption) {
          this.mergeOption(mediaOption, optionChanged = true);
        }, this);
      }
    }
    return optionChanged;
  },
  /**
   * @protected
   */
  mergeOption: function(newOption) {
    var option = this.option;
    var componentsMap = this._componentsMap;
    var newCptTypes = [];
    resetSourceDefaulter(this);
    each$9(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!ComponentModel$2.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone$1(componentOption) : merge$1(option[mainType], componentOption, true);
      } else if (mainType) {
        newCptTypes.push(mainType);
      }
    });
    ComponentModel$2.topologicalTravel(newCptTypes, ComponentModel$2.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType, dependencies) {
      var newCptOptionList = modelUtil$4.normalizeToArray(newOption[mainType]);
      var mapResult = modelUtil$4.mappingToExists(componentsMap.get(mainType), newCptOptionList);
      modelUtil$4.makeIdAndName(mapResult);
      each$9(mapResult, function(item, index2) {
        var opt = item.option;
        if (isObject$3(opt)) {
          item.keyInfo.mainType = mainType;
          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
        }
      });
      var dependentModels = getComponentsByTypes(componentsMap, dependencies);
      option[mainType] = [];
      componentsMap.set(mainType, []);
      each$9(mapResult, function(resultItem, index2) {
        var componentModel = resultItem.exist;
        var newCptOption = resultItem.option;
        assert(isObject$3(newCptOption) || componentModel, "Empty component definition");
        if (!newCptOption) {
          componentModel.mergeOption({}, this);
          componentModel.optionUpdated({}, false);
        } else {
          var ComponentModelClass = ComponentModel$2.getClass(mainType, resultItem.keyInfo.subType, true);
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCptOption, this);
            componentModel.optionUpdated(newCptOption, false);
          } else {
            var extraOpt = extend$2({
              dependentModels,
              componentIndex: index2
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);
            extend$2(componentModel, extraOpt);
            componentModel.init(newCptOption, this, this, extraOpt);
            componentModel.optionUpdated(null, true);
          }
        }
        componentsMap.get(mainType)[index2] = componentModel;
        option[mainType][index2] = componentModel.option;
      }, this);
      if (mainType === "series") {
        createSeriesIndices(this, componentsMap.get("series"));
      }
    }
    this._seriesIndicesMap = createHashMap$3(this._seriesIndices = this._seriesIndices || []);
  },
  /**
   * Get option for output (cloned option and inner info removed)
   * @public
   * @return {Object}
   */
  getOption: function() {
    var option = clone$1(this.option);
    each$9(option, function(opts, mainType) {
      if (ComponentModel$2.hasClass(mainType)) {
        var opts = modelUtil$4.normalizeToArray(opts);
        for (var i = opts.length - 1; i >= 0; i--) {
          if (modelUtil$4.isIdInner(opts[i])) {
            opts.splice(i, 1);
          }
        }
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  },
  /**
   * @return {module:echarts/model/Model}
   */
  getTheme: function() {
    return this._theme;
  },
  /**
   * @param {string} mainType
   * @param {number} [idx=0]
   * @return {module:echarts/model/Component}
   */
  getComponent: function(mainType, idx) {
    var list = this._componentsMap.get(mainType);
    if (list) {
      return list[idx || 0];
    }
  },
  /**
   * If none of index and id and name used, return all components with mainType.
   * @param {Object} condition
   * @param {string} condition.mainType
   * @param {string} [condition.subType] If ignore, only query by mainType
   * @param {number|Array.<number>} [condition.index] Either input index or id or name.
   * @param {string|Array.<string>} [condition.id] Either input index or id or name.
   * @param {string|Array.<string>} [condition.name] Either input index or id or name.
   * @return {Array.<module:echarts/model/Component>}
   */
  queryComponents: function(condition) {
    var mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    var index2 = condition.index;
    var id = condition.id;
    var name2 = condition.name;
    var cpts = this._componentsMap.get(mainType);
    if (!cpts || !cpts.length) {
      return [];
    }
    var result;
    if (index2 != null) {
      if (!isArray$3(index2)) {
        index2 = [index2];
      }
      result = filter(map$3(index2, function(idx) {
        return cpts[idx];
      }), function(val) {
        return !!val;
      });
    } else if (id != null) {
      var isIdArray = isArray$3(id);
      result = filter(cpts, function(cpt) {
        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
      });
    } else if (name2 != null) {
      var isNameArray = isArray$3(name2);
      result = filter(cpts, function(cpt) {
        return isNameArray && indexOf(name2, cpt.name) >= 0 || !isNameArray && cpt.name === name2;
      });
    } else {
      result = cpts.slice();
    }
    return filterBySubType(result, condition);
  },
  /**
   * The interface is different from queryComponents,
   * which is convenient for inner usage.
   *
   * @usage
   * var result = findComponents(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
   * );
   * var result = findComponents(
   *     {mainType: 'series',
   *     filter: function (model, index) {...}}
   * );
   * // result like [component0, componnet1, ...]
   *
   * @param {Object} condition
   * @param {string} condition.mainType Mandatory.
   * @param {string} [condition.subType] Optional.
   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
   *        where xxx is mainType.
   *        If query attribute is null/undefined or has no index/id/name,
   *        do not filtering by query conditions, which is convenient for
   *        no-payload situations or when target of action is global.
   * @param {Function} [condition.filter] parameter: component, return boolean.
   * @return {Array.<module:echarts/model/Component>}
   */
  findComponents: function(condition) {
    var query = condition.query;
    var mainType = condition.mainType;
    var queryCond = getQueryCond(query);
    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q) {
      var indexAttr = mainType + "Index";
      var idAttr = mainType + "Id";
      var nameAttr = mainType + "Name";
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType,
        // subType will be filtered finally.
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  },
  /**
   * @usage
   * eachComponent('legend', function (legendModel, index) {
   *     ...
   * });
   * eachComponent(function (componentType, model, index) {
   *     // componentType does not include subType
   *     // (componentType is 'xxx' but not 'xxx.aa')
   * });
   * eachComponent(
   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
   *     function (model, index) {...}
   * );
   * eachComponent(
   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
   *     function (model, index) {...}
   * );
   *
   * @param {string|Object=} mainType When mainType is object, the definition
   *                                  is the same as the method 'findComponents'.
   * @param {Function} cb
   * @param {*} context
   */
  eachComponent: function(mainType, cb, context) {
    var componentsMap = this._componentsMap;
    if (typeof mainType === "function") {
      context = cb;
      cb = mainType;
      componentsMap.each(function(components, componentType) {
        each$9(components, function(component2, index2) {
          cb.call(context, componentType, component2, index2);
        });
      });
    } else if (isString$2(mainType)) {
      each$9(componentsMap.get(mainType), cb, context);
    } else if (isObject$3(mainType)) {
      var queryResult = this.findComponents(mainType);
      each$9(queryResult, cb, context);
    }
  },
  /**
   * @param {string} name
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByName: function(name2) {
    var series = this._componentsMap.get("series");
    return filter(series, function(oneSeries) {
      return oneSeries.name === name2;
    });
  },
  /**
   * @param {number} seriesIndex
   * @return {module:echarts/model/Series}
   */
  getSeriesByIndex: function(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  },
  /**
   * Get series list before filtered by type.
   * FIXME: rename to getRawSeriesByType?
   *
   * @param {string} subType
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeriesByType: function(subType) {
    var series = this._componentsMap.get("series");
    return filter(series, function(oneSeries) {
      return oneSeries.subType === subType;
    });
  },
  /**
   * @return {Array.<module:echarts/model/Series>}
   */
  getSeries: function() {
    return this._componentsMap.get("series").slice();
  },
  /**
   * @return {number}
   */
  getSeriesCount: function() {
    return this._componentsMap.get("series").length;
  },
  /**
   * After filtering, series may be different
   * frome raw series.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachSeries: function(cb, context) {
    each$9(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  },
  /**
   * Iterate raw series before filtered.
   *
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeries: function(cb, context) {
    each$9(this._componentsMap.get("series"), cb, context);
  },
  /**
   * After filtering, series may be different.
   * frome raw series.
   *
   * @param {string} subType.
   * @param {Function} cb
   * @param {*} context
   */
  eachSeriesByType: function(subType, cb, context) {
    each$9(this._seriesIndices, function(rawSeriesIndex) {
      var series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  },
  /**
   * Iterate raw series before filtered of given type.
   *
   * @parma {string} subType
   * @param {Function} cb
   * @param {*} context
   */
  eachRawSeriesByType: function(subType, cb, context) {
    return each$9(this.getSeriesByType(subType), cb, context);
  },
  /**
   * @param {module:echarts/model/Series} seriesModel
   */
  isSeriesFiltered: function(seriesModel) {
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  },
  /**
   * @return {Array.<number>}
   */
  getCurrentSeriesIndices: function() {
    return (this._seriesIndices || []).slice();
  },
  /**
   * @param {Function} cb
   * @param {*} context
   */
  filterSeries: function(cb, context) {
    var filteredSeries = filter(this._componentsMap.get("series"), cb, context);
    createSeriesIndices(this, filteredSeries);
  },
  restoreData: function(payload) {
    var componentsMap = this._componentsMap;
    createSeriesIndices(this, componentsMap.get("series"));
    var componentTypes = [];
    componentsMap.each(function(components, componentType) {
      componentTypes.push(componentType);
    });
    ComponentModel$2.topologicalTravel(componentTypes, ComponentModel$2.getAllClassMainTypes(), function(componentType, dependencies) {
      each$9(componentsMap.get(componentType), function(component2) {
        (componentType !== "series" || !isNotTargetSeries(component2, payload)) && component2.restoreData();
      });
    });
  }
});
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    var index2 = payload.seiresIndex;
    var id = payload.seriesId;
    var name2 = payload.seriesName;
    return index2 != null && seriesModel.componentIndex !== index2 || id != null && seriesModel.id !== id || name2 != null && seriesModel.name !== name2;
  }
}
function mergeTheme(option, theme2) {
  var notMergeColorLayer = option.color && !option.colorLayer;
  each$9(theme2, function(themeItem, name2) {
    if (name2 === "colorLayer" && notMergeColorLayer) {
      return;
    }
    if (!ComponentModel$2.hasClass(name2)) {
      if (typeof themeItem === "object") {
        option[name2] = !option[name2] ? clone$1(themeItem) : merge$1(option[name2], themeItem, false);
      } else {
        if (option[name2] == null) {
          option[name2] = themeItem;
        }
      }
    }
  });
}
function initBase(baseOption) {
  baseOption = baseOption;
  this.option = {};
  this.option[OPTION_INNER_KEY] = 1;
  this._componentsMap = createHashMap$3({
    series: []
  });
  this._seriesIndices;
  this._seriesIndicesMap;
  mergeTheme(baseOption, this._theme.option);
  merge$1(baseOption, globalDefault, false);
  this.mergeOption(baseOption);
}
function getComponentsByTypes(componentsMap, types) {
  if (!isArray$3(types)) {
    types = types ? [types] : [];
  }
  var ret = {};
  each$9(types, function(type) {
    ret[type] = (componentsMap.get(type) || []).slice();
  });
  return ret;
}
function determineSubType(mainType, newCptOption, existComponent) {
  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel$2.determineSubType(mainType, newCptOption);
  return subType;
}
function createSeriesIndices(ecModel, seriesModels) {
  ecModel._seriesIndicesMap = createHashMap$3(ecModel._seriesIndices = map$3(seriesModels, function(series) {
    return series.componentIndex;
  }) || []);
}
function filterBySubType(components, condition) {
  return condition.hasOwnProperty("subType") ? filter(components, function(cpt) {
    return cpt.subType === condition.subType;
  }) : components;
}
mixin(GlobalModel$1, colorPaletteMixin$1);
var _default$k = GlobalModel$1;
var Global = _default$k;
var zrUtil$6 = util$6;
var echartsAPIList = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"];
function ExtensionAPI$1(chartInstance) {
  zrUtil$6.each(echartsAPIList, function(name2) {
    this[name2] = zrUtil$6.bind(chartInstance[name2], chartInstance);
  }, this);
}
var _default$j = ExtensionAPI$1;
var ExtensionAPI_1 = _default$j;
var zrUtil$5 = util$6;
var coordinateSystemCreators = {};
function CoordinateSystemManager() {
  this._coordinateSystems = [];
}
CoordinateSystemManager.prototype = {
  constructor: CoordinateSystemManager,
  create: function(ecModel, api) {
    var coordinateSystems = [];
    zrUtil$5.each(coordinateSystemCreators, function(creater, type) {
      var list = creater.create(ecModel, api);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  },
  update: function(ecModel, api) {
    zrUtil$5.each(this._coordinateSystems, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api);
    });
  },
  getCoordinateSystems: function() {
    return this._coordinateSystems.slice();
  }
};
CoordinateSystemManager.register = function(type, coordinateSystemCreator) {
  coordinateSystemCreators[type] = coordinateSystemCreator;
};
CoordinateSystemManager.get = function(type) {
  return coordinateSystemCreators[type];
};
var _default$i = CoordinateSystemManager;
var CoordinateSystem = _default$i;
var zrUtil$4 = util$6;
var modelUtil$3 = model;
var ComponentModel$1 = Component$2;
var each$8 = zrUtil$4.each;
var clone = zrUtil$4.clone;
var map$2 = zrUtil$4.map;
var merge = zrUtil$4.merge;
var QUERY_REG = /^(min|max)?(.+)$/;
function OptionManager(api) {
  this._api = api;
  this._timelineOptions = [];
  this._mediaList = [];
  this._mediaDefault;
  this._currentMediaIndices = [];
  this._optionBackup;
  this._newBaseOption;
}
OptionManager.prototype = {
  constructor: OptionManager,
  /**
   * @public
   * @param {Object} rawOption Raw option.
   * @param {module:echarts/model/Global} ecModel
   * @param {Array.<Function>} optionPreprocessorFuncs
   * @return {Object} Init option
   */
  setOption: function(rawOption, optionPreprocessorFuncs) {
    if (rawOption) {
      zrUtil$4.each(modelUtil$3.normalizeToArray(rawOption.series), function(series) {
        series && series.data && zrUtil$4.isTypedArray(series.data) && zrUtil$4.setAsPrimitive(series.data);
      });
    }
    rawOption = clone(rawOption);
    var oldOptionBackup = this._optionBackup;
    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (oldOptionBackup) {
      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);
      if (newParsedOption.timelineOptions.length) {
        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        oldOptionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  },
  /**
   * @param {boolean} isRecreate
   * @return {Object}
   */
  mountOption: function(isRecreate) {
    var optionBackup = this._optionBackup;
    this._timelineOptions = map$2(optionBackup.timelineOptions, clone);
    this._mediaList = map$2(optionBackup.mediaList, clone);
    this._mediaDefault = clone(optionBackup.mediaDefault);
    this._currentMediaIndices = [];
    return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  },
  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Object}
   */
  getTimelineOption: function(ecModel) {
    var option;
    var timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      var timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
      }
    }
    return option;
  },
  /**
   * @param {module:echarts/model/Global} ecModel
   * @return {Array.<Object>}
   */
  getMediaOption: function(ecModel) {
    var ecWidth = this._api.getWidth();
    var ecHeight = this._api.getHeight();
    var mediaList = this._mediaList;
    var mediaDefault = this._mediaDefault;
    var indices = [];
    var result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (var i = 0, len = mediaList.length; i < len; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map$2(indices, function(index2) {
        return clone(index2 === -1 ? mediaDefault.option : mediaList[index2].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  }
};
function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
  var timelineOptions = [];
  var mediaList = [];
  var mediaDefault;
  var baseOption;
  var timelineOpt = rawOption.timeline;
  if (rawOption.baseOption) {
    baseOption = rawOption.baseOption;
  }
  if (timelineOpt || rawOption.options) {
    baseOption = baseOption || {};
    timelineOptions = (rawOption.options || []).slice();
  }
  if (rawOption.media) {
    baseOption = baseOption || {};
    var media = rawOption.media;
    each$8(media, function(singleMedia) {
      if (singleMedia && singleMedia.option) {
        if (singleMedia.query) {
          mediaList.push(singleMedia);
        } else if (!mediaDefault) {
          mediaDefault = singleMedia;
        }
      }
    });
  }
  if (!baseOption) {
    baseOption = rawOption;
  }
  if (!baseOption.timeline) {
    baseOption.timeline = timelineOpt;
  }
  each$8([baseOption].concat(timelineOptions).concat(zrUtil$4.map(mediaList, function(media2) {
    return media2.option;
  })), function(option) {
    each$8(optionPreprocessorFuncs, function(preProcess) {
      preProcess(option, isNew);
    });
  });
  return {
    baseOption,
    timelineOptions,
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query, ecWidth, ecHeight) {
  var realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
    // lowser case for convenientce.
  };
  var applicatable = true;
  zrUtil$4.each(query, function(value, attr) {
    var matched = attr.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    var operator = matched[1];
    var realAttr = matched[2].toLowerCase();
    if (!compare(realMap[realAttr], value, operator)) {
      applicatable = false;
    }
  });
  return applicatable;
}
function compare(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
function mergeOption(oldOption, newOption) {
  newOption = newOption || {};
  each$8(newOption, function(newCptOpt, mainType) {
    if (newCptOpt == null) {
      return;
    }
    var oldCptOpt = oldOption[mainType];
    if (!ComponentModel$1.hasClass(mainType)) {
      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
    } else {
      newCptOpt = modelUtil$3.normalizeToArray(newCptOpt);
      oldCptOpt = modelUtil$3.normalizeToArray(oldCptOpt);
      var mapResult = modelUtil$3.mappingToExists(oldCptOpt, newCptOpt);
      oldOption[mainType] = map$2(mapResult, function(item) {
        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;
      });
    }
  });
}
var _default$h = OptionManager;
var OptionManager_1 = _default$h;
var zrUtil$3 = util$6;
var modelUtil$2 = model;
var each$7 = zrUtil$3.each;
var isObject$2 = zrUtil$3.isObject;
var POSSIBLE_STYLES = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function compatEC2ItemStyle(opt) {
  var itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
    var styleName = POSSIBLE_STYLES[i];
    var normalItemStyleOpt = itemStyleOpt.normal;
    var emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        zrUtil$3.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        zrUtil$3.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    var normalOpt = opt[optType].normal;
    var emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        zrUtil$3.defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, "itemStyle");
  convertNormalEmphasis(opt, "lineStyle");
  convertNormalEmphasis(opt, "areaStyle");
  convertNormalEmphasis(opt, "label");
  convertNormalEmphasis(opt, "labelLine");
  convertNormalEmphasis(opt, "upperLabel");
  convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  var labelOptSingle = isObject$2(opt) && opt[propName];
  var textStyle2 = isObject$2(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle2) {
    for (var i = 0, len = modelUtil$2.TEXT_STYLE_OPTIONS.length; i < len; i++) {
      var propName = modelUtil$2.TEXT_STYLE_OPTIONS[i];
      if (textStyle2.hasOwnProperty(propName)) {
        labelOptSingle[propName] = textStyle2[propName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject$2(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  var markPoint2 = seriesOpt.markPoint;
  if (markPoint2) {
    compatEC2ItemStyle(markPoint2);
    compatEC3CommonStyles(markPoint2);
  }
  var markLine2 = seriesOpt.markLine;
  if (markLine2) {
    compatEC2ItemStyle(markLine2);
    compatEC3CommonStyles(markLine2);
  }
  var markArea2 = seriesOpt.markArea;
  if (markArea2) {
    compatEC3CommonStyles(markArea2);
  }
  var data = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data = data || seriesOpt.nodes;
    var edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !zrUtil$3.isTypedArray(edgeData)) {
      for (var i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }
    zrUtil$3.each(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data && !zrUtil$3.isTypedArray(data)) {
    for (var i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  }
  var markPoint2 = seriesOpt.markPoint;
  if (markPoint2 && markPoint2.data) {
    var mpData = markPoint2.data;
    for (var i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  }
  var markLine2 = seriesOpt.markLine;
  if (markLine2 && markLine2.data) {
    var mlData = markLine2.data;
    for (var i = 0; i < mlData.length; i++) {
      if (zrUtil$3.isArray(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
    zrUtil$3.each(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o2) {
  return zrUtil$3.isArray(o2) ? o2 : o2 ? [o2] : [];
}
function toObj(o2) {
  return (zrUtil$3.isArray(o2) ? o2[0] : o2) || {};
}
function _default$g(option, isTheme) {
  each$7(toArr(option.series), function(seriesOpt) {
    isObject$2(seriesOpt) && processSeries(seriesOpt);
  });
  var axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each$7(axes, function(axisName) {
    each$7(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each$7(toArr(option.parallel), function(parallelOpt) {
    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each$7(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each$7(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
  });
  each$7(toArr(option.geo), function(geoOpt) {
    if (isObject$2(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each$7(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each$7(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, "label");
    convertNormalEmphasis(timelineOpt, "itemStyle");
    convertNormalEmphasis(timelineOpt, "controlStyle", true);
    var data = timelineOpt.data;
    zrUtil$3.isArray(data) && zrUtil$3.each(data, function(item) {
      if (zrUtil$3.isObject(item)) {
        convertNormalEmphasis(item, "label");
        convertNormalEmphasis(item, "itemStyle");
      }
    });
  });
  each$7(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, "iconStyle");
    each$7(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}
var compatStyle$1 = _default$g;
var _util$8 = util$6;
var each$6 = _util$8.each;
var isArray$2 = _util$8.isArray;
var isObject$1 = _util$8.isObject;
var compatStyle = compatStyle$1;
var _model$4 = model;
var normalizeToArray$1 = _model$4.normalizeToArray;
function get(opt, path2) {
  path2 = path2.split(",");
  var obj = opt;
  for (var i = 0; i < path2.length; i++) {
    obj = obj && obj[path2[i]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set(opt, path2, val, overwrite) {
  path2 = path2.split(",");
  var obj = opt;
  var key;
  for (var i = 0; i < path2.length - 1; i++) {
    key = path2[i];
    if (obj[key] == null) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (overwrite || obj[path2[i]] == null) {
    obj[path2[i]] = val;
  }
}
function compatLayoutProperties(option) {
  each$6(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]];
var COMPATITABLE_COMPONENTS = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
function _default$f(option, isTheme) {
  compatStyle(option, isTheme);
  option.series = normalizeToArray$1(option.series);
  each$6(option.series, function(seriesOpt) {
    if (!isObject$1(seriesOpt)) {
      return;
    }
    var seriesType2 = seriesOpt.type;
    if (seriesType2 === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
      }
    } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
      }
    } else if (seriesType2 === "gauge") {
      var pointerColor = get(seriesOpt, "pointer.color");
      pointerColor != null && set(seriesOpt, "itemStyle.color", pointerColor);
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each$6(COMPATITABLE_COMPONENTS, function(componentName) {
    var options = option[componentName];
    if (options) {
      if (!isArray$2(options)) {
        options = [options];
      }
      each$6(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}
var backwardCompat$2 = _default$f;
var _util$7 = util$6;
var createHashMap$2 = _util$7.createHashMap;
var each$5 = _util$7.each;
function _default$e(ecModel) {
  var stackInfoMap = createHashMap$2();
  ecModel.eachSeries(function(seriesModel) {
    var stack2 = seriesModel.get("stack");
    if (stack2) {
      var stackInfoList = stackInfoMap.get(stack2) || stackInfoMap.set(stack2, []);
      var data = seriesModel.getData();
      var stackInfo = {
        // Used for calculate axis extent automatically.
        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data.getCalculationInfo("stackedDimension"),
        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
        data,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}
function calculateStack(stackInfoList) {
  each$5(stackInfoList, function(targetStackInfo, idxInStack) {
    var resultVal = [];
    var resultNaN = [NaN, NaN];
    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    var targetData = targetStackInfo.data;
    var isStackedByIndex = targetStackInfo.isStackedByIndex;
    var newData = targetData.map(dims, function(v0, v1, dataIndex) {
      var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum)) {
        return resultNaN;
      }
      var byValue;
      var stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      var stackedOver = NaN;
      for (var j = idxInStack - 1; j >= 0; j--) {
        var stackInfo = stackInfoList[j];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (sum >= 0 && val > 0 || // Positive stack
          sum <= 0 && val < 0) {
            sum += val;
            stackedOver = val;
            break;
          }
        }
      }
      resultVal[0] = sum;
      resultVal[1] = stackedOver;
      return resultVal;
    });
    targetData.hostModel.setData(newData);
    targetStackInfo.data = newData;
  });
}
var dataStack = _default$e;
var dataProvider = {};
var _util$6 = util$6;
_util$6.isTypedArray;
var extend$1 = _util$6.extend;
_util$6.assert;
var each$4 = _util$6.each;
var isObject = _util$6.isObject;
var _model$3 = model;
var getDataItemValue = _model$3.getDataItemValue;
var isDataItemOption = _model$3.isDataItemOption;
var _number = requireNumber();
var parseDate = _number.parseDate;
var Source = requireSource();
var _sourceType = requireSourceType();
var SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;
var SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;
var SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;
var SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;
function DefaultDataProvider(source, dimSize) {
  if (!Source.isInstance(source)) {
    source = Source.seriesDataToSource(source);
  }
  this._source = source;
  var data = this._data = source.data;
  var sourceFormat = source.sourceFormat;
  if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
    this._offset = 0;
    this._dimSize = dimSize;
    this._data = data;
  }
  var methods2 = providerMethods[sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + source.seriesLayoutBy : sourceFormat];
  extend$1(this, methods2);
}
var providerProto = DefaultDataProvider.prototype;
providerProto.pure = false;
providerProto.persistent = true;
providerProto.getSource = function() {
  return this._source;
};
var providerMethods = {
  "arrayRows_column": {
    pure: true,
    count: function() {
      return Math.max(0, this._data.length - this._source.startIndex);
    },
    getItem: function(idx) {
      return this._data[idx + this._source.startIndex];
    },
    appendData: appendDataSimply
  },
  "arrayRows_row": {
    pure: true,
    count: function() {
      var row = this._data[0];
      return row ? Math.max(0, row.length - this._source.startIndex) : 0;
    },
    getItem: function(idx) {
      idx += this._source.startIndex;
      var item = [];
      var data = this._data;
      for (var i = 0; i < data.length; i++) {
        var row = data[i];
        item.push(row ? row[idx] : null);
      }
      return item;
    },
    appendData: function() {
      throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
    }
  },
  "objectRows": {
    pure: true,
    count: countSimply,
    getItem: getItemSimply,
    appendData: appendDataSimply
  },
  "keyedColumns": {
    pure: true,
    count: function() {
      var dimName = this._source.dimensionsDefine[0].name;
      var col = this._data[dimName];
      return col ? col.length : 0;
    },
    getItem: function(idx) {
      var item = [];
      var dims = this._source.dimensionsDefine;
      for (var i = 0; i < dims.length; i++) {
        var col = this._data[dims[i].name];
        item.push(col ? col[idx] : null);
      }
      return item;
    },
    appendData: function(newData) {
      var data = this._data;
      each$4(newData, function(newCol, key) {
        var oldCol = data[key] || (data[key] = []);
        for (var i = 0; i < (newCol || []).length; i++) {
          oldCol.push(newCol[i]);
        }
      });
    }
  },
  "original": {
    count: countSimply,
    getItem: getItemSimply,
    appendData: appendDataSimply
  },
  "typedArray": {
    persistent: false,
    pure: true,
    count: function() {
      return this._data ? this._data.length / this._dimSize : 0;
    },
    getItem: function(idx, out2) {
      idx = idx - this._offset;
      out2 = out2 || [];
      var offset = this._dimSize * idx;
      for (var i = 0; i < this._dimSize; i++) {
        out2[i] = this._data[offset + i];
      }
      return out2;
    },
    appendData: function(newData) {
      this._data = newData;
    },
    // Clean self if data is already used.
    clean: function() {
      this._offset += this.count();
      this._data = null;
    }
  }
};
function countSimply() {
  return this._data.length;
}
function getItemSimply(idx) {
  return this._data[idx];
}
function appendDataSimply(newData) {
  for (var i = 0; i < newData.length; i++) {
    this._data.push(newData[i]);
  }
}
var rawValueGetters = {
  arrayRows: getRawValueSimply,
  objectRows: function(dataItem, dataIndex, dimIndex, dimName) {
    return dimIndex != null ? dataItem[dimName] : dataItem;
  },
  keyedColumns: getRawValueSimply,
  original: function(dataItem, dataIndex, dimIndex, dimName) {
    var value = getDataItemValue(dataItem);
    return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];
  },
  typedArray: getRawValueSimply
};
function getRawValueSimply(dataItem, dataIndex, dimIndex, dimName) {
  return dimIndex != null ? dataItem[dimIndex] : dataItem;
}
var defaultDimValueGetters = {
  arrayRows: getDimValueSimply,
  objectRows: function(dataItem, dimName, dataIndex, dimIndex) {
    return converDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
  },
  keyedColumns: getDimValueSimply,
  original: function(dataItem, dimName, dataIndex, dimIndex) {
    var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
    if (!this._rawData.pure && isDataItemOption(dataItem)) {
      this.hasItemOption = true;
    }
    return converDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);
  },
  typedArray: function(dataItem, dimName, dataIndex, dimIndex) {
    return dataItem[dimIndex];
  }
};
function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
  return converDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
}
function converDataValue(value, dimInfo) {
  var dimType = dimInfo && dimInfo.type;
  if (dimType === "ordinal") {
    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;
    return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
  }
  if (dimType === "time" && typeof value !== "number" && value != null && value !== "-") {
    value = +parseDate(value);
  }
  return value == null || value === "" ? NaN : +value;
}
function retrieveRawValue$3(data, dataIndex, dim) {
  if (!data) {
    return;
  }
  var dataItem = data.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  var sourceFormat = data.getProvider().getSource().sourceFormat;
  var dimName;
  var dimIndex;
  var dimInfo = data.getDimensionInfo(dim);
  if (dimInfo) {
    dimName = dimInfo.name;
    dimIndex = dimInfo.index;
  }
  return rawValueGetters[sourceFormat](dataItem, dataIndex, dimIndex, dimName);
}
function retrieveRawAttr(data, dataIndex, attr) {
  if (!data) {
    return;
  }
  var sourceFormat = data.getProvider().getSource().sourceFormat;
  if (sourceFormat !== SOURCE_FORMAT_ORIGINAL && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
    return;
  }
  var dataItem = data.getRawDataItem(dataIndex);
  if (sourceFormat === SOURCE_FORMAT_ORIGINAL && !isObject(dataItem)) {
    dataItem = null;
  }
  if (dataItem) {
    return dataItem[attr];
  }
}
dataProvider.DefaultDataProvider = DefaultDataProvider;
dataProvider.defaultDimValueGetters = defaultDimValueGetters;
dataProvider.retrieveRawValue = retrieveRawValue$3;
dataProvider.retrieveRawAttr = retrieveRawAttr;
var _dataProvider$2 = dataProvider;
var retrieveRawValue$2 = _dataProvider$2.retrieveRawValue;
var _format$1 = requireFormat();
var getTooltipMarker$1 = _format$1.getTooltipMarker;
var formatTpl = _format$1.formatTpl;
var _model$2 = model;
var getTooltipRenderMode = _model$2.getTooltipRenderMode;
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var _default$d = {
  /**
   * Get params for formatter
   * @param {number} dataIndex
   * @param {string} [dataType]
   * @return {Object}
   */
  getDataParams: function(dataIndex, dataType) {
    var data = this.getData(dataType);
    var rawValue = this.getRawValue(dataIndex, dataType);
    var rawDataIndex = data.getRawIndex(dataIndex);
    var name2 = data.getName(dataIndex);
    var itemOpt = data.getRawDataItem(dataIndex);
    var color2 = data.getItemVisual(dataIndex, "color");
    var borderColor = data.getItemVisual(dataIndex, "borderColor");
    var tooltipModel = this.ecModel.getComponent("tooltip");
    var renderModeOption = tooltipModel && tooltipModel.get("renderMode");
    var renderMode = getTooltipRenderMode(renderModeOption);
    var mainType = this.mainType;
    var isSeries = mainType === "series";
    var userOutput = data.userOutput;
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries ? this.id : null,
      seriesName: isSeries ? this.name : null,
      name: name2,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color: color2,
      borderColor,
      dimensionNames: userOutput ? userOutput.dimensionNames : null,
      encode: userOutput ? userOutput.encode : null,
      marker: getTooltipMarker$1({
        color: color2,
        renderMode
      }),
      // Param name list for mapping `a`, `b`, `c`, `d`, `e`
      $vars: ["seriesName", "name", "value"]
    };
  },
  /**
   * Format label
   * @param {number} dataIndex
   * @param {string} [status='normal'] 'normal' or 'emphasis'
   * @param {string} [dataType]
   * @param {number} [dimIndex] Only used in some chart that
   *        use formatter in different dimensions, like radar.
   * @param {string} [labelProp='label']
   * @return {string} If not formatter, return null/undefined
   */
  getFormattedLabel: function(dataIndex, status, dataType, dimIndex, labelProp) {
    status = status || "normal";
    var data = this.getData(dataType);
    var itemModel = data.getItemModel(dataIndex);
    var params = this.getDataParams(dataIndex, dataType);
    if (dimIndex != null && params.value instanceof Array) {
      params.value = params.value[dimIndex];
    }
    var formatter = itemModel.get(status === "normal" ? [labelProp || "label", "formatter"] : [status, labelProp || "label", "formatter"]);
    if (typeof formatter === "function") {
      params.status = status;
      params.dimensionIndex = dimIndex;
      return formatter(params);
    } else if (typeof formatter === "string") {
      var str = formatTpl(formatter, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dim) {
        var len = dim.length;
        if (dim.charAt(0) === "[" && dim.charAt(len - 1) === "]") {
          dim = +dim.slice(1, len - 1);
        }
        return retrieveRawValue$2(data, dataIndex, dim);
      });
    }
  },
  /**
   * Get raw value in option
   * @param {number} idx
   * @param {string} [dataType]
   * @return {Array|number|string}
   */
  getRawValue: function(idx, dataType) {
    return retrieveRawValue$2(this.getData(dataType), idx);
  },
  /**
   * Should be implemented.
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   * @return {string} tooltip string
   */
  formatTooltip: function() {
  }
};
var dataFormat = _default$d;
var task = {};
var _util$5 = util$6;
_util$5.assert;
var isArray$1 = _util$5.isArray;
function createTask$3(define) {
  return new Task(define);
}
function Task(define) {
  define = define || {};
  this._reset = define.reset;
  this._plan = define.plan;
  this._count = define.count;
  this._onDirty = define.onDirty;
  this._dirty = true;
  this.context;
}
var taskProto = Task.prototype;
taskProto.perform = function(performArgs) {
  var upTask = this._upstream;
  var skip = performArgs && performArgs.skip;
  if (this._dirty && upTask) {
    var context = this.context;
    context.data = context.outputData = upTask.context.outputData;
  }
  if (this.__pipeline) {
    this.__pipeline.currentTask = this;
  }
  var planResult;
  if (this._plan && !skip) {
    planResult = this._plan(this.context);
  }
  var lastModBy = normalizeModBy(this._modBy);
  var lastModDataCount = this._modDataCount || 0;
  var modBy = normalizeModBy(performArgs && performArgs.modBy);
  var modDataCount = performArgs && performArgs.modDataCount || 0;
  if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
    planResult = "reset";
  }
  function normalizeModBy(val) {
    !(val >= 1) && (val = 1);
    return val;
  }
  var forceFirstProgress;
  if (this._dirty || planResult === "reset") {
    this._dirty = false;
    forceFirstProgress = reset(this, skip);
  }
  this._modBy = modBy;
  this._modDataCount = modDataCount;
  var step = performArgs && performArgs.step;
  if (upTask) {
    this._dueEnd = upTask._outputDueEnd;
  } else {
    this._dueEnd = this._count ? this._count(this.context) : Infinity;
  }
  if (this._progress) {
    var start = this._dueIndex;
    var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
    if (!skip && (forceFirstProgress || start < end)) {
      var progress = this._progress;
      if (isArray$1(progress)) {
        for (var i = 0; i < progress.length; i++) {
          doProgress(this, progress[i], start, end, modBy, modDataCount);
        }
      } else {
        doProgress(this, progress, start, end, modBy, modDataCount);
      }
    }
    this._dueIndex = end;
    var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
    this._outputDueEnd = outputDueEnd;
  } else {
    this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
  }
  return this.unfinished();
};
var iterator = function() {
  var end;
  var current;
  var modBy;
  var modDataCount;
  var winCount;
  var it = {
    reset: function(s, e2, sStep, sCount) {
      current = s;
      end = e2;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;
  function sequentialNext() {
    return current < end ? current++ : null;
  }
  function modNext() {
    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    var result = current >= end ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();
taskProto.dirty = function() {
  this._dirty = true;
  this._onDirty && this._onDirty(this.context);
};
function doProgress(taskIns, progress, start, end, modBy, modDataCount) {
  iterator.reset(start, end, modBy, modDataCount);
  taskIns._callingProgress = progress;
  taskIns._callingProgress({
    start,
    end,
    count: end - start,
    next: iterator.next
  }, taskIns.context);
}
function reset(taskIns, skip) {
  taskIns._dueIndex = taskIns._outputDueEnd = taskIns._dueEnd = 0;
  taskIns._settedOutputEnd = null;
  var progress;
  var forceFirstProgress;
  if (!skip && taskIns._reset) {
    progress = taskIns._reset(taskIns.context);
    if (progress && progress.progress) {
      forceFirstProgress = progress.forceFirstProgress;
      progress = progress.progress;
    }
    if (isArray$1(progress) && !progress.length) {
      progress = null;
    }
  }
  taskIns._progress = progress;
  taskIns._modBy = taskIns._modDataCount = null;
  var downstream = taskIns._downstream;
  downstream && downstream.dirty();
  return forceFirstProgress;
}
taskProto.unfinished = function() {
  return this._progress && this._dueIndex < this._dueEnd;
};
taskProto.pipe = function(downTask) {
  if (this._downstream !== downTask || this._dirty) {
    this._downstream = downTask;
    downTask._upstream = this;
    downTask.dirty();
  }
};
taskProto.dispose = function() {
  if (this._disposed) {
    return;
  }
  this._upstream && (this._upstream._downstream = null);
  this._downstream && (this._downstream._upstream = null);
  this._dirty = false;
  this._disposed = true;
};
taskProto.getUpstream = function() {
  return this._upstream;
};
taskProto.getDownstream = function() {
  return this._downstream;
};
taskProto.setOutputEnd = function(end) {
  this._outputDueEnd = this._settedOutputEnd = end;
};
task.createTask = createTask$3;
var zrUtil$2 = util$6;
var env = env_1;
var _format = requireFormat();
var formatTime = _format.formatTime;
var encodeHTML = _format.encodeHTML;
var addCommas = _format.addCommas;
var getTooltipMarker = _format.getTooltipMarker;
var modelUtil$1 = model;
var ComponentModel = Component$2;
var colorPaletteMixin = colorPalette$1;
var dataFormatMixin = dataFormat;
var _layout = layout$1;
var getLayoutParams = _layout.getLayoutParams;
var mergeLayoutParam = _layout.mergeLayoutParam;
var _task$2 = task;
var createTask$2 = _task$2.createTask;
var _sourceHelper = requireSourceHelper();
var prepareSource = _sourceHelper.prepareSource;
var getSource = _sourceHelper.getSource;
var _dataProvider$1 = dataProvider;
var retrieveRawValue$1 = _dataProvider$1.retrieveRawValue;
var inner$1 = modelUtil$1.makeInner();
var SeriesModel = ComponentModel.extend({
  type: "series.__base__",
  /**
   * @readOnly
   */
  seriesIndex: 0,
  // coodinateSystem will be injected in the echarts/CoordinateSystem
  coordinateSystem: null,
  /**
   * @type {Object}
   * @protected
   */
  defaultOption: null,
  /**
   * legend visual provider to the legend component
   * @type {Object}
   */
  // PENDING
  legendVisualProvider: null,
  /**
   * Access path of color for visual
   */
  visualColorAccessPath: "itemStyle.color",
  /**
   * Access path of borderColor for visual
   */
  visualBorderColorAccessPath: "itemStyle.borderColor",
  /**
   * Support merge layout params.
   * Only support 'box' now (left/right/top/bottom/width/height).
   * @type {string|Object} Object can be {ignoreSize: true}
   * @readOnly
   */
  layoutMode: null,
  init: function(option, parentModel, ecModel, extraOpt) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask$2({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {
      model: this
    };
    this.mergeDefaultAndTheme(option, ecModel);
    prepareSource(this);
    var data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;
    inner$1(this).dataBeforeProcessed = data;
    autoSeriesName(this);
  },
  /**
   * Util for merge default and theme to option
   * @param  {Object} option
   * @param  {module:echarts/model/Global} ecModel
   */
  mergeDefaultAndTheme: function(option, ecModel) {
    var layoutMode = this.layoutMode;
    var inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    var themeSubType = this.subType;
    if (ComponentModel.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    zrUtil$2.merge(option, ecModel.getTheme().get(this.subType));
    zrUtil$2.merge(option, this.getDefaultOption());
    modelUtil$1.defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  },
  mergeOption: function(newSeriesOption, ecModel) {
    newSeriesOption = zrUtil$2.merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    var layoutMode = this.layoutMode;
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    prepareSource(this);
    var data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner$1(this).dataBeforeProcessed = data;
    autoSeriesName(this);
  },
  fillDataTextStyle: function(data) {
    if (data && !zrUtil$2.isTypedArray(data)) {
      var props = ["show"];
      for (var i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          modelUtil$1.defaultEmphasis(data[i], "label", props);
        }
      }
    }
  },
  /**
   * Init a data structure from data related option in series
   * Must be overwritten
   */
  getInitialData: function() {
  },
  /**
   * Append data to list
   * @param {Object} params
   * @param {Array|TypedArray} params.data
   */
  appendData: function(params) {
    var data = this.getRawData();
    data.appendData(params.data);
  },
  /**
   * Consider some method like `filter`, `map` need make new data,
   * We should make sure that `seriesModel.getData()` get correct
   * data in the stream procedure. So we fetch data from upstream
   * each time `task.perform` called.
   * @param {string} [dataType]
   * @return {module:echarts/data/List}
   */
  getData: function(dataType) {
    var task2 = getCurrentTask(this);
    if (task2) {
      var data = task2.context.data;
      return dataType == null ? data : data.getLinkedData(dataType);
    } else {
      return inner$1(this).data;
    }
  },
  /**
   * @param {module:echarts/data/List} data
   */
  setData: function(data) {
    var task2 = getCurrentTask(this);
    if (task2) {
      var context = task2.context;
      if (context.data !== data && task2.modifyOutputEnd) {
        task2.setOutputEnd(data.count());
      }
      context.outputData = data;
      if (task2 !== this.dataTask) {
        context.data = data;
      }
    }
    inner$1(this).data = data;
  },
  /**
   * @see {module:echarts/data/helper/sourceHelper#getSource}
   * @return {module:echarts/data/Source} source
   */
  getSource: function() {
    return getSource(this);
  },
  /**
   * Get data before processed
   * @return {module:echarts/data/List}
   */
  getRawData: function() {
    return inner$1(this).dataBeforeProcessed;
  },
  /**
   * Get base axis if has coordinate system and has axis.
   * By default use coordSys.getBaseAxis();
   * Can be overrided for some chart.
   * @return {type} description
   */
  getBaseAxis: function() {
    var coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  },
  // FIXME
  /**
   * Default tooltip formatter
   *
   * @param {number} dataIndex
   * @param {boolean} [multipleSeries=false]
   * @param {number} [dataType]
   * @param {string} [renderMode='html'] valid values: 'html' and 'richText'.
   *                                     'html' is used for rendering tooltip in extra DOM form, and the result
   *                                     string is used as DOM HTML content.
   *                                     'richText' is used for rendering tooltip in rich text form, for those where
   *                                     DOM operation is not supported.
   * @return {Object} formatted tooltip with `html` and `markers`
   */
  formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
    var series = this;
    renderMode = renderMode || "html";
    var newLine = renderMode === "html" ? "<br/>" : "\n";
    var isRichText = renderMode === "richText";
    var markers = {};
    var markerId = 0;
    function formatArrayValue(value2) {
      var vertially = zrUtil$2.reduce(value2, function(vertially2, val, idx) {
        var dimItem = data.getDimensionInfo(idx);
        return vertially2 |= dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
      }, 0);
      var result = [];
      tooltipDims.length ? zrUtil$2.each(tooltipDims, function(dim) {
        setEachItem(retrieveRawValue$1(data, dataIndex, dim), dim);
      }) : zrUtil$2.each(value2, setEachItem);
      function setEachItem(val, dim) {
        var dimInfo = data.getDimensionInfo(dim);
        if (!dimInfo || dimInfo.otherDims.tooltip === false) {
          return;
        }
        var dimType = dimInfo.type;
        var markName2 = "sub" + series.seriesIndex + "at" + markerId;
        var dimHead = getTooltipMarker({
          color: color2,
          type: "subItem",
          renderMode,
          markerId: markName2
        });
        var dimHeadStr = typeof dimHead === "string" ? dimHead : dimHead.content;
        var valStr = (vertially ? dimHeadStr + encodeHTML(dimInfo.displayName || "-") + ": " : "") + // FIXME should not format time for raw data?
        encodeHTML(dimType === "ordinal" ? val + "" : dimType === "time" ? multipleSeries ? "" : formatTime("yyyy/MM/dd hh:mm:ss", val) : addCommas(val));
        valStr && result.push(valStr);
        if (isRichText) {
          markers[markName2] = color2;
          ++markerId;
        }
      }
      var newLine2 = vertially ? isRichText ? "\n" : "<br/>" : "";
      var content2 = newLine2 + result.join(newLine2 || ", ");
      return {
        renderMode,
        content: content2,
        style: markers
      };
    }
    function formatSingleValue(val) {
      return {
        renderMode,
        content: encodeHTML(addCommas(val)),
        style: markers
      };
    }
    var data = this.getData();
    var tooltipDims = data.mapDimension("defaultedTooltip", true);
    var tooltipDimLen = tooltipDims.length;
    var value = this.getRawValue(dataIndex);
    var isValueArr = zrUtil$2.isArray(value);
    var color2 = data.getItemVisual(dataIndex, "color");
    if (zrUtil$2.isObject(color2) && color2.colorStops) {
      color2 = (color2.colorStops[0] || {}).color;
    }
    color2 = color2 || "transparent";
    var formattedValue = tooltipDimLen > 1 || isValueArr && !tooltipDimLen ? formatArrayValue(value) : tooltipDimLen ? formatSingleValue(retrieveRawValue$1(data, dataIndex, tooltipDims[0])) : formatSingleValue(isValueArr ? value[0] : value);
    var content = formattedValue.content;
    var markName = series.seriesIndex + "at" + markerId;
    var colorEl = getTooltipMarker({
      color: color2,
      type: "item",
      renderMode,
      markerId: markName
    });
    markers[markName] = color2;
    ++markerId;
    var name2 = data.getName(dataIndex);
    var seriesName = this.name;
    if (!modelUtil$1.isNameSpecified(this)) {
      seriesName = "";
    }
    seriesName = seriesName ? encodeHTML(seriesName) + (!multipleSeries ? newLine : ": ") : "";
    var colorStr = typeof colorEl === "string" ? colorEl : colorEl.content;
    var html = !multipleSeries ? seriesName + colorStr + (name2 ? encodeHTML(name2) + ": " + content : content) : colorStr + seriesName + content;
    return {
      html,
      markers
    };
  },
  /**
   * @return {boolean}
   */
  isAnimationEnabled: function() {
    if (env.node) {
      return false;
    }
    var animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return animationEnabled;
  },
  restoreData: function() {
    this.dataTask.dirty();
  },
  getColorFromPalette: function(name2, scope, requestColorNum) {
    var ecModel = this.ecModel;
    var color2 = colorPaletteMixin.getColorFromPalette.call(this, name2, scope, requestColorNum);
    if (!color2) {
      color2 = ecModel.getColorFromPalette(name2, scope, requestColorNum);
    }
    return color2;
  },
  /**
   * Use `data.mapDimension(coordDim, true)` instead.
   * @deprecated
   */
  coordDimToDataDim: function(coordDim) {
    return this.getRawData().mapDimension(coordDim, true);
  },
  /**
   * Get progressive rendering count each step
   * @return {number}
   */
  getProgressive: function() {
    return this.get("progressive");
  },
  /**
   * Get progressive rendering count each step
   * @return {number}
   */
  getProgressiveThreshold: function() {
    return this.get("progressiveThreshold");
  },
  /**
   * Get data indices for show tooltip content. See tooltip.
   * @abstract
   * @param {Array.<string>|string} dim
   * @param {Array.<number>} value
   * @param {module:echarts/coord/single/SingleAxis} baseAxis
   * @return {Object} {dataIndices, nestestValue}.
   */
  getAxisTooltipData: null,
  /**
   * See tooltip.
   * @abstract
   * @param {number} dataIndex
   * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
   */
  getTooltipPosition: null,
  /**
   * @see {module:echarts/stream/Scheduler}
   */
  pipeTask: null,
  /**
   * Convinient for override in extended class.
   * @protected
   * @type {Function}
   */
  preventIncremental: null,
  /**
   * @public
   * @readOnly
   * @type {Object}
   */
  pipelineContext: null
});
zrUtil$2.mixin(SeriesModel, dataFormatMixin);
zrUtil$2.mixin(SeriesModel, colorPaletteMixin);
function autoSeriesName(seriesModel) {
  var name2 = seriesModel.name;
  if (!modelUtil$1.isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name2;
  }
}
function getSeriesAutoName(seriesModel) {
  var data = seriesModel.getRawData();
  var dataDims = data.mapDimension("seriesName", true);
  var nameArr = [];
  zrUtil$2.each(dataDims, function(dataDim) {
    var dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  var seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param2, context) {
  if (context.outputData && param2.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data, seriesModel) {
  zrUtil$2.each(data.CHANGABLE_METHODS, function(methodName) {
    data.wrapMethod(methodName, zrUtil$2.curry(onDataSelfChange, seriesModel));
  });
}
function onDataSelfChange(seriesModel) {
  var task2 = getCurrentTask(seriesModel);
  if (task2) {
    task2.setOutputEnd(this.count());
  }
}
function getCurrentTask(seriesModel) {
  var scheduler = (seriesModel.ecModel || {}).scheduler;
  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    var task2 = pipeline.currentTask;
    if (task2) {
      var agentStubMap = task2.agentStubMap;
      if (agentStubMap) {
        task2 = agentStubMap.get(seriesModel.uid);
      }
    }
    return task2;
  }
}
var _default$c = SeriesModel;
var Series = _default$c;
var Group$2 = Group_1;
var componentUtil$1 = component;
var clazzUtil$1 = clazz;
var Component$1 = function() {
  this.group = new Group$2();
  this.uid = componentUtil$1.getUID("viewComponent");
};
Component$1.prototype = {
  constructor: Component$1,
  init: function(ecModel, api) {
  },
  render: function(componentModel, ecModel, api, payload) {
  },
  dispose: function() {
  },
  /**
   * @param {string} eventType
   * @param {Object} query
   * @param {module:zrender/Element} targetEl
   * @param {Object} packedEvent
   * @return {boolen} Pass only when return `true`.
   */
  filterForExposedEvent: null
};
var componentProto = Component$1.prototype;
componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function(seriesModel, ecModel, api, payload) {
};
clazzUtil$1.enableClassExtend(Component$1);
clazzUtil$1.enableClassManagement(Component$1, {
  registerWhenExtend: true
});
var _default$b = Component$1;
var Component_1 = _default$b;
var _model$1 = model;
var makeInner = _model$1.makeInner;
function _default$a() {
  var inner2 = makeInner();
  return function(seriesModel) {
    var fields = inner2(seriesModel);
    var pipelineContext = seriesModel.pipelineContext;
    var originalLarge = fields.large;
    var originalProgressive = fields.progressiveRender;
    var large = fields.large = pipelineContext && pipelineContext.large;
    var progressive = fields.progressiveRender = pipelineContext && pipelineContext.progressiveRender;
    return !!(originalLarge ^ large || originalProgressive ^ progressive) && "reset";
  };
}
var createRenderPlanner$1 = _default$a;
var _util$4 = util$6;
var each$3 = _util$4.each;
var Group$1 = Group_1;
var componentUtil = component;
var clazzUtil = clazz;
var modelUtil = model;
var graphicUtil = graphic$4;
var _task$1 = task;
var createTask$1 = _task$1.createTask;
var createRenderPlanner = createRenderPlanner$1;
var inner = modelUtil.makeInner();
var renderPlanner = createRenderPlanner();
function Chart() {
  this.group = new Group$1();
  this.uid = componentUtil.getUID("viewChart");
  this.renderTask = createTask$1({
    plan: renderTaskPlan,
    reset: renderTaskReset
  });
  this.renderTask.context = {
    view: this
  };
}
Chart.prototype = {
  type: "chart",
  /**
   * Init the chart.
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  init: function(ecModel, api) {
  },
  /**
   * Render the chart.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  render: function(seriesModel, ecModel, api, payload) {
  },
  /**
   * Highlight series or specified data item.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  highlight: function(seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, "emphasis");
  },
  /**
   * Downplay series or specified data item.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  downplay: function(seriesModel, ecModel, api, payload) {
    toggleHighlight(seriesModel.getData(), payload, "normal");
  },
  /**
   * Remove self.
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  remove: function(ecModel, api) {
    this.group.removeAll();
  },
  /**
   * Dispose self.
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   */
  dispose: function() {
  },
  /**
   * Rendering preparation in progressive mode.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  incrementalPrepareRender: null,
  /**
   * Render in progressive mode.
   * @param  {Object} params See taskParams in `stream/task.js`
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   */
  incrementalRender: null,
  /**
   * Update transform directly.
   * @param  {module:echarts/model/Series} seriesModel
   * @param  {module:echarts/model/Global} ecModel
   * @param  {module:echarts/ExtensionAPI} api
   * @param  {Object} payload
   * @return {Object} {update: true}
   */
  updateTransform: null,
  /**
   * The view contains the given point.
   * @interface
   * @param {Array.<number>} point
   * @return {boolean}
   */
  // containPoint: function () {}
  /**
   * @param {string} eventType
   * @param {Object} query
   * @param {module:zrender/Element} targetEl
   * @param {Object} packedEvent
   * @return {boolen} Pass only when return `true`.
   */
  filterForExposedEvent: null
};
var chartProto = Chart.prototype;
chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function(seriesModel, ecModel, api, payload) {
  this.render(seriesModel, ecModel, api, payload);
};
function elSetState(el, state, highlightDigit) {
  if (el) {
    el.trigger(state, highlightDigit);
    if (el.isGroup && !graphicUtil.isHighDownDispatcher(el)) {
      for (var i = 0, len = el.childCount(); i < len; i++) {
        elSetState(el.childAt(i), state, highlightDigit);
      }
    }
  }
}
function toggleHighlight(data, payload, state) {
  var dataIndex = modelUtil.queryDataIndex(data, payload);
  var highlightDigit = payload && payload.highlightKey != null ? graphicUtil.getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each$3(modelUtil.normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function(el) {
      elSetState(el, state, highlightDigit);
    });
  }
}
clazzUtil.enableClassExtend(Chart, ["dispose"]);
clazzUtil.enableClassManagement(Chart, {
  registerWhenExtend: true
});
Chart.markUpdateMethod = function(payload, methodName) {
  inner(payload).updateMethod = methodName;
};
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  var seriesModel = context.model;
  var ecModel = context.ecModel;
  var api = context.api;
  var payload = context.payload;
  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
  var view = context.view;
  var updateMethod = payload && inner(payload).updateMethod;
  var methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view[methodName](seriesModel, ecModel, api, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var _default$9 = Chart;
var Chart_1 = _default$9;
var throttle$1 = {};
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
function throttle(fn, delay, debounce) {
  var currCall;
  var lastCall = 0;
  var lastExec = 0;
  var timer = null;
  var diff2;
  var scope;
  var args;
  var debounceNextCall;
  delay = delay || 0;
  function exec() {
    lastExec = (/* @__PURE__ */ new Date()).getTime();
    timer = null;
    fn.apply(scope, args || []);
  }
  var cb = function() {
    currCall = (/* @__PURE__ */ new Date()).getTime();
    scope = this;
    args = arguments;
    var thisDelay = debounceNextCall || delay;
    var thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff2 = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);
    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff2 >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff2);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  var fn = obj[fnAttr];
  if (!fn) {
    return;
  }
  var originFn = fn[ORIGIN_METHOD] || fn;
  var lastThrottleType = fn[THROTTLE_TYPE];
  var lastRate = fn[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }
  return fn;
}
function clear(obj, fnAttr) {
  var fn = obj[fnAttr];
  if (fn && fn[ORIGIN_METHOD]) {
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}
throttle$1.throttle = throttle;
throttle$1.createOrUpdate = createOrUpdate;
throttle$1.clear = clear;
var Gradient = Gradient_1;
var _util$3 = util$6;
var isFunction$1 = _util$3.isFunction;
var _default$8 = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    var data = seriesModel.getData();
    var colorAccessPath = (seriesModel.visualColorAccessPath || "itemStyle.color").split(".");
    var color2 = seriesModel.get(colorAccessPath);
    var colorCallback = isFunction$1(color2) && !(color2 instanceof Gradient) ? color2 : null;
    if (!color2 || colorCallback) {
      color2 = seriesModel.getColorFromPalette(
        // TODO series count changed.
        seriesModel.name,
        null,
        ecModel.getSeriesCount()
      );
    }
    data.setVisual("color", color2);
    var borderColorAccessPath = (seriesModel.visualBorderColorAccessPath || "itemStyle.borderColor").split(".");
    var borderColor = seriesModel.get(borderColorAccessPath);
    data.setVisual("borderColor", borderColor);
    if (!ecModel.isSeriesFiltered(seriesModel)) {
      if (colorCallback) {
        data.each(function(idx) {
          data.setItemVisual(idx, "color", colorCallback(seriesModel.getDataParams(idx)));
        });
      }
      var dataEach = function(data2, idx) {
        var itemModel = data2.getItemModel(idx);
        var color3 = itemModel.get(colorAccessPath, true);
        var borderColor2 = itemModel.get(borderColorAccessPath, true);
        if (color3 != null) {
          data2.setItemVisual(idx, "color", color3);
        }
        if (borderColor2 != null) {
          data2.setItemVisual(idx, "borderColor", borderColor2);
        }
      };
      return {
        dataEach: data.hasItemOption ? dataEach : null
      };
    }
  }
};
var seriesColor = _default$8;
var _default$7 = {
  legend: {
    selector: {
      all: "全选",
      inverse: "反选"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "矩形选择",
        polygon: "圈选",
        lineX: "横向选择",
        lineY: "纵向选择",
        keep: "保持选择",
        clear: "清除选择"
      }
    },
    dataView: {
      title: "数据视图",
      lang: ["数据视图", "关闭", "刷新"]
    },
    dataZoom: {
      title: {
        zoom: "区域缩放",
        back: "区域缩放还原"
      }
    },
    magicType: {
      title: {
        line: "切换为折线图",
        bar: "切换为柱状图",
        stack: "切换为堆叠",
        tiled: "切换为平铺"
      }
    },
    restore: {
      title: "还原"
    },
    saveAsImage: {
      title: "保存为图片",
      lang: ["右键另存为图片"]
    }
  },
  series: {
    typeNames: {
      pie: "饼图",
      bar: "柱状图",
      line: "折线图",
      scatter: "散点图",
      effectScatter: "涟漪散点图",
      radar: "雷达图",
      tree: "树图",
      treemap: "矩形树图",
      boxplot: "箱型图",
      candlestick: "K线图",
      k: "K线图",
      heatmap: "热力图",
      map: "地图",
      parallel: "平行坐标图",
      lines: "线图",
      graph: "关系图",
      sankey: "桑基图",
      funnel: "漏斗图",
      gauge: "仪表盘图",
      pictorialBar: "象形柱图",
      themeRiver: "主题河流图",
      sunburst: "旭日图"
    }
  },
  aria: {
    general: {
      withTitle: "这是一个关于“{title}”的图表。",
      withoutTitle: "这是一个图表，"
    },
    series: {
      single: {
        prefix: "",
        withName: "图表类型是{seriesType}，表示{seriesName}。",
        withoutName: "图表类型是{seriesType}。"
      },
      multiple: {
        prefix: "它由{seriesCount}个图表系列组成。",
        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
        withoutName: "第{seriesId}个系列是一个{seriesType}，",
        separator: {
          middle: "；",
          end: "。"
        }
      }
    },
    data: {
      allData: "其数据是——",
      partialData: "其中，前{displayCnt}项是——",
      withName: "{name}的数据是{value}",
      withoutName: "{value}",
      separator: {
        middle: "，",
        end: ""
      }
    }
  }
};
var lang$1 = _default$7;
var zrUtil$1 = util$6;
var lang = lang$1;
var _dataProvider = dataProvider;
var retrieveRawValue = _dataProvider.retrieveRawValue;
function _default$6(dom2, ecModel) {
  var ariaModel = ecModel.getModel("aria");
  if (!ariaModel.get("show")) {
    return;
  } else if (ariaModel.get("description")) {
    dom2.setAttribute("aria-label", ariaModel.get("description"));
    return;
  }
  var seriesCnt = 0;
  ecModel.eachSeries(function(seriesModel, idx) {
    ++seriesCnt;
  }, this);
  var maxDataCnt = ariaModel.get("data.maxCount") || 10;
  var maxSeriesCnt = ariaModel.get("series.maxCount") || 10;
  var displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
  var ariaLabel;
  if (seriesCnt < 1) {
    return;
  } else {
    var title2 = getTitle();
    if (title2) {
      ariaLabel = replace(getConfig("general.withTitle"), {
        title: title2
      });
    } else {
      ariaLabel = getConfig("general.withoutTitle");
    }
    var seriesLabels = [];
    var prefix = seriesCnt > 1 ? "series.multiple.prefix" : "series.single.prefix";
    ariaLabel += replace(getConfig(prefix), {
      seriesCount: seriesCnt
    });
    ecModel.eachSeries(function(seriesModel, idx) {
      if (idx < displaySeriesCnt) {
        var seriesLabel;
        var seriesName = seriesModel.get("name");
        var seriesTpl = "series." + (seriesCnt > 1 ? "multiple" : "single") + ".";
        seriesLabel = getConfig(seriesName ? seriesTpl + "withName" : seriesTpl + "withoutName");
        seriesLabel = replace(seriesLabel, {
          seriesId: seriesModel.seriesIndex,
          seriesName: seriesModel.get("name"),
          seriesType: getSeriesTypeName(seriesModel.subType)
        });
        var data = seriesModel.getData();
        window.data = data;
        if (data.count() > maxDataCnt) {
          seriesLabel += replace(getConfig("data.partialData"), {
            displayCnt: maxDataCnt
          });
        } else {
          seriesLabel += getConfig("data.allData");
        }
        var dataLabels = [];
        for (var i = 0; i < data.count(); i++) {
          if (i < maxDataCnt) {
            var name2 = data.getName(i);
            var value = retrieveRawValue(data, i);
            dataLabels.push(replace(name2 ? getConfig("data.withName") : getConfig("data.withoutName"), {
              name: name2,
              value
            }));
          }
        }
        seriesLabel += dataLabels.join(getConfig("data.separator.middle")) + getConfig("data.separator.end");
        seriesLabels.push(seriesLabel);
      }
    });
    ariaLabel += seriesLabels.join(getConfig("series.multiple.separator.middle")) + getConfig("series.multiple.separator.end");
    dom2.setAttribute("aria-label", ariaLabel);
  }
  function replace(str, keyValues) {
    if (typeof str !== "string") {
      return str;
    }
    var result = str;
    zrUtil$1.each(keyValues, function(value, key) {
      result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
    });
    return result;
  }
  function getConfig(path2) {
    var userConfig = ariaModel.get(path2);
    if (userConfig == null) {
      var pathArr = path2.split(".");
      var result = lang.aria;
      for (var i = 0; i < pathArr.length; ++i) {
        result = result[pathArr[i]];
      }
      return result;
    } else {
      return userConfig;
    }
  }
  function getTitle() {
    var title3 = ecModel.getModel("title").option;
    if (title3 && title3.length) {
      title3 = title3[0];
    }
    return title3 && title3.text;
  }
  function getSeriesTypeName(type) {
    return lang.series.typeNames[type] || "自定义图";
  }
}
var aria = _default$6;
var zrUtil = util$6;
var graphic$3 = graphic$4;
var textContain = text;
var PI = Math.PI;
function _default$5(api, opts) {
  opts = opts || {};
  zrUtil.defaults(opts, {
    text: "loading",
    textColor: "#000",
    fontSize: "12px",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: true,
    color: "#c23531",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var group = new graphic$3.Group();
  var mask = new graphic$3.Rect({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask);
  var font = opts.fontSize + " sans-serif";
  var labelRect = new graphic$3.Rect({
    style: {
      fill: "none",
      text: opts.text,
      font,
      textPosition: "right",
      textDistance: 10,
      textFill: opts.textColor
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  if (opts.showSpinner) {
    var arc2 = new graphic$3.Arc({
      shape: {
        startAngle: -PI / 2,
        endAngle: -PI / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc2.animateShape(true).when(1e3, {
      endAngle: PI * 3 / 2
    }).start("circularInOut");
    arc2.animateShape(true).when(1e3, {
      startAngle: PI * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc2);
  }
  group.resize = function() {
    var textWidth = textContain.getWidth(opts.text, font);
    var r = opts.showSpinner ? opts.spinnerRadius : 0;
    var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner ? 0 : textWidth / 2);
    var cy = api.getHeight() / 2;
    opts.showSpinner && arc2.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api.getWidth(),
      height: api.getHeight()
    });
  };
  group.resize();
  return group;
}
var _default_1 = _default$5;
var _util$2 = util$6;
var each$2 = _util$2.each;
var map$1 = _util$2.map;
var isFunction = _util$2.isFunction;
var createHashMap$1 = _util$2.createHashMap;
var noop = _util$2.noop;
var _task = task;
var createTask = _task.createTask;
var _component = component;
var getUID = _component.getUID;
var GlobalModel = Global;
var ExtensionAPI = ExtensionAPI_1;
var _model = model;
var normalizeToArray = _model.normalizeToArray;
function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
  this.ecInstance = ecInstance;
  this.api = api;
  this.unfinished;
  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
  var visualHandlers = this._visualHandlers = visualHandlers.slice();
  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  this._stageTaskMap = createHashMap$1();
}
var proto = Scheduler.prototype;
proto.restoreData = function(ecModel, payload) {
  ecModel.restoreData(payload);
  this._stageTaskMap.each(function(taskRecord) {
    var overallTask = taskRecord.overallTask;
    overallTask && overallTask.dirty();
  });
};
proto.getPerformArgs = function(task2, isBlock) {
  if (!task2.__pipeline) {
    return;
  }
  var pipeline = this._pipelineMap.get(task2.__pipeline.id);
  var pCtx = pipeline.context;
  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task2.__idxInPipeline > pipeline.blockIndex;
  var step = incremental ? pipeline.step : null;
  var modDataCount = pCtx && pCtx.modDataCount;
  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
  return {
    step,
    modBy,
    modDataCount
  };
};
proto.getPipeline = function(pipelineId) {
  return this._pipelineMap.get(pipelineId);
};
proto.updateStreamModes = function(seriesModel, view) {
  var pipeline = this._pipelineMap.get(seriesModel.uid);
  var data = seriesModel.getData();
  var dataLen = data.count();
  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
  var large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
  var modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
  seriesModel.pipelineContext = pipeline.context = {
    progressiveRender,
    modDataCount,
    large
  };
};
proto.restorePipelines = function(ecModel) {
  var scheduler = this;
  var pipelineMap = scheduler._pipelineMap = createHashMap$1();
  ecModel.eachSeries(function(seriesModel) {
    var progressive = seriesModel.getProgressive();
    var pipelineId = seriesModel.uid;
    pipelineMap.set(pipelineId, {
      id: pipelineId,
      head: null,
      tail: null,
      threshold: seriesModel.getProgressiveThreshold(),
      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
      blockIndex: -1,
      step: Math.round(progressive || 700),
      count: 0
    });
    pipe(scheduler, seriesModel, seriesModel.dataTask);
  });
};
proto.prepareStageTasks = function() {
  var stageTaskMap = this._stageTaskMap;
  var ecModel = this.ecInstance.getModel();
  var api = this.api;
  each$2(this._allHandlers, function(handler) {
    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);
    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);
    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);
  }, this);
};
proto.prepareView = function(view, model2, ecModel, api) {
  var renderTask = view.renderTask;
  var context = renderTask.context;
  context.model = model2;
  context.ecModel = ecModel;
  context.api = api;
  renderTask.__block = !view.incrementalPrepareRender;
  pipe(this, model2, renderTask);
};
proto.performDataProcessorTasks = function(ecModel, payload) {
  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {
    block: true
  });
};
proto.performVisualTasks = function(ecModel, payload, opt) {
  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);
};
function performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {
  opt = opt || {};
  var unfinished;
  each$2(stageHandlers, function(stageHandler, idx) {
    if (opt.visualType && opt.visualType !== stageHandler.visualType) {
      return;
    }
    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
    var overallTask = stageHandlerRecord.overallTask;
    if (overallTask) {
      var overallNeedDirty;
      var agentStubMap = overallTask.agentStubMap;
      agentStubMap.each(function(stub) {
        if (needSetDirty(opt, stub)) {
          stub.dirty();
          overallNeedDirty = true;
        }
      });
      overallNeedDirty && overallTask.dirty();
      updatePayload(overallTask, payload);
      var performArgs = scheduler.getPerformArgs(overallTask, opt.block);
      agentStubMap.each(function(stub) {
        stub.perform(performArgs);
      });
      unfinished |= overallTask.perform(performArgs);
    } else if (seriesTaskMap) {
      seriesTaskMap.each(function(task2, pipelineId) {
        if (needSetDirty(opt, task2)) {
          task2.dirty();
        }
        var performArgs2 = scheduler.getPerformArgs(task2, opt.block);
        performArgs2.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task2.context.model);
        updatePayload(task2, payload);
        unfinished |= task2.perform(performArgs2);
      });
    }
  });
  function needSetDirty(opt2, task2) {
    return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task2.__pipeline.id));
  }
  scheduler.unfinished |= unfinished;
}
proto.performSeriesTasks = function(ecModel) {
  var unfinished;
  ecModel.eachSeries(function(seriesModel) {
    unfinished |= seriesModel.dataTask.perform();
  });
  this.unfinished |= unfinished;
};
proto.plan = function() {
  this._pipelineMap.each(function(pipeline) {
    var task2 = pipeline.tail;
    do {
      if (task2.__block) {
        pipeline.blockIndex = task2.__idxInPipeline;
        break;
      }
      task2 = task2.getUpstream();
    } while (task2);
  });
};
var updatePayload = proto.updatePayload = function(task2, payload) {
  payload !== "remain" && (task2.context.payload = payload);
};
function createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap$1());
  var seriesType2 = stageHandler.seriesType;
  var getTargetSeries = stageHandler.getTargetSeries;
  if (stageHandler.createOnAllSeries) {
    ecModel.eachRawSeries(create);
  } else if (seriesType2) {
    ecModel.eachRawSeriesByType(seriesType2, create);
  } else if (getTargetSeries) {
    getTargetSeries(ecModel, api).each(create);
  }
  function create(seriesModel) {
    var pipelineId = seriesModel.uid;
    var task2 = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({
      plan: seriesTaskPlan,
      reset: seriesTaskReset,
      count: seriesTaskCount
    }));
    task2.context = {
      model: seriesModel,
      ecModel,
      api,
      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
      plan: stageHandler.plan,
      reset: stageHandler.reset,
      scheduler
    };
    pipe(scheduler, seriesModel, task2);
  }
  var pipelineMap = scheduler._pipelineMap;
  seriesTaskMap.each(function(task2, pipelineId) {
    if (!pipelineMap.get(pipelineId)) {
      task2.dispose();
      seriesTaskMap.removeKey(pipelineId);
    }
  });
}
function createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {
  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({
    reset: overallTaskReset
  });
  overallTask.context = {
    ecModel,
    api,
    overallReset: stageHandler.overallReset,
    scheduler
  };
  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap$1();
  var seriesType2 = stageHandler.seriesType;
  var getTargetSeries = stageHandler.getTargetSeries;
  var overallProgress = true;
  var modifyOutputEnd = stageHandler.modifyOutputEnd;
  if (seriesType2) {
    ecModel.eachRawSeriesByType(seriesType2, createStub);
  } else if (getTargetSeries) {
    getTargetSeries(ecModel, api).each(createStub);
  } else {
    overallProgress = false;
    each$2(ecModel.getSeries(), createStub);
  }
  function createStub(seriesModel) {
    var pipelineId = seriesModel.uid;
    var stub = agentStubMap.get(pipelineId);
    if (!stub) {
      stub = agentStubMap.set(pipelineId, createTask({
        reset: stubReset,
        onDirty: stubOnDirty
      }));
      overallTask.dirty();
    }
    stub.context = {
      model: seriesModel,
      overallProgress,
      modifyOutputEnd
    };
    stub.agent = overallTask;
    stub.__block = overallProgress;
    pipe(scheduler, seriesModel, stub);
  }
  var pipelineMap = scheduler._pipelineMap;
  agentStubMap.each(function(stub, pipelineId) {
    if (!pipelineMap.get(pipelineId)) {
      stub.dispose();
      overallTask.dirty();
      agentStubMap.removeKey(pipelineId);
    }
  });
}
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context, upstreamContext) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map$1(resetDefines, function(v, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    var data = context.data;
    var resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (var i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function pipe(scheduler, seriesModel, task2) {
  var pipelineId = seriesModel.uid;
  var pipeline = scheduler._pipelineMap.get(pipelineId);
  !pipeline.head && (pipeline.head = task2);
  pipeline.tail && pipeline.tail.pipe(task2);
  pipeline.tail = task2;
  task2.__idxInPipeline = pipeline.count++;
  task2.__pipeline = pipeline;
}
Scheduler.wrapStageHandler = function(stageHandler, visualType) {
  if (isFunction(stageHandler)) {
    stageHandler = {
      overallReset: stageHandler,
      seriesType: detectSeriseType(stageHandler)
    };
  }
  stageHandler.uid = getUID("stageHandler");
  visualType && (stageHandler.visualType = visualType);
  return stageHandler;
};
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e2) {
  }
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, GlobalModel);
mockMethods(apiMock, ExtensionAPI);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
  seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (var name2 in Clz.prototype) {
    target[name2] = noop;
  }
}
var _default$4 = Scheduler;
var Scheduler_1 = _default$4;
var colorAll = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
var _default$3 = {
  color: colorAll,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], colorAll]
};
var light = _default$3;
var contrastColor = "#eee";
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    axisTick: {
      lineStyle: {
        color: contrastColor
      }
    },
    axisLabel: {
      textStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        type: "dashed",
        color: "#aaa"
      }
    },
    splitArea: {
      areaStyle: {
        color: contrastColor
      }
    }
  };
};
var colorPalette = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"];
var theme = {
  color: colorPalette,
  backgroundColor: "#333",
  tooltip: {
    axisPointer: {
      lineStyle: {
        color: contrastColor
      },
      crossStyle: {
        color: contrastColor
      },
      label: {
        color: "#000"
      }
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: contrastColor
    }
  },
  toolbox: {
    iconStyle: {
      normal: {
        borderColor: contrastColor
      }
    }
  },
  dataZoom: {
    textStyle: {
      color: contrastColor
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    itemStyle: {
      normal: {
        color: colorPalette[1]
      }
    },
    label: {
      normal: {
        textStyle: {
          color: contrastColor
        }
      }
    },
    controlStyle: {
      normal: {
        color: contrastColor,
        borderColor: contrastColor
      }
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      textStyle: {
        color: contrastColor
      }
    }
  },
  candlestick: {
    itemStyle: {
      normal: {
        color: "#FD1050",
        color0: "#0CF49B",
        borderColor: "#FD1050",
        borderColor0: "#0CF49B"
      }
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var _default$2 = theme;
var dark = _default$2;
var dataset = {};
var hasRequiredDataset;
function requireDataset() {
  if (hasRequiredDataset)
    return dataset;
  hasRequiredDataset = 1;
  var ComponentModel2 = Component$2;
  var ComponentView = Component_1;
  var _sourceHelper2 = requireSourceHelper();
  var detectSourceFormat = _sourceHelper2.detectSourceFormat;
  var _sourceType2 = requireSourceType();
  var SERIES_LAYOUT_BY_COLUMN = _sourceType2.SERIES_LAYOUT_BY_COLUMN;
  ComponentModel2.extend({
    type: "dataset",
    /**
     * @protected
     */
    defaultOption: {
      // 'row', 'column'
      seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
      // null/'auto': auto detect header, see "module:echarts/data/helper/sourceHelper"
      sourceHeader: null,
      dimensions: null,
      source: null
    },
    optionUpdated: function() {
      detectSourceFormat(this);
    }
  });
  ComponentView.extend({
    type: "dataset"
  });
  return dataset;
}
var parseSVG$1 = {};
var Path$1 = Path_1;
var _default$1 = Path$1.extend({
  type: "ellipse",
  shape: {
    cx: 0,
    cy: 0,
    rx: 0,
    ry: 0
  },
  buildPath: function(ctx, shape) {
    var k = 0.5522848;
    var x = shape.cx;
    var y = shape.cy;
    var a = shape.rx;
    var b = shape.ry;
    var ox = a * k;
    var oy = b * k;
    ctx.moveTo(x - a, y);
    ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
    ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
    ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
    ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
    ctx.closePath();
  }
});
var Ellipse$1 = _default$1;
var Group = Group_1;
var ZImage = Image$2;
var Text = Text_1;
var Circle = Circle$2;
var Rect = Rect$2;
var Ellipse = Ellipse$1;
var Line = Line$2;
var Path = Path_1;
var Polygon = Polygon$2;
var Polyline = Polyline$2;
var LinearGradient = LinearGradient_1;
var Style = Style_1;
var matrix = requireMatrix();
var _path = path$1;
var createFromString = _path.createFromString;
var _util$1 = util$6;
var isString$1 = _util$1.isString;
var extend = _util$1.extend;
var defaults = _util$1.defaults;
var trim = _util$1.trim;
var each$1 = _util$1.each;
var DILIMITER_REG = /[\s,]+/;
function parseXML$1(svg2) {
  if (isString$1(svg2)) {
    var parser = new DOMParser();
    svg2 = parser.parseFromString(svg2, "text/xml");
  }
  if (svg2.nodeType === 9) {
    svg2 = svg2.firstChild;
  }
  while (svg2.nodeName.toLowerCase() !== "svg" || svg2.nodeType !== 1) {
    svg2 = svg2.nextSibling;
  }
  return svg2;
}
function SVGParser() {
  this._defs = {};
  this._root = null;
  this._isDefine = false;
  this._isText = false;
}
SVGParser.prototype.parse = function(xml, opt) {
  opt = opt || {};
  var svg2 = parseXML$1(xml);
  if (!svg2) {
    throw new Error("Illegal svg");
  }
  var root = new Group();
  this._root = root;
  var viewBox = svg2.getAttribute("viewBox") || "";
  var width = parseFloat(svg2.getAttribute("width") || opt.width);
  var height = parseFloat(svg2.getAttribute("height") || opt.height);
  isNaN(width) && (width = null);
  isNaN(height) && (height = null);
  parseAttributes(svg2, root, null, true);
  var child = svg2.firstChild;
  while (child) {
    this._parseNode(child, root);
    child = child.nextSibling;
  }
  var viewBoxRect;
  var viewBoxTransform;
  if (viewBox) {
    var viewBoxArr = trim(viewBox).split(DILIMITER_REG);
    if (viewBoxArr.length >= 4) {
      viewBoxRect = {
        x: parseFloat(viewBoxArr[0] || 0),
        y: parseFloat(viewBoxArr[1] || 0),
        width: parseFloat(viewBoxArr[2]),
        height: parseFloat(viewBoxArr[3])
      };
    }
  }
  if (viewBoxRect && width != null && height != null) {
    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);
    if (!opt.ignoreViewBox) {
      var elRoot = root;
      root = new Group();
      root.add(elRoot);
      elRoot.scale = viewBoxTransform.scale.slice();
      elRoot.position = viewBoxTransform.position.slice();
    }
  }
  if (!opt.ignoreRootClip && width != null && height != null) {
    root.setClipPath(new Rect({
      shape: {
        x: 0,
        y: 0,
        width,
        height
      }
    }));
  }
  return {
    root,
    width,
    height,
    viewBoxRect,
    viewBoxTransform
  };
};
SVGParser.prototype._parseNode = function(xmlNode, parentGroup) {
  var nodeName = xmlNode.nodeName.toLowerCase();
  if (nodeName === "defs") {
    this._isDefine = true;
  } else if (nodeName === "text") {
    this._isText = true;
  }
  var el;
  if (this._isDefine) {
    var parser = defineParsers[nodeName];
    if (parser) {
      var def2 = parser.call(this, xmlNode);
      var id = xmlNode.getAttribute("id");
      if (id) {
        this._defs[id] = def2;
      }
    }
  } else {
    var parser = nodeParsers[nodeName];
    if (parser) {
      el = parser.call(this, xmlNode, parentGroup);
      parentGroup.add(el);
    }
  }
  var child = xmlNode.firstChild;
  while (child) {
    if (child.nodeType === 1) {
      this._parseNode(child, el);
    }
    if (child.nodeType === 3 && this._isText) {
      this._parseText(child, el);
    }
    child = child.nextSibling;
  }
  if (nodeName === "defs") {
    this._isDefine = false;
  } else if (nodeName === "text") {
    this._isText = false;
  }
};
SVGParser.prototype._parseText = function(xmlNode, parentGroup) {
  if (xmlNode.nodeType === 1) {
    var dx = xmlNode.getAttribute("dx") || 0;
    var dy = xmlNode.getAttribute("dy") || 0;
    this._textX += parseFloat(dx);
    this._textY += parseFloat(dy);
  }
  var text2 = new Text({
    style: {
      text: xmlNode.textContent,
      transformText: true
    },
    position: [this._textX || 0, this._textY || 0]
  });
  inheritStyle(parentGroup, text2);
  parseAttributes(xmlNode, text2, this._defs);
  var fontSize = text2.style.fontSize;
  if (fontSize && fontSize < 9) {
    text2.style.fontSize = 9;
    text2.scale = text2.scale || [1, 1];
    text2.scale[0] *= fontSize / 9;
    text2.scale[1] *= fontSize / 9;
  }
  var rect = text2.getBoundingRect();
  this._textX += rect.width;
  parentGroup.add(text2);
  return text2;
};
var nodeParsers = {
  "g": function(xmlNode, parentGroup) {
    var g = new Group();
    inheritStyle(parentGroup, g);
    parseAttributes(xmlNode, g, this._defs);
    return g;
  },
  "rect": function(xmlNode, parentGroup) {
    var rect = new Rect();
    inheritStyle(parentGroup, rect);
    parseAttributes(xmlNode, rect, this._defs);
    rect.setShape({
      x: parseFloat(xmlNode.getAttribute("x") || 0),
      y: parseFloat(xmlNode.getAttribute("y") || 0),
      width: parseFloat(xmlNode.getAttribute("width") || 0),
      height: parseFloat(xmlNode.getAttribute("height") || 0)
    });
    return rect;
  },
  "circle": function(xmlNode, parentGroup) {
    var circle = new Circle();
    inheritStyle(parentGroup, circle);
    parseAttributes(xmlNode, circle, this._defs);
    circle.setShape({
      cx: parseFloat(xmlNode.getAttribute("cx") || 0),
      cy: parseFloat(xmlNode.getAttribute("cy") || 0),
      r: parseFloat(xmlNode.getAttribute("r") || 0)
    });
    return circle;
  },
  "line": function(xmlNode, parentGroup) {
    var line2 = new Line();
    inheritStyle(parentGroup, line2);
    parseAttributes(xmlNode, line2, this._defs);
    line2.setShape({
      x1: parseFloat(xmlNode.getAttribute("x1") || 0),
      y1: parseFloat(xmlNode.getAttribute("y1") || 0),
      x2: parseFloat(xmlNode.getAttribute("x2") || 0),
      y2: parseFloat(xmlNode.getAttribute("y2") || 0)
    });
    return line2;
  },
  "ellipse": function(xmlNode, parentGroup) {
    var ellipse = new Ellipse();
    inheritStyle(parentGroup, ellipse);
    parseAttributes(xmlNode, ellipse, this._defs);
    ellipse.setShape({
      cx: parseFloat(xmlNode.getAttribute("cx") || 0),
      cy: parseFloat(xmlNode.getAttribute("cy") || 0),
      rx: parseFloat(xmlNode.getAttribute("rx") || 0),
      ry: parseFloat(xmlNode.getAttribute("ry") || 0)
    });
    return ellipse;
  },
  "polygon": function(xmlNode, parentGroup) {
    var points2 = xmlNode.getAttribute("points");
    if (points2) {
      points2 = parsePoints(points2);
    }
    var polygon2 = new Polygon({
      shape: {
        points: points2 || []
      }
    });
    inheritStyle(parentGroup, polygon2);
    parseAttributes(xmlNode, polygon2, this._defs);
    return polygon2;
  },
  "polyline": function(xmlNode, parentGroup) {
    var path2 = new Path();
    inheritStyle(parentGroup, path2);
    parseAttributes(xmlNode, path2, this._defs);
    var points2 = xmlNode.getAttribute("points");
    if (points2) {
      points2 = parsePoints(points2);
    }
    var polyline = new Polyline({
      shape: {
        points: points2 || []
      }
    });
    return polyline;
  },
  "image": function(xmlNode, parentGroup) {
    var img = new ZImage();
    inheritStyle(parentGroup, img);
    parseAttributes(xmlNode, img, this._defs);
    img.setStyle({
      image: xmlNode.getAttribute("xlink:href"),
      x: xmlNode.getAttribute("x"),
      y: xmlNode.getAttribute("y"),
      width: xmlNode.getAttribute("width"),
      height: xmlNode.getAttribute("height")
    });
    return img;
  },
  "text": function(xmlNode, parentGroup) {
    var x = xmlNode.getAttribute("x") || 0;
    var y = xmlNode.getAttribute("y") || 0;
    var dx = xmlNode.getAttribute("dx") || 0;
    var dy = xmlNode.getAttribute("dy") || 0;
    this._textX = parseFloat(x) + parseFloat(dx);
    this._textY = parseFloat(y) + parseFloat(dy);
    var g = new Group();
    inheritStyle(parentGroup, g);
    parseAttributes(xmlNode, g, this._defs);
    return g;
  },
  "tspan": function(xmlNode, parentGroup) {
    var x = xmlNode.getAttribute("x");
    var y = xmlNode.getAttribute("y");
    if (x != null) {
      this._textX = parseFloat(x);
    }
    if (y != null) {
      this._textY = parseFloat(y);
    }
    var dx = xmlNode.getAttribute("dx") || 0;
    var dy = xmlNode.getAttribute("dy") || 0;
    var g = new Group();
    inheritStyle(parentGroup, g);
    parseAttributes(xmlNode, g, this._defs);
    this._textX += dx;
    this._textY += dy;
    return g;
  },
  "path": function(xmlNode, parentGroup) {
    var d = xmlNode.getAttribute("d") || "";
    var path2 = createFromString(d);
    inheritStyle(parentGroup, path2);
    parseAttributes(xmlNode, path2, this._defs);
    return path2;
  }
};
var defineParsers = {
  "lineargradient": function(xmlNode) {
    var x1 = parseInt(xmlNode.getAttribute("x1") || 0, 10);
    var y1 = parseInt(xmlNode.getAttribute("y1") || 0, 10);
    var x2 = parseInt(xmlNode.getAttribute("x2") || 10, 10);
    var y2 = parseInt(xmlNode.getAttribute("y2") || 0, 10);
    var gradient = new LinearGradient(x1, y1, x2, y2);
    _parseGradientColorStops(xmlNode, gradient);
    return gradient;
  },
  "radialgradient": function(xmlNode) {
  }
};
function _parseGradientColorStops(xmlNode, gradient) {
  var stop2 = xmlNode.firstChild;
  while (stop2) {
    if (stop2.nodeType === 1) {
      var offset = stop2.getAttribute("offset");
      if (offset.indexOf("%") > 0) {
        offset = parseInt(offset, 10) / 100;
      } else if (offset) {
        offset = parseFloat(offset);
      } else {
        offset = 0;
      }
      var stopColor = stop2.getAttribute("stop-color") || "#000000";
      gradient.addColorStop(offset, stopColor);
    }
    stop2 = stop2.nextSibling;
  }
}
function inheritStyle(parent, child) {
  if (parent && parent.__inheritedStyle) {
    if (!child.__inheritedStyle) {
      child.__inheritedStyle = {};
    }
    defaults(child.__inheritedStyle, parent.__inheritedStyle);
  }
}
function parsePoints(pointsString) {
  var list = trim(pointsString).split(DILIMITER_REG);
  var points2 = [];
  for (var i = 0; i < list.length; i += 2) {
    var x = parseFloat(list[i]);
    var y = parseFloat(list[i + 1]);
    points2.push([x, y]);
  }
  return points2;
}
var attributesMap = {
  "fill": "fill",
  "stroke": "stroke",
  "stroke-width": "lineWidth",
  "opacity": "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-align": "textAlign",
  "alignment-baseline": "textBaseline"
};
function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
  var zrStyle = el.__inheritedStyle || {};
  var isTextEl = el.type === "text";
  if (xmlNode.nodeType === 1) {
    parseTransformAttribute(xmlNode, el);
    extend(zrStyle, parseStyleAttribute(xmlNode));
    if (!onlyInlineStyle) {
      for (var svgAttrName in attributesMap) {
        if (attributesMap.hasOwnProperty(svgAttrName)) {
          var attrValue = xmlNode.getAttribute(svgAttrName);
          if (attrValue != null) {
            zrStyle[attributesMap[svgAttrName]] = attrValue;
          }
        }
      }
    }
  }
  var elFillProp = isTextEl ? "textFill" : "fill";
  var elStrokeProp = isTextEl ? "textStroke" : "stroke";
  el.style = el.style || new Style();
  var elStyle = el.style;
  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));
  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));
  each$1(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(propName) {
    var elPropName = propName === "lineWidth" && isTextEl ? "textStrokeWidth" : propName;
    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));
  });
  if (!zrStyle.textBaseline || zrStyle.textBaseline === "auto") {
    zrStyle.textBaseline = "alphabetic";
  }
  if (zrStyle.textBaseline === "alphabetic") {
    zrStyle.textBaseline = "bottom";
  }
  if (zrStyle.textAlign === "start") {
    zrStyle.textAlign = "left";
  }
  if (zrStyle.textAlign === "end") {
    zrStyle.textAlign = "right";
  }
  each$1(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function(propName) {
    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);
  });
  if (zrStyle.lineDash) {
    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);
  }
  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== "none") {
    el[elStrokeProp] = true;
  }
  el.__inheritedStyle = zrStyle;
}
var urlRegex = /url\(\s*#(.*?)\)/;
function getPaint(str, defs) {
  var urlMatch = defs && str && str.match(urlRegex);
  if (urlMatch) {
    var url = trim(urlMatch[1]);
    var def2 = defs[url];
    return def2;
  }
  return str;
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;
function parseTransformAttribute(xmlNode, node) {
  var transform = xmlNode.getAttribute("transform");
  if (transform) {
    transform = transform.replace(/,/g, " ");
    var m2 = null;
    var transformOps = [];
    transform.replace(transformRegex, function(str, type2, value2) {
      transformOps.push(type2, value2);
    });
    for (var i = transformOps.length - 1; i > 0; i -= 2) {
      var value = transformOps[i];
      var type = transformOps[i - 1];
      m2 = m2 || matrix.create();
      switch (type) {
        case "translate":
          value = trim(value).split(DILIMITER_REG);
          matrix.translate(m2, m2, [parseFloat(value[0]), parseFloat(value[1] || 0)]);
          break;
        case "scale":
          value = trim(value).split(DILIMITER_REG);
          matrix.scale(m2, m2, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);
          break;
        case "rotate":
          value = trim(value).split(DILIMITER_REG);
          matrix.rotate(m2, m2, parseFloat(value[0]));
          break;
        case "skew":
          value = trim(value).split(DILIMITER_REG);
          console.warn("Skew transform is not supported yet");
          break;
        case "matrix":
          var value = trim(value).split(DILIMITER_REG);
          m2[0] = parseFloat(value[0]);
          m2[1] = parseFloat(value[1]);
          m2[2] = parseFloat(value[2]);
          m2[3] = parseFloat(value[3]);
          m2[4] = parseFloat(value[4]);
          m2[5] = parseFloat(value[5]);
          break;
      }
    }
    node.setLocalTransform(m2);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseStyleAttribute(xmlNode) {
  var style = xmlNode.getAttribute("style");
  var result = {};
  if (!style) {
    return result;
  }
  var styleList = {};
  styleRegex.lastIndex = 0;
  var styleRegResult;
  while ((styleRegResult = styleRegex.exec(style)) != null) {
    styleList[styleRegResult[1]] = styleRegResult[2];
  }
  for (var svgAttrName in attributesMap) {
    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
      result[attributesMap[svgAttrName]] = styleList[svgAttrName];
    }
  }
  return result;
}
function makeViewBoxTransform(viewBoxRect, width, height) {
  var scaleX = width / viewBoxRect.width;
  var scaleY = height / viewBoxRect.height;
  var scale = Math.min(scaleX, scaleY);
  var viewBoxScale = [scale, scale];
  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];
  return {
    scale: viewBoxScale,
    position: viewBoxPosition
  };
}
function parseSVG(xml, opt) {
  var parser = new SVGParser();
  return parser.parse(xml, opt);
}
parseSVG$1.parseXML = parseXML$1;
parseSVG$1.makeViewBoxTransform = makeViewBoxTransform;
parseSVG$1.parseSVG = parseSVG;
var _util = util$6;
var createHashMap = _util.createHashMap;
var isString = _util.isString;
var isArray = _util.isArray;
var each = _util.each;
_util.assert;
var _parseSVG = parseSVG$1;
var parseXML = _parseSVG.parseXML;
var storage = createHashMap();
var _default = {
  // The format of record: see `echarts.registerMap`.
  // Compatible with previous `echarts.registerMap`.
  registerMap: function(mapName, rawGeoJson, rawSpecialAreas) {
    var records;
    if (isArray(rawGeoJson)) {
      records = rawGeoJson;
    } else if (rawGeoJson.svg) {
      records = [{
        type: "svg",
        source: rawGeoJson.svg,
        specialAreas: rawGeoJson.specialAreas
      }];
    } else {
      if (rawGeoJson.geoJson && !rawGeoJson.features) {
        rawSpecialAreas = rawGeoJson.specialAreas;
        rawGeoJson = rawGeoJson.geoJson;
      }
      records = [{
        type: "geoJSON",
        source: rawGeoJson,
        specialAreas: rawSpecialAreas
      }];
    }
    each(records, function(record) {
      var type = record.type;
      type === "geoJson" && (type = record.type = "geoJSON");
      var parse2 = parsers[type];
      parse2(record);
    });
    return storage.set(mapName, records);
  },
  retrieveMap: function(mapName) {
    return storage.get(mapName);
  }
};
var parsers = {
  geoJSON: function(record) {
    var source = record.source;
    record.geoJSON = !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
  },
  // Only perform parse to XML object here, which might be time
  // consiming for large SVG.
  // Although convert XML to zrender element is also time consiming,
  // if we do it here, the clone of zrender elements has to be
  // required. So we do it once for each geo instance, util real
  // performance issues call for optimizing it.
  svg: function(record) {
    record.svgXML = parseXML(record.source);
  }
};
var mapDataStorage = _default;
var _export = {};
var helper$5 = {};
var DataDiffer_1;
var hasRequiredDataDiffer;
function requireDataDiffer() {
  if (hasRequiredDataDiffer)
    return DataDiffer_1;
  hasRequiredDataDiffer = 1;
  function defaultKeyGetter(item) {
    return item;
  }
  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
  }
  DataDiffer.prototype = {
    constructor: DataDiffer,
    /**
     * Callback function when add a data
     */
    add: function(func) {
      this._add = func;
      return this;
    },
    /**
     * Callback function when update a data
     */
    update: function(func) {
      this._update = func;
      return this;
    },
    /**
     * Callback function when remove a data
     */
    remove: function(func) {
      this._remove = func;
      return this;
    },
    execute: function() {
      var oldArr = this._old;
      var newArr = this._new;
      var oldDataIndexMap = {};
      var newDataIndexMap = {};
      var oldDataKeyArr = [];
      var newDataKeyArr = [];
      var i;
      initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter", this);
      initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter", this);
      for (i = 0; i < oldArr.length; i++) {
        var key = oldDataKeyArr[i];
        var idx = newDataIndexMap[key];
        if (idx != null) {
          var len = idx.length;
          if (len) {
            len === 1 && (newDataIndexMap[key] = null);
            idx = idx.shift();
          } else {
            newDataIndexMap[key] = null;
          }
          this._update && this._update(idx, i);
        } else {
          this._remove && this._remove(i);
        }
      }
      for (var i = 0; i < newDataKeyArr.length; i++) {
        var key = newDataKeyArr[i];
        if (newDataIndexMap.hasOwnProperty(key)) {
          var idx = newDataIndexMap[key];
          if (idx == null) {
            continue;
          }
          if (!idx.length) {
            this._add && this._add(idx);
          } else {
            for (var j = 0, len = idx.length; j < len; j++) {
              this._add && this._add(idx[j]);
            }
          }
        }
      }
    }
  };
  function initIndexMap(arr, map2, keyArr, keyGetterName, dataDiffer) {
    for (var i = 0; i < arr.length; i++) {
      var key = "_ec_" + dataDiffer[keyGetterName](arr[i], i);
      var existence = map2[key];
      if (existence == null) {
        keyArr.push(key);
        map2[key] = i;
      } else {
        if (!existence.length) {
          map2[key] = existence = [existence];
        }
        existence.push(i);
      }
    }
  }
  var _default2 = DataDiffer;
  DataDiffer_1 = _default2;
  return DataDiffer_1;
}
var dimensionHelper = {};
var hasRequiredDimensionHelper;
function requireDimensionHelper() {
  if (hasRequiredDimensionHelper)
    return dimensionHelper;
  hasRequiredDimensionHelper = 1;
  var _util2 = util$6;
  var each2 = _util2.each;
  var createHashMap2 = _util2.createHashMap;
  _util2.assert;
  var OTHER_DIMENSIONS = createHashMap2(["tooltip", "label", "itemName", "itemId", "seriesName"]);
  function summarizeDimensions(data) {
    var summary = {};
    var encode2 = summary.encode = {};
    var notExtraCoordDimMap = createHashMap2();
    var defaultedLabel = [];
    var defaultedTooltip = [];
    var userOutput = summary.userOutput = {
      dimensionNames: data.dimensions.slice(),
      encode: {}
    };
    each2(data.dimensions, function(dimName) {
      var dimItem = data.getDimensionInfo(dimName);
      var coordDim = dimItem.coordDim;
      if (coordDim) {
        var coordDimIndex = dimItem.coordDimIndex;
        getOrCreateEncodeArr(encode2, coordDim)[coordDimIndex] = dimName;
        if (!dimItem.isExtraCoord) {
          notExtraCoordDimMap.set(coordDim, 1);
          if (mayLabelDimType(dimItem.type)) {
            defaultedLabel[0] = dimName;
          }
          getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index;
        }
        if (dimItem.defaultTooltip) {
          defaultedTooltip.push(dimName);
        }
      }
      OTHER_DIMENSIONS.each(function(v, otherDim) {
        var encodeArr = getOrCreateEncodeArr(encode2, otherDim);
        var dimIndex = dimItem.otherDims[otherDim];
        if (dimIndex != null && dimIndex !== false) {
          encodeArr[dimIndex] = dimItem.name;
        }
      });
    });
    var dataDimsOnCoord = [];
    var encodeFirstDimNotExtra = {};
    notExtraCoordDimMap.each(function(v, coordDim) {
      var dimArr = encode2[coordDim];
      encodeFirstDimNotExtra[coordDim] = dimArr[0];
      dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
    });
    summary.dataDimsOnCoord = dataDimsOnCoord;
    summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
    var encodeLabel = encode2.label;
    if (encodeLabel && encodeLabel.length) {
      defaultedLabel = encodeLabel.slice();
    }
    var encodeTooltip = encode2.tooltip;
    if (encodeTooltip && encodeTooltip.length) {
      defaultedTooltip = encodeTooltip.slice();
    } else if (!defaultedTooltip.length) {
      defaultedTooltip = defaultedLabel.slice();
    }
    encode2.defaultedLabel = defaultedLabel;
    encode2.defaultedTooltip = defaultedTooltip;
    return summary;
  }
  function getOrCreateEncodeArr(encode2, dim) {
    if (!encode2.hasOwnProperty(dim)) {
      encode2[dim] = [];
    }
    return encode2[dim];
  }
  function getDimensionTypeByAxis(axisType) {
    return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
  }
  function mayLabelDimType(dimType) {
    return !(dimType === "ordinal" || dimType === "time");
  }
  dimensionHelper.OTHER_DIMENSIONS = OTHER_DIMENSIONS;
  dimensionHelper.summarizeDimensions = summarizeDimensions;
  dimensionHelper.getDimensionTypeByAxis = getDimensionTypeByAxis;
  return dimensionHelper;
}
var DataDimensionInfo_1;
var hasRequiredDataDimensionInfo;
function requireDataDimensionInfo() {
  if (hasRequiredDataDimensionInfo)
    return DataDimensionInfo_1;
  hasRequiredDataDimensionInfo = 1;
  var zrUtil2 = util$6;
  function DataDimensionInfo(opt) {
    if (opt != null) {
      zrUtil2.extend(this, opt);
    }
    this.otherDims = {};
  }
  var _default2 = DataDimensionInfo;
  DataDimensionInfo_1 = _default2;
  return DataDimensionInfo_1;
}
var List_1;
var hasRequiredList;
function requireList() {
  if (hasRequiredList)
    return List_1;
  hasRequiredList = 1;
  var zrUtil2 = util$6;
  var Model2 = requireModel();
  var DataDiffer = requireDataDiffer();
  var Source2 = requireSource();
  var _dataProvider2 = dataProvider;
  var defaultDimValueGetters2 = _dataProvider2.defaultDimValueGetters;
  var DefaultDataProvider2 = _dataProvider2.DefaultDataProvider;
  var _dimensionHelper = requireDimensionHelper();
  var summarizeDimensions = _dimensionHelper.summarizeDimensions;
  var DataDimensionInfo = requireDataDimensionInfo();
  var isObject2 = zrUtil2.isObject;
  var UNDEFINED = "undefined";
  var INDEX_NOT_FOUND = -1;
  var ID_PREFIX = "e\0\0";
  var dataCtors = {
    "float": typeof Float64Array === UNDEFINED ? Array : Float64Array,
    "int": typeof Int32Array === UNDEFINED ? Array : Int32Array,
    // Ordinal data type can be string or int
    "ordinal": Array,
    "number": Array,
    "time": Array
  };
  var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
  var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
  var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
  function getIndicesCtor(list) {
    return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
  }
  function cloneChunk(originalChunk) {
    var Ctor = originalChunk.constructor;
    return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
  }
  var TRANSFERABLE_PROPERTIES = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"];
  var CLONE_PROPERTIES = ["_extent", "_approximateExtent", "_rawExtent"];
  function transferProperties(target, source) {
    zrUtil2.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
      if (source.hasOwnProperty(propName)) {
        target[propName] = source[propName];
      }
    });
    target.__wrappedMethods = source.__wrappedMethods;
    zrUtil2.each(CLONE_PROPERTIES, function(propName) {
      target[propName] = zrUtil2.clone(source[propName]);
    });
    target._calculationInfo = zrUtil2.extend(source._calculationInfo);
  }
  var List = function(dimensions, hostModel) {
    dimensions = dimensions || ["x", "y"];
    var dimensionInfos = {};
    var dimensionNames = [];
    var invertedIndicesMap = {};
    for (var i = 0; i < dimensions.length; i++) {
      var dimensionInfo = dimensions[i];
      if (zrUtil2.isString(dimensionInfo)) {
        dimensionInfo = new DataDimensionInfo({
          name: dimensionInfo
        });
      } else if (!(dimensionInfo instanceof DataDimensionInfo)) {
        dimensionInfo = new DataDimensionInfo(dimensionInfo);
      }
      var dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      dimensionInfo.index = i;
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
    }
    this.dimensions = dimensionNames;
    this._dimensionInfos = dimensionInfos;
    this.hostModel = hostModel;
    this.dataType;
    this._indices = null;
    this._count = 0;
    this._rawCount = 0;
    this._storage = {};
    this._nameList = [];
    this._idList = [];
    this._optionModels = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this.hasItemVisual = {};
    this._itemLayouts = [];
    this._graphicEls = [];
    this._chunkSize = 1e5;
    this._chunkCount = 0;
    this._rawData;
    this._rawExtent = {};
    this._extent = {};
    this._approximateExtent = {};
    this._dimensionsSummary = summarizeDimensions(this);
    this._invertedIndicesMap = invertedIndicesMap;
    this._calculationInfo = {};
    this.userOutput = this._dimensionsSummary.userOutput;
  };
  var listProto = List.prototype;
  listProto.type = "list";
  listProto.hasItemOption = true;
  listProto.getDimension = function(dim) {
    if (typeof dim === "number" || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {
      dim = this.dimensions[dim];
    }
    return dim;
  };
  listProto.getDimensionInfo = function(dim) {
    return this._dimensionInfos[this.getDimension(dim)];
  };
  listProto.getDimensionsOnCoord = function() {
    return this._dimensionsSummary.dataDimsOnCoord.slice();
  };
  listProto.mapDimension = function(coordDim, idx) {
    var dimensionsSummary = this._dimensionsSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    var dims = dimensionsSummary.encode[coordDim];
    return idx === true ? (dims || []).slice() : dims && dims[idx];
  };
  listProto.initData = function(data, nameList, dimValueGetter) {
    var notProvider = Source2.isInstance(data) || zrUtil2.isArrayLike(data);
    if (notProvider) {
      data = new DefaultDataProvider2(data, this.dimensions.length);
    }
    this._rawData = data;
    this._storage = {};
    this._indices = null;
    this._nameList = nameList || [];
    this._idList = [];
    this._nameRepeatCount = {};
    if (!dimValueGetter) {
      this.hasItemOption = false;
    }
    this.defaultDimValueGetter = defaultDimValueGetters2[this._rawData.getSource().sourceFormat];
    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;
    this._dimValueGetterArrayRows = defaultDimValueGetters2.arrayRows;
    this._rawExtent = {};
    this._initDataFromProvider(0, data.count());
    if (data.pure) {
      this.hasItemOption = false;
    }
  };
  listProto.getProvider = function() {
    return this._rawData;
  };
  listProto.appendData = function(data) {
    var rawData = this._rawData;
    var start = this.count();
    rawData.appendData(data);
    var end = rawData.count();
    if (!rawData.persistent) {
      end += start;
    }
    this._initDataFromProvider(start, end);
  };
  listProto.appendValues = function(values, names) {
    var chunkSize = this._chunkSize;
    var storage2 = this._storage;
    var dimensions = this.dimensions;
    var dimLen = dimensions.length;
    var rawExtent = this._rawExtent;
    var start = this.count();
    var end = start + Math.max(values.length, names ? names.length : 0);
    var originalChunkCount = this._chunkCount;
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      if (!rawExtent[dim]) {
        rawExtent[dim] = getInitialExtent();
      }
      if (!storage2[dim]) {
        storage2[dim] = [];
      }
      prepareChunks(storage2, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);
      this._chunkCount = storage2[dim].length;
    }
    var emptyDataItem = new Array(dimLen);
    for (var idx = start; idx < end; idx++) {
      var sourceIdx = idx - start;
      var chunkIndex = Math.floor(idx / chunkSize);
      var chunkOffset = idx % chunkSize;
      for (var k = 0; k < dimLen; k++) {
        var dim = dimensions[k];
        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);
        storage2[dim][chunkIndex][chunkOffset] = val;
        var dimRawExtent = rawExtent[dim];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
      if (names) {
        this._nameList[idx] = names[sourceIdx];
      }
    }
    this._rawCount = this._count = end;
    this._extent = {};
    prepareInvertedIndex(this);
  };
  listProto._initDataFromProvider = function(start, end) {
    if (start >= end) {
      return;
    }
    var chunkSize = this._chunkSize;
    var rawData = this._rawData;
    var storage2 = this._storage;
    var dimensions = this.dimensions;
    var dimLen = dimensions.length;
    var dimensionInfoMap = this._dimensionInfos;
    var nameList = this._nameList;
    var idList = this._idList;
    var rawExtent = this._rawExtent;
    var nameRepeatCount = this._nameRepeatCount = {};
    var nameDimIdx;
    var originalChunkCount = this._chunkCount;
    for (var i = 0; i < dimLen; i++) {
      var dim = dimensions[i];
      if (!rawExtent[dim]) {
        rawExtent[dim] = getInitialExtent();
      }
      var dimInfo = dimensionInfoMap[dim];
      if (dimInfo.otherDims.itemName === 0) {
        nameDimIdx = this._nameDimIdx = i;
      }
      if (dimInfo.otherDims.itemId === 0) {
        this._idDimIdx = i;
      }
      if (!storage2[dim]) {
        storage2[dim] = [];
      }
      prepareChunks(storage2, dimInfo, chunkSize, originalChunkCount, end);
      this._chunkCount = storage2[dim].length;
    }
    var dataItem = new Array(dimLen);
    for (var idx = start; idx < end; idx++) {
      dataItem = rawData.getItem(idx, dataItem);
      var chunkIndex = Math.floor(idx / chunkSize);
      var chunkOffset = idx % chunkSize;
      for (var k = 0; k < dimLen; k++) {
        var dim = dimensions[k];
        var dimStorage = storage2[dim][chunkIndex];
        var val = this._dimValueGetter(dataItem, dim, idx, k);
        dimStorage[chunkOffset] = val;
        var dimRawExtent = rawExtent[dim];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
      if (!rawData.pure) {
        var name2 = nameList[idx];
        if (dataItem && name2 == null) {
          if (dataItem.name != null) {
            nameList[idx] = name2 = dataItem.name;
          } else if (nameDimIdx != null) {
            var nameDim = dimensions[nameDimIdx];
            var nameDimChunk = storage2[nameDim][chunkIndex];
            if (nameDimChunk) {
              name2 = nameDimChunk[chunkOffset];
              var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;
              if (ordinalMeta && ordinalMeta.categories.length) {
                name2 = ordinalMeta.categories[name2];
              }
            }
          }
        }
        var id = dataItem == null ? null : dataItem.id;
        if (id == null && name2 != null) {
          nameRepeatCount[name2] = nameRepeatCount[name2] || 0;
          id = name2;
          if (nameRepeatCount[name2] > 0) {
            id += "__ec__" + nameRepeatCount[name2];
          }
          nameRepeatCount[name2]++;
        }
        id != null && (idList[idx] = id);
      }
    }
    if (!rawData.persistent && rawData.clean) {
      rawData.clean();
    }
    this._rawCount = this._count = end;
    this._extent = {};
    prepareInvertedIndex(this);
  };
  function prepareChunks(storage2, dimInfo, chunkSize, chunkCount, end) {
    var DataCtor = dataCtors[dimInfo.type];
    var lastChunkIndex = chunkCount - 1;
    var dim = dimInfo.name;
    var resizeChunkArray = storage2[dim][lastChunkIndex];
    if (resizeChunkArray && resizeChunkArray.length < chunkSize) {
      var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize));
      for (var j = 0; j < resizeChunkArray.length; j++) {
        newStore[j] = resizeChunkArray[j];
      }
      storage2[dim][lastChunkIndex] = newStore;
    }
    for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {
      storage2[dim].push(new DataCtor(Math.min(end - k, chunkSize)));
    }
  }
  function prepareInvertedIndex(list) {
    var invertedIndicesMap = list._invertedIndicesMap;
    zrUtil2.each(invertedIndicesMap, function(invertedIndices, dim) {
      var dimInfo = list._dimensionInfos[dim];
      var ordinalMeta = dimInfo.ordinalMeta;
      if (ordinalMeta) {
        invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
        for (var i = 0; i < invertedIndices.length; i++) {
          invertedIndices[i] = INDEX_NOT_FOUND;
        }
        for (var i = 0; i < list._count; i++) {
          invertedIndices[list.get(dim, i)] = i;
        }
      }
    });
  }
  function getRawValueFromStore(list, dimIndex, rawIndex) {
    var val;
    if (dimIndex != null) {
      var chunkSize = list._chunkSize;
      var chunkIndex = Math.floor(rawIndex / chunkSize);
      var chunkOffset = rawIndex % chunkSize;
      var dim = list.dimensions[dimIndex];
      var chunk = list._storage[dim][chunkIndex];
      if (chunk) {
        val = chunk[chunkOffset];
        var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;
        if (ordinalMeta && ordinalMeta.categories.length) {
          val = ordinalMeta.categories[val];
        }
      }
    }
    return val;
  }
  listProto.count = function() {
    return this._count;
  };
  listProto.getIndices = function() {
    var newIndices;
    var indices = this._indices;
    if (indices) {
      var Ctor = indices.constructor;
      var thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (var i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      var Ctor = getIndicesCtor(this);
      var newIndices = new Ctor(this.count());
      for (var i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }
    return newIndices;
  };
  listProto.get = function(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    var storage2 = this._storage;
    if (!storage2[dim]) {
      return NaN;
    }
    idx = this.getRawIndex(idx);
    var chunkIndex = Math.floor(idx / this._chunkSize);
    var chunkOffset = idx % this._chunkSize;
    var chunkStore = storage2[dim][chunkIndex];
    var value = chunkStore[chunkOffset];
    return value;
  };
  listProto.getByRawIndex = function(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    var dimStore = this._storage[dim];
    if (!dimStore) {
      return NaN;
    }
    var chunkIndex = Math.floor(rawIdx / this._chunkSize);
    var chunkOffset = rawIdx % this._chunkSize;
    var chunkStore = dimStore[chunkIndex];
    return chunkStore[chunkOffset];
  };
  listProto._getFast = function(dim, rawIdx) {
    var chunkIndex = Math.floor(rawIdx / this._chunkSize);
    var chunkOffset = rawIdx % this._chunkSize;
    var chunkStore = this._storage[dim][chunkIndex];
    return chunkStore[chunkOffset];
  };
  listProto.getValues = function(dimensions, idx) {
    var values = [];
    if (!zrUtil2.isArray(dimensions)) {
      idx = dimensions;
      dimensions = this.dimensions;
    }
    for (var i = 0, len = dimensions.length; i < len; i++) {
      values.push(this.get(
        dimensions[i],
        idx
        /*, stack */
      ));
    }
    return values;
  };
  listProto.hasValue = function(idx) {
    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;
    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {
      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {
        return false;
      }
    }
    return true;
  };
  listProto.getDataExtent = function(dim) {
    dim = this.getDimension(dim);
    var dimData = this._storage[dim];
    var initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    var currEnd = this.count();
    var useRaw = !this._indices;
    var dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    var min3 = dimExtent[0];
    var max3 = dimExtent[1];
    for (var i = 0; i < currEnd; i++) {
      var value = this._getFast(dim, this.getRawIndex(i));
      value < min3 && (min3 = value);
      value > max3 && (max3 = value);
    }
    dimExtent = [min3, max3];
    this._extent[dim] = dimExtent;
    return dimExtent;
  };
  listProto.getApproximateExtent = function(dim) {
    dim = this.getDimension(dim);
    return this._approximateExtent[dim] || this.getDataExtent(
      dim
      /*, stack */
    );
  };
  listProto.setApproximateExtent = function(extent, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent.slice();
  };
  listProto.getCalculationInfo = function(key) {
    return this._calculationInfo[key];
  };
  listProto.setCalculationInfo = function(key, value) {
    isObject2(key) ? zrUtil2.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
  };
  listProto.getSum = function(dim) {
    var dimData = this._storage[dim];
    var sum = 0;
    if (dimData) {
      for (var i = 0, len = this.count(); i < len; i++) {
        var value = this.get(
          dim,
          i
          /*, stack */
        );
        if (!isNaN(value)) {
          sum += value;
        }
      }
    }
    return sum;
  };
  listProto.getMedian = function(dim) {
    var dimDataArray = [];
    this.each(dim, function(val, idx) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    });
    var sortedDimDataArray = [].concat(dimDataArray).sort(function(a, b) {
      return a - b;
    });
    var len = this.count();
    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
  };
  listProto.rawIndexOf = function(dim, value) {
    var invertedIndices = dim && this._invertedIndicesMap[dim];
    var rawIndex = invertedIndices[value];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  };
  listProto.indexOfName = function(name2) {
    for (var i = 0, len = this.count(); i < len; i++) {
      if (this.getName(i) === name2) {
        return i;
      }
    }
    return -1;
  };
  listProto.indexOfRawIndex = function(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    var indices = this._indices;
    var rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    var left = 0;
    var right = this._count - 1;
    while (left <= right) {
      var mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  };
  listProto.indicesOfNearest = function(dim, value, maxDistance) {
    var storage2 = this._storage;
    var dimData = storage2[dim];
    var nearestIndices = [];
    if (!dimData) {
      return nearestIndices;
    }
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    var minDist = Infinity;
    var minDiff = -1;
    var nearestIndicesLen = 0;
    for (var i = 0, len = this.count(); i < len; i++) {
      var diff2 = value - this.get(dim, i);
      var dist2 = Math.abs(diff2);
      if (dist2 <= maxDistance) {
        if (dist2 < minDist || dist2 === minDist && diff2 >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff2;
          nearestIndicesLen = 0;
        }
        if (diff2 === minDiff) {
          nearestIndices[nearestIndicesLen++] = i;
        }
      }
    }
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  };
  listProto.getRawIndex = getRawIndexWithoutIndices;
  function getRawIndexWithoutIndices(idx) {
    return idx;
  }
  function getRawIndexWithIndices(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  }
  listProto.getRawDataItem = function(idx) {
    if (!this._rawData.persistent) {
      var val = [];
      for (var i = 0; i < this.dimensions.length; i++) {
        var dim = this.dimensions[i];
        val.push(this.get(dim, idx));
      }
      return val;
    } else {
      return this._rawData.getItem(this.getRawIndex(idx));
    }
  };
  listProto.getName = function(idx) {
    var rawIndex = this.getRawIndex(idx);
    return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || "";
  };
  listProto.getId = function(idx) {
    return getId2(this, this.getRawIndex(idx));
  };
  function getId2(list, rawIndex) {
    var id = list._idList[rawIndex];
    if (id == null) {
      id = getRawValueFromStore(list, list._idDimIdx, rawIndex);
    }
    if (id == null) {
      id = ID_PREFIX + rawIndex;
    }
    return id;
  }
  function normalizeDimensions(dimensions) {
    if (!zrUtil2.isArray(dimensions)) {
      dimensions = [dimensions];
    }
    return dimensions;
  }
  listProto.each = function(dims, cb, context, contextCompat) {
    if (!this._count) {
      return;
    }
    if (typeof dims === "function") {
      contextCompat = context;
      context = cb;
      cb = dims;
      dims = [];
    }
    context = context || contextCompat || this;
    dims = zrUtil2.map(normalizeDimensions(dims), this.getDimension, this);
    var dimSize = dims.length;
    for (var i = 0; i < this.count(); i++) {
      switch (dimSize) {
        case 0:
          cb.call(context, i);
          break;
        case 1:
          cb.call(context, this.get(dims[0], i), i);
          break;
        case 2:
          cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);
          break;
        default:
          var k = 0;
          var value = [];
          for (; k < dimSize; k++) {
            value[k] = this.get(dims[k], i);
          }
          value[k] = i;
          cb.apply(context, value);
      }
    }
  };
  listProto.filterSelf = function(dimensions, cb, context, contextCompat) {
    if (!this._count) {
      return;
    }
    if (typeof dimensions === "function") {
      contextCompat = context;
      context = cb;
      cb = dimensions;
      dimensions = [];
    }
    context = context || contextCompat || this;
    dimensions = zrUtil2.map(normalizeDimensions(dimensions), this.getDimension, this);
    var count = this.count();
    var Ctor = getIndicesCtor(this);
    var newIndices = new Ctor(count);
    var value = [];
    var dimSize = dimensions.length;
    var offset = 0;
    var dim0 = dimensions[0];
    for (var i = 0; i < count; i++) {
      var keep;
      var rawIdx = this.getRawIndex(i);
      if (dimSize === 0) {
        keep = cb.call(context, i);
      } else if (dimSize === 1) {
        var val = this._getFast(dim0, rawIdx);
        keep = cb.call(context, val, i);
      } else {
        for (var k = 0; k < dimSize; k++) {
          value[k] = this._getFast(dim0, rawIdx);
        }
        value[k] = i;
        keep = cb.apply(context, value);
      }
      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    }
    if (offset < count) {
      this._indices = newIndices;
    }
    this._count = offset;
    this._extent = {};
    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    return this;
  };
  listProto.selectRange = function(range) {
    if (!this._count) {
      return;
    }
    var dimensions = [];
    for (var dim in range) {
      if (range.hasOwnProperty(dim)) {
        dimensions.push(dim);
      }
    }
    var dimSize = dimensions.length;
    if (!dimSize) {
      return;
    }
    var originalCount = this.count();
    var Ctor = getIndicesCtor(this);
    var newIndices = new Ctor(originalCount);
    var offset = 0;
    var dim0 = dimensions[0];
    var min3 = range[dim0][0];
    var max3 = range[dim0][1];
    var quickFinished = false;
    if (!this._indices) {
      var idx = 0;
      if (dimSize === 1) {
        var dimStorage = this._storage[dimensions[0]];
        for (var k = 0; k < this._chunkCount; k++) {
          var chunkStorage = dimStorage[k];
          var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);
          for (var i = 0; i < len; i++) {
            var val = chunkStorage[i];
            if (val >= min3 && val <= max3 || isNaN(val)) {
              newIndices[offset++] = idx;
            }
            idx++;
          }
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        var dimStorage = this._storage[dim0];
        var dimStorage2 = this._storage[dimensions[1]];
        var min22 = range[dimensions[1]][0];
        var max22 = range[dimensions[1]][1];
        for (var k = 0; k < this._chunkCount; k++) {
          var chunkStorage = dimStorage[k];
          var chunkStorage2 = dimStorage2[k];
          var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);
          for (var i = 0; i < len; i++) {
            var val = chunkStorage[i];
            var val2 = chunkStorage2[i];
            if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min22 && val2 <= max22 || isNaN(val2))) {
              newIndices[offset++] = idx;
            }
            idx++;
          }
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (var i = 0; i < originalCount; i++) {
          var rawIndex = this.getRawIndex(i);
          var val = this._getFast(dim0, rawIndex);
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (var i = 0; i < originalCount; i++) {
          var keep = true;
          var rawIndex = this.getRawIndex(i);
          for (var k = 0; k < dimSize; k++) {
            var dimk = dimensions[k];
            var val = this._getFast(dim, rawIndex);
            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset++] = this.getRawIndex(i);
          }
        }
      }
    }
    if (offset < originalCount) {
      this._indices = newIndices;
    }
    this._count = offset;
    this._extent = {};
    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    return this;
  };
  listProto.mapArray = function(dimensions, cb, context, contextCompat) {
    if (typeof dimensions === "function") {
      contextCompat = context;
      context = cb;
      cb = dimensions;
      dimensions = [];
    }
    context = context || contextCompat || this;
    var result = [];
    this.each(dimensions, function() {
      result.push(cb && cb.apply(this, arguments));
    }, context);
    return result;
  };
  function cloneListForMapAndSample(original, excludeDimensions) {
    var allDimensions = original.dimensions;
    var list = new List(zrUtil2.map(allDimensions, original.getDimensionInfo, original), original.hostModel);
    transferProperties(list, original);
    var storage2 = list._storage = {};
    var originalStorage = original._storage;
    for (var i = 0; i < allDimensions.length; i++) {
      var dim = allDimensions[i];
      if (originalStorage[dim]) {
        if (zrUtil2.indexOf(excludeDimensions, dim) >= 0) {
          storage2[dim] = cloneDimStore(originalStorage[dim]);
          list._rawExtent[dim] = getInitialExtent();
          list._extent[dim] = null;
        } else {
          storage2[dim] = originalStorage[dim];
        }
      }
    }
    return list;
  }
  function cloneDimStore(originalDimStore) {
    var newDimStore = new Array(originalDimStore.length);
    for (var j = 0; j < originalDimStore.length; j++) {
      newDimStore[j] = cloneChunk(originalDimStore[j]);
    }
    return newDimStore;
  }
  function getInitialExtent() {
    return [Infinity, -Infinity];
  }
  listProto.map = function(dimensions, cb, context, contextCompat) {
    context = context || contextCompat || this;
    dimensions = zrUtil2.map(normalizeDimensions(dimensions), this.getDimension, this);
    var list = cloneListForMapAndSample(this, dimensions);
    list._indices = this._indices;
    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    var storage2 = list._storage;
    var tmpRetValue = [];
    var chunkSize = this._chunkSize;
    var dimSize = dimensions.length;
    var dataCount = this.count();
    var values = [];
    var rawExtent = list._rawExtent;
    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {
        values[dimIndex] = this.get(
          dimensions[dimIndex],
          dataIndex
          /*, stack */
        );
      }
      values[dimSize] = dataIndex;
      var retValue = cb && cb.apply(context, values);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        var rawIndex = this.getRawIndex(dataIndex);
        var chunkIndex = Math.floor(rawIndex / chunkSize);
        var chunkOffset = rawIndex % chunkSize;
        for (var i = 0; i < retValue.length; i++) {
          var dim = dimensions[i];
          var val = retValue[i];
          var rawExtentOnDim = rawExtent[dim];
          var dimStore = storage2[dim];
          if (dimStore) {
            dimStore[chunkIndex][chunkOffset] = val;
          }
          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }
          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
    return list;
  };
  listProto.downSample = function(dimension, rate, sampleValue, sampleIndex) {
    var list = cloneListForMapAndSample(this, [dimension]);
    var targetStorage = list._storage;
    var frameValues = [];
    var frameSize = Math.floor(1 / rate);
    var dimStore = targetStorage[dimension];
    var len = this.count();
    var chunkSize = this._chunkSize;
    var rawExtentOnDim = list._rawExtent[dimension];
    var newIndices = new (getIndicesCtor(this))(len);
    var offset = 0;
    for (var i = 0; i < len; i += frameSize) {
      if (frameSize > len - i) {
        frameSize = len - i;
        frameValues.length = frameSize;
      }
      for (var k = 0; k < frameSize; k++) {
        var dataIdx = this.getRawIndex(i + k);
        var originalChunkIndex = Math.floor(dataIdx / chunkSize);
        var originalChunkOffset = dataIdx % chunkSize;
        frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];
      }
      var value = sampleValue(frameValues);
      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
      var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);
      var sampleChunkOffset = sampleFrameIdx % chunkSize;
      dimStore[sampleChunkIndex][sampleChunkOffset] = value;
      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }
      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }
      newIndices[offset++] = sampleFrameIdx;
    }
    list._count = offset;
    list._indices = newIndices;
    list.getRawIndex = getRawIndexWithIndices;
    return list;
  };
  listProto.getItemModel = function(idx) {
    var hostModel = this.hostModel;
    return new Model2(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);
  };
  listProto.diff = function(otherList) {
    var thisList = this;
    return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function(idx) {
      return getId2(otherList, idx);
    }, function(idx) {
      return getId2(thisList, idx);
    });
  };
  listProto.getVisual = function(key) {
    var visual = this._visual;
    return visual && visual[key];
  };
  listProto.setVisual = function(key, val) {
    if (isObject2(key)) {
      for (var name2 in key) {
        if (key.hasOwnProperty(name2)) {
          this.setVisual(name2, key[name2]);
        }
      }
      return;
    }
    this._visual = this._visual || {};
    this._visual[key] = val;
  };
  listProto.setLayout = function(key, val) {
    if (isObject2(key)) {
      for (var name2 in key) {
        if (key.hasOwnProperty(name2)) {
          this.setLayout(name2, key[name2]);
        }
      }
      return;
    }
    this._layout[key] = val;
  };
  listProto.getLayout = function(key) {
    return this._layout[key];
  };
  listProto.getItemLayout = function(idx) {
    return this._itemLayouts[idx];
  };
  listProto.setItemLayout = function(idx, layout2, merge2) {
    this._itemLayouts[idx] = merge2 ? zrUtil2.extend(this._itemLayouts[idx] || {}, layout2) : layout2;
  };
  listProto.clearItemLayouts = function() {
    this._itemLayouts.length = 0;
  };
  listProto.getItemVisual = function(idx, key, ignoreParent) {
    var itemVisual = this._itemVisuals[idx];
    var val = itemVisual && itemVisual[key];
    if (val == null && !ignoreParent) {
      return this.getVisual(key);
    }
    return val;
  };
  listProto.setItemVisual = function(idx, key, value) {
    var itemVisual = this._itemVisuals[idx] || {};
    var hasItemVisual = this.hasItemVisual;
    this._itemVisuals[idx] = itemVisual;
    if (isObject2(key)) {
      for (var name2 in key) {
        if (key.hasOwnProperty(name2)) {
          itemVisual[name2] = key[name2];
          hasItemVisual[name2] = true;
        }
      }
      return;
    }
    itemVisual[key] = value;
    hasItemVisual[key] = true;
  };
  listProto.clearAllVisual = function() {
    this._visual = {};
    this._itemVisuals = [];
    this.hasItemVisual = {};
  };
  var setItemDataAndSeriesIndex = function(child) {
    child.seriesIndex = this.seriesIndex;
    child.dataIndex = this.dataIndex;
    child.dataType = this.dataType;
  };
  listProto.setItemGraphicEl = function(idx, el) {
    var hostModel = this.hostModel;
    if (el) {
      el.dataIndex = idx;
      el.dataType = this.dataType;
      el.seriesIndex = hostModel && hostModel.seriesIndex;
      if (el.type === "group") {
        el.traverse(setItemDataAndSeriesIndex, el);
      }
    }
    this._graphicEls[idx] = el;
  };
  listProto.getItemGraphicEl = function(idx) {
    return this._graphicEls[idx];
  };
  listProto.eachItemGraphicEl = function(cb, context) {
    zrUtil2.each(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  };
  listProto.cloneShallow = function(list) {
    if (!list) {
      var dimensionInfoList = zrUtil2.map(this.dimensions, this.getDimensionInfo, this);
      list = new List(dimensionInfoList, this.hostModel);
    }
    list._storage = this._storage;
    transferProperties(list, this);
    if (this._indices) {
      var Ctor = this._indices.constructor;
      list._indices = new Ctor(this._indices);
    } else {
      list._indices = null;
    }
    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
    return list;
  };
  listProto.wrapMethod = function(methodName, injectFunction) {
    var originalMethod = this[methodName];
    if (typeof originalMethod !== "function") {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      var res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(zrUtil2.slice(arguments)));
    };
  };
  listProto.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"];
  listProto.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
  var _default2 = List;
  List_1 = _default2;
  return List_1;
}
var completeDimensions_1;
var hasRequiredCompleteDimensions;
function requireCompleteDimensions() {
  if (hasRequiredCompleteDimensions)
    return completeDimensions_1;
  hasRequiredCompleteDimensions = 1;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  var each2 = _util2.each;
  var isString2 = _util2.isString;
  var defaults2 = _util2.defaults;
  var extend2 = _util2.extend;
  var isObject2 = _util2.isObject;
  var clone2 = _util2.clone;
  var _model2 = model;
  var normalizeToArray2 = _model2.normalizeToArray;
  var _sourceHelper2 = requireSourceHelper();
  var guessOrdinal = _sourceHelper2.guessOrdinal;
  var BE_ORDINAL = _sourceHelper2.BE_ORDINAL;
  var Source2 = requireSource();
  var _dimensionHelper = requireDimensionHelper();
  var OTHER_DIMENSIONS = _dimensionHelper.OTHER_DIMENSIONS;
  var DataDimensionInfo = requireDataDimensionInfo();
  function completeDimensions(sysDims, source, opt) {
    if (!Source2.isInstance(source)) {
      source = Source2.seriesDataToSource(source);
    }
    opt = opt || {};
    sysDims = (sysDims || []).slice();
    var dimsDef = (opt.dimsDef || []).slice();
    var dataDimNameMap = createHashMap2();
    var coordDimNameMap = createHashMap2();
    var result = [];
    var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount);
    for (var i = 0; i < dimCount; i++) {
      var dimDefItem = dimsDef[i] = extend2({}, isObject2(dimsDef[i]) ? dimsDef[i] : {
        name: dimsDef[i]
      });
      var userDimName = dimDefItem.name;
      var resultItem = result[i] = new DataDimensionInfo();
      if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
        resultItem.name = resultItem.displayName = userDimName;
        dataDimNameMap.set(userDimName, i);
      }
      dimDefItem.type != null && (resultItem.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
    }
    var encodeDef = opt.encodeDef;
    if (!encodeDef && opt.encodeDefaulter) {
      encodeDef = opt.encodeDefaulter(source, dimCount);
    }
    encodeDef = createHashMap2(encodeDef);
    encodeDef.each(function(dataDims, coordDim2) {
      dataDims = normalizeToArray2(dataDims).slice();
      if (dataDims.length === 1 && !isString2(dataDims[0]) && dataDims[0] < 0) {
        encodeDef.set(coordDim2, false);
        return;
      }
      var validDataDims = encodeDef.set(coordDim2, []);
      each2(dataDims, function(resultDimIdx2, idx) {
        isString2(resultDimIdx2) && (resultDimIdx2 = dataDimNameMap.get(resultDimIdx2));
        if (resultDimIdx2 != null && resultDimIdx2 < dimCount) {
          validDataDims[idx] = resultDimIdx2;
          applyDim(result[resultDimIdx2], coordDim2, idx);
        }
      });
    });
    var availDimIdx = 0;
    each2(sysDims, function(sysDimItem, sysDimIndex) {
      var coordDim2;
      var sysDimItem;
      var sysDimItemDimsDef;
      var sysDimItemOtherDims;
      if (isString2(sysDimItem)) {
        coordDim2 = sysDimItem;
        sysDimItem = {};
      } else {
        coordDim2 = sysDimItem.name;
        var ordinalMeta = sysDimItem.ordinalMeta;
        sysDimItem.ordinalMeta = null;
        sysDimItem = clone2(sysDimItem);
        sysDimItem.ordinalMeta = ordinalMeta;
        sysDimItemDimsDef = sysDimItem.dimsDef;
        sysDimItemOtherDims = sysDimItem.otherDims;
        sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
      }
      var dataDims = encodeDef.get(coordDim2);
      if (dataDims === false) {
        return;
      }
      var dataDims = normalizeToArray2(dataDims);
      if (!dataDims.length) {
        for (var i2 = 0; i2 < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i2++) {
          while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
            availDimIdx++;
          }
          availDimIdx < result.length && dataDims.push(availDimIdx++);
        }
      }
      each2(dataDims, function(resultDimIdx2, coordDimIndex) {
        var resultItem2 = result[resultDimIdx2];
        applyDim(defaults2(resultItem2, sysDimItem), coordDim2, coordDimIndex);
        if (resultItem2.name == null && sysDimItemDimsDef) {
          var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
          !isObject2(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
            name: sysDimItemDimsDefItem
          });
          resultItem2.name = resultItem2.displayName = sysDimItemDimsDefItem.name;
          resultItem2.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
        }
        sysDimItemOtherDims && defaults2(resultItem2.otherDims, sysDimItemOtherDims);
      });
    });
    function applyDim(resultItem2, coordDim2, coordDimIndex) {
      if (OTHER_DIMENSIONS.get(coordDim2) != null) {
        resultItem2.otherDims[coordDim2] = coordDimIndex;
      } else {
        resultItem2.coordDim = coordDim2;
        resultItem2.coordDimIndex = coordDimIndex;
        coordDimNameMap.set(coordDim2, true);
      }
    }
    var generateCoord = opt.generateCoord;
    var generateCoordCount = opt.generateCoordCount;
    var fromZero = generateCoordCount != null;
    generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
    var extra = generateCoord || "value";
    for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo();
      var coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap));
      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx, resultItem.name) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
    return result;
  }
  function getDimCount(source, sysDims, dimsDef, optDimCount) {
    var dimCount = Math.max(source.dimensionsDetectCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
    each2(sysDims, function(sysDimItem) {
      var sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemDimsDef && (dimCount = Math.max(dimCount, sysDimItemDimsDef.length));
    });
    return dimCount;
  }
  function genName(name2, map2, fromZero) {
    if (fromZero || map2.get(name2) != null) {
      var i = 0;
      while (map2.get(name2 + i) != null) {
        i++;
      }
      name2 += i;
    }
    map2.set(name2, true);
    return name2;
  }
  var _default2 = completeDimensions;
  completeDimensions_1 = _default2;
  return completeDimensions_1;
}
var createDimensions;
var hasRequiredCreateDimensions;
function requireCreateDimensions() {
  if (hasRequiredCreateDimensions)
    return createDimensions;
  hasRequiredCreateDimensions = 1;
  var completeDimensions = requireCompleteDimensions();
  function _default2(source, opt) {
    opt = opt || {};
    return completeDimensions(opt.coordDimensions || [], source, {
      dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
      encodeDef: opt.encodeDefine || source.encodeDefine,
      dimCount: opt.dimensionsCount,
      encodeDefaulter: opt.encodeDefaulter,
      generateCoord: opt.generateCoord,
      generateCoordCount: opt.generateCoordCount
    });
  }
  createDimensions = _default2;
  return createDimensions;
}
var referHelper = {};
var hasRequiredReferHelper;
function requireReferHelper() {
  if (hasRequiredReferHelper)
    return referHelper;
  hasRequiredReferHelper = 1;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  _util2.retrieve;
  var each2 = _util2.each;
  function CoordSysInfo(coordSysName) {
    this.coordSysName = coordSysName;
    this.coordSysDims = [];
    this.axisMap = createHashMap2();
    this.categoryAxisMap = createHashMap2();
    this.firstCategoryDimIndex = null;
  }
  function getCoordSysInfoBySeries(seriesModel) {
    var coordSysName = seriesModel.get("coordinateSystem");
    var result = new CoordSysInfo(coordSysName);
    var fetch = fetchers[coordSysName];
    if (fetch) {
      fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
      return result;
    }
  }
  var fetchers = {
    cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
      var xAxisModel = seriesModel.getReferringComponents("xAxis")[0];
      var yAxisModel = seriesModel.getReferringComponents("yAxis")[0];
      result.coordSysDims = ["x", "y"];
      axisMap.set("x", xAxisModel);
      axisMap.set("y", yAxisModel);
      if (isCategory(xAxisModel)) {
        categoryAxisMap.set("x", xAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(yAxisModel)) {
        categoryAxisMap.set("y", yAxisModel);
        result.firstCategoryDimIndex == null & (result.firstCategoryDimIndex = 1);
      }
    },
    singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
      var singleAxisModel = seriesModel.getReferringComponents("singleAxis")[0];
      result.coordSysDims = ["single"];
      axisMap.set("single", singleAxisModel);
      if (isCategory(singleAxisModel)) {
        categoryAxisMap.set("single", singleAxisModel);
        result.firstCategoryDimIndex = 0;
      }
    },
    polar: function(seriesModel, result, axisMap, categoryAxisMap) {
      var polarModel = seriesModel.getReferringComponents("polar")[0];
      var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      var angleAxisModel = polarModel.findAxisModel("angleAxis");
      result.coordSysDims = ["radius", "angle"];
      axisMap.set("radius", radiusAxisModel);
      axisMap.set("angle", angleAxisModel);
      if (isCategory(radiusAxisModel)) {
        categoryAxisMap.set("radius", radiusAxisModel);
        result.firstCategoryDimIndex = 0;
      }
      if (isCategory(angleAxisModel)) {
        categoryAxisMap.set("angle", angleAxisModel);
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
      }
    },
    geo: function(seriesModel, result, axisMap, categoryAxisMap) {
      result.coordSysDims = ["lng", "lat"];
    },
    parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
      var ecModel = seriesModel.ecModel;
      var parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
      var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
      each2(parallelModel.parallelAxisIndex, function(axisIndex, index2) {
        var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
        var axisDim = coordSysDims[index2];
        axisMap.set(axisDim, axisModel);
        if (isCategory(axisModel) && result.firstCategoryDimIndex == null) {
          categoryAxisMap.set(axisDim, axisModel);
          result.firstCategoryDimIndex = index2;
        }
      });
    }
  };
  function isCategory(axisModel) {
    return axisModel.get("type") === "category";
  }
  referHelper.getCoordSysInfoBySeries = getCoordSysInfoBySeries;
  return referHelper;
}
var dataStackHelper = {};
var hasRequiredDataStackHelper;
function requireDataStackHelper() {
  if (hasRequiredDataStackHelper)
    return dataStackHelper;
  hasRequiredDataStackHelper = 1;
  var _util2 = util$6;
  var each2 = _util2.each;
  var isString2 = _util2.isString;
  function enableDataStack(seriesModel, dimensionInfoList, opt) {
    opt = opt || {};
    var byIndex = opt.byIndex;
    var stackedCoordDimension = opt.stackedCoordDimension;
    var mayStack = !!(seriesModel && seriesModel.get("stack"));
    var stackedByDimInfo;
    var stackedDimInfo;
    var stackResultDimension;
    var stackedOverDimension;
    each2(dimensionInfoList, function(dimensionInfo, index2) {
      if (isString2(dimensionInfo)) {
        dimensionInfoList[index2] = dimensionInfo = {
          name: dimensionInfo
        };
      }
      if (mayStack && !dimensionInfo.isExtraCoord) {
        if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
          stackedByDimInfo = dimensionInfo;
        }
        if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
          stackedDimInfo = dimensionInfo;
        }
      }
    });
    if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
      byIndex = true;
    }
    if (stackedDimInfo) {
      stackResultDimension = "__\0ecstackresult";
      stackedOverDimension = "__\0ecstackedover";
      if (stackedByDimInfo) {
        stackedByDimInfo.createInvertedIndices = true;
      }
      var stackedDimCoordDim = stackedDimInfo.coordDim;
      var stackedDimType = stackedDimInfo.type;
      var stackedDimCoordIndex = 0;
      each2(dimensionInfoList, function(dimensionInfo) {
        if (dimensionInfo.coordDim === stackedDimCoordDim) {
          stackedDimCoordIndex++;
        }
      });
      dimensionInfoList.push({
        name: stackResultDimension,
        coordDim: stackedDimCoordDim,
        coordDimIndex: stackedDimCoordIndex,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true
      });
      stackedDimCoordIndex++;
      dimensionInfoList.push({
        name: stackedOverDimension,
        // This dimension contains stack base (generally, 0), so do not set it as
        // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
        coordDim: stackedOverDimension,
        coordDimIndex: stackedDimCoordIndex,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true
      });
    }
    return {
      stackedDimension: stackedDimInfo && stackedDimInfo.name,
      stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
      isStackedByIndex: byIndex,
      stackedOverDimension,
      stackResultDimension
    };
  }
  function isDimensionStacked(data, stackedDim) {
    return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
  }
  function getStackedDimension(data, targetDim) {
    return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
  }
  dataStackHelper.enableDataStack = enableDataStack;
  dataStackHelper.isDimensionStacked = isDimensionStacked;
  dataStackHelper.getStackedDimension = getStackedDimension;
  return dataStackHelper;
}
var createListFromArray_1;
var hasRequiredCreateListFromArray;
function requireCreateListFromArray() {
  if (hasRequiredCreateListFromArray)
    return createListFromArray_1;
  hasRequiredCreateListFromArray = 1;
  var zrUtil2 = util$6;
  var List = requireList();
  var createDimensions2 = requireCreateDimensions();
  var _sourceType2 = requireSourceType();
  var SOURCE_FORMAT_ORIGINAL2 = _sourceType2.SOURCE_FORMAT_ORIGINAL;
  var _dimensionHelper = requireDimensionHelper();
  var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
  var _model2 = model;
  var getDataItemValue2 = _model2.getDataItemValue;
  var CoordinateSystem$1 = CoordinateSystem;
  var _referHelper = requireReferHelper();
  var getCoordSysInfoBySeries = _referHelper.getCoordSysInfoBySeries;
  var Source2 = requireSource();
  var _dataStackHelper = requireDataStackHelper();
  var enableDataStack = _dataStackHelper.enableDataStack;
  var _sourceHelper2 = requireSourceHelper();
  var makeSeriesEncodeForAxisCoordSys = _sourceHelper2.makeSeriesEncodeForAxisCoordSys;
  function createListFromArray(source, seriesModel, opt) {
    opt = opt || {};
    if (!Source2.isInstance(source)) {
      source = Source2.seriesDataToSource(source);
    }
    var coordSysName = seriesModel.get("coordinateSystem");
    var registeredCoordSys = CoordinateSystem$1.get(coordSysName);
    var coordSysInfo = getCoordSysInfoBySeries(seriesModel);
    var coordSysDimDefs;
    if (coordSysInfo) {
      coordSysDimDefs = zrUtil2.map(coordSysInfo.coordSysDims, function(dim) {
        var dimInfo = {
          name: dim
        };
        var axisModel = coordSysInfo.axisMap.get(dim);
        if (axisModel) {
          var axisType = axisModel.get("type");
          dimInfo.type = getDimensionTypeByAxis(axisType);
        }
        return dimInfo;
      });
    }
    if (!coordSysDimDefs) {
      coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
    }
    var dimInfoList = createDimensions2(source, {
      coordDimensions: coordSysDimDefs,
      generateCoord: opt.generateCoord,
      encodeDefaulter: opt.useEncodeDefaulter ? zrUtil2.curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null
    });
    var firstCategoryDimIndex;
    var hasNameEncode;
    coordSysInfo && zrUtil2.each(dimInfoList, function(dimInfo, dimIndex) {
      var coordDim = dimInfo.coordDim;
      var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
      if (categoryAxisModel) {
        if (firstCategoryDimIndex == null) {
          firstCategoryDimIndex = dimIndex;
        }
        dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      }
      if (dimInfo.otherDims.itemName != null) {
        hasNameEncode = true;
      }
    });
    if (!hasNameEncode && firstCategoryDimIndex != null) {
      dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
    }
    var stackCalculationInfo = enableDataStack(seriesModel, dimInfoList);
    var list = new List(dimInfoList, seriesModel);
    list.setCalculationInfo(stackCalculationInfo);
    var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
      return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
    } : null;
    list.hasItemOption = false;
    list.initData(source, null, dimValueGetter);
    return list;
  }
  function isNeedCompleteOrdinalData(source) {
    if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL2) {
      var sampleItem = firstDataNotNull(source.data || []);
      return sampleItem != null && !zrUtil2.isArray(getDataItemValue2(sampleItem));
    }
  }
  function firstDataNotNull(data) {
    var i = 0;
    while (i < data.length && data[i] == null) {
      i++;
    }
    return data[i];
  }
  var _default2 = createListFromArray;
  createListFromArray_1 = _default2;
  return createListFromArray_1;
}
var axisHelper = {};
var Scale_1;
var hasRequiredScale;
function requireScale() {
  if (hasRequiredScale)
    return Scale_1;
  hasRequiredScale = 1;
  var clazzUtil2 = clazz;
  function Scale(setting) {
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
    this._interval = 0;
    this.init && this.init.apply(this, arguments);
  }
  Scale.prototype.parse = function(val) {
    return val;
  };
  Scale.prototype.getSetting = function(name2) {
    return this._setting[name2];
  };
  Scale.prototype.contain = function(val) {
    var extent = this._extent;
    return val >= extent[0] && val <= extent[1];
  };
  Scale.prototype.normalize = function(val) {
    var extent = this._extent;
    if (extent[1] === extent[0]) {
      return 0.5;
    }
    return (val - extent[0]) / (extent[1] - extent[0]);
  };
  Scale.prototype.scale = function(val) {
    var extent = this._extent;
    return val * (extent[1] - extent[0]) + extent[0];
  };
  Scale.prototype.unionExtent = function(other) {
    var extent = this._extent;
    other[0] < extent[0] && (extent[0] = other[0]);
    other[1] > extent[1] && (extent[1] = other[1]);
  };
  Scale.prototype.unionExtentFromData = function(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  };
  Scale.prototype.getExtent = function() {
    return this._extent.slice();
  };
  Scale.prototype.setExtent = function(start, end) {
    var thisExtent = this._extent;
    if (!isNaN(start)) {
      thisExtent[0] = start;
    }
    if (!isNaN(end)) {
      thisExtent[1] = end;
    }
  };
  Scale.prototype.isBlank = function() {
    return this._isBlank;
  }, /**
   * When axis extent depends on data and no data exists,
   * axis ticks should not be drawn, which is named 'blank'.
   */
  Scale.prototype.setBlank = function(isBlank) {
    this._isBlank = isBlank;
  };
  Scale.prototype.getLabel = null;
  clazzUtil2.enableClassExtend(Scale);
  clazzUtil2.enableClassManagement(Scale, {
    registerWhenExtend: true
  });
  var _default2 = Scale;
  Scale_1 = _default2;
  return Scale_1;
}
var OrdinalMeta_1;
var hasRequiredOrdinalMeta;
function requireOrdinalMeta() {
  if (hasRequiredOrdinalMeta)
    return OrdinalMeta_1;
  hasRequiredOrdinalMeta = 1;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  var isObject2 = _util2.isObject;
  var map2 = _util2.map;
  function OrdinalMeta(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this._map;
  }
  OrdinalMeta.createByAxisModel = function(axisModel) {
    var option = axisModel.option;
    var data = option.data;
    var categories = data && map2(data, getName);
    return new OrdinalMeta({
      categories,
      needCollect: !categories,
      // deduplication is default in axis.
      deduplication: option.dedplication !== false
    });
  };
  var proto2 = OrdinalMeta.prototype;
  proto2.getOrdinal = function(category) {
    return getOrCreateMap(this).get(category);
  };
  proto2.parseAndCollect = function(category) {
    var index2;
    var needCollect = this._needCollect;
    if (typeof category !== "string" && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index2 = this.categories.length;
      this.categories[index2] = category;
      return index2;
    }
    var map3 = getOrCreateMap(this);
    index2 = map3.get(category);
    if (index2 == null) {
      if (needCollect) {
        index2 = this.categories.length;
        this.categories[index2] = category;
        map3.set(category, index2);
      } else {
        index2 = NaN;
      }
    }
    return index2;
  };
  function getOrCreateMap(ordinalMeta) {
    return ordinalMeta._map || (ordinalMeta._map = createHashMap2(ordinalMeta.categories));
  }
  function getName(obj) {
    if (isObject2(obj) && obj.value != null) {
      return obj.value;
    } else {
      return obj + "";
    }
  }
  var _default2 = OrdinalMeta;
  OrdinalMeta_1 = _default2;
  return OrdinalMeta_1;
}
var Ordinal;
var hasRequiredOrdinal;
function requireOrdinal() {
  if (hasRequiredOrdinal)
    return Ordinal;
  hasRequiredOrdinal = 1;
  var zrUtil2 = util$6;
  var Scale = requireScale();
  var OrdinalMeta = requireOrdinalMeta();
  var scaleProto = Scale.prototype;
  var OrdinalScale = Scale.extend({
    type: "ordinal",
    /**
     * @param {module:echarts/data/OrdianlMeta|Array.<string>} ordinalMeta
     */
    init: function(ordinalMeta, extent) {
      if (!ordinalMeta || zrUtil2.isArray(ordinalMeta)) {
        ordinalMeta = new OrdinalMeta({
          categories: ordinalMeta
        });
      }
      this._ordinalMeta = ordinalMeta;
      this._extent = extent || [0, ordinalMeta.categories.length - 1];
    },
    parse: function(val) {
      return typeof val === "string" ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
    },
    contain: function(rank) {
      rank = this.parse(rank);
      return scaleProto.contain.call(this, rank) && this._ordinalMeta.categories[rank] != null;
    },
    /**
     * Normalize given rank or name to linear [0, 1]
     * @param {number|string} [val]
     * @return {number}
     */
    normalize: function(val) {
      return scaleProto.normalize.call(this, this.parse(val));
    },
    scale: function(val) {
      return Math.round(scaleProto.scale.call(this, val));
    },
    /**
     * @return {Array}
     */
    getTicks: function() {
      var ticks = [];
      var extent = this._extent;
      var rank = extent[0];
      while (rank <= extent[1]) {
        ticks.push(rank);
        rank++;
      }
      return ticks;
    },
    /**
     * Get item on rank n
     * @param {number} n
     * @return {string}
     */
    getLabel: function(n) {
      if (!this.isBlank()) {
        return this._ordinalMeta.categories[n];
      }
    },
    /**
     * @return {number}
     */
    count: function() {
      return this._extent[1] - this._extent[0] + 1;
    },
    /**
     * @override
     */
    unionExtentFromData: function(data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    },
    getOrdinalMeta: function() {
      return this._ordinalMeta;
    },
    niceTicks: zrUtil2.noop,
    niceExtent: zrUtil2.noop
  });
  OrdinalScale.create = function() {
    return new OrdinalScale();
  };
  var _default2 = OrdinalScale;
  Ordinal = _default2;
  return Ordinal;
}
var helper$4 = {};
var hasRequiredHelper$5;
function requireHelper$5() {
  if (hasRequiredHelper$5)
    return helper$4;
  hasRequiredHelper$5 = 1;
  var numberUtil = requireNumber();
  var roundNumber = numberUtil.round;
  function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
    var result = {};
    var span = extent[1] - extent[0];
    var interval = result.interval = numberUtil.nice(span / splitNumber, true);
    if (minInterval != null && interval < minInterval) {
      interval = result.interval = minInterval;
    }
    if (maxInterval != null && interval > maxInterval) {
      interval = result.interval = maxInterval;
    }
    var precision = result.intervalPrecision = getIntervalPrecision(interval);
    var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
    fixExtent(niceTickExtent, extent);
    return result;
  }
  function getIntervalPrecision(interval) {
    return numberUtil.getPrecisionSafe(interval) + 2;
  }
  function clamp(niceTickExtent, idx, extent) {
    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
  }
  function fixExtent(niceTickExtent, extent) {
    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
    clamp(niceTickExtent, 0, extent);
    clamp(niceTickExtent, 1, extent);
    if (niceTickExtent[0] > niceTickExtent[1]) {
      niceTickExtent[0] = niceTickExtent[1];
    }
  }
  helper$4.intervalScaleNiceTicks = intervalScaleNiceTicks;
  helper$4.getIntervalPrecision = getIntervalPrecision;
  helper$4.fixExtent = fixExtent;
  return helper$4;
}
var Interval;
var hasRequiredInterval;
function requireInterval() {
  if (hasRequiredInterval)
    return Interval;
  hasRequiredInterval = 1;
  var numberUtil = requireNumber();
  var formatUtil2 = requireFormat();
  var Scale = requireScale();
  var helper2 = requireHelper$5();
  var roundNumber = numberUtil.round;
  var IntervalScale = Scale.extend({
    type: "interval",
    _interval: 0,
    _intervalPrecision: 2,
    setExtent: function(start, end) {
      var thisExtent = this._extent;
      if (!isNaN(start)) {
        thisExtent[0] = parseFloat(start);
      }
      if (!isNaN(end)) {
        thisExtent[1] = parseFloat(end);
      }
    },
    unionExtent: function(other) {
      var extent = this._extent;
      other[0] < extent[0] && (extent[0] = other[0]);
      other[1] > extent[1] && (extent[1] = other[1]);
      IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
    },
    /**
     * Get interval
     */
    getInterval: function() {
      return this._interval;
    },
    /**
     * Set interval
     */
    setInterval: function(interval) {
      this._interval = interval;
      this._niceExtent = this._extent.slice();
      this._intervalPrecision = helper2.getIntervalPrecision(interval);
    },
    /**
     * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
     * @return {Array.<number>}
     */
    getTicks: function(expandToNicedExtent) {
      var interval = this._interval;
      var extent = this._extent;
      var niceTickExtent = this._niceExtent;
      var intervalPrecision = this._intervalPrecision;
      var ticks = [];
      if (!interval) {
        return ticks;
      }
      var safeLimit = 1e4;
      if (extent[0] < niceTickExtent[0]) {
        if (expandToNicedExtent) {
          ticks.push(roundNumber(niceTickExtent[0] - interval, intervalPrecision));
        } else {
          ticks.push(extent[0]);
        }
      }
      var tick = niceTickExtent[0];
      while (tick <= niceTickExtent[1]) {
        ticks.push(tick);
        tick = roundNumber(tick + interval, intervalPrecision);
        if (tick === ticks[ticks.length - 1]) {
          break;
        }
        if (ticks.length > safeLimit) {
          return [];
        }
      }
      var lastNiceTick = ticks.length ? ticks[ticks.length - 1] : niceTickExtent[1];
      if (extent[1] > lastNiceTick) {
        if (expandToNicedExtent) {
          ticks.push(roundNumber(lastNiceTick + interval, intervalPrecision));
        } else {
          ticks.push(extent[1]);
        }
      }
      return ticks;
    },
    /**
     * @param {number} [splitNumber=5]
     * @return {Array.<Array.<number>>}
     */
    getMinorTicks: function(splitNumber) {
      var ticks = this.getTicks(true);
      var minorTicks = [];
      var extent = this.getExtent();
      for (var i = 1; i < ticks.length; i++) {
        var nextTick2 = ticks[i];
        var prevTick = ticks[i - 1];
        var count = 0;
        var minorTicksGroup = [];
        var interval = nextTick2 - prevTick;
        var minorInterval = interval / splitNumber;
        while (count < splitNumber - 1) {
          var minorTick = numberUtil.round(prevTick + (count + 1) * minorInterval);
          if (minorTick > extent[0] && minorTick < extent[1]) {
            minorTicksGroup.push(minorTick);
          }
          count++;
        }
        minorTicks.push(minorTicksGroup);
      }
      return minorTicks;
    },
    /**
     * @param {number} data
     * @param {Object} [opt]
     * @param {number|string} [opt.precision] If 'auto', use nice presision.
     * @param {boolean} [opt.pad] returns 1.50 but not 1.5 if precision is 2.
     * @return {string}
     */
    getLabel: function(data, opt) {
      if (data == null) {
        return "";
      }
      var precision = opt && opt.precision;
      if (precision == null) {
        precision = numberUtil.getPrecisionSafe(data) || 0;
      } else if (precision === "auto") {
        precision = this._intervalPrecision;
      }
      data = roundNumber(data, precision, true);
      return formatUtil2.addCommas(data);
    },
    /**
     * Update interval and extent of intervals for nice ticks
     *
     * @param {number} [splitNumber = 5] Desired number of ticks
     * @param {number} [minInterval]
     * @param {number} [maxInterval]
     */
    niceTicks: function(splitNumber, minInterval, maxInterval) {
      splitNumber = splitNumber || 5;
      var extent = this._extent;
      var span = extent[1] - extent[0];
      if (!isFinite(span)) {
        return;
      }
      if (span < 0) {
        span = -span;
        extent.reverse();
      }
      var result = helper2.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
      this._intervalPrecision = result.intervalPrecision;
      this._interval = result.interval;
      this._niceExtent = result.niceTickExtent;
    },
    /**
     * Nice extent.
     * @param {Object} opt
     * @param {number} [opt.splitNumber = 5] Given approx tick number
     * @param {boolean} [opt.fixMin=false]
     * @param {boolean} [opt.fixMax=false]
     * @param {boolean} [opt.minInterval]
     * @param {boolean} [opt.maxInterval]
     */
    niceExtent: function(opt) {
      var extent = this._extent;
      if (extent[0] === extent[1]) {
        if (extent[0] !== 0) {
          var expandSize = extent[0];
          if (!opt.fixMax) {
            extent[1] += expandSize / 2;
            extent[0] -= expandSize / 2;
          } else {
            extent[0] -= expandSize / 2;
          }
        } else {
          extent[1] = 1;
        }
      }
      var span = extent[1] - extent[0];
      if (!isFinite(span)) {
        extent[0] = 0;
        extent[1] = 1;
      }
      this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
      var interval = this._interval;
      if (!opt.fixMin) {
        extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
      }
      if (!opt.fixMax) {
        extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
      }
    }
  });
  IntervalScale.create = function() {
    return new IntervalScale();
  };
  var _default2 = IntervalScale;
  Interval = _default2;
  return Interval;
}
var barGrid = {};
var hasRequiredBarGrid;
function requireBarGrid() {
  if (hasRequiredBarGrid)
    return barGrid;
  hasRequiredBarGrid = 1;
  var zrUtil2 = util$6;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var _dataStackHelper = requireDataStackHelper();
  var isDimensionStacked = _dataStackHelper.isDimensionStacked;
  var createRenderPlanner2 = createRenderPlanner$1;
  var STACK_PREFIX = "__ec_stack_";
  var LARGE_BAR_MIN_WIDTH = 0.5;
  var LargeArr = typeof Float32Array !== "undefined" ? Float32Array : Array;
  function getSeriesStackId(seriesModel) {
    return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
  }
  function getAxisKey(axis2) {
    return axis2.dim + axis2.index;
  }
  function getLayoutOnAxis(opt) {
    var params = [];
    var baseAxis = opt.axis;
    var axisKey = "axis0";
    if (baseAxis.type !== "category") {
      return;
    }
    var bandWidth = baseAxis.getBandWidth();
    for (var i = 0; i < opt.count || 0; i++) {
      params.push(zrUtil2.defaults({
        bandWidth,
        axisKey,
        stackId: STACK_PREFIX + i
      }, opt));
    }
    var widthAndOffsets = doCalBarWidthAndOffset(params);
    var result = [];
    for (var i = 0; i < opt.count; i++) {
      var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
      item.offsetCenter = item.offset + item.width / 2;
      result.push(item);
    }
    return result;
  }
  function prepareLayoutBarSeries(seriesType2, ecModel) {
    var seriesModels = [];
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {
        seriesModels.push(seriesModel);
      }
    });
    return seriesModels;
  }
  function getValueAxesMinGaps(barSeries) {
    var axisValues = {};
    zrUtil2.each(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      if (baseAxis.type !== "time" && baseAxis.type !== "value") {
        return;
      }
      var data = seriesModel.getData();
      var key2 = baseAxis.dim + "_" + baseAxis.index;
      var dim = data.mapDimension(baseAxis.dim);
      for (var i = 0, cnt = data.count(); i < cnt; ++i) {
        var value = data.get(dim, i);
        if (!axisValues[key2]) {
          axisValues[key2] = [value];
        } else {
          axisValues[key2].push(value);
        }
      }
    });
    var axisMinGaps = [];
    for (var key in axisValues) {
      if (axisValues.hasOwnProperty(key)) {
        var valuesInAxis = axisValues[key];
        if (valuesInAxis) {
          valuesInAxis.sort(function(a, b) {
            return a - b;
          });
          var min3 = null;
          for (var j = 1; j < valuesInAxis.length; ++j) {
            var delta = valuesInAxis[j] - valuesInAxis[j - 1];
            if (delta > 0) {
              min3 = min3 === null ? delta : Math.min(min3, delta);
            }
          }
          axisMinGaps[key] = min3;
        }
      }
    }
    return axisMinGaps;
  }
  function makeColumnLayout(barSeries) {
    var axisMinGaps = getValueAxesMinGaps(barSeries);
    var seriesInfoList = [];
    zrUtil2.each(barSeries, function(seriesModel) {
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var axisExtent = baseAxis.getExtent();
      var bandWidth;
      if (baseAxis.type === "category") {
        bandWidth = baseAxis.getBandWidth();
      } else if (baseAxis.type === "value" || baseAxis.type === "time") {
        var key = baseAxis.dim + "_" + baseAxis.index;
        var minGap = axisMinGaps[key];
        var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
        var scale = baseAxis.scale.getExtent();
        var scaleSpan = Math.abs(scale[1] - scale[0]);
        bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
      } else {
        var data = seriesModel.getData();
        bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
      }
      var barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
      var barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
      var barMinWidth = parsePercent2(
        // barMinWidth by default is 1 in cartesian. Because in value axis,
        // the auto-calculated bar width might be less than 1.
        seriesModel.get("barMinWidth") || 1,
        bandWidth
      );
      var barGap = seriesModel.get("barGap");
      var barCategoryGap = seriesModel.get("barCategoryGap");
      seriesInfoList.push({
        bandWidth,
        barWidth,
        barMaxWidth,
        barMinWidth,
        barGap,
        barCategoryGap,
        axisKey: getAxisKey(baseAxis),
        stackId: getSeriesStackId(seriesModel)
      });
    });
    return doCalBarWidthAndOffset(seriesInfoList);
  }
  function doCalBarWidthAndOffset(seriesInfoList) {
    var columnsMap = {};
    zrUtil2.each(seriesInfoList, function(seriesInfo, idx) {
      var axisKey = seriesInfo.axisKey;
      var bandWidth = seriesInfo.bandWidth;
      var columnsOnAxis = columnsMap[axisKey] || {
        bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: "20%",
        gap: "30%",
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[axisKey] = columnsOnAxis;
      var stackId = seriesInfo.stackId;
      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }
      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      };
      var barWidth = seriesInfo.barWidth;
      if (barWidth && !stacks[stackId].width) {
        stacks[stackId].width = barWidth;
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        columnsOnAxis.remainedWidth -= barWidth;
      }
      var barMaxWidth = seriesInfo.barMaxWidth;
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      var barMinWidth = seriesInfo.barMinWidth;
      barMinWidth && (stacks[stackId].minWidth = barMinWidth);
      var barGap = seriesInfo.barGap;
      barGap != null && (columnsOnAxis.gap = barGap);
      var barCategoryGap = seriesInfo.barCategoryGap;
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    zrUtil2.each(columnsMap, function(columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGap = parsePercent2(columnsOnAxis.categoryGap, bandWidth);
      var barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      zrUtil2.each(stacks, function(column) {
        var maxWidth = column.maxWidth;
        var minWidth = column.minWidth;
        if (!column.width) {
          var finalWidth = autoWidth;
          if (maxWidth && maxWidth < finalWidth) {
            finalWidth = Math.min(maxWidth, remainedWidth);
          }
          if (minWidth && minWidth > finalWidth) {
            finalWidth = minWidth;
          }
          if (finalWidth !== autoWidth) {
            column.width = finalWidth;
            remainedWidth -= finalWidth + barGapPercent * finalWidth;
            autoWidthCount--;
          }
        } else {
          var finalWidth = column.width;
          if (maxWidth) {
            finalWidth = Math.min(finalWidth, maxWidth);
          }
          if (minWidth) {
            finalWidth = Math.max(finalWidth, minWidth);
          }
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      });
      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      zrUtil2.each(stacks, function(column, idx) {
        if (!column.width) {
          column.width = autoWidth;
        }
        lastColumn = column;
        widthSum += column.width * (1 + barGapPercent);
      });
      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }
      var offset = -widthSum / 2;
      zrUtil2.each(stacks, function(column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          bandWidth,
          offset,
          width: column.width
        };
        offset += column.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  function retrieveColumnLayout(barWidthAndOffset, axis2, seriesModel) {
    if (barWidthAndOffset && axis2) {
      var result = barWidthAndOffset[getAxisKey(axis2)];
      if (result != null && seriesModel != null) {
        result = result[getSeriesStackId(seriesModel)];
      }
      return result;
    }
  }
  function layout2(seriesType2, ecModel) {
    var seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
    var barWidthAndOffset = makeColumnLayout(seriesModels);
    var lastStackCoords = {};
    zrUtil2.each(seriesModels, function(seriesModel) {
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var stackId = getSeriesStackId(seriesModel);
      var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
      var columnOffset = columnLayoutInfo.offset;
      var columnWidth = columnLayoutInfo.width;
      var valueAxis = cartesian.getOtherAxis(baseAxis);
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      lastStackCoords[stackId] = lastStackCoords[stackId] || [];
      data.setLayout({
        bandWidth: columnLayoutInfo.bandWidth,
        offset: columnOffset,
        size: columnWidth
      });
      var valueDim = data.mapDimension(valueAxis.dim);
      var baseDim = data.mapDimension(baseAxis.dim);
      var stacked = isDimensionStacked(
        data,
        valueDim
        /*, baseDim*/
      );
      var isValueAxisH = valueAxis.isHorizontal();
      var valueAxisStart = getValueAxisStart(baseAxis, valueAxis);
      for (var idx = 0, len = data.count(); idx < len; idx++) {
        var value = data.get(valueDim, idx);
        var baseValue = data.get(baseDim, idx);
        var sign = value >= 0 ? "p" : "n";
        var baseCoord = valueAxisStart;
        if (stacked) {
          if (!lastStackCoords[stackId][baseValue]) {
            lastStackCoords[stackId][baseValue] = {
              p: valueAxisStart,
              // Positive stack
              n: valueAxisStart
              // Negative stack
            };
          }
          baseCoord = lastStackCoords[stackId][baseValue][sign];
        }
        var x;
        var y;
        var width;
        var height;
        if (isValueAxisH) {
          var coord = cartesian.dataToPoint([value, baseValue]);
          x = baseCoord;
          y = coord[1] + columnOffset;
          width = coord[0] - valueAxisStart;
          height = columnWidth;
          if (Math.abs(width) < barMinHeight) {
            width = (width < 0 ? -1 : 1) * barMinHeight;
          }
          if (!isNaN(width)) {
            stacked && (lastStackCoords[stackId][baseValue][sign] += width);
          }
        } else {
          var coord = cartesian.dataToPoint([baseValue, value]);
          x = coord[0] + columnOffset;
          y = baseCoord;
          width = columnWidth;
          height = coord[1] - valueAxisStart;
          if (Math.abs(height) < barMinHeight) {
            height = (height <= 0 ? -1 : 1) * barMinHeight;
          }
          if (!isNaN(height)) {
            stacked && (lastStackCoords[stackId][baseValue][sign] += height);
          }
        }
        data.setItemLayout(idx, {
          x,
          y,
          width,
          height
        });
      }
    }, this);
  }
  var largeLayout = {
    seriesType: "bar",
    plan: createRenderPlanner2(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {
        return;
      }
      var data = seriesModel.getData();
      var cartesian = seriesModel.coordinateSystem;
      var coordLayout = cartesian.grid.getRect();
      var baseAxis = cartesian.getBaseAxis();
      var valueAxis = cartesian.getOtherAxis(baseAxis);
      var valueDim = data.mapDimension(valueAxis.dim);
      var baseDim = data.mapDimension(baseAxis.dim);
      var valueAxisHorizontal = valueAxis.isHorizontal();
      var valueDimIdx = valueAxisHorizontal ? 0 : 1;
      var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;
      if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {
        barWidth = LARGE_BAR_MIN_WIDTH;
      }
      return {
        progress
      };
      function progress(params, data2) {
        var count = params.count;
        var largePoints = new LargeArr(count * 2);
        var largeBackgroundPoints = new LargeArr(count * 2);
        var largeDataIndices = new LargeArr(count);
        var dataIndex;
        var coord = [];
        var valuePair = [];
        var pointsOffset = 0;
        var idxOffset = 0;
        while ((dataIndex = params.next()) != null) {
          valuePair[valueDimIdx] = data2.get(valueDim, dataIndex);
          valuePair[1 - valueDimIdx] = data2.get(baseDim, dataIndex);
          coord = cartesian.dataToPoint(valuePair, null, coord);
          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];
          largePoints[pointsOffset++] = coord[0];
          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;
          largePoints[pointsOffset++] = coord[1];
          largeDataIndices[idxOffset++] = dataIndex;
        }
        data2.setLayout({
          largePoints,
          largeDataIndices,
          largeBackgroundPoints,
          barWidth,
          valueAxisStart: getValueAxisStart(baseAxis, valueAxis),
          backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,
          valueAxisHorizontal
        });
      }
    }
  };
  function isOnCartesian(seriesModel) {
    return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
  }
  function isInLargeMode(seriesModel) {
    return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
  }
  function getValueAxisStart(baseAxis, valueAxis, stacked) {
    return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === "log" ? 1 : 0));
  }
  barGrid.getLayoutOnAxis = getLayoutOnAxis;
  barGrid.prepareLayoutBarSeries = prepareLayoutBarSeries;
  barGrid.makeColumnLayout = makeColumnLayout;
  barGrid.retrieveColumnLayout = retrieveColumnLayout;
  barGrid.layout = layout2;
  barGrid.largeLayout = largeLayout;
  return barGrid;
}
var Time;
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime)
    return Time;
  hasRequiredTime = 1;
  var zrUtil2 = util$6;
  var numberUtil = requireNumber();
  var formatUtil2 = requireFormat();
  var scaleHelper = requireHelper$5();
  var IntervalScale = requireInterval();
  var intervalScaleProto = IntervalScale.prototype;
  var mathCeil = Math.ceil;
  var mathFloor = Math.floor;
  var ONE_SECOND = 1e3;
  var ONE_MINUTE = ONE_SECOND * 60;
  var ONE_HOUR = ONE_MINUTE * 60;
  var ONE_DAY = ONE_HOUR * 24;
  var bisect = function(a, x, lo, hi) {
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid][1] < x) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    return lo;
  };
  var TimeScale = IntervalScale.extend({
    type: "time",
    /**
     * @override
     */
    getLabel: function(val) {
      var stepLvl = this._stepLvl;
      var date = new Date(val);
      return formatUtil2.formatTime(stepLvl[0], date, this.getSetting("useUTC"));
    },
    /**
     * @override
     */
    niceExtent: function(opt) {
      var extent = this._extent;
      if (extent[0] === extent[1]) {
        extent[0] -= ONE_DAY;
        extent[1] += ONE_DAY;
      }
      if (extent[1] === -Infinity && extent[0] === Infinity) {
        var d = /* @__PURE__ */ new Date();
        extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
        extent[0] = extent[1] - ONE_DAY;
      }
      this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
      var interval = this._interval;
      if (!opt.fixMin) {
        extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
      }
      if (!opt.fixMax) {
        extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
      }
    },
    /**
     * @override
     */
    niceTicks: function(approxTickNum, minInterval, maxInterval) {
      approxTickNum = approxTickNum || 10;
      var extent = this._extent;
      var span = extent[1] - extent[0];
      var approxInterval = span / approxTickNum;
      if (minInterval != null && approxInterval < minInterval) {
        approxInterval = minInterval;
      }
      if (maxInterval != null && approxInterval > maxInterval) {
        approxInterval = maxInterval;
      }
      var scaleLevelsLen = scaleLevels.length;
      var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
      var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
      var interval = level[1];
      if (level[0] === "year") {
        var yearSpan = span / interval;
        var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
        interval *= yearStep;
      }
      var timezoneOffset = this.getSetting("useUTC") ? 0 : (/* @__PURE__ */ new Date(+extent[0] || +extent[1])).getTimezoneOffset() * 60 * 1e3;
      var niceExtent = [Math.round(mathCeil((extent[0] - timezoneOffset) / interval) * interval + timezoneOffset), Math.round(mathFloor((extent[1] - timezoneOffset) / interval) * interval + timezoneOffset)];
      scaleHelper.fixExtent(niceExtent, extent);
      this._stepLvl = level;
      this._interval = interval;
      this._niceExtent = niceExtent;
    },
    parse: function(val) {
      return +numberUtil.parseDate(val);
    }
  });
  zrUtil2.each(["contain", "normalize"], function(methodName) {
    TimeScale.prototype[methodName] = function(val) {
      return intervalScaleProto[methodName].call(this, this.parse(val));
    };
  });
  var scaleLevels = [
    // Format              interval
    ["hh:mm:ss", ONE_SECOND],
    // 1s
    ["hh:mm:ss", ONE_SECOND * 5],
    // 5s
    ["hh:mm:ss", ONE_SECOND * 10],
    // 10s
    ["hh:mm:ss", ONE_SECOND * 15],
    // 15s
    ["hh:mm:ss", ONE_SECOND * 30],
    // 30s
    ["hh:mm\nMM-dd", ONE_MINUTE],
    // 1m
    ["hh:mm\nMM-dd", ONE_MINUTE * 5],
    // 5m
    ["hh:mm\nMM-dd", ONE_MINUTE * 10],
    // 10m
    ["hh:mm\nMM-dd", ONE_MINUTE * 15],
    // 15m
    ["hh:mm\nMM-dd", ONE_MINUTE * 30],
    // 30m
    ["hh:mm\nMM-dd", ONE_HOUR],
    // 1h
    ["hh:mm\nMM-dd", ONE_HOUR * 2],
    // 2h
    ["hh:mm\nMM-dd", ONE_HOUR * 6],
    // 6h
    ["hh:mm\nMM-dd", ONE_HOUR * 12],
    // 12h
    ["MM-dd\nyyyy", ONE_DAY],
    // 1d
    ["MM-dd\nyyyy", ONE_DAY * 2],
    // 2d
    ["MM-dd\nyyyy", ONE_DAY * 3],
    // 3d
    ["MM-dd\nyyyy", ONE_DAY * 4],
    // 4d
    ["MM-dd\nyyyy", ONE_DAY * 5],
    // 5d
    ["MM-dd\nyyyy", ONE_DAY * 6],
    // 6d
    ["week", ONE_DAY * 7],
    // 7d
    ["MM-dd\nyyyy", ONE_DAY * 10],
    // 10d
    ["week", ONE_DAY * 14],
    // 2w
    ["week", ONE_DAY * 21],
    // 3w
    ["month", ONE_DAY * 31],
    // 1M
    ["week", ONE_DAY * 42],
    // 6w
    ["month", ONE_DAY * 62],
    // 2M
    ["week", ONE_DAY * 70],
    // 10w
    ["quarter", ONE_DAY * 95],
    // 3M
    ["month", ONE_DAY * 31 * 4],
    // 4M
    ["month", ONE_DAY * 31 * 5],
    // 5M
    ["half-year", ONE_DAY * 380 / 2],
    // 6M
    ["month", ONE_DAY * 31 * 8],
    // 8M
    ["month", ONE_DAY * 31 * 10],
    // 10M
    ["year", ONE_DAY * 380]
    // 1Y
  ];
  TimeScale.create = function(model2) {
    return new TimeScale({
      useUTC: model2.ecModel.get("useUTC")
    });
  };
  var _default2 = TimeScale;
  Time = _default2;
  return Time;
}
var Log;
var hasRequiredLog;
function requireLog() {
  if (hasRequiredLog)
    return Log;
  hasRequiredLog = 1;
  var zrUtil2 = util$6;
  var Scale = requireScale();
  var numberUtil = requireNumber();
  var IntervalScale = requireInterval();
  var scaleProto = Scale.prototype;
  var intervalScaleProto = IntervalScale.prototype;
  var getPrecisionSafe = numberUtil.getPrecisionSafe;
  var roundingErrorFix = numberUtil.round;
  var mathFloor = Math.floor;
  var mathCeil = Math.ceil;
  var mathPow2 = Math.pow;
  var mathLog = Math.log;
  var LogScale = Scale.extend({
    type: "log",
    base: 10,
    $constructor: function() {
      Scale.apply(this, arguments);
      this._originalScale = new IntervalScale();
    },
    /**
     * @param {boolean} [expandToNicedExtent=false] If expand the ticks to niced extent.
     * @return {Array.<number>}
     */
    getTicks: function(expandToNicedExtent) {
      var originalScale = this._originalScale;
      var extent = this._extent;
      var originalExtent = originalScale.getExtent();
      return zrUtil2.map(intervalScaleProto.getTicks.call(this, expandToNicedExtent), function(val) {
        var powVal = numberUtil.round(mathPow2(this.base, val));
        powVal = val === extent[0] && originalScale.__fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
        powVal = val === extent[1] && originalScale.__fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
        return powVal;
      }, this);
    },
    /**
     * @param {number} splitNumber
     * @return {Array.<Array.<number>>}
     */
    getMinorTicks: intervalScaleProto.getMinorTicks,
    /**
     * @param {number} val
     * @return {string}
     */
    getLabel: intervalScaleProto.getLabel,
    /**
     * @param  {number} val
     * @return {number}
     */
    scale: function(val) {
      val = scaleProto.scale.call(this, val);
      return mathPow2(this.base, val);
    },
    /**
     * @param {number} start
     * @param {number} end
     */
    setExtent: function(start, end) {
      var base2 = this.base;
      start = mathLog(start) / mathLog(base2);
      end = mathLog(end) / mathLog(base2);
      intervalScaleProto.setExtent.call(this, start, end);
    },
    /**
     * @return {number} end
     */
    getExtent: function() {
      var base2 = this.base;
      var extent = scaleProto.getExtent.call(this);
      extent[0] = mathPow2(base2, extent[0]);
      extent[1] = mathPow2(base2, extent[1]);
      var originalScale = this._originalScale;
      var originalExtent = originalScale.getExtent();
      originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
      originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
      return extent;
    },
    /**
     * @param  {Array.<number>} extent
     */
    unionExtent: function(extent) {
      this._originalScale.unionExtent(extent);
      var base2 = this.base;
      extent[0] = mathLog(extent[0]) / mathLog(base2);
      extent[1] = mathLog(extent[1]) / mathLog(base2);
      scaleProto.unionExtent.call(this, extent);
    },
    /**
     * @override
     */
    unionExtentFromData: function(data, dim) {
      this.unionExtent(data.getApproximateExtent(dim));
    },
    /**
     * Update interval and extent of intervals for nice ticks
     * @param  {number} [approxTickNum = 10] Given approx tick number
     */
    niceTicks: function(approxTickNum) {
      approxTickNum = approxTickNum || 10;
      var extent = this._extent;
      var span = extent[1] - extent[0];
      if (span === Infinity || span <= 0) {
        return;
      }
      var interval = numberUtil.quantity(span);
      var err = approxTickNum / span * interval;
      if (err <= 0.5) {
        interval *= 10;
      }
      while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
        interval *= 10;
      }
      var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
      this._interval = interval;
      this._niceExtent = niceExtent;
    },
    /**
     * Nice extent.
     * @override
     */
    niceExtent: function(opt) {
      intervalScaleProto.niceExtent.call(this, opt);
      var originalScale = this._originalScale;
      originalScale.__fixMin = opt.fixMin;
      originalScale.__fixMax = opt.fixMax;
    }
  });
  zrUtil2.each(["contain", "normalize"], function(methodName) {
    LogScale.prototype[methodName] = function(val) {
      val = mathLog(val) / mathLog(this.base);
      return scaleProto[methodName].call(this, val);
    };
  });
  LogScale.create = function() {
    return new LogScale();
  };
  function fixRoundingError(val, originalVal) {
    return roundingErrorFix(val, getPrecisionSafe(originalVal));
  }
  var _default2 = LogScale;
  Log = _default2;
  return Log;
}
var hasRequiredAxisHelper;
function requireAxisHelper() {
  if (hasRequiredAxisHelper)
    return axisHelper;
  hasRequiredAxisHelper = 1;
  var zrUtil2 = util$6;
  var OrdinalScale = requireOrdinal();
  var IntervalScale = requireInterval();
  var Scale = requireScale();
  var numberUtil = requireNumber();
  var _barGrid = requireBarGrid();
  var prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries;
  var makeColumnLayout = _barGrid.makeColumnLayout;
  var retrieveColumnLayout = _barGrid.retrieveColumnLayout;
  var BoundingRect2 = BoundingRect_1;
  requireTime();
  requireLog();
  function getScaleExtent(scale, model2) {
    var scaleType = scale.type;
    var min3 = model2.getMin();
    var max3 = model2.getMax();
    var originalExtent = scale.getExtent();
    var axisDataLen;
    var boundaryGap;
    var span;
    if (scaleType === "ordinal") {
      axisDataLen = model2.getCategories().length;
    } else {
      boundaryGap = model2.get("boundaryGap");
      if (!zrUtil2.isArray(boundaryGap)) {
        boundaryGap = [boundaryGap || 0, boundaryGap || 0];
      }
      if (typeof boundaryGap[0] === "boolean") {
        boundaryGap = [0, 0];
      }
      boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
      boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
      span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);
    }
    if (min3 === "dataMin") {
      min3 = originalExtent[0];
    } else if (typeof min3 === "function") {
      min3 = min3({
        min: originalExtent[0],
        max: originalExtent[1]
      });
    }
    if (max3 === "dataMax") {
      max3 = originalExtent[1];
    } else if (typeof max3 === "function") {
      max3 = max3({
        min: originalExtent[0],
        max: originalExtent[1]
      });
    }
    var fixMin = min3 != null;
    var fixMax = max3 != null;
    if (min3 == null) {
      min3 = scaleType === "ordinal" ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;
    }
    if (max3 == null) {
      max3 = scaleType === "ordinal" ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;
    }
    (min3 == null || !isFinite(min3)) && (min3 = NaN);
    (max3 == null || !isFinite(max3)) && (max3 = NaN);
    scale.setBlank(zrUtil2.eqNaN(min3) || zrUtil2.eqNaN(max3) || scaleType === "ordinal" && !scale.getOrdinalMeta().categories.length);
    if (model2.getNeedCrossZero()) {
      if (min3 > 0 && max3 > 0 && !fixMin) {
        min3 = 0;
      }
      if (min3 < 0 && max3 < 0 && !fixMax) {
        max3 = 0;
      }
    }
    var ecModel = model2.ecModel;
    if (ecModel && scaleType === "time") {
      var barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
      var isBaseAxisAndHasBarSeries;
      zrUtil2.each(barSeriesModels, function(seriesModel) {
        isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model2.axis;
      });
      if (isBaseAxisAndHasBarSeries) {
        var barWidthAndOffset = makeColumnLayout(barSeriesModels);
        var adjustedScale = adjustScaleForOverflow(min3, max3, model2, barWidthAndOffset);
        min3 = adjustedScale.min;
        max3 = adjustedScale.max;
      }
    }
    return {
      extent: [min3, max3],
      // "fix" means "fixed", the value should not be
      // changed in the subsequent steps.
      fixMin,
      fixMax
    };
  }
  function adjustScaleForOverflow(min3, max3, model2, barWidthAndOffset) {
    var axisExtent = model2.axis.getExtent();
    var axisLength = axisExtent[1] - axisExtent[0];
    var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model2.axis);
    if (barsOnCurrentAxis === void 0) {
      return {
        min: min3,
        max: max3
      };
    }
    var minOverflow = Infinity;
    zrUtil2.each(barsOnCurrentAxis, function(item) {
      minOverflow = Math.min(item.offset, minOverflow);
    });
    var maxOverflow = -Infinity;
    zrUtil2.each(barsOnCurrentAxis, function(item) {
      maxOverflow = Math.max(item.offset + item.width, maxOverflow);
    });
    minOverflow = Math.abs(minOverflow);
    maxOverflow = Math.abs(maxOverflow);
    var totalOverFlow = minOverflow + maxOverflow;
    var oldRange = max3 - min3;
    var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
    var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
    max3 += overflowBuffer * (maxOverflow / totalOverFlow);
    min3 -= overflowBuffer * (minOverflow / totalOverFlow);
    return {
      min: min3,
      max: max3
    };
  }
  function niceScaleExtent(scale, model2) {
    var extentInfo = getScaleExtent(scale, model2);
    var extent = extentInfo.extent;
    var splitNumber = model2.get("splitNumber");
    if (scale.type === "log") {
      scale.base = model2.get("logBase");
    }
    var scaleType = scale.type;
    scale.setExtent(extent[0], extent[1]);
    scale.niceExtent({
      splitNumber,
      fixMin: extentInfo.fixMin,
      fixMax: extentInfo.fixMax,
      minInterval: scaleType === "interval" || scaleType === "time" ? model2.get("minInterval") : null,
      maxInterval: scaleType === "interval" || scaleType === "time" ? model2.get("maxInterval") : null
    });
    var interval = model2.get("interval");
    if (interval != null) {
      scale.setInterval && scale.setInterval(interval);
    }
  }
  function createScaleByModel(model2, axisType) {
    axisType = axisType || model2.get("type");
    if (axisType) {
      switch (axisType) {
        case "category":
          return new OrdinalScale(model2.getOrdinalMeta ? model2.getOrdinalMeta() : model2.getCategories(), [Infinity, -Infinity]);
        case "value":
          return new IntervalScale();
        default:
          return (Scale.getClass(axisType) || IntervalScale).create(model2);
      }
    }
  }
  function ifAxisCrossZero(axis2) {
    var dataExtent = axis2.scale.getExtent();
    var min3 = dataExtent[0];
    var max3 = dataExtent[1];
    return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
  }
  function makeLabelFormatter(axis2) {
    var labelFormatter = axis2.getLabelModel().get("formatter");
    var categoryTickStart = axis2.type === "category" ? axis2.scale.getExtent()[0] : null;
    if (typeof labelFormatter === "string") {
      labelFormatter = function(tpl) {
        return function(val) {
          val = axis2.scale.getLabel(val);
          return tpl.replace("{value}", val != null ? val : "");
        };
      }(labelFormatter);
      return labelFormatter;
    } else if (typeof labelFormatter === "function") {
      return function(tickValue, idx) {
        if (categoryTickStart != null) {
          idx = tickValue - categoryTickStart;
        }
        return labelFormatter(getAxisRawValue(axis2, tickValue), idx);
      };
    } else {
      return function(tick) {
        return axis2.scale.getLabel(tick);
      };
    }
  }
  function getAxisRawValue(axis2, value) {
    return axis2.type === "category" ? axis2.scale.getLabel(value) : value;
  }
  function estimateLabelUnionRect(axis2) {
    var axisModel = axis2.model;
    var scale = axis2.scale;
    if (!axisModel.get("axisLabel.show") || scale.isBlank()) {
      return;
    }
    var isCategory = axis2.type === "category";
    var realNumberScaleTicks;
    var tickCount;
    var categoryScaleExtent = scale.getExtent();
    if (isCategory) {
      tickCount = scale.count();
    } else {
      realNumberScaleTicks = scale.getTicks();
      tickCount = realNumberScaleTicks.length;
    }
    var axisLabelModel = axis2.getLabelModel();
    var labelFormatter = makeLabelFormatter(axis2);
    var rect;
    var step = 1;
    if (tickCount > 40) {
      step = Math.ceil(tickCount / 40);
    }
    for (var i = 0; i < tickCount; i += step) {
      var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;
      var label = labelFormatter(tickValue);
      var unrotatedSingleRect = axisLabelModel.getTextRect(label);
      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
      rect ? rect.union(singleRect) : rect = singleRect;
    }
    return rect;
  }
  function rotateTextRect(textRect, rotate) {
    var rotateRadians = rotate * Math.PI / 180;
    var boundingBox = textRect.plain();
    var beforeWidth = boundingBox.width;
    var beforeHeight = boundingBox.height;
    var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
    var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
    var rotatedRect = new BoundingRect2(boundingBox.x, boundingBox.y, afterWidth, afterHeight);
    return rotatedRect;
  }
  function getOptionCategoryInterval(model2) {
    var interval = model2.get("interval");
    return interval == null ? "auto" : interval;
  }
  function shouldShowAllLabels(axis2) {
    return axis2.type === "category" && getOptionCategoryInterval(axis2.getLabelModel()) === 0;
  }
  axisHelper.getScaleExtent = getScaleExtent;
  axisHelper.niceScaleExtent = niceScaleExtent;
  axisHelper.createScaleByModel = createScaleByModel;
  axisHelper.ifAxisCrossZero = ifAxisCrossZero;
  axisHelper.makeLabelFormatter = makeLabelFormatter;
  axisHelper.getAxisRawValue = getAxisRawValue;
  axisHelper.estimateLabelUnionRect = estimateLabelUnionRect;
  axisHelper.getOptionCategoryInterval = getOptionCategoryInterval;
  axisHelper.shouldShowAllLabels = shouldShowAllLabels;
  return axisHelper;
}
var axisModelCommonMixin;
var hasRequiredAxisModelCommonMixin;
function requireAxisModelCommonMixin() {
  if (hasRequiredAxisModelCommonMixin)
    return axisModelCommonMixin;
  hasRequiredAxisModelCommonMixin = 1;
  var zrUtil2 = util$6;
  var _default2 = {
    /**
     * @param {boolean} origin
     * @return {number|string} min value or 'dataMin' or null/undefined (means auto) or NaN
     */
    getMin: function(origin) {
      var option = this.option;
      var min3 = !origin && option.rangeStart != null ? option.rangeStart : option.min;
      if (this.axis && min3 != null && min3 !== "dataMin" && typeof min3 !== "function" && !zrUtil2.eqNaN(min3)) {
        min3 = this.axis.scale.parse(min3);
      }
      return min3;
    },
    /**
     * @param {boolean} origin
     * @return {number|string} max value or 'dataMax' or null/undefined (means auto) or NaN
     */
    getMax: function(origin) {
      var option = this.option;
      var max3 = !origin && option.rangeEnd != null ? option.rangeEnd : option.max;
      if (this.axis && max3 != null && max3 !== "dataMax" && typeof max3 !== "function" && !zrUtil2.eqNaN(max3)) {
        max3 = this.axis.scale.parse(max3);
      }
      return max3;
    },
    /**
     * @return {boolean}
     */
    getNeedCrossZero: function() {
      var option = this.option;
      return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
    },
    /**
     * Should be implemented by each axis model if necessary.
     * @return {module:echarts/model/Component} coordinate system model
     */
    getCoordSysModel: zrUtil2.noop,
    /**
     * @param {number} rangeStart Can only be finite number or null/undefined or NaN.
     * @param {number} rangeEnd Can only be finite number or null/undefined or NaN.
     */
    setRange: function(rangeStart, rangeEnd) {
      this.option.rangeStart = rangeStart;
      this.option.rangeEnd = rangeEnd;
    },
    /**
     * Reset range
     */
    resetRange: function() {
      this.option.rangeStart = this.option.rangeEnd = null;
    }
  };
  axisModelCommonMixin = _default2;
  return axisModelCommonMixin;
}
var symbol$1 = {};
var hasRequiredSymbol$1;
function requireSymbol$1() {
  if (hasRequiredSymbol$1)
    return symbol$1;
  hasRequiredSymbol$1 = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var BoundingRect2 = BoundingRect_1;
  var _text = text;
  var calculateTextPosition2 = _text.calculateTextPosition;
  var Triangle = graphic2.extendShape({
    type: "triangle",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path2, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path2.moveTo(cx, cy - height);
      path2.lineTo(cx + width, cy + height);
      path2.lineTo(cx - width, cy + height);
      path2.closePath();
    }
  });
  var Diamond = graphic2.extendShape({
    type: "diamond",
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path2, shape) {
      var cx = shape.cx;
      var cy = shape.cy;
      var width = shape.width / 2;
      var height = shape.height / 2;
      path2.moveTo(cx, cy - height);
      path2.lineTo(cx + width, cy);
      path2.lineTo(cx, cy + height);
      path2.lineTo(cx - width, cy);
      path2.closePath();
    }
  });
  var Pin = graphic2.extendShape({
    type: "pin",
    shape: {
      // x, y on the cusp
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(path2, shape) {
      var x = shape.x;
      var y = shape.y;
      var w = shape.width / 5 * 3;
      var h = Math.max(w, shape.height);
      var r = w / 2;
      var dy = r * r / (h - r);
      var cy = y - h + r + dy;
      var angle = Math.asin(dy / r);
      var dx = Math.cos(angle) * r;
      var tanX = Math.sin(angle);
      var tanY = Math.cos(angle);
      var cpLen = r * 0.6;
      var cpLen2 = r * 0.7;
      path2.moveTo(x - dx, cy + dy);
      path2.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
      path2.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
      path2.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
      path2.closePath();
    }
  });
  var Arrow = graphic2.extendShape({
    type: "arrow",
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function(ctx, shape) {
      var height = shape.height;
      var width = shape.width;
      var x = shape.x;
      var y = shape.y;
      var dx = width / 3 * 2;
      ctx.moveTo(x, y);
      ctx.lineTo(x + dx, y + height);
      ctx.lineTo(x, y + height / 4 * 3);
      ctx.lineTo(x - dx, y + height);
      ctx.lineTo(x, y);
      ctx.closePath();
    }
  });
  var symbolCtors = {
    line: graphic2.Line,
    rect: graphic2.Rect,
    roundRect: graphic2.Rect,
    square: graphic2.Rect,
    circle: graphic2.Circle,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  };
  var symbolShapeMakers = {
    line: function(x, y, w, h, shape) {
      shape.x1 = x;
      shape.y1 = y + h / 2;
      shape.x2 = x + w;
      shape.y2 = y + h / 2;
    },
    rect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
    },
    roundRect: function(x, y, w, h, shape) {
      shape.x = x;
      shape.y = y;
      shape.width = w;
      shape.height = h;
      shape.r = Math.min(w, h) / 4;
    },
    square: function(x, y, w, h, shape) {
      var size2 = Math.min(w, h);
      shape.x = x;
      shape.y = y;
      shape.width = size2;
      shape.height = size2;
    },
    circle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.r = Math.min(w, h) / 2;
    },
    diamond: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    pin: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    arrow: function(x, y, w, h, shape) {
      shape.x = x + w / 2;
      shape.y = y + h / 2;
      shape.width = w;
      shape.height = h;
    },
    triangle: function(x, y, w, h, shape) {
      shape.cx = x + w / 2;
      shape.cy = y + h / 2;
      shape.width = w;
      shape.height = h;
    }
  };
  var symbolBuildProxies = {};
  zrUtil2.each(symbolCtors, function(Ctor, name2) {
    symbolBuildProxies[name2] = new Ctor();
  });
  var SymbolClz = graphic2.extendShape({
    type: "symbol",
    shape: {
      symbolType: "",
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function(out2, style, rect) {
      var res = calculateTextPosition2(out2, style, rect);
      var shape = this.shape;
      if (shape && shape.symbolType === "pin" && style.textPosition === "inside") {
        res.y = rect.y + rect.height * 0.4;
      }
      return res;
    },
    buildPath: function(ctx, shape, inBundle) {
      var symbolType = shape.symbolType;
      if (symbolType !== "none") {
        var proxySymbol = symbolBuildProxies[symbolType];
        if (!proxySymbol) {
          symbolType = "rect";
          proxySymbol = symbolBuildProxies[symbolType];
        }
        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
        proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
      }
    }
  });
  function symbolPathSetColor(color2, innerColor) {
    if (this.type !== "image") {
      var symbolStyle = this.style;
      var symbolShape = this.shape;
      if (symbolShape && symbolShape.symbolType === "line") {
        symbolStyle.stroke = color2;
      } else if (this.__isEmptyBrush) {
        symbolStyle.stroke = color2;
        symbolStyle.fill = innerColor || "#fff";
      } else {
        symbolStyle.fill && (symbolStyle.fill = color2);
        symbolStyle.stroke && (symbolStyle.stroke = color2);
      }
      this.dirty(false);
    }
  }
  function createSymbol(symbolType, x, y, w, h, color2, keepAspect) {
    var isEmpty = symbolType.indexOf("empty") === 0;
    if (isEmpty) {
      symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
    }
    var symbolPath;
    if (symbolType.indexOf("image://") === 0) {
      symbolPath = graphic2.makeImage(symbolType.slice(8), new BoundingRect2(x, y, w, h), keepAspect ? "center" : "cover");
    } else if (symbolType.indexOf("path://") === 0) {
      symbolPath = graphic2.makePath(symbolType.slice(7), {}, new BoundingRect2(x, y, w, h), keepAspect ? "center" : "cover");
    } else {
      symbolPath = new SymbolClz({
        shape: {
          symbolType,
          x,
          y,
          width: w,
          height: h
        }
      });
    }
    symbolPath.__isEmptyBrush = isEmpty;
    symbolPath.setColor = symbolPathSetColor;
    symbolPath.setColor(color2);
    return symbolPath;
  }
  symbol$1.createSymbol = createSymbol;
  return symbol$1;
}
var hasRequiredHelper$4;
function requireHelper$4() {
  if (hasRequiredHelper$4)
    return helper$5;
  hasRequiredHelper$4 = 1;
  var zrUtil2 = util$6;
  var createListFromArray = requireCreateListFromArray();
  var axisHelper2 = requireAxisHelper();
  var axisModelCommonMixin2 = requireAxisModelCommonMixin();
  var Model2 = requireModel();
  var _layout2 = layout$1;
  _layout2.getLayoutRect;
  helper$5.getLayoutRect = _layout2.getLayoutRect;
  var _dataStackHelper = requireDataStackHelper();
  var enableDataStack = _dataStackHelper.enableDataStack;
  var isDimensionStacked = _dataStackHelper.isDimensionStacked;
  var getStackedDimension = _dataStackHelper.getStackedDimension;
  var _completeDimensions = requireCompleteDimensions();
  helper$5.completeDimensions = _completeDimensions;
  var _createDimensions = requireCreateDimensions();
  helper$5.createDimensions = _createDimensions;
  var _symbol = requireSymbol$1();
  helper$5.createSymbol = _symbol.createSymbol;
  function createList(seriesModel) {
    return createListFromArray(seriesModel.getSource(), seriesModel);
  }
  var dataStack2 = {
    isDimensionStacked,
    enableDataStack,
    getStackedDimension
  };
  function createScale(dataExtent, option) {
    var axisModel = option;
    if (!Model2.isInstance(option)) {
      axisModel = new Model2(option);
      zrUtil2.mixin(axisModel, axisModelCommonMixin2);
    }
    var scale = axisHelper2.createScaleByModel(axisModel);
    scale.setExtent(dataExtent[0], dataExtent[1]);
    axisHelper2.niceScaleExtent(scale, axisModel);
    return scale;
  }
  function mixinAxisModelCommonMethods(Model3) {
    zrUtil2.mixin(Model3, axisModelCommonMixin2);
  }
  helper$5.createList = createList;
  helper$5.dataStack = dataStack2;
  helper$5.createScale = createScale;
  helper$5.mixinAxisModelCommonMethods = mixinAxisModelCommonMethods;
  return helper$5;
}
var polygon = {};
var hasRequiredPolygon;
function requirePolygon() {
  if (hasRequiredPolygon)
    return polygon;
  hasRequiredPolygon = 1;
  var windingLine2 = windingLine_1;
  var EPSILON2 = 1e-8;
  function isAroundEqual2(a, b) {
    return Math.abs(a - b) < EPSILON2;
  }
  function contain2(points2, x, y) {
    var w = 0;
    var p2 = points2[0];
    if (!p2) {
      return false;
    }
    for (var i = 1; i < points2.length; i++) {
      var p22 = points2[i];
      w += windingLine2(p2[0], p2[1], p22[0], p22[1], x, y);
      p2 = p22;
    }
    var p0 = points2[0];
    if (!isAroundEqual2(p2[0], p0[0]) || !isAroundEqual2(p2[1], p0[1])) {
      w += windingLine2(p2[0], p2[1], p0[0], p0[1], x, y);
    }
    return w !== 0;
  }
  polygon.contain = contain2;
  return polygon;
}
var Region_1;
var hasRequiredRegion;
function requireRegion() {
  if (hasRequiredRegion)
    return Region_1;
  hasRequiredRegion = 1;
  var BoundingRect2 = BoundingRect_1;
  var bbox2 = requireBbox();
  var vec22 = requireVector();
  var polygonContain = requirePolygon();
  function Region(name2, geometries, cp) {
    this.name = name2;
    this.geometries = geometries;
    if (!cp) {
      var rect = this.getBoundingRect();
      cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    } else {
      cp = [cp[0], cp[1]];
    }
    this.center = cp;
  }
  Region.prototype = {
    constructor: Region,
    properties: null,
    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getBoundingRect: function() {
      var rect = this._rect;
      if (rect) {
        return rect;
      }
      var MAX_NUMBER = Number.MAX_VALUE;
      var min3 = [MAX_NUMBER, MAX_NUMBER];
      var max3 = [-MAX_NUMBER, -MAX_NUMBER];
      var min22 = [];
      var max22 = [];
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        if (geometries[i].type !== "polygon") {
          continue;
        }
        var exterior = geometries[i].exterior;
        bbox2.fromPoints(exterior, min22, max22);
        vec22.min(min3, min3, min22);
        vec22.max(max3, max3, max22);
      }
      if (i === 0) {
        min3[0] = min3[1] = max3[0] = max3[1] = 0;
      }
      return this._rect = new BoundingRect2(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    },
    /**
     * @param {<Array.<number>} coord
     * @return {boolean}
     */
    contain: function(coord) {
      var rect = this.getBoundingRect();
      var geometries = this.geometries;
      if (!rect.contain(coord[0], coord[1])) {
        return false;
      }
      loopGeo:
        for (var i = 0, len = geometries.length; i < len; i++) {
          if (geometries[i].type !== "polygon") {
            continue;
          }
          var exterior = geometries[i].exterior;
          var interiors = geometries[i].interiors;
          if (polygonContain.contain(exterior, coord[0], coord[1])) {
            for (var k = 0; k < (interiors ? interiors.length : 0); k++) {
              if (polygonContain.contain(interiors[k])) {
                continue loopGeo;
              }
            }
            return true;
          }
        }
      return false;
    },
    transformTo: function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var aspect = rect.width / rect.height;
      if (!width) {
        width = aspect * height;
      } else if (!height) {
        height = width / aspect;
      }
      var target = new BoundingRect2(x, y, width, height);
      var transform = rect.calculateTransform(target);
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        if (geometries[i].type !== "polygon") {
          continue;
        }
        var exterior = geometries[i].exterior;
        var interiors = geometries[i].interiors;
        for (var p2 = 0; p2 < exterior.length; p2++) {
          vec22.applyTransform(exterior[p2], exterior[p2], transform);
        }
        for (var h = 0; h < (interiors ? interiors.length : 0); h++) {
          for (var p2 = 0; p2 < interiors[h].length; p2++) {
            vec22.applyTransform(interiors[h][p2], interiors[h][p2], transform);
          }
        }
      }
      rect = this._rect;
      rect.copy(target);
      this.center = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    },
    cloneShallow: function(name2) {
      name2 == null && (name2 = this.name);
      var newRegion = new Region(name2, this.geometries, this.center);
      newRegion._rect = this._rect;
      newRegion.transformTo = null;
      return newRegion;
    }
  };
  var _default2 = Region;
  Region_1 = _default2;
  return Region_1;
}
var parseGeoJson;
var hasRequiredParseGeoJson;
function requireParseGeoJson() {
  if (hasRequiredParseGeoJson)
    return parseGeoJson;
  hasRequiredParseGeoJson = 1;
  var zrUtil2 = util$6;
  var Region = requireRegion();
  function decode(json) {
    if (!json.UTF8Encoding) {
      return json;
    }
    var encodeScale = json.UTF8Scale;
    if (encodeScale == null) {
      encodeScale = 1024;
    }
    var features = json.features;
    for (var f2 = 0; f2 < features.length; f2++) {
      var feature = features[f2];
      var geometry = feature.geometry;
      var coordinates = geometry.coordinates;
      var encodeOffsets = geometry.encodeOffsets;
      for (var c = 0; c < coordinates.length; c++) {
        var coordinate = coordinates[c];
        if (geometry.type === "Polygon") {
          coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale);
        } else if (geometry.type === "MultiPolygon") {
          for (var c2 = 0; c2 < coordinate.length; c2++) {
            var polygon2 = coordinate[c2];
            coordinate[c2] = decodePolygon(polygon2, encodeOffsets[c][c2], encodeScale);
          }
        }
      }
    }
    json.UTF8Encoding = false;
    return json;
  }
  function decodePolygon(coordinate, encodeOffsets, encodeScale) {
    var result = [];
    var prevX = encodeOffsets[0];
    var prevY = encodeOffsets[1];
    for (var i = 0; i < coordinate.length; i += 2) {
      var x = coordinate.charCodeAt(i) - 64;
      var y = coordinate.charCodeAt(i + 1) - 64;
      x = x >> 1 ^ -(x & 1);
      y = y >> 1 ^ -(y & 1);
      x += prevX;
      y += prevY;
      prevX = x;
      prevY = y;
      result.push([x / encodeScale, y / encodeScale]);
    }
    return result;
  }
  function _default2(geoJson, nameProperty) {
    decode(geoJson);
    return zrUtil2.map(zrUtil2.filter(geoJson.features, function(featureObj) {
      return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
    }), function(featureObj) {
      var properties = featureObj.properties;
      var geo2 = featureObj.geometry;
      var coordinates = geo2.coordinates;
      var geometries = [];
      if (geo2.type === "Polygon") {
        geometries.push({
          type: "polygon",
          // According to the GeoJSON specification.
          // First must be exterior, and the rest are all interior(holes).
          exterior: coordinates[0],
          interiors: coordinates.slice(1)
        });
      }
      if (geo2.type === "MultiPolygon") {
        zrUtil2.each(coordinates, function(item) {
          if (item[0]) {
            geometries.push({
              type: "polygon",
              exterior: item[0],
              interiors: item.slice(1)
            });
          }
        });
      }
      var region = new Region(properties[nameProperty || "name"], geometries, properties.cp);
      region.properties = properties;
      return region;
    });
  }
  parseGeoJson = _default2;
  return parseGeoJson;
}
var axisTickLabelBuilder = {};
var hasRequiredAxisTickLabelBuilder;
function requireAxisTickLabelBuilder() {
  if (hasRequiredAxisTickLabelBuilder)
    return axisTickLabelBuilder;
  hasRequiredAxisTickLabelBuilder = 1;
  var zrUtil2 = util$6;
  var textContain2 = text;
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var _axisHelper = requireAxisHelper();
  var makeLabelFormatter = _axisHelper.makeLabelFormatter;
  var getOptionCategoryInterval = _axisHelper.getOptionCategoryInterval;
  var shouldShowAllLabels = _axisHelper.shouldShowAllLabels;
  var inner2 = makeInner2();
  function createAxisLabels(axis2) {
    return axis2.type === "category" ? makeCategoryLabels(axis2) : makeRealNumberLabels(axis2);
  }
  function createAxisTicks(axis2, tickModel) {
    return axis2.type === "category" ? makeCategoryTicks(axis2, tickModel) : {
      ticks: axis2.scale.getTicks()
    };
  }
  function makeCategoryLabels(axis2) {
    var labelModel = axis2.getLabelModel();
    var result = makeCategoryLabelsActually(axis2, labelModel);
    return !labelModel.get("show") || axis2.scale.isBlank() ? {
      labels: [],
      labelCategoryInterval: result.labelCategoryInterval
    } : result;
  }
  function makeCategoryLabelsActually(axis2, labelModel) {
    var labelsCache = getListCache(axis2, "labels");
    var optionLabelInterval = getOptionCategoryInterval(labelModel);
    var result = listCacheGet(labelsCache, optionLabelInterval);
    if (result) {
      return result;
    }
    var labels;
    var numericLabelInterval;
    if (zrUtil2.isFunction(optionLabelInterval)) {
      labels = makeLabelsByCustomizedCategoryInterval(axis2, optionLabelInterval);
    } else {
      numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis2) : optionLabelInterval;
      labels = makeLabelsByNumericCategoryInterval(axis2, numericLabelInterval);
    }
    return listCacheSet(labelsCache, optionLabelInterval, {
      labels,
      labelCategoryInterval: numericLabelInterval
    });
  }
  function makeCategoryTicks(axis2, tickModel) {
    var ticksCache = getListCache(axis2, "ticks");
    var optionTickInterval = getOptionCategoryInterval(tickModel);
    var result = listCacheGet(ticksCache, optionTickInterval);
    if (result) {
      return result;
    }
    var ticks;
    var tickCategoryInterval;
    if (!tickModel.get("show") || axis2.scale.isBlank()) {
      ticks = [];
    }
    if (zrUtil2.isFunction(optionTickInterval)) {
      ticks = makeLabelsByCustomizedCategoryInterval(axis2, optionTickInterval, true);
    } else if (optionTickInterval === "auto") {
      var labelsResult = makeCategoryLabelsActually(axis2, axis2.getLabelModel());
      tickCategoryInterval = labelsResult.labelCategoryInterval;
      ticks = zrUtil2.map(labelsResult.labels, function(labelItem) {
        return labelItem.tickValue;
      });
    } else {
      tickCategoryInterval = optionTickInterval;
      ticks = makeLabelsByNumericCategoryInterval(axis2, tickCategoryInterval, true);
    }
    return listCacheSet(ticksCache, optionTickInterval, {
      ticks,
      tickCategoryInterval
    });
  }
  function makeRealNumberLabels(axis2) {
    var ticks = axis2.scale.getTicks();
    var labelFormatter = makeLabelFormatter(axis2);
    return {
      labels: zrUtil2.map(ticks, function(tickValue, idx) {
        return {
          formattedLabel: labelFormatter(tickValue, idx),
          rawLabel: axis2.scale.getLabel(tickValue),
          tickValue
        };
      })
    };
  }
  function getListCache(axis2, prop) {
    return inner2(axis2)[prop] || (inner2(axis2)[prop] = []);
  }
  function listCacheGet(cache, key) {
    for (var i = 0; i < cache.length; i++) {
      if (cache[i].key === key) {
        return cache[i].value;
      }
    }
  }
  function listCacheSet(cache, key, value) {
    cache.push({
      key,
      value
    });
    return value;
  }
  function makeAutoCategoryInterval(axis2) {
    var result = inner2(axis2).autoInterval;
    return result != null ? result : inner2(axis2).autoInterval = axis2.calculateCategoryInterval();
  }
  function calculateCategoryInterval(axis2) {
    var params = fetchAutoCategoryIntervalCalculationParams(axis2);
    var labelFormatter = makeLabelFormatter(axis2);
    var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
    var ordinalScale = axis2.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    var step = 1;
    if (tickCount > 40) {
      step = Math.max(1, Math.floor(tickCount / 40));
    }
    var tickValue = ordinalExtent[0];
    var unitSpan = axis2.dataToCoord(tickValue + 1) - axis2.dataToCoord(tickValue);
    var unitW = Math.abs(unitSpan * Math.cos(rotation));
    var unitH = Math.abs(unitSpan * Math.sin(rotation));
    var maxW = 0;
    var maxH = 0;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      var width = 0;
      var height = 0;
      var rect = textContain2.getBoundingRect(labelFormatter(tickValue), params.font, "center", "top");
      width = rect.width * 1.3;
      height = rect.height * 1.3;
      maxW = Math.max(maxW, width, 7);
      maxH = Math.max(maxH, height, 7);
    }
    var dw = maxW / unitW;
    var dh = maxH / unitH;
    isNaN(dw) && (dw = Infinity);
    isNaN(dh) && (dh = Infinity);
    var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
    var cache = inner2(axis2.model);
    var axisExtent = axis2.getExtent();
    var lastAutoInterval = cache.lastAutoInterval;
    var lastTickCount = cache.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtend0 === axisExtent[0] && cache.axisExtend1 === axisExtent[1]) {
      interval = lastAutoInterval;
    } else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
      cache.axisExtend0 = axisExtent[0];
      cache.axisExtend1 = axisExtent[1];
    }
    return interval;
  }
  function fetchAutoCategoryIntervalCalculationParams(axis2) {
    var labelModel = axis2.getLabelModel();
    return {
      axisRotate: axis2.getRotate ? axis2.getRotate() : axis2.isHorizontal && !axis2.isHorizontal() ? 90 : 0,
      labelRotate: labelModel.get("rotate") || 0,
      font: labelModel.getFont()
    };
  }
  function makeLabelsByNumericCategoryInterval(axis2, categoryInterval, onlyTick) {
    var labelFormatter = makeLabelFormatter(axis2);
    var ordinalScale = axis2.scale;
    var ordinalExtent = ordinalScale.getExtent();
    var labelModel = axis2.getLabelModel();
    var result = [];
    var step = Math.max((categoryInterval || 0) + 1, 1);
    var startTick = ordinalExtent[0];
    var tickCount = ordinalScale.count();
    if (startTick !== 0 && step > 1 && tickCount / step > 2) {
      startTick = Math.round(Math.ceil(startTick / step) * step);
    }
    var showAllLabel = shouldShowAllLabels(axis2);
    var includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
    var includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
    if (includeMinLabel && startTick !== ordinalExtent[0]) {
      addItem(ordinalExtent[0]);
    }
    var tickValue = startTick;
    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      addItem(tickValue);
    }
    if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
      addItem(ordinalExtent[1]);
    }
    function addItem(tVal) {
      result.push(onlyTick ? tVal : {
        formattedLabel: labelFormatter(tVal),
        rawLabel: ordinalScale.getLabel(tVal),
        tickValue: tVal
      });
    }
    return result;
  }
  function makeLabelsByCustomizedCategoryInterval(axis2, categoryInterval, onlyTick) {
    var ordinalScale = axis2.scale;
    var labelFormatter = makeLabelFormatter(axis2);
    var result = [];
    zrUtil2.each(ordinalScale.getTicks(), function(tickValue) {
      var rawLabel = ordinalScale.getLabel(tickValue);
      if (categoryInterval(tickValue, rawLabel)) {
        result.push(onlyTick ? tickValue : {
          formattedLabel: labelFormatter(tickValue),
          rawLabel,
          tickValue
        });
      }
    });
    return result;
  }
  axisTickLabelBuilder.createAxisLabels = createAxisLabels;
  axisTickLabelBuilder.createAxisTicks = createAxisTicks;
  axisTickLabelBuilder.calculateCategoryInterval = calculateCategoryInterval;
  return axisTickLabelBuilder;
}
var Axis_1;
var hasRequiredAxis$1;
function requireAxis$1() {
  if (hasRequiredAxis$1)
    return Axis_1;
  hasRequiredAxis$1 = 1;
  var _util2 = util$6;
  var each2 = _util2.each;
  var map2 = _util2.map;
  var _number2 = requireNumber();
  var linearMap = _number2.linearMap;
  var getPixelPrecision = _number2.getPixelPrecision;
  var round2 = _number2.round;
  var _axisTickLabelBuilder = requireAxisTickLabelBuilder();
  var createAxisTicks = _axisTickLabelBuilder.createAxisTicks;
  var createAxisLabels = _axisTickLabelBuilder.createAxisLabels;
  var calculateCategoryInterval = _axisTickLabelBuilder.calculateCategoryInterval;
  var NORMALIZED_EXTENT = [0, 1];
  var Axis = function(dim, scale, extent) {
    this.dim = dim;
    this.scale = scale;
    this._extent = extent || [0, 0];
    this.inverse = false;
    this.onBand = false;
  };
  Axis.prototype = {
    constructor: Axis,
    /**
     * If axis extent contain given coord
     * @param {number} coord
     * @return {boolean}
     */
    contain: function(coord) {
      var extent = this._extent;
      var min3 = Math.min(extent[0], extent[1]);
      var max3 = Math.max(extent[0], extent[1]);
      return coord >= min3 && coord <= max3;
    },
    /**
     * If axis extent contain given data
     * @param {number} data
     * @return {boolean}
     */
    containData: function(data) {
      return this.scale.contain(data);
    },
    /**
     * Get coord extent.
     * @return {Array.<number>}
     */
    getExtent: function() {
      return this._extent.slice();
    },
    /**
     * Get precision used for formatting
     * @param {Array.<number>} [dataExtent]
     * @return {number}
     */
    getPixelPrecision: function(dataExtent) {
      return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
    },
    /**
     * Set coord extent
     * @param {number} start
     * @param {number} end
     */
    setExtent: function(start, end) {
      var extent = this._extent;
      extent[0] = start;
      extent[1] = end;
    },
    /**
     * Convert data to coord. Data is the rank if it has an ordinal scale
     * @param {number} data
     * @param  {boolean} clamp
     * @return {number}
     */
    dataToCoord: function(data, clamp) {
      var extent = this._extent;
      var scale = this.scale;
      data = scale.normalize(data);
      if (this.onBand && scale.type === "ordinal") {
        extent = extent.slice();
        fixExtentWithBands(extent, scale.count());
      }
      return linearMap(data, NORMALIZED_EXTENT, extent, clamp);
    },
    /**
     * Convert coord to data. Data is the rank if it has an ordinal scale
     * @param {number} coord
     * @param  {boolean} clamp
     * @return {number}
     */
    coordToData: function(coord, clamp) {
      var extent = this._extent;
      var scale = this.scale;
      if (this.onBand && scale.type === "ordinal") {
        extent = extent.slice();
        fixExtentWithBands(extent, scale.count());
      }
      var t2 = linearMap(coord, extent, NORMALIZED_EXTENT, clamp);
      return this.scale.scale(t2);
    },
    /**
     * Convert pixel point to data in axis
     * @param {Array.<number>} point
     * @param  {boolean} clamp
     * @return {number} data
     */
    pointToData: function(point, clamp) {
    },
    /**
     * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
     * `axis.getTicksCoords` considers `onBand`, which is used by
     * `boundaryGap:true` of category axis and splitLine and splitArea.
     * @param {Object} [opt]
     * @param {Model} [opt.tickModel=axis.model.getModel('axisTick')]
     * @param {boolean} [opt.clamp] If `true`, the first and the last
     *        tick must be at the axis end points. Otherwise, clip ticks
     *        that outside the axis extent.
     * @return {Array.<Object>} [{
     *     coord: ...,
     *     tickValue: ...
     * }, ...]
     */
    getTicksCoords: function(opt) {
      opt = opt || {};
      var tickModel = opt.tickModel || this.getTickModel();
      var result = createAxisTicks(this, tickModel);
      var ticks = result.ticks;
      var ticksCoords = map2(ticks, function(tickValue) {
        return {
          coord: this.dataToCoord(tickValue),
          tickValue
        };
      }, this);
      var alignWithLabel = tickModel.get("alignWithLabel");
      fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
      return ticksCoords;
    },
    /**
     * @return {Array.<Array.<Object>>} [{ coord: ..., tickValue: ...}]
     */
    getMinorTicksCoords: function() {
      if (this.scale.type === "ordinal") {
        return [];
      }
      var minorTickModel = this.model.getModel("minorTick");
      var splitNumber = minorTickModel.get("splitNumber");
      if (!(splitNumber > 0 && splitNumber < 100)) {
        splitNumber = 5;
      }
      var minorTicks = this.scale.getMinorTicks(splitNumber);
      var minorTicksCoords = map2(minorTicks, function(minorTicksGroup) {
        return map2(minorTicksGroup, function(minorTick) {
          return {
            coord: this.dataToCoord(minorTick),
            tickValue: minorTick
          };
        }, this);
      }, this);
      return minorTicksCoords;
    },
    /**
     * @return {Array.<Object>} [{
     *     formattedLabel: string,
     *     rawLabel: axis.scale.getLabel(tickValue)
     *     tickValue: number
     * }, ...]
     */
    getViewLabels: function() {
      return createAxisLabels(this).labels;
    },
    /**
     * @return {module:echarts/coord/model/Model}
     */
    getLabelModel: function() {
      return this.model.getModel("axisLabel");
    },
    /**
     * Notice here we only get the default tick model. For splitLine
     * or splitArea, we should pass the splitLineModel or splitAreaModel
     * manually when calling `getTicksCoords`.
     * In GL, this method may be overrided to:
     * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
     * @return {module:echarts/coord/model/Model}
     */
    getTickModel: function() {
      return this.model.getModel("axisTick");
    },
    /**
     * Get width of band
     * @return {number}
     */
    getBandWidth: function() {
      var axisExtent = this._extent;
      var dataExtent = this.scale.getExtent();
      var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
      len === 0 && (len = 1);
      var size2 = Math.abs(axisExtent[1] - axisExtent[0]);
      return Math.abs(size2) / len;
    },
    /**
     * @abstract
     * @return {boolean} Is horizontal
     */
    isHorizontal: null,
    /**
     * @abstract
     * @return {number} Get axis rotate, by degree.
     */
    getRotate: null,
    /**
     * Only be called in category axis.
     * Can be overrided, consider other axes like in 3D.
     * @return {number} Auto interval for cateogry axis tick and label
     */
    calculateCategoryInterval: function() {
      return calculateCategoryInterval(this);
    }
  };
  function fixExtentWithBands(extent, nTick) {
    var size2 = extent[1] - extent[0];
    var len = nTick;
    var margin = size2 / len / 2;
    extent[0] += margin;
    extent[1] -= margin;
  }
  function fixOnBandTicksCoords(axis2, ticksCoords, alignWithLabel, clamp) {
    var ticksLen = ticksCoords.length;
    if (!axis2.onBand || alignWithLabel || !ticksLen) {
      return;
    }
    var axisExtent = axis2.getExtent();
    var last;
    var diffSize;
    if (ticksLen === 1) {
      ticksCoords[0].coord = axisExtent[0];
      last = ticksCoords[1] = {
        coord: axisExtent[0]
      };
    } else {
      var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
      var shift = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
      each2(ticksCoords, function(ticksItem) {
        ticksItem.coord -= shift / 2;
      });
      var dataExtent = axis2.scale.getExtent();
      diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
      last = {
        coord: ticksCoords[ticksLen - 1].coord + shift * diffSize
      };
      ticksCoords.push(last);
    }
    var inverse = axisExtent[0] > axisExtent[1];
    if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
      clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
    }
    if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
      ticksCoords.unshift({
        coord: axisExtent[0]
      });
    }
    if (littleThan(axisExtent[1], last.coord)) {
      clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
    }
    if (clamp && littleThan(last.coord, axisExtent[1])) {
      ticksCoords.push({
        coord: axisExtent[1]
      });
    }
    function littleThan(a, b) {
      a = round2(a);
      b = round2(b);
      return inverse ? a > b : a < b;
    }
  }
  var _default2 = Axis;
  Axis_1 = _default2;
  return Axis_1;
}
var hasRequired_export;
function require_export() {
  if (hasRequired_export)
    return _export;
  hasRequired_export = 1;
  var zrender$1 = zrender;
  _export.zrender = zrender$1;
  var matrix2 = requireMatrix();
  _export.matrix = matrix2;
  var vector2 = requireVector();
  _export.vector = vector2;
  var zrUtil2 = util$6;
  var colorTool2 = color$1;
  _export.color = colorTool2;
  var graphicUtil2 = graphic$4;
  var numberUtil = requireNumber();
  _export.number = numberUtil;
  var formatUtil2 = requireFormat();
  _export.format = formatUtil2;
  var _throttle = throttle$1;
  _throttle.throttle;
  _export.throttle = _throttle.throttle;
  var ecHelper = requireHelper$4();
  _export.helper = ecHelper;
  var parseGeoJSON = requireParseGeoJson();
  _export.parseGeoJSON = parseGeoJSON;
  var _List = requireList();
  _export.List = _List;
  var _Model = requireModel();
  _export.Model = _Model;
  var _Axis = requireAxis$1();
  _export.Axis = _Axis;
  var _env = env_1;
  _export.env = _env;
  var parseGeoJson2 = parseGeoJSON;
  var ecUtil = {};
  zrUtil2.each(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function(name2) {
    ecUtil[name2] = zrUtil2[name2];
  });
  var graphic2 = {};
  zrUtil2.each(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "registerShape", "getShapeClass", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function(name2) {
    graphic2[name2] = graphicUtil2[name2];
  });
  _export.parseGeoJson = parseGeoJson2;
  _export.util = ecUtil;
  _export.graphic = graphic2;
  return _export;
}
(function(exports2) {
  var zrender$1 = zrender;
  var zrUtil2 = util$6;
  var colorTool2 = color$1;
  var env2 = env_1;
  var timsort2 = timsort$2;
  var Eventful2 = Eventful_1;
  var GlobalModel2 = Global;
  var ExtensionAPI2 = ExtensionAPI_1;
  var CoordinateSystemManager2 = CoordinateSystem;
  var OptionManager2 = OptionManager_1;
  var backwardCompat2 = backwardCompat$2;
  var dataStack$1 = dataStack;
  var ComponentModel2 = Component$2;
  var SeriesModel2 = Series;
  var ComponentView = Component_1;
  var ChartView = Chart_1;
  var graphic2 = graphic$4;
  var modelUtil2 = model;
  var _throttle = throttle$1;
  var throttle2 = _throttle.throttle;
  var seriesColor$1 = seriesColor;
  var aria$1 = aria;
  var loadingDefault = _default_1;
  var Scheduler2 = Scheduler_1;
  var lightTheme = light;
  var darkTheme = dark;
  requireDataset();
  var mapDataStorage$1 = mapDataStorage;
  var assert2 = zrUtil2.assert;
  var each2 = zrUtil2.each;
  var isFunction2 = zrUtil2.isFunction;
  var isObject2 = zrUtil2.isObject;
  var parseClassType2 = ComponentModel2.parseClassType;
  var version2 = "4.9.0";
  var dependencies = {
    zrender: "4.3.2"
  };
  var TEST_FRAME_REMAIN_TIME = 1;
  var PRIORITY_PROCESSOR_FILTER = 1e3;
  var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
  var PRIORITY_PROCESSOR_DATASTACK = 900;
  var PRIORITY_PROCESSOR_STATISTIC = 5e3;
  var PRIORITY_VISUAL_LAYOUT = 1e3;
  var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
  var PRIORITY_VISUAL_GLOBAL = 2e3;
  var PRIORITY_VISUAL_CHART = 3e3;
  var PRIORITY_VISUAL_POST_CHART_LAYOUT = 3500;
  var PRIORITY_VISUAL_COMPONENT = 4e3;
  var PRIORITY_VISUAL_BRUSH = 5e3;
  var PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH
    }
  };
  var IN_MAIN_PROCESS = "__flagInMainProcess";
  var OPTION_UPDATED = "__optionUpdated";
  var ACTION_REG = /^[a-zA-Z0-9_]+$/;
  function createRegisterEventWithLowercaseName(method, ignoreDisposed) {
    return function(eventName, handler, context) {
      if (!ignoreDisposed && this._disposed) {
        disposedWarning(this.id);
        return;
      }
      eventName = eventName && eventName.toLowerCase();
      Eventful2.prototype[method].call(this, eventName, handler, context);
    };
  }
  function MessageCenter() {
    Eventful2.call(this);
  }
  MessageCenter.prototype.on = createRegisterEventWithLowercaseName("on", true);
  MessageCenter.prototype.off = createRegisterEventWithLowercaseName("off", true);
  MessageCenter.prototype.one = createRegisterEventWithLowercaseName("one", true);
  zrUtil2.mixin(MessageCenter, Eventful2);
  function ECharts(dom2, theme2, opts) {
    opts = opts || {};
    if (typeof theme2 === "string") {
      theme2 = themeStorage[theme2];
    }
    this.id;
    this.group;
    this._dom = dom2;
    var defaultRenderer = "canvas";
    var zr = this._zr = zrender$1.init(dom2, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height
    });
    this._throttledZrFlush = throttle2(zrUtil2.bind(zr.flush, zr), 17);
    var theme2 = zrUtil2.clone(theme2);
    theme2 && backwardCompat2(theme2, true);
    this._theme = theme2;
    this._chartsViews = [];
    this._chartsMap = {};
    this._componentsViews = [];
    this._componentsMap = {};
    this._coordSysMgr = new CoordinateSystemManager2();
    var api = this._api = createExtensionAPI(this);
    function prioritySortFunc(a, b) {
      return a.__prio - b.__prio;
    }
    timsort2(visualFuncs, prioritySortFunc);
    timsort2(dataProcessorFuncs, prioritySortFunc);
    this._scheduler = new Scheduler2(this, api, dataProcessorFuncs, visualFuncs);
    Eventful2.call(this, this._ecEventProcessor = new EventProcessor());
    this._messageCenter = new MessageCenter();
    this._initEvents();
    this.resize = zrUtil2.bind(this.resize, this);
    this._pendingActions = [];
    zr.animation.on("frame", this._onframe, this);
    bindRenderedEvent(zr, this);
    zrUtil2.setAsPrimitive(this);
  }
  var echartsProto = ECharts.prototype;
  echartsProto._onframe = function() {
    if (this._disposed) {
      return;
    }
    var scheduler = this._scheduler;
    if (this[OPTION_UPDATED]) {
      var silent = this[OPTION_UPDATED].silent;
      this[IN_MAIN_PROCESS] = true;
      prepare(this);
      updateMethods.update.call(this);
      this[IN_MAIN_PROCESS] = false;
      this[OPTION_UPDATED] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      var remainTime = TEST_FRAME_REMAIN_TIME;
      var ecModel = this._model;
      var api = this._api;
      scheduler.unfinished = false;
      do {
        var startTime = +/* @__PURE__ */ new Date();
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api, "remain");
        remainTime -= +/* @__PURE__ */ new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  };
  echartsProto.getDom = function() {
    return this._dom;
  };
  echartsProto.getZr = function() {
    return this._zr;
  };
  echartsProto.setOption = function(option, notMerge, lazyUpdate) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var silent;
    if (isObject2(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS] = true;
    if (!this._model || notMerge) {
      var optionManager = new OptionManager2(this._api);
      var theme2 = this._theme;
      var ecModel = this._model = new GlobalModel2();
      ecModel.scheduler = this._scheduler;
      ecModel.init(null, null, theme2, optionManager);
    }
    this._model.setOption(option, optionPreprocessorFuncs);
    if (lazyUpdate) {
      this[OPTION_UPDATED] = {
        silent
      };
      this[IN_MAIN_PROCESS] = false;
    } else {
      prepare(this);
      updateMethods.update.call(this);
      this._zr.flush();
      this[OPTION_UPDATED] = false;
      this[IN_MAIN_PROCESS] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  };
  echartsProto.setTheme = function() {
    console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
  };
  echartsProto.getModel = function() {
    return this._model;
  };
  echartsProto.getOption = function() {
    return this._model && this._model.getOption();
  };
  echartsProto.getWidth = function() {
    return this._zr.getWidth();
  };
  echartsProto.getHeight = function() {
    return this._zr.getHeight();
  };
  echartsProto.getDevicePixelRatio = function() {
    return this._zr.painter.dpr || window.devicePixelRatio || 1;
  };
  echartsProto.getRenderedCanvas = function(opts) {
    if (!env2.canvasSupported) {
      return;
    }
    opts = opts || {};
    opts.pixelRatio = opts.pixelRatio || 1;
    opts.backgroundColor = opts.backgroundColor || this._model.get("backgroundColor");
    var zr = this._zr;
    return zr.painter.getRenderedCanvas(opts);
  };
  echartsProto.getSvgDataURL = function() {
    if (!env2.svgSupported) {
      return;
    }
    var zr = this._zr;
    var list = zr.storage.getDisplayList();
    zrUtil2.each(list, function(el) {
      el.stopAnimation(true);
    });
    return zr.painter.toDataURL();
  };
  echartsProto.getDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    var excludeComponents = opts.excludeComponents;
    var ecModel = this._model;
    var excludesComponentViews = [];
    var self2 = this;
    each2(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component2) {
        var view = self2._componentsMap[component2.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    var url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.getRenderedCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each2(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url;
  };
  echartsProto.getConnectedDataURL = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!env2.canvasSupported) {
      return;
    }
    var isSvg = opts.type === "svg";
    var groupId = this.group;
    var mathMin2 = Math.min;
    var mathMax2 = Math.max;
    var MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      var left = MAX_NUMBER;
      var top = MAX_NUMBER;
      var right = -MAX_NUMBER;
      var bottom = -MAX_NUMBER;
      var canvasList = [];
      var dpr2 = opts && opts.pixelRatio || 1;
      zrUtil2.each(instances2, function(chart, id) {
        if (chart.group === groupId) {
          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.getRenderedCanvas(zrUtil2.clone(opts));
          var boundingRect = chart.getDom().getBoundingClientRect();
          left = mathMin2(boundingRect.left, left);
          top = mathMin2(boundingRect.top, top);
          right = mathMax2(boundingRect.right, right);
          bottom = mathMax2(boundingRect.bottom, bottom);
          canvasList.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left *= dpr2;
      top *= dpr2;
      right *= dpr2;
      bottom *= dpr2;
      var width = right - left;
      var height = bottom - top;
      var targetCanvas = zrUtil2.createCanvas();
      var zr = zrender$1.init(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr.resize({
        width,
        height
      });
      if (isSvg) {
        var content = "";
        each2(canvasList, function(item) {
          var x = item.left - left;
          var y = item.top - top;
          content += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
        });
        zr.painter.getSvgRoot().innerHTML = content;
        if (opts.connectedBackgroundColor) {
          zr.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr.refreshImmediately();
        return zr.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr.add(new graphic2.Rect({
            shape: {
              x: 0,
              y: 0,
              width,
              height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each2(canvasList, function(item) {
          var img = new graphic2.Image({
            style: {
              x: item.left * dpr2 - left,
              y: item.top * dpr2 - top,
              image: item.dom
            }
          });
          zr.add(img);
        });
        zr.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  };
  echartsProto.convertToPixel = zrUtil2.curry(doConvertPixel, "convertToPixel");
  echartsProto.convertFromPixel = zrUtil2.curry(doConvertPixel, "convertFromPixel");
  function doConvertPixel(methodName, finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var ecModel = this._model;
    var coordSysList = this._coordSysMgr.getCoordinateSystems();
    var result;
    finder = modelUtil2.parseFinder(ecModel, finder);
    for (var i = 0; i < coordSysList.length; i++) {
      var coordSys = coordSysList[i];
      if (coordSys[methodName] && (result = coordSys[methodName](ecModel, finder, value)) != null) {
        return result;
      }
    }
  }
  echartsProto.containPixel = function(finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var ecModel = this._model;
    var result;
    finder = modelUtil2.parseFinder(ecModel, finder);
    zrUtil2.each(finder, function(models, key) {
      key.indexOf("Models") >= 0 && zrUtil2.each(models, function(model2) {
        var coordSys = model2.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result |= !!coordSys.containPoint(value);
        } else if (key === "seriesModels") {
          var view = this._chartsMap[model2.__viewId];
          if (view && view.containPoint) {
            result |= view.containPoint(value, model2);
          }
        } else
          ;
      }, this);
    }, this);
    return !!result;
  };
  echartsProto.getVisual = function(finder, visualType) {
    var ecModel = this._model;
    finder = modelUtil2.parseFinder(ecModel, finder, {
      defaultMainType: "series"
    });
    var seriesModel = finder.seriesModel;
    var data = seriesModel.getData();
    var dataIndexInside = finder.hasOwnProperty("dataIndexInside") ? finder.dataIndexInside : finder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(finder.dataIndex) : null;
    return dataIndexInside != null ? data.getItemVisual(dataIndexInside, visualType) : data.getVisual(visualType);
  };
  echartsProto.getViewOfComponentModel = function(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  };
  echartsProto.getViewOfSeriesModel = function(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  };
  var updateMethods = {
    prepareAndUpdate: function(payload) {
      prepare(this);
      updateMethods.update.call(this, payload);
    },
    /**
     * @param {Object} payload
     * @private
     */
    update: function(payload) {
      var ecModel = this._model;
      var api = this._api;
      var zr = this._zr;
      var coordSysMgr = this._coordSysMgr;
      var scheduler = this._scheduler;
      if (!ecModel) {
        return;
      }
      scheduler.restoreData(ecModel, payload);
      scheduler.performSeriesTasks(ecModel);
      coordSysMgr.create(ecModel, api);
      scheduler.performDataProcessorTasks(ecModel, payload);
      updateStreamModes(this, ecModel);
      coordSysMgr.update(ecModel, api);
      clearColorPalette(ecModel);
      scheduler.performVisualTasks(ecModel, payload);
      render(this, ecModel, api, payload);
      var backgroundColor = ecModel.get("backgroundColor") || "transparent";
      if (!env2.canvasSupported) {
        var colorArr = colorTool2.parse(backgroundColor);
        backgroundColor = colorTool2.stringify(colorArr, "rgb");
        if (colorArr[3] === 0) {
          backgroundColor = "transparent";
        }
      } else {
        zr.setBackgroundColor(backgroundColor);
      }
      performPostUpdateFuncs(ecModel, api);
    },
    /**
     * @param {Object} payload
     * @private
     */
    updateTransform: function(payload) {
      var ecModel = this._model;
      var ecIns = this;
      var api = this._api;
      if (!ecModel) {
        return;
      }
      var componentDirtyList = [];
      ecModel.eachComponent(function(componentType, componentModel) {
        var componentView = ecIns.getViewOfComponentModel(componentModel);
        if (componentView && componentView.__alive) {
          if (componentView.updateTransform) {
            var result = componentView.updateTransform(componentModel, ecModel, api, payload);
            result && result.update && componentDirtyList.push(componentView);
          } else {
            componentDirtyList.push(componentView);
          }
        }
      });
      var seriesDirtyMap = zrUtil2.createHashMap();
      ecModel.eachSeries(function(seriesModel) {
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        if (chartView.updateTransform) {
          var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
          result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
        } else {
          seriesDirtyMap.set(seriesModel.uid, 1);
        }
      });
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {
        setDirty: true,
        dirtyMap: seriesDirtyMap
      });
      renderSeries(ecIns, ecModel, api, payload, seriesDirtyMap);
      performPostUpdateFuncs(ecModel, this._api);
    },
    /**
     * @param {Object} payload
     * @private
     */
    updateView: function(payload) {
      var ecModel = this._model;
      if (!ecModel) {
        return;
      }
      ChartView.markUpdateMethod(payload, "updateView");
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {
        setDirty: true
      });
      render(this, this._model, this._api, payload);
      performPostUpdateFuncs(ecModel, this._api);
    },
    /**
     * @param {Object} payload
     * @private
     */
    updateVisual: function(payload) {
      updateMethods.update.call(this, payload);
    },
    /**
     * @param {Object} payload
     * @private
     */
    updateLayout: function(payload) {
      updateMethods.update.call(this, payload);
    }
  };
  function prepare(ecIns) {
    var ecModel = ecIns._model;
    var scheduler = ecIns._scheduler;
    scheduler.restorePipelines(ecModel);
    scheduler.prepareStageTasks();
    prepareView(ecIns, "component", ecModel, scheduler);
    prepareView(ecIns, "chart", ecModel, scheduler);
    scheduler.plan();
  }
  function updateDirectly(ecIns, method, payload, mainType, subType) {
    var ecModel = ecIns._model;
    if (!mainType) {
      each2(ecIns._componentsViews.concat(ecIns._chartsViews), callView);
      return;
    }
    var query = {};
    query[mainType + "Id"] = payload[mainType + "Id"];
    query[mainType + "Index"] = payload[mainType + "Index"];
    query[mainType + "Name"] = payload[mainType + "Name"];
    var condition = {
      mainType,
      query
    };
    subType && (condition.subType = subType);
    var excludeSeriesId = payload.excludeSeriesId;
    if (excludeSeriesId != null) {
      excludeSeriesId = zrUtil2.createHashMap(modelUtil2.normalizeToArray(excludeSeriesId));
    }
    ecModel && ecModel.eachComponent(condition, function(model2) {
      if (!excludeSeriesId || excludeSeriesId.get(model2.id) == null) {
        callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model2.__viewId]);
      }
    }, ecIns);
    function callView(view) {
      view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
    }
  }
  echartsProto.resize = function(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    var ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    var optionChanged = ecModel.resetOption("media");
    var silent = opts && opts.silent;
    this[IN_MAIN_PROCESS] = true;
    optionChanged && prepare(this);
    updateMethods.update.call(this);
    this[IN_MAIN_PROCESS] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  };
  function updateStreamModes(ecIns, ecModel) {
    var chartsMap = ecIns._chartsMap;
    var scheduler = ecIns._scheduler;
    ecModel.eachSeries(function(seriesModel) {
      scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
    });
  }
  echartsProto.showLoading = function(name2, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject2(name2)) {
      cfg = name2;
      name2 = "";
    }
    name2 = name2 || "default";
    this.hideLoading();
    if (!loadingEffects[name2]) {
      return;
    }
    var el = loadingEffects[name2](this._api, cfg);
    var zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  };
  echartsProto.hideLoading = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  };
  echartsProto.makeActionFromEvent = function(eventObj) {
    var payload = zrUtil2.extend({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  };
  echartsProto.dispatchAction = function(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject2(opt)) {
      opt = {
        silent: !!opt
      };
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS]) {
      this._pendingActions.push(payload);
      return;
    }
    doDispatchAction.call(this, payload, opt.silent);
    if (opt.flush) {
      this._zr.flush(true);
    } else if (opt.flush !== false && env2.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, opt.silent);
    triggerUpdatedEvent.call(this, opt.silent);
  };
  function doDispatchAction(payload, silent) {
    var payloadType = payload.type;
    var escapeConnect = payload.escapeConnect;
    var actionWrap = actions[payloadType];
    var actionInfo = actionWrap.actionInfo;
    var cptType = (actionInfo.update || "update").split(":");
    var updateMethod = cptType.pop();
    cptType = cptType[0] != null && parseClassType2(cptType[0]);
    this[IN_MAIN_PROCESS] = true;
    var payloads = [payload];
    var batched = false;
    if (payload.batch) {
      batched = true;
      payloads = zrUtil2.map(payload.batch, function(item) {
        item = zrUtil2.defaults(zrUtil2.extend({}, item), payload);
        item.batch = null;
        return item;
      });
    }
    var eventObjBatch = [];
    var eventObj;
    var isHighDown = payloadType === "highlight" || payloadType === "downplay";
    each2(payloads, function(batchItem) {
      eventObj = actionWrap.action(batchItem, this._model, this._api);
      eventObj = eventObj || zrUtil2.extend({}, batchItem);
      eventObj.type = actionInfo.event || eventObj.type;
      eventObjBatch.push(eventObj);
      if (isHighDown) {
        updateDirectly(this, updateMethod, batchItem, "series");
      } else if (cptType) {
        updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
      }
    }, this);
    if (updateMethod !== "none" && !isHighDown && !cptType) {
      if (this[OPTION_UPDATED]) {
        prepare(this);
        updateMethods.update.call(this, payload);
        this[OPTION_UPDATED] = false;
      } else {
        updateMethods[updateMethod].call(this, payload);
      }
    }
    if (batched) {
      eventObj = {
        type: actionInfo.event || payloadType,
        escapeConnect,
        batch: eventObjBatch
      };
    } else {
      eventObj = eventObjBatch[0];
    }
    this[IN_MAIN_PROCESS] = false;
    !silent && this._messageCenter.trigger(eventObj.type, eventObj);
  }
  function flushPendingActions(silent) {
    var pendingActions = this._pendingActions;
    while (pendingActions.length) {
      var payload = pendingActions.shift();
      doDispatchAction.call(this, payload, silent);
    }
  }
  function triggerUpdatedEvent(silent) {
    !silent && this.trigger("updated");
  }
  function bindRenderedEvent(zr, ecIns) {
    zr.on("rendered", function() {
      ecIns.trigger("rendered");
      if (
        // Although zr is dirty if initial animation is not finished
        // and this checking is called on frame, we also check
        // animation finished for robustness.
        zr.animation.isFinished() && !ecIns[OPTION_UPDATED] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length
      ) {
        ecIns.trigger("finished");
      }
    });
  }
  echartsProto.appendData = function(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    var seriesIndex = params.seriesIndex;
    var ecModel = this.getModel();
    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
  };
  echartsProto.on = createRegisterEventWithLowercaseName("on", false);
  echartsProto.off = createRegisterEventWithLowercaseName("off", false);
  echartsProto.one = createRegisterEventWithLowercaseName("one", false);
  function prepareView(ecIns, type, ecModel, scheduler) {
    var isComponent = type === "component";
    var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
    var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
    var zr = ecIns._zr;
    var api = ecIns._api;
    for (var i = 0; i < viewList.length; i++) {
      viewList[i].__alive = false;
    }
    isComponent ? ecModel.eachComponent(function(componentType, model2) {
      componentType !== "series" && doPrepare(model2);
    }) : ecModel.eachSeries(doPrepare);
    function doPrepare(model2) {
      var viewId = "_ec_" + model2.id + "_" + model2.type;
      var view2 = viewMap[viewId];
      if (!view2) {
        var classType = parseClassType2(model2.type);
        var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);
        view2 = new Clazz();
        view2.init(ecModel, api);
        viewMap[viewId] = view2;
        viewList.push(view2);
        zr.add(view2.group);
      }
      model2.__viewId = view2.__id = viewId;
      view2.__alive = true;
      view2.__model = model2;
      view2.group.__ecComponentInfo = {
        mainType: model2.mainType,
        index: model2.componentIndex
      };
      !isComponent && scheduler.prepareView(view2, model2, ecModel, api);
    }
    for (var i = 0; i < viewList.length; ) {
      var view = viewList[i];
      if (!view.__alive) {
        !isComponent && view.renderTask.dispose();
        zr.remove(view.group);
        view.dispose(ecModel, api);
        viewList.splice(i, 1);
        delete viewMap[view.__id];
        view.__id = view.group.__ecComponentInfo = null;
      } else {
        i++;
      }
    }
  }
  function clearColorPalette(ecModel) {
    ecModel.clearColorPalette();
    ecModel.eachSeries(function(seriesModel) {
      seriesModel.clearColorPalette();
    });
  }
  function render(ecIns, ecModel, api, payload) {
    renderComponents(ecIns, ecModel, api, payload);
    each2(ecIns._chartsViews, function(chart) {
      chart.__alive = false;
    });
    renderSeries(ecIns, ecModel, api, payload);
    each2(ecIns._chartsViews, function(chart) {
      if (!chart.__alive) {
        chart.remove(ecModel, api);
      }
    });
  }
  function renderComponents(ecIns, ecModel, api, payload, dirtyList) {
    each2(dirtyList || ecIns._componentsViews, function(componentView) {
      var componentModel = componentView.__model;
      componentView.render(componentModel, ecModel, api, payload);
      updateZ(componentModel, componentView);
    });
  }
  function renderSeries(ecIns, ecModel, api, payload, dirtyMap) {
    var scheduler = ecIns._scheduler;
    var unfinished;
    ecModel.eachSeries(function(seriesModel) {
      var chartView = ecIns._chartsMap[seriesModel.__viewId];
      chartView.__alive = true;
      var renderTask = chartView.renderTask;
      scheduler.updatePayload(renderTask, payload);
      if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
        renderTask.dirty();
      }
      unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask));
      chartView.group.silent = !!seriesModel.get("silent");
      updateZ(seriesModel, chartView);
      updateBlend(seriesModel, chartView);
    });
    scheduler.unfinished |= unfinished;
    updateHoverLayerStatus(ecIns, ecModel);
    aria$1(ecIns._zr.dom, ecModel);
  }
  function performPostUpdateFuncs(ecModel, api) {
    each2(postUpdateFuncs, function(func) {
      func(ecModel, api);
    });
  }
  var MOUSE_EVENT_NAMES = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
  echartsProto._initEvents = function() {
    each2(MOUSE_EVENT_NAMES, function(eveName) {
      var handler = function(e2) {
        var ecModel = this.getModel();
        var el = e2.target;
        var params;
        var isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else if (el && el.dataIndex != null) {
          var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
          params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType, el) || {};
        } else if (el && el.eventData) {
          params = zrUtil2.extend({}, el.eventData);
        }
        if (params) {
          var componentType = params.componentType;
          var componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          var model2 = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          var view = model2 && this[model2.mainType === "series" ? "_chartsMap" : "_componentsMap"][model2.__viewId];
          params.event = e2;
          params.type = eveName;
          this._ecEventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model: model2,
            view
          };
          this.trigger(eveName, params);
        }
      };
      handler.zrEventfulCallAtLast = true;
      this._zr.on(eveName, handler, this);
    }, this);
    each2(eventActionMap, function(actionType, eventType) {
      this._messageCenter.on(eventType, function(event2) {
        this.trigger(eventType, event2);
      }, this);
    }, this);
  };
  echartsProto.isDisposed = function() {
    return this._disposed;
  };
  echartsProto.clear = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({
      series: []
    }, true);
  };
  echartsProto.dispose = function() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    modelUtil2.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    var api = this._api;
    var ecModel = this._model;
    each2(this._componentsViews, function(component2) {
      component2.dispose(ecModel, api);
    });
    each2(this._chartsViews, function(chart) {
      chart.dispose(ecModel, api);
    });
    this._zr.dispose();
    delete instances2[this.id];
  };
  zrUtil2.mixin(ECharts, Eventful2);
  function disposedWarning(id) {
  }
  function updateHoverLayerStatus(ecIns, ecModel) {
    var zr = ecIns._zr;
    var storage2 = zr.storage;
    var elCount = 0;
    storage2.traverse(function(el) {
      elCount++;
    });
    if (elCount > ecModel.get("hoverLayerThreshold") && !env2.node) {
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.preventUsingHoverLayer) {
          return;
        }
        var chartView = ecIns._chartsMap[seriesModel.__viewId];
        if (chartView.__alive) {
          chartView.group.traverse(function(el) {
            el.useHoverLayer = true;
          });
        }
      });
    }
  }
  function updateBlend(seriesModel, chartView) {
    var blendMode = seriesModel.get("blendMode") || null;
    chartView.group.traverse(function(el) {
      if (!el.isGroup) {
        if (el.style.blend !== blendMode) {
          el.setStyle("blend", blendMode);
        }
      }
      if (el.eachPendingDisplayable) {
        el.eachPendingDisplayable(function(displayable) {
          displayable.setStyle("blend", blendMode);
        });
      }
    });
  }
  function updateZ(model2, view) {
    var z = model2.get("z");
    var zlevel = model2.get("zlevel");
    view.group.traverse(function(el) {
      if (el.type !== "group") {
        z != null && (el.z = z);
        zlevel != null && (el.zlevel = zlevel);
      }
    });
  }
  function createExtensionAPI(ecInstance) {
    var coordSysMgr = ecInstance._coordSysMgr;
    return zrUtil2.extend(new ExtensionAPI2(ecInstance), {
      // Inject methods
      getCoordinateSystems: zrUtil2.bind(coordSysMgr.getCoordinateSystems, coordSysMgr),
      getComponentByElement: function(el) {
        while (el) {
          var modelInfo = el.__ecComponentInfo;
          if (modelInfo != null) {
            return ecInstance._model.getComponent(modelInfo.mainType, modelInfo.index);
          }
          el = el.parent;
        }
      }
    });
  }
  function EventProcessor() {
    this.eventInfo;
  }
  EventProcessor.prototype = {
    constructor: EventProcessor,
    normalizeQuery: function(query) {
      var cptQuery = {};
      var dataQuery = {};
      var otherQuery = {};
      if (zrUtil2.isString(query)) {
        var condCptType = parseClassType2(query);
        cptQuery.mainType = condCptType.main || null;
        cptQuery.subType = condCptType.sub || null;
      } else {
        var suffixes = ["Index", "Name", "Id"];
        var dataKeys = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        zrUtil2.each(query, function(val, key) {
          var reserved = false;
          for (var i = 0; i < suffixes.length; i++) {
            var propSuffix = suffixes[i];
            var suffixPos = key.lastIndexOf(propSuffix);
            if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
              var mainType = key.slice(0, suffixPos);
              if (mainType !== "data") {
                cptQuery.mainType = mainType;
                cptQuery[propSuffix.toLowerCase()] = val;
                reserved = true;
              }
            }
          }
          if (dataKeys.hasOwnProperty(key)) {
            dataQuery[key] = val;
            reserved = true;
          }
          if (!reserved) {
            otherQuery[key] = val;
          }
        });
      }
      return {
        cptQuery,
        dataQuery,
        otherQuery
      };
    },
    filter: function(eventType, query, args) {
      var eventInfo = this.eventInfo;
      if (!eventInfo) {
        return true;
      }
      var targetEl = eventInfo.targetEl;
      var packedEvent = eventInfo.packedEvent;
      var model2 = eventInfo.model;
      var view = eventInfo.view;
      if (!model2 || !view) {
        return true;
      }
      var cptQuery = query.cptQuery;
      var dataQuery = query.dataQuery;
      return check(cptQuery, model2, "mainType") && check(cptQuery, model2, "subType") && check(cptQuery, model2, "index", "componentIndex") && check(cptQuery, model2, "name") && check(cptQuery, model2, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
      function check(query2, host2, prop, propOnHost) {
        return query2[prop] == null || host2[propOnHost || prop] === query2[prop];
      }
    },
    afterTrigger: function() {
      this.eventInfo = null;
    }
  };
  var actions = {};
  var eventActionMap = {};
  var dataProcessorFuncs = [];
  var optionPreprocessorFuncs = [];
  var postUpdateFuncs = [];
  var visualFuncs = [];
  var themeStorage = {};
  var loadingEffects = {};
  var instances2 = {};
  var connectedGroups = {};
  var idBase = /* @__PURE__ */ new Date() - 0;
  var groupIdBase = /* @__PURE__ */ new Date() - 0;
  var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
  function enableConnect(chart) {
    var STATUS_PENDING = 0;
    var STATUS_UPDATING = 1;
    var STATUS_UPDATED = 2;
    var STATUS_KEY = "__connectUpdateStatus";
    function updateConnectedChartsStatus(charts, status) {
      for (var i = 0; i < charts.length; i++) {
        var otherChart = charts[i];
        otherChart[STATUS_KEY] = status;
      }
    }
    each2(eventActionMap, function(actionType, eventType) {
      chart._messageCenter.on(eventType, function(event2) {
        if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
          if (event2 && event2.escapeConnect) {
            return;
          }
          var action = chart.makeActionFromEvent(event2);
          var otherCharts = [];
          each2(instances2, function(otherChart) {
            if (otherChart !== chart && otherChart.group === chart.group) {
              otherCharts.push(otherChart);
            }
          });
          updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
          each2(otherCharts, function(otherChart) {
            if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
              otherChart.dispatchAction(action);
            }
          });
          updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
        }
      });
    });
  }
  function init2(dom2, theme2, opts) {
    var existInstance = getInstanceByDom(dom2);
    if (existInstance) {
      return existInstance;
    }
    var chart = new ECharts(dom2, theme2, opts);
    chart.id = "ec_" + idBase++;
    instances2[chart.id] = chart;
    modelUtil2.setAttribute(dom2, DOM_ATTRIBUTE_KEY, chart.id);
    enableConnect(chart);
    return chart;
  }
  function connect(groupId) {
    if (zrUtil2.isArray(groupId)) {
      var charts = groupId;
      groupId = null;
      each2(charts, function(chart) {
        if (chart.group != null) {
          groupId = chart.group;
        }
      });
      groupId = groupId || "g_" + groupIdBase++;
      each2(charts, function(chart) {
        chart.group = groupId;
      });
    }
    connectedGroups[groupId] = true;
    return groupId;
  }
  function disConnect(groupId) {
    connectedGroups[groupId] = false;
  }
  var disconnect = disConnect;
  function dispose2(chart) {
    if (typeof chart === "string") {
      chart = instances2[chart];
    } else if (!(chart instanceof ECharts)) {
      chart = getInstanceByDom(chart);
    }
    if (chart instanceof ECharts && !chart.isDisposed()) {
      chart.dispose();
    }
  }
  function getInstanceByDom(dom2) {
    return instances2[modelUtil2.getAttribute(dom2, DOM_ATTRIBUTE_KEY)];
  }
  function getInstanceById(key) {
    return instances2[key];
  }
  function registerTheme(name2, theme2) {
    themeStorage[name2] = theme2;
  }
  function registerPreprocessor(preprocessorFunc) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
  function registerProcessor(priority, processor) {
    normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_FILTER);
  }
  function registerPostUpdate(postUpdateFunc) {
    postUpdateFuncs.push(postUpdateFunc);
  }
  function registerAction(actionInfo, eventName, action) {
    if (typeof eventName === "function") {
      action = eventName;
      eventName = "";
    }
    var actionType = isObject2(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
      event: eventName
    }][0];
    actionInfo.event = (actionInfo.event || actionType).toLowerCase();
    eventName = actionInfo.event;
    assert2(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
    if (!actions[actionType]) {
      actions[actionType] = {
        action,
        actionInfo
      };
    }
    eventActionMap[eventName] = actionType;
  }
  function registerCoordinateSystem(type, CoordinateSystem2) {
    CoordinateSystemManager2.register(type, CoordinateSystem2);
  }
  function getCoordinateSystemDimensions(type) {
    var coordSysCreator = CoordinateSystemManager2.get(type);
    if (coordSysCreator) {
      return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
    }
  }
  function registerLayout(priority, layoutTask) {
    normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
  }
  function registerVisual(priority, visualTask) {
    normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
  }
  function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
    if (isFunction2(priority) || isObject2(priority)) {
      fn = priority;
      priority = defaultPriority;
    }
    var stageHandler = Scheduler2.wrapStageHandler(fn, visualType);
    stageHandler.__prio = priority;
    stageHandler.__raw = fn;
    targetList.push(stageHandler);
    return stageHandler;
  }
  function registerLoading(name2, loadingFx) {
    loadingEffects[name2] = loadingFx;
  }
  function extendComponentModel(opts) {
    return ComponentModel2.extend(opts);
  }
  function extendComponentView(opts) {
    return ComponentView.extend(opts);
  }
  function extendSeriesModel(opts) {
    return SeriesModel2.extend(opts);
  }
  function extendChartView(opts) {
    return ChartView.extend(opts);
  }
  function setCanvasCreator(creator) {
    zrUtil2.$override("createCanvas", creator);
  }
  function registerMap(mapName, geoJson, specialAreas) {
    mapDataStorage$1.registerMap(mapName, geoJson, specialAreas);
  }
  function getMap(mapName) {
    var records = mapDataStorage$1.retrieveMap(mapName);
    return records && records[0] && {
      geoJson: records[0].geoJSON,
      specialAreas: records[0].specialAreas
    };
  }
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesColor$1);
  registerPreprocessor(backwardCompat2);
  registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack$1);
  registerLoading("default", loadingDefault);
  registerAction({
    type: "highlight",
    event: "highlight",
    update: "highlight"
  }, zrUtil2.noop);
  registerAction({
    type: "downplay",
    event: "downplay",
    update: "downplay"
  }, zrUtil2.noop);
  registerTheme("light", lightTheme);
  registerTheme("dark", darkTheme);
  var dataTool = {};
  exports2.version = version2;
  exports2.dependencies = dependencies;
  exports2.PRIORITY = PRIORITY;
  exports2.init = init2;
  exports2.connect = connect;
  exports2.disConnect = disConnect;
  exports2.disconnect = disconnect;
  exports2.dispose = dispose2;
  exports2.getInstanceByDom = getInstanceByDom;
  exports2.getInstanceById = getInstanceById;
  exports2.registerTheme = registerTheme;
  exports2.registerPreprocessor = registerPreprocessor;
  exports2.registerProcessor = registerProcessor;
  exports2.registerPostUpdate = registerPostUpdate;
  exports2.registerAction = registerAction;
  exports2.registerCoordinateSystem = registerCoordinateSystem;
  exports2.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
  exports2.registerLayout = registerLayout;
  exports2.registerVisual = registerVisual;
  exports2.registerLoading = registerLoading;
  exports2.extendComponentModel = extendComponentModel;
  exports2.extendComponentView = extendComponentView;
  exports2.extendSeriesModel = extendSeriesModel;
  exports2.extendChartView = extendChartView;
  exports2.setCanvasCreator = setCanvasCreator;
  exports2.registerMap = registerMap;
  exports2.getMap = getMap;
  exports2.dataTool = dataTool;
  var ___ec_export = require_export();
  (function() {
    for (var key in ___ec_export) {
      if (___ec_export.hasOwnProperty(key)) {
        exports2[key] = ___ec_export[key];
      }
    }
  })();
})(echarts);
var line = {};
var LineSeries;
var hasRequiredLineSeries;
function requireLineSeries() {
  if (hasRequiredLineSeries)
    return LineSeries;
  hasRequiredLineSeries = 1;
  var createListFromArray = requireCreateListFromArray();
  var SeriesModel2 = Series;
  var _default2 = SeriesModel2.extend({
    type: "series.line",
    dependencies: ["grid", "polar"],
    getInitialData: function(option, ecModel) {
      return createListFromArray(this.getSource(), this, {
        useEncodeDefaulter: true
      });
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      hoverAnimation: true,
      // stack: null
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // If clip the overflow value
      clip: true,
      // cursor: null,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: false,
      // Disabled if step is true
      smooth: false,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: true,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: false,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: Infinity
    }
  });
  LineSeries = _default2;
  return LineSeries;
}
var labelHelper = {};
var hasRequiredLabelHelper;
function requireLabelHelper() {
  if (hasRequiredLabelHelper)
    return labelHelper;
  hasRequiredLabelHelper = 1;
  var _dataProvider2 = dataProvider;
  var retrieveRawValue2 = _dataProvider2.retrieveRawValue;
  function getDefaultLabel(data, dataIndex) {
    var labelDims = data.mapDimension("defaultedLabel", true);
    var len = labelDims.length;
    if (len === 1) {
      return retrieveRawValue2(data, dataIndex, labelDims[0]);
    } else if (len) {
      var vals = [];
      for (var i = 0; i < labelDims.length; i++) {
        var val = retrieveRawValue2(data, dataIndex, labelDims[i]);
        vals.push(val);
      }
      return vals.join(" ");
    }
  }
  labelHelper.getDefaultLabel = getDefaultLabel;
  return labelHelper;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol)
    return _Symbol;
  hasRequired_Symbol = 1;
  var zrUtil2 = util$6;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var graphic2 = graphic$4;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var _labelHelper = requireLabelHelper();
  var getDefaultLabel = _labelHelper.getDefaultLabel;
  function SymbolClz(data, idx, seriesScope) {
    graphic2.Group.call(this);
    this.updateData(data, idx, seriesScope);
  }
  var symbolProto = SymbolClz.prototype;
  var getSymbolSize = SymbolClz.getSymbolSize = function(data, idx) {
    var symbolSize = data.getItemVisual(idx, "symbolSize");
    return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
  };
  function getScale(symbolSize) {
    return [symbolSize[0] / 2, symbolSize[1] / 2];
  }
  function driftSymbol(dx, dy) {
    this.parent.drift(dx, dy);
  }
  symbolProto._createSymbol = function(symbolType, data, idx, symbolSize, keepAspect) {
    this.removeAll();
    var color2 = data.getItemVisual(idx, "color");
    var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color2, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scale: getScale(symbolSize)
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  };
  symbolProto.stopSymbolAnimation = function(toLastFrame) {
    this.childAt(0).stopAnimation(toLastFrame);
  };
  symbolProto.getSymbolPath = function() {
    return this.childAt(0);
  };
  symbolProto.getScale = function() {
    return this.childAt(0).scale;
  };
  symbolProto.highlight = function() {
    this.childAt(0).trigger("emphasis");
  };
  symbolProto.downplay = function() {
    this.childAt(0).trigger("normal");
  };
  symbolProto.setZ = function(zlevel, z) {
    var symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  };
  symbolProto.setDraggable = function(draggable) {
    var symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = draggable ? "move" : symbolPath.cursor;
  };
  symbolProto.updateData = function(data, idx, seriesScope) {
    this.silent = false;
    var symbolType = data.getItemVisual(idx, "symbol") || "circle";
    var seriesModel = data.hostModel;
    var symbolSize = getSymbolSize(data, idx);
    var isInit = symbolType !== this._symbolType;
    if (isInit) {
      var keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      var symbolPath = this.childAt(0);
      symbolPath.silent = false;
      graphic2.updateProps(symbolPath, {
        scale: getScale(symbolSize)
      }, seriesModel, idx);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope);
    if (isInit) {
      var symbolPath = this.childAt(0);
      var fadeIn = seriesScope && seriesScope.fadeIn;
      var target = {
        scale: symbolPath.scale.slice()
      };
      fadeIn && (target.style = {
        opacity: symbolPath.style.opacity
      });
      symbolPath.scale = [0, 0];
      fadeIn && (symbolPath.style.opacity = 0);
      graphic2.initProps(symbolPath, target, seriesModel, idx);
    }
    this._seriesModel = seriesModel;
  };
  var normalStyleAccessPath = ["itemStyle"];
  var emphasisStyleAccessPath = ["emphasis", "itemStyle"];
  var normalLabelAccessPath = ["label"];
  var emphasisLabelAccessPath = ["emphasis", "label"];
  symbolProto._updateCommon = function(data, idx, symbolSize, seriesScope) {
    var symbolPath = this.childAt(0);
    var seriesModel = data.hostModel;
    var color2 = data.getItemVisual(idx, "color");
    if (symbolPath.type !== "image") {
      symbolPath.useStyle({
        strokeNoScale: true
      });
    } else {
      symbolPath.setStyle({
        opacity: 1,
        shadowBlur: null,
        shadowOffsetX: null,
        shadowOffsetY: null,
        shadowColor: null
      });
    }
    var itemStyle2 = seriesScope && seriesScope.itemStyle;
    var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
    var symbolOffset = seriesScope && seriesScope.symbolOffset;
    var labelModel = seriesScope && seriesScope.labelModel;
    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
    var hoverAnimation = seriesScope && seriesScope.hoverAnimation;
    var cursorStyle = seriesScope && seriesScope.cursorStyle;
    if (!seriesScope || data.hasItemOption) {
      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      itemStyle2 = itemModel.getModel(normalStyleAccessPath).getItemStyle(["color"]);
      hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
      symbolOffset = itemModel.getShallow("symbolOffset");
      labelModel = itemModel.getModel(normalLabelAccessPath);
      hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
      hoverAnimation = itemModel.getShallow("hoverAnimation");
      cursorStyle = itemModel.getShallow("cursor");
    } else {
      hoverItemStyle = zrUtil2.extend({}, hoverItemStyle);
    }
    var elStyle = symbolPath.style;
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    if (symbolOffset) {
      symbolPath.attr("position", [parsePercent2(symbolOffset[0], symbolSize[0]), parsePercent2(symbolOffset[1], symbolSize[1])]);
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    symbolPath.setColor(color2, seriesScope && seriesScope.symbolInnerColor);
    symbolPath.setStyle(itemStyle2);
    var opacity = data.getItemVisual(idx, "opacity");
    if (opacity != null) {
      elStyle.opacity = opacity;
    }
    var liftZ = data.getItemVisual(idx, "liftZ");
    var z2Origin = symbolPath.__z2Origin;
    if (liftZ != null) {
      if (z2Origin == null) {
        symbolPath.__z2Origin = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      symbolPath.__z2Origin = null;
    }
    var useNameLabel = seriesScope && seriesScope.useNameLabel;
    graphic2.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      isRectText: true,
      autoColor: color2
    });
    function getLabelDefaultText(idx2, opt) {
      return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
    }
    symbolPath.__symbolOriginalScale = getScale(symbolSize);
    symbolPath.hoverStyle = hoverItemStyle;
    symbolPath.highDownOnUpdate = hoverAnimation && seriesModel.isAnimationEnabled() ? highDownOnUpdate : null;
    graphic2.setHoverStyle(symbolPath);
  };
  function highDownOnUpdate(fromState, toState) {
    if (this.incremental || this.useHoverLayer) {
      return;
    }
    if (toState === "emphasis") {
      var scale = this.__symbolOriginalScale;
      var ratio = scale[1] / scale[0];
      var emphasisOpt = {
        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]
      };
      this.animateTo(emphasisOpt, 400, "elasticOut");
    } else if (toState === "normal") {
      this.animateTo({
        scale: this.__symbolOriginalScale
      }, 400, "elasticOut");
    }
  }
  symbolProto.fadeOut = function(cb, opt) {
    var symbolPath = this.childAt(0);
    this.silent = symbolPath.silent = true;
    !(opt && opt.keepLabel) && (symbolPath.style.text = null);
    graphic2.updateProps(symbolPath, {
      style: {
        opacity: 0
      },
      scale: [0, 0]
    }, this._seriesModel, this.dataIndex, cb);
  };
  zrUtil2.inherits(SymbolClz, graphic2.Group);
  var _default2 = SymbolClz;
  _Symbol = _default2;
  return _Symbol;
}
var SymbolDraw_1;
var hasRequiredSymbolDraw;
function requireSymbolDraw() {
  if (hasRequiredSymbolDraw)
    return SymbolDraw_1;
  hasRequiredSymbolDraw = 1;
  var graphic2 = graphic$4;
  var SymbolClz = require_Symbol();
  var _util2 = util$6;
  var isObject2 = _util2.isObject;
  function SymbolDraw(symbolCtor) {
    this.group = new graphic2.Group();
    this._symbolCtor = symbolCtor || SymbolClz;
  }
  var symbolDrawProto = SymbolDraw.prototype;
  function symbolNeedsDraw(data, point, idx, opt) {
    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
  }
  symbolDrawProto.updateData = function(data, opt) {
    opt = normalizeUpdateOpt(opt);
    var group = this.group;
    var seriesModel = data.hostModel;
    var oldData = this._data;
    var SymbolCtor = this._symbolCtor;
    var seriesScope = makeSeriesScope(data);
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      var point = data.getItemLayout(newIdx);
      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
        symbolEl.attr("position", point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      var symbolEl = oldData.getItemGraphicEl(oldIdx);
      var point = data.getItemLayout(newIdx);
      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      if (!symbolEl) {
        symbolEl = new SymbolCtor(data, newIdx);
        symbolEl.attr("position", point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope);
        graphic2.updateProps(symbolEl, {
          position: point
        }, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      var el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      });
    }).execute();
    this._data = data;
  };
  symbolDrawProto.isPersistent = function() {
    return true;
  };
  symbolDrawProto.updateLayout = function() {
    var data = this._data;
    if (data) {
      data.eachItemGraphicEl(function(el, idx) {
        var point = data.getItemLayout(idx);
        el.attr("position", point);
      });
    }
  };
  symbolDrawProto.incrementalPrepareUpdate = function(data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  };
  symbolDrawProto.incrementalUpdate = function(taskParams, data, opt) {
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup) {
        el2.incremental = el2.useHoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var point = data.getItemLayout(idx);
      if (symbolNeedsDraw(data, point, idx, opt)) {
        var el = new this._symbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.attr("position", point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
      }
    }
  };
  function normalizeUpdateOpt(opt) {
    if (opt != null && !isObject2(opt)) {
      opt = {
        isIgnore: opt
      };
    }
    return opt || {};
  }
  symbolDrawProto.remove = function(enableAnimation) {
    var group = this.group;
    var data = this._data;
    if (data && enableAnimation) {
      data.eachItemGraphicEl(function(el) {
        el.fadeOut(function() {
          group.remove(el);
        });
      });
    } else {
      group.removeAll();
    }
  };
  function makeSeriesScope(data) {
    var seriesModel = data.hostModel;
    return {
      itemStyle: seriesModel.getModel("itemStyle").getItemStyle(["color"]),
      hoverItemStyle: seriesModel.getModel("emphasis.itemStyle").getItemStyle(),
      symbolRotate: seriesModel.get("symbolRotate"),
      symbolOffset: seriesModel.get("symbolOffset"),
      hoverAnimation: seriesModel.get("hoverAnimation"),
      labelModel: seriesModel.getModel("label"),
      hoverLabelModel: seriesModel.getModel("emphasis.label"),
      cursorStyle: seriesModel.get("cursor")
    };
  }
  var _default2 = SymbolDraw;
  SymbolDraw_1 = _default2;
  return SymbolDraw_1;
}
var helper$3 = {};
var hasRequiredHelper$3;
function requireHelper$3() {
  if (hasRequiredHelper$3)
    return helper$3;
  hasRequiredHelper$3 = 1;
  var _dataStackHelper = requireDataStackHelper();
  var isDimensionStacked = _dataStackHelper.isDimensionStacked;
  var _util2 = util$6;
  var map2 = _util2.map;
  function prepareDataCoordInfo(coordSys, data, valueOrigin) {
    var baseAxis = coordSys.getBaseAxis();
    var valueAxis = coordSys.getOtherAxis(baseAxis);
    var valueStart = getValueStart(valueAxis, valueOrigin);
    var baseAxisDim = baseAxis.dim;
    var valueAxisDim = valueAxis.dim;
    var valueDim = data.mapDimension(valueAxisDim);
    var baseDim = data.mapDimension(baseAxisDim);
    var baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
    var dims = map2(coordSys.dimensions, function(coordDim) {
      return data.mapDimension(coordDim);
    });
    var stacked;
    var stackResultDim = data.getCalculationInfo("stackResultDimension");
    if (stacked |= isDimensionStacked(
      data,
      dims[0]
      /*, dims[1]*/
    )) {
      dims[0] = stackResultDim;
    }
    if (stacked |= isDimensionStacked(
      data,
      dims[1]
      /*, dims[0]*/
    )) {
      dims[1] = stackResultDim;
    }
    return {
      dataDimsForPoint: dims,
      valueStart,
      valueAxisDim,
      baseAxisDim,
      stacked: !!stacked,
      valueDim,
      baseDim,
      baseDataOffset,
      stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
    };
  }
  function getValueStart(valueAxis, valueOrigin) {
    var valueStart = 0;
    var extent = valueAxis.scale.getExtent();
    if (valueOrigin === "start") {
      valueStart = extent[0];
    } else if (valueOrigin === "end") {
      valueStart = extent[1];
    } else {
      if (extent[0] > 0) {
        valueStart = extent[0];
      } else if (extent[1] < 0) {
        valueStart = extent[1];
      }
    }
    return valueStart;
  }
  function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
    var value = NaN;
    if (dataCoordInfo.stacked) {
      value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
    }
    if (isNaN(value)) {
      value = dataCoordInfo.valueStart;
    }
    var baseDataOffset = dataCoordInfo.baseDataOffset;
    var stackedData = [];
    stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
    stackedData[1 - baseDataOffset] = value;
    return coordSys.dataToPoint(stackedData);
  }
  helper$3.prepareDataCoordInfo = prepareDataCoordInfo;
  helper$3.getStackedOnPoint = getStackedOnPoint;
  return helper$3;
}
var lineAnimationDiff;
var hasRequiredLineAnimationDiff;
function requireLineAnimationDiff() {
  if (hasRequiredLineAnimationDiff)
    return lineAnimationDiff;
  hasRequiredLineAnimationDiff = 1;
  var _helper = requireHelper$3();
  var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
  var getStackedOnPoint = _helper.getStackedOnPoint;
  function diffData(oldData, newData) {
    var diffResult = [];
    newData.diff(oldData).add(function(idx) {
      diffResult.push({
        cmd: "+",
        idx
      });
    }).update(function(newIdx, oldIdx) {
      diffResult.push({
        cmd: "=",
        idx: oldIdx,
        idx1: newIdx
      });
    }).remove(function(idx) {
      diffResult.push({
        cmd: "-",
        idx
      });
    }).execute();
    return diffResult;
  }
  function _default2(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
    var diff2 = diffData(oldData, newData);
    var currPoints = [];
    var nextPoints = [];
    var currStackedPoints = [];
    var nextStackedPoints = [];
    var status = [];
    var sortedIndices = [];
    var rawIndices = [];
    var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
    var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);
    for (var i = 0; i < diff2.length; i++) {
      var diffItem = diff2[i];
      var pointAdded = true;
      switch (diffItem.cmd) {
        case "=":
          var currentPt = oldData.getItemLayout(diffItem.idx);
          var nextPt = newData.getItemLayout(diffItem.idx1);
          if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
            currentPt = nextPt.slice();
          }
          currPoints.push(currentPt);
          nextPoints.push(nextPt);
          currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
          nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
          rawIndices.push(newData.getRawIndex(diffItem.idx1));
          break;
        case "+":
          var idx = diffItem.idx;
          currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));
          nextPoints.push(newData.getItemLayout(idx).slice());
          currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));
          nextStackedPoints.push(newStackedOnPoints[idx]);
          rawIndices.push(newData.getRawIndex(idx));
          break;
        case "-":
          var idx = diffItem.idx;
          var rawIndex = oldData.getRawIndex(idx);
          if (rawIndex !== idx) {
            currPoints.push(oldData.getItemLayout(idx));
            nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));
            currStackedPoints.push(oldStackedOnPoints[idx]);
            nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));
            rawIndices.push(rawIndex);
          } else {
            pointAdded = false;
          }
      }
      if (pointAdded) {
        status.push(diffItem);
        sortedIndices.push(sortedIndices.length);
      }
    }
    sortedIndices.sort(function(a, b) {
      return rawIndices[a] - rawIndices[b];
    });
    var sortedCurrPoints = [];
    var sortedNextPoints = [];
    var sortedCurrStackedPoints = [];
    var sortedNextStackedPoints = [];
    var sortedStatus = [];
    for (var i = 0; i < sortedIndices.length; i++) {
      var idx = sortedIndices[i];
      sortedCurrPoints[i] = currPoints[idx];
      sortedNextPoints[i] = nextPoints[idx];
      sortedCurrStackedPoints[i] = currStackedPoints[idx];
      sortedNextStackedPoints[i] = nextStackedPoints[idx];
      sortedStatus[i] = status[idx];
    }
    return {
      current: sortedCurrPoints,
      next: sortedNextPoints,
      stackedOnCurrent: sortedCurrStackedPoints,
      stackedOnNext: sortedNextStackedPoints,
      status: sortedStatus
    };
  }
  lineAnimationDiff = _default2;
  return lineAnimationDiff;
}
var poly = {};
var hasRequiredPoly;
function requirePoly() {
  if (hasRequiredPoly)
    return poly;
  hasRequiredPoly = 1;
  var Path2 = Path_1;
  var vec22 = requireVector();
  var fixClipWithShadow2 = fixClipWithShadow$1;
  var vec2Min = vec22.min;
  var vec2Max = vec22.max;
  var scaleAndAdd = vec22.scaleAndAdd;
  var v2Copy = vec22.copy;
  var v = [];
  var cp0 = [];
  var cp1 = [];
  function isPointNull(p2) {
    return isNaN(p2[0]) || isNaN(p2[1]);
  }
  function drawSegment(ctx, points2, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    if (smoothMonotone === "none" || !smoothMonotone) {
      return drawNonMono.apply(this, arguments);
    } else {
      return drawMono.apply(this, arguments);
    }
  }
  function drawMono(ctx, points2, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    var prevIdx = 0;
    var idx = start;
    for (var k = 0; k < segLen; k++) {
      var p2 = points2[idx];
      if (idx >= allLen || idx < 0) {
        break;
      }
      if (isPointNull(p2)) {
        if (connectNulls) {
          idx += dir;
          continue;
        }
        break;
      }
      if (idx === start) {
        ctx[dir > 0 ? "moveTo" : "lineTo"](p2[0], p2[1]);
      } else {
        if (smooth > 0) {
          var prevP = points2[prevIdx];
          var dim = smoothMonotone === "y" ? 1 : 0;
          var ctrlLen = (p2[dim] - prevP[dim]) * smooth;
          v2Copy(cp0, prevP);
          cp0[dim] = prevP[dim] + ctrlLen;
          v2Copy(cp1, p2);
          cp1[dim] = p2[dim] - ctrlLen;
          ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p2[0], p2[1]);
        } else {
          ctx.lineTo(p2[0], p2[1]);
        }
      }
      prevIdx = idx;
      idx += dir;
    }
    return k;
  }
  function drawNonMono(ctx, points2, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {
    var prevIdx = 0;
    var idx = start;
    for (var k = 0; k < segLen; k++) {
      var p2 = points2[idx];
      if (idx >= allLen || idx < 0) {
        break;
      }
      if (isPointNull(p2)) {
        if (connectNulls) {
          idx += dir;
          continue;
        }
        break;
      }
      if (idx === start) {
        ctx[dir > 0 ? "moveTo" : "lineTo"](p2[0], p2[1]);
        v2Copy(cp0, p2);
      } else {
        if (smooth > 0) {
          var nextIdx = idx + dir;
          var nextP = points2[nextIdx];
          if (connectNulls) {
            while (nextP && isPointNull(points2[nextIdx])) {
              nextIdx += dir;
              nextP = points2[nextIdx];
            }
          }
          var ratioNextSeg = 0.5;
          var prevP = points2[prevIdx];
          var nextP = points2[nextIdx];
          if (!nextP || isPointNull(nextP)) {
            v2Copy(cp1, p2);
          } else {
            if (isPointNull(nextP) && !connectNulls) {
              nextP = p2;
            }
            vec22.sub(v, nextP, prevP);
            var lenPrevSeg;
            var lenNextSeg;
            if (smoothMonotone === "x" || smoothMonotone === "y") {
              var dim = smoothMonotone === "x" ? 0 : 1;
              lenPrevSeg = Math.abs(p2[dim] - prevP[dim]);
              lenNextSeg = Math.abs(p2[dim] - nextP[dim]);
            } else {
              lenPrevSeg = vec22.dist(p2, prevP);
              lenNextSeg = vec22.dist(p2, nextP);
            }
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            scaleAndAdd(cp1, p2, v, -smooth * (1 - ratioNextSeg));
          }
          vec2Min(cp0, cp0, smoothMax);
          vec2Max(cp0, cp0, smoothMin);
          vec2Min(cp1, cp1, smoothMax);
          vec2Max(cp1, cp1, smoothMin);
          ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p2[0], p2[1]);
          scaleAndAdd(cp0, p2, v, smooth * ratioNextSeg);
        } else {
          ctx.lineTo(p2[0], p2[1]);
        }
      }
      prevIdx = idx;
      idx += dir;
    }
    return k;
  }
  function getBoundingBox(points2, smoothConstraint) {
    var ptMin = [Infinity, Infinity];
    var ptMax = [-Infinity, -Infinity];
    if (smoothConstraint) {
      for (var i = 0; i < points2.length; i++) {
        var pt = points2[i];
        if (pt[0] < ptMin[0]) {
          ptMin[0] = pt[0];
        }
        if (pt[1] < ptMin[1]) {
          ptMin[1] = pt[1];
        }
        if (pt[0] > ptMax[0]) {
          ptMax[0] = pt[0];
        }
        if (pt[1] > ptMax[1]) {
          ptMax[1] = pt[1];
        }
      }
    }
    return {
      min: smoothConstraint ? ptMin : ptMax,
      max: smoothConstraint ? ptMax : ptMin
    };
  }
  var Polyline2 = Path2.extend({
    type: "ec-polyline",
    shape: {
      points: [],
      smooth: 0,
      smoothConstraint: true,
      smoothMonotone: null,
      connectNulls: false
    },
    style: {
      fill: null,
      stroke: "#000"
    },
    brush: fixClipWithShadow2(Path2.prototype.brush),
    buildPath: function(ctx, shape) {
      var points2 = shape.points;
      var i = 0;
      var len = points2.length;
      var result = getBoundingBox(points2, shape.smoothConstraint);
      if (shape.connectNulls) {
        for (; len > 0; len--) {
          if (!isPointNull(points2[len - 1])) {
            break;
          }
        }
        for (; i < len; i++) {
          if (!isPointNull(points2[i])) {
            break;
          }
        }
      }
      while (i < len) {
        i += drawSegment(ctx, points2, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
      }
    }
  });
  var Polygon2 = Path2.extend({
    type: "ec-polygon",
    shape: {
      points: [],
      // Offset between stacked base points and points
      stackedOnPoints: [],
      smooth: 0,
      stackedOnSmooth: 0,
      smoothConstraint: true,
      smoothMonotone: null,
      connectNulls: false
    },
    brush: fixClipWithShadow2(Path2.prototype.brush),
    buildPath: function(ctx, shape) {
      var points2 = shape.points;
      var stackedOnPoints = shape.stackedOnPoints;
      var i = 0;
      var len = points2.length;
      var smoothMonotone = shape.smoothMonotone;
      var bbox2 = getBoundingBox(points2, shape.smoothConstraint);
      var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);
      if (shape.connectNulls) {
        for (; len > 0; len--) {
          if (!isPointNull(points2[len - 1])) {
            break;
          }
        }
        for (; i < len; i++) {
          if (!isPointNull(points2[i])) {
            break;
          }
        }
      }
      while (i < len) {
        var k = drawSegment(ctx, points2, i, len, len, 1, bbox2.min, bbox2.max, shape.smooth, smoothMonotone, shape.connectNulls);
        drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
        i += k + 1;
        ctx.closePath();
      }
    }
  });
  poly.Polyline = Polyline2;
  poly.Polygon = Polygon2;
  return poly;
}
var createClipPathFromCoordSys = {};
var hasRequiredCreateClipPathFromCoordSys;
function requireCreateClipPathFromCoordSys() {
  if (hasRequiredCreateClipPathFromCoordSys)
    return createClipPathFromCoordSys;
  hasRequiredCreateClipPathFromCoordSys = 1;
  var graphic2 = graphic$4;
  var _number2 = requireNumber();
  var round2 = _number2.round;
  function createGridClipPath(cartesian, hasAnimation, seriesModel) {
    var rect = cartesian.getArea();
    var isHorizontal = cartesian.getBaseAxis().isHorizontal();
    var x = rect.x;
    var y = rect.y;
    var width = rect.width;
    var height = rect.height;
    var lineWidth = seriesModel.get("lineStyle.width") || 2;
    x -= lineWidth / 2;
    y -= lineWidth / 2;
    width += lineWidth;
    height += lineWidth;
    x = Math.floor(x);
    width = Math.round(width);
    var clipPath = new graphic2.Rect({
      shape: {
        x,
        y,
        width,
        height
      }
    });
    if (hasAnimation) {
      clipPath.shape[isHorizontal ? "width" : "height"] = 0;
      graphic2.initProps(clipPath, {
        shape: {
          width,
          height
        }
      }, seriesModel);
    }
    return clipPath;
  }
  function createPolarClipPath(polar2, hasAnimation, seriesModel) {
    var sectorArea = polar2.getArea();
    var clipPath = new graphic2.Sector({
      shape: {
        cx: round2(polar2.cx, 1),
        cy: round2(polar2.cy, 1),
        r0: round2(sectorArea.r0, 1),
        r: round2(sectorArea.r, 1),
        startAngle: sectorArea.startAngle,
        endAngle: sectorArea.endAngle,
        clockwise: sectorArea.clockwise
      }
    });
    if (hasAnimation) {
      clipPath.shape.endAngle = sectorArea.startAngle;
      graphic2.initProps(clipPath, {
        shape: {
          endAngle: sectorArea.endAngle
        }
      }, seriesModel);
    }
    return clipPath;
  }
  function createClipPath(coordSys, hasAnimation, seriesModel) {
    if (!coordSys) {
      return null;
    } else if (coordSys.type === "polar") {
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    } else if (coordSys.type === "cartesian2d") {
      return createGridClipPath(coordSys, hasAnimation, seriesModel);
    }
    return null;
  }
  createClipPathFromCoordSys.createGridClipPath = createGridClipPath;
  createClipPathFromCoordSys.createPolarClipPath = createPolarClipPath;
  createClipPathFromCoordSys.createClipPath = createClipPath;
  return createClipPathFromCoordSys;
}
var LineView;
var hasRequiredLineView;
function requireLineView() {
  if (hasRequiredLineView)
    return LineView;
  hasRequiredLineView = 1;
  var zrUtil2 = util$6;
  var _bbox = requireBbox();
  var fromPoints = _bbox.fromPoints;
  var SymbolDraw = requireSymbolDraw();
  var SymbolClz = require_Symbol();
  var lineAnimationDiff2 = requireLineAnimationDiff();
  var graphic2 = graphic$4;
  var modelUtil2 = model;
  var _poly = requirePoly();
  var Polyline2 = _poly.Polyline;
  var Polygon2 = _poly.Polygon;
  var ChartView = Chart_1;
  var _helper = requireHelper$3();
  var prepareDataCoordInfo = _helper.prepareDataCoordInfo;
  var getStackedOnPoint = _helper.getStackedOnPoint;
  var _createClipPathFromCoordSys = requireCreateClipPathFromCoordSys();
  var createGridClipPath = _createClipPathFromCoordSys.createGridClipPath;
  var createPolarClipPath = _createClipPathFromCoordSys.createPolarClipPath;
  function isPointsSame(points1, points2) {
    if (points1.length !== points2.length) {
      return;
    }
    for (var i = 0; i < points1.length; i++) {
      var p1 = points1[i];
      var p2 = points2[i];
      if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
        return;
      }
    }
    return true;
  }
  function getBoundingDiff(points1, points2) {
    var min1 = [];
    var max1 = [];
    var min22 = [];
    var max22 = [];
    fromPoints(points1, min1, max1);
    fromPoints(points2, min22, max22);
    return Math.max(Math.abs(min1[0] - min22[0]), Math.abs(min1[1] - min22[1]), Math.abs(max1[0] - max22[0]), Math.abs(max1[1] - max22[1]));
  }
  function getSmooth(smooth) {
    return typeof smooth === "number" ? smooth : smooth ? 0.5 : 0;
  }
  function getStackedOnPoints(coordSys, data, dataCoordInfo) {
    if (!dataCoordInfo.valueDim) {
      return [];
    }
    var points2 = [];
    for (var idx = 0, len = data.count(); idx < len; idx++) {
      points2.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));
    }
    return points2;
  }
  function turnPointsIntoStep(points2, coordSys, stepTurnAt) {
    var baseAxis = coordSys.getBaseAxis();
    var baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
    var stepPoints = [];
    for (var i = 0; i < points2.length - 1; i++) {
      var nextPt = points2[i + 1];
      var pt = points2[i];
      stepPoints.push(pt);
      var stepPt = [];
      switch (stepTurnAt) {
        case "end":
          stepPt[baseIndex] = nextPt[baseIndex];
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPoints.push(stepPt);
          break;
        case "middle":
          var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
          var stepPt2 = [];
          stepPt[baseIndex] = stepPt2[baseIndex] = middle;
          stepPt[1 - baseIndex] = pt[1 - baseIndex];
          stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt);
          stepPoints.push(stepPt2);
          break;
        default:
          stepPt[baseIndex] = pt[baseIndex];
          stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
          stepPoints.push(stepPt);
      }
    }
    points2[i] && stepPoints.push(points2[i]);
    return stepPoints;
  }
  function getVisualGradient(data, coordSys) {
    var visualMetaList = data.getVisual("visualMeta");
    if (!visualMetaList || !visualMetaList.length || !data.count()) {
      return;
    }
    if (coordSys.type !== "cartesian2d") {
      return;
    }
    var coordDim;
    var visualMeta;
    for (var i = visualMetaList.length - 1; i >= 0; i--) {
      var dimIndex = visualMetaList[i].dimension;
      var dimName = data.dimensions[dimIndex];
      var dimInfo = data.getDimensionInfo(dimName);
      coordDim = dimInfo && dimInfo.coordDim;
      if (coordDim === "x" || coordDim === "y") {
        visualMeta = visualMetaList[i];
        break;
      }
    }
    if (!visualMeta) {
      return;
    }
    var axis2 = coordSys.getAxis(coordDim);
    var colorStops = zrUtil2.map(visualMeta.stops, function(stop2) {
      return {
        coord: axis2.toGlobalCoord(axis2.dataToCoord(stop2.value)),
        color: stop2.color
      };
    });
    var stopLen = colorStops.length;
    var outerColors = visualMeta.outerColors.slice();
    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
      colorStops.reverse();
      outerColors.reverse();
    }
    var tinyExtent = 10;
    var minCoord = colorStops[0].coord - tinyExtent;
    var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
    var coordSpan = maxCoord - minCoord;
    if (coordSpan < 1e-3) {
      return "transparent";
    }
    zrUtil2.each(colorStops, function(stop2) {
      stop2.offset = (stop2.coord - minCoord) / coordSpan;
    });
    colorStops.push({
      offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
      color: outerColors[1] || "transparent"
    });
    colorStops.unshift({
      // notice colorStops.length have been changed.
      offset: stopLen ? colorStops[0].offset : 0.5,
      color: outerColors[0] || "transparent"
    });
    var gradient = new graphic2.LinearGradient(0, 0, 0, 0, colorStops, true);
    gradient[coordDim] = minCoord;
    gradient[coordDim + "2"] = maxCoord;
    return gradient;
  }
  function getIsIgnoreFunc(seriesModel, data, coordSys) {
    var showAllSymbol = seriesModel.get("showAllSymbol");
    var isAuto = showAllSymbol === "auto";
    if (showAllSymbol && !isAuto) {
      return;
    }
    var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
    if (!categoryAxis) {
      return;
    }
    if (isAuto && canShowAllSymbolForCategory(categoryAxis, data)) {
      return;
    }
    var categoryDataDim = data.mapDimension(categoryAxis.dim);
    var labelMap = {};
    zrUtil2.each(categoryAxis.getViewLabels(), function(labelItem) {
      labelMap[labelItem.tickValue] = 1;
    });
    return function(dataIndex) {
      return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
    };
  }
  function canShowAllSymbolForCategory(categoryAxis, data) {
    var axisExtent = categoryAxis.getExtent();
    var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
    isNaN(availSize) && (availSize = 0);
    var dataLen = data.count();
    var step = Math.max(1, Math.round(dataLen / 5));
    for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
      if (SymbolClz.getSymbolSize(
        data,
        dataIndex
        // Only for cartesian, where `isHorizontal` exists.
      )[categoryAxis.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
        return false;
      }
    }
    return true;
  }
  function createLineClipPath(coordSys, hasAnimation, seriesModel) {
    if (coordSys.type === "cartesian2d") {
      var isHorizontal = coordSys.getBaseAxis().isHorizontal();
      var clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel);
      if (!seriesModel.get("clip", true)) {
        var rectShape = clipPath.shape;
        var expandSize = Math.max(rectShape.width, rectShape.height);
        if (isHorizontal) {
          rectShape.y -= expandSize;
          rectShape.height += expandSize * 2;
        } else {
          rectShape.x -= expandSize;
          rectShape.width += expandSize * 2;
        }
      }
      return clipPath;
    } else {
      return createPolarClipPath(coordSys, hasAnimation, seriesModel);
    }
  }
  var _default2 = ChartView.extend({
    type: "line",
    init: function() {
      var lineGroup = new graphic2.Group();
      var symbolDraw = new SymbolDraw();
      this.group.add(symbolDraw.group);
      this._symbolDraw = symbolDraw;
      this._lineGroup = lineGroup;
    },
    render: function(seriesModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var lineStyleModel = seriesModel.getModel("lineStyle");
      var areaStyleModel = seriesModel.getModel("areaStyle");
      var points2 = data.mapArray(data.getItemLayout);
      var isCoordSysPolar = coordSys.type === "polar";
      var prevCoordSys = this._coordSys;
      var symbolDraw = this._symbolDraw;
      var polyline = this._polyline;
      var polygon2 = this._polygon;
      var lineGroup = this._lineGroup;
      var hasAnimation = seriesModel.get("animation");
      var isAreaChart = !areaStyleModel.isEmpty();
      var valueOrigin = areaStyleModel.get("origin");
      var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
      var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);
      var showSymbol = seriesModel.get("showSymbol");
      var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
      var oldData = this._data;
      oldData && oldData.eachItemGraphicEl(function(el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      });
      if (!showSymbol) {
        symbolDraw.remove();
      }
      group.add(lineGroup);
      var step = !isCoordSysPolar && seriesModel.get("step");
      var clipShapeForSymbol;
      if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
        clipShapeForSymbol = coordSys.getArea();
        if (clipShapeForSymbol.width != null) {
          clipShapeForSymbol.x -= 0.1;
          clipShapeForSymbol.y -= 0.1;
          clipShapeForSymbol.width += 0.2;
          clipShapeForSymbol.height += 0.2;
        } else if (clipShapeForSymbol.r0) {
          clipShapeForSymbol.r0 -= 0.5;
          clipShapeForSymbol.r1 += 0.5;
        }
      }
      this._clipShapeForSymbol = clipShapeForSymbol;
      if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
        showSymbol && symbolDraw.updateData(data, {
          isIgnore: isIgnoreFunc,
          clipShape: clipShapeForSymbol
        });
        if (step) {
          points2 = turnPointsIntoStep(points2, coordSys, step);
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
        }
        polyline = this._newPolyline(points2, coordSys, hasAnimation);
        if (isAreaChart) {
          polygon2 = this._newPolygon(points2, stackedOnPoints, coordSys, hasAnimation);
        }
        lineGroup.setClipPath(createLineClipPath(coordSys, true, seriesModel));
      } else {
        if (isAreaChart && !polygon2) {
          polygon2 = this._newPolygon(points2, stackedOnPoints, coordSys, hasAnimation);
        } else if (polygon2 && !isAreaChart) {
          lineGroup.remove(polygon2);
          polygon2 = this._polygon = null;
        }
        lineGroup.setClipPath(createLineClipPath(coordSys, false, seriesModel));
        showSymbol && symbolDraw.updateData(data, {
          isIgnore: isIgnoreFunc,
          clipShape: clipShapeForSymbol
        });
        data.eachItemGraphicEl(function(el) {
          el.stopAnimation(true);
        });
        if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points2)) {
          if (hasAnimation) {
            this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
          } else {
            if (step) {
              points2 = turnPointsIntoStep(points2, coordSys, step);
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
            }
            polyline.setShape({
              points: points2
            });
            polygon2 && polygon2.setShape({
              points: points2,
              stackedOnPoints
            });
          }
        }
      }
      var visualColor = getVisualGradient(data, coordSys) || data.getVisual("color");
      polyline.useStyle(zrUtil2.defaults(
        // Use color in lineStyle first
        lineStyleModel.getLineStyle(),
        {
          fill: "none",
          stroke: visualColor,
          lineJoin: "bevel"
        }
      ));
      var smooth = seriesModel.get("smooth");
      smooth = getSmooth(seriesModel.get("smooth"));
      polyline.setShape({
        smooth,
        smoothMonotone: seriesModel.get("smoothMonotone"),
        connectNulls: seriesModel.get("connectNulls")
      });
      if (polygon2) {
        var stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
        var stackedOnSmooth = 0;
        polygon2.useStyle(zrUtil2.defaults(areaStyleModel.getAreaStyle(), {
          fill: visualColor,
          opacity: 0.7,
          lineJoin: "bevel"
        }));
        if (stackedOnSeries) {
          stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
        }
        polygon2.setShape({
          smooth,
          stackedOnSmooth,
          smoothMonotone: seriesModel.get("smoothMonotone"),
          connectNulls: seriesModel.get("connectNulls")
        });
      }
      this._data = data;
      this._coordSys = coordSys;
      this._stackedOnPoints = stackedOnPoints;
      this._points = points2;
      this._step = step;
      this._valueOrigin = valueOrigin;
    },
    dispose: function() {
    },
    highlight: function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = modelUtil2.queryDataIndex(data, payload);
      if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
        var symbol2 = data.getItemGraphicEl(dataIndex);
        if (!symbol2) {
          var pt = data.getItemLayout(dataIndex);
          if (!pt) {
            return;
          }
          if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(pt[0], pt[1])) {
            return;
          }
          symbol2 = new SymbolClz(data, dataIndex);
          symbol2.position = pt;
          symbol2.setZ(seriesModel.get("zlevel"), seriesModel.get("z"));
          symbol2.ignore = isNaN(pt[0]) || isNaN(pt[1]);
          symbol2.__temp = true;
          data.setItemGraphicEl(dataIndex, symbol2);
          symbol2.stopSymbolAnimation(true);
          this.group.add(symbol2);
        }
        symbol2.highlight();
      } else {
        ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
      }
    },
    downplay: function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var dataIndex = modelUtil2.queryDataIndex(data, payload);
      if (dataIndex != null && dataIndex >= 0) {
        var symbol2 = data.getItemGraphicEl(dataIndex);
        if (symbol2) {
          if (symbol2.__temp) {
            data.setItemGraphicEl(dataIndex, null);
            this.group.remove(symbol2);
          } else {
            symbol2.downplay();
          }
        }
      } else {
        ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
      }
    },
    /**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} points
     * @private
     */
    _newPolyline: function(points2) {
      var polyline = this._polyline;
      if (polyline) {
        this._lineGroup.remove(polyline);
      }
      polyline = new Polyline2({
        shape: {
          points: points2
        },
        silent: true,
        z2: 10
      });
      this._lineGroup.add(polyline);
      this._polyline = polyline;
      return polyline;
    },
    /**
     * @param {module:zrender/container/Group} group
     * @param {Array.<Array.<number>>} stackedOnPoints
     * @param {Array.<Array.<number>>} points
     * @private
     */
    _newPolygon: function(points2, stackedOnPoints) {
      var polygon2 = this._polygon;
      if (polygon2) {
        this._lineGroup.remove(polygon2);
      }
      polygon2 = new Polygon2({
        shape: {
          points: points2,
          stackedOnPoints
        },
        silent: true
      });
      this._lineGroup.add(polygon2);
      this._polygon = polygon2;
      return polygon2;
    },
    /**
     * @private
     */
    // FIXME Two value axis
    _updateAnimation: function(data, stackedOnPoints, coordSys, api, step, valueOrigin) {
      var polyline = this._polyline;
      var polygon2 = this._polygon;
      var seriesModel = data.hostModel;
      var diff2 = lineAnimationDiff2(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
      var current = diff2.current;
      var stackedOnCurrent = diff2.stackedOnCurrent;
      var next = diff2.next;
      var stackedOnNext = diff2.stackedOnNext;
      if (step) {
        current = turnPointsIntoStep(diff2.current, coordSys, step);
        stackedOnCurrent = turnPointsIntoStep(diff2.stackedOnCurrent, coordSys, step);
        next = turnPointsIntoStep(diff2.next, coordSys, step);
        stackedOnNext = turnPointsIntoStep(diff2.stackedOnNext, coordSys, step);
      }
      if (getBoundingDiff(current, next) > 3e3 || polygon2 && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
        polyline.setShape({
          points: next
        });
        if (polygon2) {
          polygon2.setShape({
            points: next,
            stackedOnPoints: stackedOnNext
          });
        }
        return;
      }
      polyline.shape.__points = diff2.current;
      polyline.shape.points = current;
      graphic2.updateProps(polyline, {
        shape: {
          points: next
        }
      }, seriesModel);
      if (polygon2) {
        polygon2.setShape({
          points: current,
          stackedOnPoints: stackedOnCurrent
        });
        graphic2.updateProps(polygon2, {
          shape: {
            points: next,
            stackedOnPoints: stackedOnNext
          }
        }, seriesModel);
      }
      var updatedDataInfo = [];
      var diffStatus = diff2.status;
      for (var i = 0; i < diffStatus.length; i++) {
        var cmd = diffStatus[i].cmd;
        if (cmd === "=") {
          var el = data.getItemGraphicEl(diffStatus[i].idx1);
          if (el) {
            updatedDataInfo.push({
              el,
              ptIdx: i
              // Index of points
            });
          }
        }
      }
      if (polyline.animators && polyline.animators.length) {
        polyline.animators[0].during(function() {
          for (var i2 = 0; i2 < updatedDataInfo.length; i2++) {
            var el2 = updatedDataInfo[i2].el;
            el2.attr("position", polyline.shape.__points[updatedDataInfo[i2].ptIdx]);
          }
        });
      }
    },
    remove: function(ecModel) {
      var group = this.group;
      var oldData = this._data;
      this._lineGroup.removeAll();
      this._symbolDraw.remove(true);
      oldData && oldData.eachItemGraphicEl(function(el, idx) {
        if (el.__temp) {
          group.remove(el);
          oldData.setItemGraphicEl(idx, null);
        }
      });
      this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
    }
  });
  LineView = _default2;
  return LineView;
}
var symbol;
var hasRequiredSymbol;
function requireSymbol() {
  if (hasRequiredSymbol)
    return symbol;
  hasRequiredSymbol = 1;
  var _util2 = util$6;
  var isFunction2 = _util2.isFunction;
  function _default2(seriesType2, defaultSymbolType, legendSymbol) {
    return {
      seriesType: seriesType2,
      // For legend.
      performRawSeries: true,
      reset: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var symbolType = seriesModel.get("symbol");
        var symbolSize = seriesModel.get("symbolSize");
        var keepAspect = seriesModel.get("symbolKeepAspect");
        var symbolRotate = seriesModel.get("symbolRotate");
        var hasSymbolTypeCallback = isFunction2(symbolType);
        var hasSymbolSizeCallback = isFunction2(symbolSize);
        var hasSymbolRotateCallback = isFunction2(symbolRotate);
        var hasCallback2 = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;
        var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : defaultSymbolType;
        var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;
        data.setVisual({
          legendSymbol: legendSymbol || seriesSymbol,
          // If seting callback functions on `symbol` or `symbolSize`, for simplicity and avoiding
          // to bring trouble, we do not pick a reuslt from one of its calling on data item here,
          // but just use the default value. Callback on `symbol` or `symbolSize` is convenient in
          // some cases but generally it is not recommanded.
          symbol: seriesSymbol,
          symbolSize: seriesSymbolSize,
          symbolKeepAspect: keepAspect,
          symbolRotate
        });
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        function dataEach(data2, idx) {
          if (hasCallback2) {
            var rawValue = seriesModel.getRawValue(idx);
            var params = seriesModel.getDataParams(idx);
            hasSymbolTypeCallback && data2.setItemVisual(idx, "symbol", symbolType(rawValue, params));
            hasSymbolSizeCallback && data2.setItemVisual(idx, "symbolSize", symbolSize(rawValue, params));
            hasSymbolRotateCallback && data2.setItemVisual(idx, "symbolRotate", symbolRotate(rawValue, params));
          }
          if (data2.hasItemOption) {
            var itemModel = data2.getItemModel(idx);
            var itemSymbolType = itemModel.getShallow("symbol", true);
            var itemSymbolSize = itemModel.getShallow("symbolSize", true);
            var itemSymbolRotate = itemModel.getShallow("symbolRotate", true);
            var itemSymbolKeepAspect = itemModel.getShallow("symbolKeepAspect", true);
            if (itemSymbolType != null) {
              data2.setItemVisual(idx, "symbol", itemSymbolType);
            }
            if (itemSymbolSize != null) {
              data2.setItemVisual(idx, "symbolSize", itemSymbolSize);
            }
            if (itemSymbolRotate != null) {
              data2.setItemVisual(idx, "symbolRotate", itemSymbolRotate);
            }
            if (itemSymbolKeepAspect != null) {
              data2.setItemVisual(idx, "symbolKeepAspect", itemSymbolKeepAspect);
            }
          }
        }
        return {
          dataEach: data.hasItemOption || hasCallback2 ? dataEach : null
        };
      }
    };
  }
  symbol = _default2;
  return symbol;
}
var points;
var hasRequiredPoints;
function requirePoints() {
  if (hasRequiredPoints)
    return points;
  hasRequiredPoints = 1;
  var _util2 = util$6;
  var map2 = _util2.map;
  var createRenderPlanner2 = createRenderPlanner$1;
  var _dataStackHelper = requireDataStackHelper();
  var isDimensionStacked = _dataStackHelper.isDimensionStacked;
  function _default2(seriesType2) {
    return {
      seriesType: seriesType2,
      plan: createRenderPlanner2(),
      reset: function(seriesModel) {
        var data = seriesModel.getData();
        var coordSys = seriesModel.coordinateSystem;
        var pipelineContext = seriesModel.pipelineContext;
        var isLargeRender = pipelineContext.large;
        if (!coordSys) {
          return;
        }
        var dims = map2(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }).slice(0, 2);
        var dimLen = dims.length;
        var stackResultDim = data.getCalculationInfo("stackResultDimension");
        if (isDimensionStacked(
          data,
          dims[0]
          /*, dims[1]*/
        )) {
          dims[0] = stackResultDim;
        }
        if (isDimensionStacked(
          data,
          dims[1]
          /*, dims[0]*/
        )) {
          dims[1] = stackResultDim;
        }
        function progress(params, data2) {
          var segCount = params.end - params.start;
          var points2 = isLargeRender && new Float32Array(segCount * dimLen);
          for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {
            var point;
            if (dimLen === 1) {
              var x = data2.get(dims[0], i);
              point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);
            } else {
              var x = tmpIn[0] = data2.get(dims[0], i);
              var y = tmpIn[1] = data2.get(dims[1], i);
              point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (isLargeRender) {
              points2[offset++] = point ? point[0] : NaN;
              points2[offset++] = point ? point[1] : NaN;
            } else {
              data2.setItemLayout(i, point && point.slice() || [NaN, NaN]);
            }
          }
          isLargeRender && data2.setLayout("symbolPoints", points2);
        }
        return dimLen && {
          progress
        };
      }
    };
  }
  points = _default2;
  return points;
}
var dataSample;
var hasRequiredDataSample;
function requireDataSample() {
  if (hasRequiredDataSample)
    return dataSample;
  hasRequiredDataSample = 1;
  var samplers = {
    average: function(frame) {
      var sum = 0;
      var count = 0;
      for (var i = 0; i < frame.length; i++) {
        if (!isNaN(frame[i])) {
          sum += frame[i];
          count++;
        }
      }
      return count === 0 ? NaN : sum / count;
    },
    sum: function(frame) {
      var sum = 0;
      for (var i = 0; i < frame.length; i++) {
        sum += frame[i] || 0;
      }
      return sum;
    },
    max: function(frame) {
      var max3 = -Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] > max3 && (max3 = frame[i]);
      }
      return isFinite(max3) ? max3 : NaN;
    },
    min: function(frame) {
      var min3 = Infinity;
      for (var i = 0; i < frame.length; i++) {
        frame[i] < min3 && (min3 = frame[i]);
      }
      return isFinite(min3) ? min3 : NaN;
    },
    // TODO
    // Median
    nearest: function(frame) {
      return frame[0];
    }
  };
  var indexSampler = function(frame, value) {
    return Math.round(frame.length / 2);
  };
  function _default2(seriesType2) {
    return {
      seriesType: seriesType2,
      modifyOutputEnd: true,
      reset: function(seriesModel, ecModel, api) {
        var data = seriesModel.getData();
        var sampling = seriesModel.get("sampling");
        var coordSys = seriesModel.coordinateSystem;
        if (coordSys.type === "cartesian2d" && sampling) {
          var baseAxis = coordSys.getBaseAxis();
          var valueAxis = coordSys.getOtherAxis(baseAxis);
          var extent = baseAxis.getExtent();
          var size2 = Math.abs(extent[1] - extent[0]);
          var rate = Math.round(data.count() / size2);
          if (rate > 1) {
            var sampler;
            if (typeof sampling === "string") {
              sampler = samplers[sampling];
            } else if (typeof sampling === "function") {
              sampler = sampling;
            }
            if (sampler) {
              seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
            }
          }
        }
      }
    };
  }
  dataSample = _default2;
  return dataSample;
}
var gridSimple = {};
var Cartesian_1;
var hasRequiredCartesian;
function requireCartesian() {
  if (hasRequiredCartesian)
    return Cartesian_1;
  hasRequiredCartesian = 1;
  var zrUtil2 = util$6;
  function dimAxisMapper(dim) {
    return this._axes[dim];
  }
  var Cartesian = function(name2) {
    this._axes = {};
    this._dimList = [];
    this.name = name2 || "";
  };
  Cartesian.prototype = {
    constructor: Cartesian,
    type: "cartesian",
    /**
     * Get axis
     * @param  {number|string} dim
     * @return {module:echarts/coord/Cartesian~Axis}
     */
    getAxis: function(dim) {
      return this._axes[dim];
    },
    /**
     * Get axes list
     * @return {Array.<module:echarts/coord/Cartesian~Axis>}
     */
    getAxes: function() {
      return zrUtil2.map(this._dimList, dimAxisMapper, this);
    },
    /**
     * Get axes list by given scale type
     */
    getAxesByScale: function(scaleType) {
      scaleType = scaleType.toLowerCase();
      return zrUtil2.filter(this.getAxes(), function(axis2) {
        return axis2.scale.type === scaleType;
      });
    },
    /**
     * Add axis
     * @param {module:echarts/coord/Cartesian.Axis}
     */
    addAxis: function(axis2) {
      var dim = axis2.dim;
      this._axes[dim] = axis2;
      this._dimList.push(dim);
    },
    /**
     * Convert data to coord in nd space
     * @param {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */
    dataToCoord: function(val) {
      return this._dataCoordConvert(val, "dataToCoord");
    },
    /**
     * Convert coord in nd space to data
     * @param  {Array.<number>|Object.<string, number>} val
     * @return {Array.<number>|Object.<string, number>}
     */
    coordToData: function(val) {
      return this._dataCoordConvert(val, "coordToData");
    },
    _dataCoordConvert: function(input, method) {
      var dimList = this._dimList;
      var output = input instanceof Array ? [] : {};
      for (var i = 0; i < dimList.length; i++) {
        var dim = dimList[i];
        var axis2 = this._axes[dim];
        output[dim] = axis2[method](input[dim]);
      }
      return output;
    }
  };
  var _default2 = Cartesian;
  Cartesian_1 = _default2;
  return Cartesian_1;
}
var Cartesian2D_1;
var hasRequiredCartesian2D;
function requireCartesian2D() {
  if (hasRequiredCartesian2D)
    return Cartesian2D_1;
  hasRequiredCartesian2D = 1;
  var zrUtil2 = util$6;
  var BoundingRect2 = BoundingRect_1;
  var Cartesian = requireCartesian();
  function Cartesian2D(name2) {
    Cartesian.call(this, name2);
  }
  Cartesian2D.prototype = {
    constructor: Cartesian2D,
    type: "cartesian2d",
    /**
     * @type {Array.<string>}
     * @readOnly
     */
    dimensions: ["x", "y"],
    /**
     * Base axis will be used on stacking.
     *
     * @return {module:echarts/coord/cartesian/Axis2D}
     */
    getBaseAxis: function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    },
    /**
     * If contain point
     * @param {Array.<number>} point
     * @return {boolean}
     */
    containPoint: function(point) {
      var axisX = this.getAxis("x");
      var axisY = this.getAxis("y");
      return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
    },
    /**
     * If contain data
     * @param {Array.<number>} data
     * @return {boolean}
     */
    containData: function(data) {
      return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
    },
    /**
     * @param {Array.<number>} data
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */
    dataToPoint: function(data, reserved, out2) {
      var xAxis = this.getAxis("x");
      var yAxis = this.getAxis("y");
      out2 = out2 || [];
      out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));
      out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));
      return out2;
    },
    /**
     * @param {Array.<number>} data
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */
    clampData: function(data, out2) {
      var xScale = this.getAxis("x").scale;
      var yScale = this.getAxis("y").scale;
      var xAxisExtent = xScale.getExtent();
      var yAxisExtent = yScale.getExtent();
      var x = xScale.parse(data[0]);
      var y = yScale.parse(data[1]);
      out2 = out2 || [];
      out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
      out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
      return out2;
    },
    /**
     * @param {Array.<number>} point
     * @param {Array.<number>} out
     * @return {Array.<number>}
     */
    pointToData: function(point, out2) {
      var xAxis = this.getAxis("x");
      var yAxis = this.getAxis("y");
      out2 = out2 || [];
      out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
      out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
      return out2;
    },
    /**
     * Get other axis
     * @param {module:echarts/coord/cartesian/Axis2D} axis
     */
    getOtherAxis: function(axis2) {
      return this.getAxis(axis2.dim === "x" ? "y" : "x");
    },
    /**
     * Get rect area of cartesian.
     * Area will have a contain function to determine if a point is in the coordinate system.
     * @return {BoundingRect}
     */
    getArea: function() {
      var xExtent = this.getAxis("x").getGlobalExtent();
      var yExtent = this.getAxis("y").getGlobalExtent();
      var x = Math.min(xExtent[0], xExtent[1]);
      var y = Math.min(yExtent[0], yExtent[1]);
      var width = Math.max(xExtent[0], xExtent[1]) - x;
      var height = Math.max(yExtent[0], yExtent[1]) - y;
      var rect = new BoundingRect2(x, y, width, height);
      return rect;
    }
  };
  zrUtil2.inherits(Cartesian2D, Cartesian);
  var _default2 = Cartesian2D;
  Cartesian2D_1 = _default2;
  return Cartesian2D_1;
}
var Axis2D_1;
var hasRequiredAxis2D;
function requireAxis2D() {
  if (hasRequiredAxis2D)
    return Axis2D_1;
  hasRequiredAxis2D = 1;
  var zrUtil2 = util$6;
  var Axis = requireAxis$1();
  var Axis2D = function(dim, scale, coordExtent, axisType, position) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || "value";
    this.position = position || "bottom";
  };
  Axis2D.prototype = {
    constructor: Axis2D,
    /**
     * Index of axis, can be used as key
     */
    index: 0,
    /**
     * Implemented in <module:echarts/coord/cartesian/Grid>.
     * @return {Array.<module:echarts/coord/cartesian/Axis2D>}
     *         If not on zero of other axis, return null/undefined.
     *         If no axes, return an empty array.
     */
    getAxesOnZeroOf: null,
    /**
     * Axis model
     * @param {module:echarts/coord/cartesian/AxisModel}
     */
    model: null,
    isHorizontal: function() {
      var position = this.position;
      return position === "top" || position === "bottom";
    },
    /**
     * Each item cooresponds to this.getExtent(), which
     * means globalExtent[0] may greater than globalExtent[1],
     * unless `asc` is input.
     *
     * @param {boolean} [asc]
     * @return {Array.<number>}
     */
    getGlobalExtent: function(asc) {
      var ret = this.getExtent();
      ret[0] = this.toGlobalCoord(ret[0]);
      ret[1] = this.toGlobalCoord(ret[1]);
      asc && ret[0] > ret[1] && ret.reverse();
      return ret;
    },
    getOtherAxis: function() {
      this.grid.getOtherAxis();
    },
    /**
     * @override
     */
    pointToData: function(point, clamp) {
      return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp);
    },
    /**
     * Transform global coord to local coord,
     * i.e. var localCoord = axis.toLocalCoord(80);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */
    toLocalCoord: null,
    /**
     * Transform global coord to local coord,
     * i.e. var globalCoord = axis.toLocalCoord(40);
     * designate by module:echarts/coord/cartesian/Grid.
     * @type {Function}
     */
    toGlobalCoord: null
  };
  zrUtil2.inherits(Axis2D, Axis);
  var _default2 = Axis2D;
  Axis2D_1 = _default2;
  return Axis2D_1;
}
var axisDefault_1;
var hasRequiredAxisDefault;
function requireAxisDefault() {
  if (hasRequiredAxisDefault)
    return axisDefault_1;
  hasRequiredAxisDefault = 1;
  var zrUtil2 = util$6;
  var defaultOption = {
    show: true,
    zlevel: 0,
    z: 0,
    // Inverse the axis.
    inverse: false,
    // Axis name displayed.
    name: "",
    // 'start' | 'middle' | 'end'
    nameLocation: "end",
    // By degree. By default auto rotate by nameLocation.
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: "...",
      placeholder: "."
    },
    // Use global text style by default.
    nameTextStyle: {},
    // The gap between axisName and axisLine.
    nameGap: 15,
    // Default `false` to support tooltip.
    silent: false,
    // Default `false` to avoid legacy user event listener fail.
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: "#333",
        width: 1,
        type: "solid"
      },
      // The arrow at both ends the the axis.
      symbol: ["none", "none"],
      symbolSize: [10, 15]
    },
    axisTick: {
      show: true,
      // Whether axisTick is inside the grid or outside the grid.
      inside: false,
      // The length of axisTick.
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      // Whether axisLabel is inside the grid or outside the grid.
      inside: false,
      rotate: 0,
      // true | false | null/undefined (auto)
      showMinLabel: null,
      // true | false | null/undefined (auto)
      showMaxLabel: null,
      margin: 8,
      // formatter: null,
      fontSize: 12
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: ["#ccc"],
        width: 1,
        type: "solid"
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
      }
    }
  };
  var axisDefault = {};
  axisDefault.categoryAxis = zrUtil2.merge({
    // The gap at both ends of the axis. For categoryAxis, boolean.
    boundaryGap: true,
    // Set false to faster category collection.
    // Only usefull in the case like: category is
    // ['2012-01-01', '2012-01-02', ...], where the input
    // data has been ensured not duplicate and is large data.
    // null means "auto":
    // if axis.data provided, do not deduplication,
    // else do deduplication.
    deduplication: null,
    // splitArea: {
    // show: false
    // },
    splitLine: {
      show: false
    },
    axisTick: {
      // If tick is align with label when boundaryGap is true
      alignWithLabel: false,
      interval: "auto"
    },
    axisLabel: {
      interval: "auto"
    }
  }, defaultOption);
  axisDefault.valueAxis = zrUtil2.merge({
    // The gap at both ends of the axis. For value axis, [GAP, GAP], where
    // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)
    boundaryGap: [0, 0],
    // TODO
    // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
    // Min value of the axis. can be:
    // + a number
    // + 'dataMin': use the min value in data.
    // + null/undefined: auto decide min value (consider pretty look and boundaryGap).
    // min: null,
    // Max value of the axis. can be:
    // + a number
    // + 'dataMax': use the max value in data.
    // + null/undefined: auto decide max value (consider pretty look and boundaryGap).
    // max: null,
    // Readonly prop, specifies start value of the range when using data zoom.
    // rangeStart: null
    // Readonly prop, specifies end value of the range when using data zoom.
    // rangeEnd: null
    // Optional value can be:
    // + `false`: always include value 0.
    // + `true`: the extent do not consider value 0.
    // scale: false,
    // AxisTick and axisLabel and splitLine are caculated based on splitNumber.
    splitNumber: 5,
    // Interval specifies the span of the ticks is mandatorily.
    // interval: null
    // Specify min interval when auto calculate tick interval.
    // minInterval: null
    // Specify max interval when auto calculate tick interval.
    // maxInterval: null
    minorTick: {
      // Minor tick, not available for cateogry axis.
      show: false,
      // Split number of minor ticks. The value should be in range of (0, 100)
      splitNumber: 5,
      // Lenght of minor tick
      length: 3,
      // Same inside with axisTick
      // Line style
      lineStyle: {
        // Default to be same with axisTick
      }
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: "#eee",
        width: 1
      }
    }
  }, defaultOption);
  axisDefault.timeAxis = zrUtil2.defaults({
    scale: true,
    min: "dataMin",
    max: "dataMax"
  }, axisDefault.valueAxis);
  axisDefault.logAxis = zrUtil2.defaults({
    scale: true,
    logBase: 10
  }, axisDefault.valueAxis);
  var _default2 = axisDefault;
  axisDefault_1 = _default2;
  return axisDefault_1;
}
var axisModelCreator;
var hasRequiredAxisModelCreator;
function requireAxisModelCreator() {
  if (hasRequiredAxisModelCreator)
    return axisModelCreator;
  hasRequiredAxisModelCreator = 1;
  var zrUtil2 = util$6;
  var axisDefault = requireAxisDefault();
  var ComponentModel2 = Component$2;
  var _layout2 = layout$1;
  var getLayoutParams2 = _layout2.getLayoutParams;
  var mergeLayoutParam2 = _layout2.mergeLayoutParam;
  var OrdinalMeta = requireOrdinalMeta();
  var AXIS_TYPES = ["value", "category", "time", "log"];
  function _default2(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
    zrUtil2.each(AXIS_TYPES, function(axisType) {
      BaseAxisModelClass.extend({
        /**
         * @readOnly
         */
        type: axisName + "Axis." + axisType,
        mergeDefaultAndTheme: function(option, ecModel) {
          var layoutMode = this.layoutMode;
          var inputPositionParams = layoutMode ? getLayoutParams2(option) : {};
          var themeModel = ecModel.getTheme();
          zrUtil2.merge(option, themeModel.get(axisType + "Axis"));
          zrUtil2.merge(option, this.getDefaultOption());
          option.type = axisTypeDefaulter(axisName, option);
          if (layoutMode) {
            mergeLayoutParam2(option, inputPositionParams, layoutMode);
          }
        },
        /**
         * @override
         */
        optionUpdated: function() {
          var thisOption = this.option;
          if (thisOption.type === "category") {
            this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);
          }
        },
        /**
         * Should not be called before all of 'getInitailData' finished.
         * Because categories are collected during initializing data.
         */
        getCategories: function(rawData) {
          var option = this.option;
          if (option.type === "category") {
            if (rawData) {
              return option.data;
            }
            return this.__ordinalMeta.categories;
          }
        },
        getOrdinalMeta: function() {
          return this.__ordinalMeta;
        },
        defaultOption: zrUtil2.mergeAll([{}, axisDefault[axisType + "Axis"], extraDefaultOption], true)
      });
    });
    ComponentModel2.registerSubTypeDefaulter(axisName + "Axis", zrUtil2.curry(axisTypeDefaulter, axisName));
  }
  axisModelCreator = _default2;
  return axisModelCreator;
}
var AxisModel_1$2;
var hasRequiredAxisModel$3;
function requireAxisModel$3() {
  if (hasRequiredAxisModel$3)
    return AxisModel_1$2;
  hasRequiredAxisModel$3 = 1;
  var zrUtil2 = util$6;
  var ComponentModel2 = Component$2;
  var axisModelCreator2 = requireAxisModelCreator();
  var axisModelCommonMixin2 = requireAxisModelCommonMixin();
  var AxisModel2 = ComponentModel2.extend({
    type: "cartesian2dAxis",
    /**
     * @type {module:echarts/coord/cartesian/Axis2D}
     */
    axis: null,
    /**
     * @override
     */
    init: function() {
      AxisModel2.superApply(this, "init", arguments);
      this.resetRange();
    },
    /**
     * @override
     */
    mergeOption: function() {
      AxisModel2.superApply(this, "mergeOption", arguments);
      this.resetRange();
    },
    /**
     * @override
     */
    restoreData: function() {
      AxisModel2.superApply(this, "restoreData", arguments);
      this.resetRange();
    },
    /**
     * @override
     * @return {module:echarts/model/Component}
     */
    getCoordSysModel: function() {
      return this.ecModel.queryComponents({
        mainType: "grid",
        index: this.option.gridIndex,
        id: this.option.gridId
      })[0];
    }
  });
  function getAxisType(axisDim, option) {
    return option.type || (option.data ? "category" : "value");
  }
  zrUtil2.merge(AxisModel2.prototype, axisModelCommonMixin2);
  var extraOption = {
    // gridIndex: 0,
    // gridId: '',
    // Offset is for multiple axis on the same position
    offset: 0
  };
  axisModelCreator2("x", AxisModel2, getAxisType, extraOption);
  axisModelCreator2("y", AxisModel2, getAxisType, extraOption);
  var _default2 = AxisModel2;
  AxisModel_1$2 = _default2;
  return AxisModel_1$2;
}
var GridModel;
var hasRequiredGridModel;
function requireGridModel() {
  if (hasRequiredGridModel)
    return GridModel;
  hasRequiredGridModel = 1;
  requireAxisModel$3();
  var ComponentModel2 = Component$2;
  var _default2 = ComponentModel2.extend({
    type: "grid",
    dependencies: ["xAxis", "yAxis"],
    layoutMode: "box",
    /**
     * @type {module:echarts/coord/cartesian/Grid}
     */
    coordinateSystem: null,
    defaultOption: {
      show: false,
      zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 60,
      // If grid size contain label
      containLabel: false,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }
  });
  GridModel = _default2;
  return GridModel;
}
var Grid_1;
var hasRequiredGrid$1;
function requireGrid$1() {
  if (hasRequiredGrid$1)
    return Grid_1;
  hasRequiredGrid$1 = 1;
  var _util2 = util$6;
  var isObject2 = _util2.isObject;
  var each2 = _util2.each;
  var map2 = _util2.map;
  var indexOf2 = _util2.indexOf;
  _util2.retrieve;
  var _layout2 = layout$1;
  var getLayoutRect2 = _layout2.getLayoutRect;
  var _axisHelper = requireAxisHelper();
  var createScaleByModel = _axisHelper.createScaleByModel;
  var ifAxisCrossZero = _axisHelper.ifAxisCrossZero;
  var niceScaleExtent = _axisHelper.niceScaleExtent;
  var estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;
  var Cartesian2D = requireCartesian2D();
  var Axis2D = requireAxis2D();
  var CoordinateSystem$1 = CoordinateSystem;
  var _dataStackHelper = requireDataStackHelper();
  var getStackedDimension = _dataStackHelper.getStackedDimension;
  requireGridModel();
  function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
    return axisModel.getCoordSysModel() === gridModel;
  }
  function Grid(gridModel, ecModel, api) {
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this._initCartesian(gridModel, ecModel, api);
    this.model = gridModel;
  }
  var gridProto = Grid.prototype;
  gridProto.type = "grid";
  gridProto.axisPointerEnabled = true;
  gridProto.getRect = function() {
    return this._rect;
  };
  gridProto.update = function(ecModel, api) {
    var axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    each2(axesMap.x, function(xAxis) {
      niceScaleExtent(xAxis.scale, xAxis.model);
    });
    each2(axesMap.y, function(yAxis) {
      niceScaleExtent(yAxis.scale, yAxis.model);
    });
    var onZeroRecords = {};
    each2(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each2(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api);
  };
  function fixAxisOnZero(axesMap, otherAxisDim, axis2, onZeroRecords) {
    axis2.getAxesOnZeroOf = function() {
      return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
    };
    var otherAxes = axesMap[otherAxisDim];
    var otherAxisOnZeroOf;
    var axisModel = axis2.model;
    var onZero = axisModel.get("axisLine.onZero");
    var onZeroAxisIndex = axisModel.get("axisLine.onZeroAxisIndex");
    if (!onZero) {
      return;
    }
    if (onZeroAxisIndex != null) {
      if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
        otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
      }
    } else {
      for (var idx in otherAxes) {
        if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
          otherAxisOnZeroOf = otherAxes[idx];
          break;
        }
      }
    }
    if (otherAxisOnZeroOf) {
      onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
    }
    function getOnZeroRecordKey(axis3) {
      return axis3.dim + "_" + axis3.index;
    }
  }
  function canOnZeroToAxis(axis2) {
    return axis2 && axis2.type !== "category" && axis2.type !== "time" && ifAxisCrossZero(axis2);
  }
  gridProto.resize = function(gridModel, api, ignoreContainLabel) {
    var gridRect = getLayoutRect2(gridModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
    this._rect = gridRect;
    var axesList = this._axesList;
    adjustAxes();
    if (!ignoreContainLabel && gridModel.get("containLabel")) {
      each2(axesList, function(axis2) {
        if (!axis2.model.get("axisLabel.inside")) {
          var labelUnionRect = estimateLabelUnionRect(axis2);
          if (labelUnionRect) {
            var dim = axis2.isHorizontal() ? "height" : "width";
            var margin = axis2.model.get("axisLabel.margin");
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis2.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis2.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    function adjustAxes() {
      each2(axesList, function(axis2) {
        var isHorizontal = axis2.isHorizontal();
        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        var idx = axis2.inverse ? 1 : 0;
        axis2.setExtent(extent[idx], extent[1 - idx]);
        updateAxisTransform(axis2, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  };
  gridProto.getAxis = function(axisType, axisIndex) {
    var axesMapOnDim = this._axesMap[axisType];
    if (axesMapOnDim != null) {
      if (axisIndex == null) {
        for (var name2 in axesMapOnDim) {
          if (axesMapOnDim.hasOwnProperty(name2)) {
            return axesMapOnDim[name2];
          }
        }
      }
      return axesMapOnDim[axisIndex];
    }
  };
  gridProto.getAxes = function() {
    return this._axesList.slice();
  };
  gridProto.getCartesian = function(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      var key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject2(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
        return coordList[i];
      }
    }
  };
  gridProto.getCartesians = function() {
    return this._coordsList.slice();
  };
  gridProto.convertToPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(ecModel, finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  };
  gridProto.convertFromPixel = function(ecModel, finder, value) {
    var target = this._findConvertTarget(ecModel, finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  };
  gridProto._findConvertTarget = function(ecModel, finder) {
    var seriesModel = finder.seriesModel;
    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis")[0];
    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis")[0];
    var gridModel = finder.gridModel;
    var coordsList = this._coordsList;
    var cartesian;
    var axis2;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf2(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis2 = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis2 = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      var grid2 = gridModel.coordinateSystem;
      if (grid2 === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {
      cartesian,
      axis: axis2
    };
  };
  gridProto.containPoint = function(point) {
    var coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  };
  gridProto._initCartesian = function(gridModel, ecModel, api) {
    var axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    var axesMap = {
      x: {},
      y: {}
    };
    var axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each2(axesMap.x, function(xAxis, xAxisIndex) {
      each2(axesMap.y, function(yAxis, yAxisIndex) {
        var key = "x" + xAxisIndex + "y" + yAxisIndex;
        var cartesian = new Cartesian2D(key);
        cartesian.grid = this;
        cartesian.model = gridModel;
        this._coordsMap[key] = cartesian;
        this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      }, this);
    }, this);
    function createAxisCreator(axisType) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        var axisPosition = axisModel.get("position");
        if (axisType === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        var axis2 = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        var isCategory = axis2.type === "category";
        axis2.onBand = isCategory && axisModel.get("boundaryGap");
        axis2.inverse = axisModel.get("inverse");
        axisModel.axis = axis2;
        axis2.model = axisModel;
        axis2.grid = this;
        axis2.index = idx;
        this._axesList.push(axis2);
        axesMap[axisType][idx] = axis2;
        axesCount[axisType]++;
      };
    }
  };
  gridProto._updateScale = function(ecModel, gridModel) {
    each2(this._axesList, function(axis2) {
      axis2.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2D(seriesModel)) {
        var axesModels = findAxesModels(seriesModel);
        var xAxisModel = axesModels[0];
        var yAxisModel = axesModels[1];
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        var data = seriesModel.getData();
        var xAxis = cartesian.getAxis("x");
        var yAxis = cartesian.getAxis("y");
        if (data.type === "list") {
          unionExtent(data, xAxis);
          unionExtent(data, yAxis);
        }
      }
    }, this);
    function unionExtent(data, axis2, seriesModel) {
      each2(data.mapDimension(axis2.dim, true), function(dim) {
        axis2.scale.unionExtentFromData(
          // For example, the extent of the orginal dimension
          // is [0.1, 0.5], the extent of the `stackResultDimension`
          // is [7, 9], the final extent should not include [0.1, 0.5].
          data,
          getStackedDimension(data, dim)
        );
      });
    }
  };
  gridProto.getTooltipAxes = function(dim) {
    var baseAxes = [];
    var otherAxes = [];
    each2(this.getCartesians(), function(cartesian) {
      var baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      var otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf2(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf2(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {
      baseAxes,
      otherAxes
    };
  };
  function updateAxisTransform(axis2, coordBase) {
    var axisExtent = axis2.getExtent();
    var axisExtentSum = axisExtent[0] + axisExtent[1];
    axis2.toGlobalCoord = axis2.dim === "x" ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
    axis2.toLocalCoord = axis2.dim === "x" ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return axisExtentSum - coord + coordBase;
    };
  }
  var axesTypes = ["xAxis", "yAxis"];
  function findAxesModels(seriesModel, ecModel) {
    return map2(axesTypes, function(axisType) {
      var axisModel = seriesModel.getReferringComponents(axisType)[0];
      return axisModel;
    });
  }
  function isCartesian2D(seriesModel) {
    return seriesModel.get("coordinateSystem") === "cartesian2d";
  }
  Grid.create = function(ecModel, api) {
    var grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      var grid2 = new Grid(gridModel, ecModel, api);
      grid2.name = "grid_" + idx;
      grid2.resize(gridModel, api, true);
      gridModel.coordinateSystem = grid2;
      grids.push(grid2);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2D(seriesModel)) {
        return;
      }
      var axesModels = findAxesModels(seriesModel);
      var xAxisModel = axesModels[0];
      var yAxisModel = axesModels[1];
      var gridModel = xAxisModel.getCoordSysModel();
      var grid2 = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid2.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  };
  Grid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;
  CoordinateSystem$1.register("cartesian2d", Grid);
  var _default2 = Grid;
  Grid_1 = _default2;
  return Grid_1;
}
var axis = {};
var CartesianAxisView = {};
var AxisBuilder_1;
var hasRequiredAxisBuilder;
function requireAxisBuilder() {
  if (hasRequiredAxisBuilder)
    return AxisBuilder_1;
  hasRequiredAxisBuilder = 1;
  var _util2 = util$6;
  var retrieve4 = _util2.retrieve;
  var defaults2 = _util2.defaults;
  var extend2 = _util2.extend;
  var each2 = _util2.each;
  var formatUtil2 = requireFormat();
  var graphic2 = graphic$4;
  var Model2 = requireModel();
  var _number2 = requireNumber();
  var isRadianAroundZero = _number2.isRadianAroundZero;
  var remRadian = _number2.remRadian;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var matrixUtil = requireMatrix();
  var _vector2 = requireVector();
  var v2ApplyTransform2 = _vector2.applyTransform;
  var _axisHelper = requireAxisHelper();
  var shouldShowAllLabels = _axisHelper.shouldShowAllLabels;
  var PI3 = Math.PI;
  var AxisBuilder = function(axisModel, opt) {
    this.opt = opt;
    this.axisModel = axisModel;
    defaults2(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true
    });
    this.group = new graphic2.Group();
    var dumbGroup = new graphic2.Group({
      position: opt.position.slice(),
      rotation: opt.rotation
    });
    dumbGroup.updateTransform();
    this._transform = dumbGroup.transform;
    this._dumbGroup = dumbGroup;
  };
  AxisBuilder.prototype = {
    constructor: AxisBuilder,
    hasBuilder: function(name2) {
      return !!builders[name2];
    },
    add: function(name2) {
      builders[name2].call(this);
    },
    getGroup: function() {
      return this.group;
    }
  };
  var builders = {
    /**
     * @private
     */
    axisLine: function() {
      var opt = this.opt;
      var axisModel = this.axisModel;
      if (!axisModel.get("axisLine.show")) {
        return;
      }
      var extent = this.axisModel.axis.getExtent();
      var matrix2 = this._transform;
      var pt1 = [extent[0], 0];
      var pt2 = [extent[1], 0];
      if (matrix2) {
        v2ApplyTransform2(pt1, pt1, matrix2);
        v2ApplyTransform2(pt2, pt2, matrix2);
      }
      var lineStyle2 = extend2({
        lineCap: "round"
      }, axisModel.getModel("axisLine.lineStyle").getLineStyle());
      this.group.add(new graphic2.Line({
        // Id for animation
        anid: "line",
        subPixelOptimize: true,
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: lineStyle2,
        strokeContainThreshold: opt.strokeContainThreshold || 5,
        silent: true,
        z2: 1
      }));
      var arrows = axisModel.get("axisLine.symbol");
      var arrowSize = axisModel.get("axisLine.symbolSize");
      var arrowOffset = axisModel.get("axisLine.symbolOffset") || 0;
      if (typeof arrowOffset === "number") {
        arrowOffset = [arrowOffset, arrowOffset];
      }
      if (arrows != null) {
        if (typeof arrows === "string") {
          arrows = [arrows, arrows];
        }
        if (typeof arrowSize === "string" || typeof arrowSize === "number") {
          arrowSize = [arrowSize, arrowSize];
        }
        var symbolWidth = arrowSize[0];
        var symbolHeight = arrowSize[1];
        each2([{
          rotate: opt.rotation + Math.PI / 2,
          offset: arrowOffset[0],
          r: 0
        }, {
          rotate: opt.rotation - Math.PI / 2,
          offset: arrowOffset[1],
          r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
        }], function(point, index2) {
          if (arrows[index2] !== "none" && arrows[index2] != null) {
            var symbol2 = createSymbol(arrows[index2], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle2.stroke, true);
            var r = point.r + point.offset;
            var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];
            symbol2.attr({
              rotation: point.rotate,
              position: pos,
              silent: true,
              z2: 11
            });
            this.group.add(symbol2);
          }
        }, this);
      }
    },
    /**
     * @private
     */
    axisTickLabel: function() {
      var axisModel = this.axisModel;
      var opt = this.opt;
      var ticksEls = buildAxisMajorTicks(this, axisModel, opt);
      var labelEls = buildAxisLabel(this, axisModel, opt);
      fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
      buildAxisMinorTicks(this, axisModel, opt);
    },
    /**
     * @private
     */
    axisName: function() {
      var opt = this.opt;
      var axisModel = this.axisModel;
      var name2 = retrieve4(opt.axisName, axisModel.get("name"));
      if (!name2) {
        return;
      }
      var nameLocation = axisModel.get("nameLocation");
      var nameDirection = opt.nameDirection;
      var textStyleModel = axisModel.getModel("nameTextStyle");
      var gap = axisModel.get("nameGap") || 0;
      var extent = this.axisModel.axis.getExtent();
      var gapSignal = extent[0] > extent[1] ? -1 : 1;
      var pos = [
        nameLocation === "start" ? extent[0] - gapSignal * gap : nameLocation === "end" ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,
        // 'middle'
        // Reuse labelOffset.
        isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
      ];
      var labelLayout2;
      var nameRotation = axisModel.get("nameRotate");
      if (nameRotation != null) {
        nameRotation = nameRotation * PI3 / 180;
      }
      var axisNameAvailableWidth;
      if (isNameLocationCenter(nameLocation)) {
        labelLayout2 = innerTextLayout(
          opt.rotation,
          nameRotation != null ? nameRotation : opt.rotation,
          // Adapt to axis.
          nameDirection
        );
      } else {
        labelLayout2 = endTextLayout(opt, nameLocation, nameRotation || 0, extent);
        axisNameAvailableWidth = opt.axisNameAvailableWidth;
        if (axisNameAvailableWidth != null) {
          axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout2.rotation));
          !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
        }
      }
      var textFont = textStyleModel.getFont();
      var truncateOpt = axisModel.get("nameTruncate", true) || {};
      var ellipsis = truncateOpt.ellipsis;
      var maxWidth = retrieve4(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
      var truncatedText = ellipsis != null && maxWidth != null ? formatUtil2.truncateText(name2, maxWidth, textFont, ellipsis, {
        minChar: 2,
        placeholder: truncateOpt.placeholder
      }) : name2;
      var tooltipOpt = axisModel.get("tooltip", true);
      var mainType = axisModel.mainType;
      var formatterParams = {
        componentType: mainType,
        name: name2,
        $vars: ["name"]
      };
      formatterParams[mainType + "Index"] = axisModel.componentIndex;
      var textEl = new graphic2.Text({
        // Id for animation
        anid: "name",
        __fullText: name2,
        __truncatedText: truncatedText,
        position: pos,
        rotation: labelLayout2.rotation,
        silent: isLabelSilent(axisModel),
        z2: 1,
        tooltip: tooltipOpt && tooltipOpt.show ? extend2({
          content: name2,
          formatter: function() {
            return name2;
          },
          formatterParams
        }, tooltipOpt) : null
      });
      graphic2.setTextStyle(textEl.style, textStyleModel, {
        text: truncatedText,
        textFont,
        textFill: textStyleModel.getTextColor() || axisModel.get("axisLine.lineStyle.color"),
        textAlign: textStyleModel.get("align") || labelLayout2.textAlign,
        textVerticalAlign: textStyleModel.get("verticalAlign") || labelLayout2.textVerticalAlign
      });
      if (axisModel.get("triggerEvent")) {
        textEl.eventData = makeAxisEventDataBase(axisModel);
        textEl.eventData.targetType = "axisName";
        textEl.eventData.name = name2;
      }
      this._dumbGroup.add(textEl);
      textEl.updateTransform();
      this.group.add(textEl);
      textEl.decomposeTransform();
    }
  };
  var makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function(axisModel) {
    var eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  };
  var innerTextLayout = AxisBuilder.innerTextLayout = function(axisRotation, textRotation, direction) {
    var rotationDiff = remRadian(textRotation - axisRotation);
    var textAlign;
    var textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI3)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI3) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  };
  function endTextLayout(opt, textPosition, textRotate, extent) {
    var rotationDiff = remRadian(textRotate - opt.rotation);
    var textAlign;
    var textVerticalAlign;
    var inverse = extent[0] > extent[1];
    var onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
    if (isRadianAroundZero(rotationDiff - PI3 / 2)) {
      textVerticalAlign = onLeft ? "bottom" : "top";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI3 * 1.5)) {
      textVerticalAlign = onLeft ? "top" : "bottom";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff < PI3 * 1.5 && rotationDiff > PI3 / 2) {
        textAlign = onLeft ? "left" : "right";
      } else {
        textAlign = onLeft ? "right" : "left";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  }
  var isLabelSilent = AxisBuilder.isLabelSilent = function(axisModel) {
    var tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  };
  function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
    if (shouldShowAllLabels(axisModel.axis)) {
      return;
    }
    var showMinLabel = axisModel.get("axisLabel.showMinLabel");
    var showMaxLabel = axisModel.get("axisLabel.showMaxLabel");
    labelEls = labelEls || [];
    tickEls = tickEls || [];
    var firstLabel = labelEls[0];
    var nextLabel = labelEls[1];
    var lastLabel = labelEls[labelEls.length - 1];
    var prevLabel = labelEls[labelEls.length - 2];
    var firstTick = tickEls[0];
    var nextTick2 = tickEls[1];
    var lastTick = tickEls[tickEls.length - 1];
    var prevTick = tickEls[tickEls.length - 2];
    if (showMinLabel === false) {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
      if (showMinLabel) {
        ignoreEl(nextLabel);
        ignoreEl(nextTick2);
      } else {
        ignoreEl(firstLabel);
        ignoreEl(firstTick);
      }
    }
    if (showMaxLabel === false) {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
      if (showMaxLabel) {
        ignoreEl(prevLabel);
        ignoreEl(prevTick);
      } else {
        ignoreEl(lastLabel);
        ignoreEl(lastTick);
      }
    }
  }
  function ignoreEl(el) {
    el && (el.ignore = true);
  }
  function isTwoLabelOverlapped(current, next, labelLayout2) {
    var firstRect = current && current.getBoundingRect().clone();
    var nextRect = next && next.getBoundingRect().clone();
    if (!firstRect || !nextRect) {
      return;
    }
    var mRotationBack = matrixUtil.identity([]);
    matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
    firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
    nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
    return firstRect.intersect(nextRect);
  }
  function isNameLocationCenter(nameLocation) {
    return nameLocation === "middle" || nameLocation === "center";
  }
  function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, aniid) {
    var tickEls = [];
    var pt1 = [];
    var pt2 = [];
    for (var i = 0; i < ticksCoords.length; i++) {
      var tickCoord = ticksCoords[i].coord;
      pt1[0] = tickCoord;
      pt1[1] = 0;
      pt2[0] = tickCoord;
      pt2[1] = tickEndCoord;
      if (tickTransform) {
        v2ApplyTransform2(pt1, pt1, tickTransform);
        v2ApplyTransform2(pt2, pt2, tickTransform);
      }
      var tickEl = new graphic2.Line({
        // Id for animation
        anid: aniid + "_" + ticksCoords[i].tickValue,
        subPixelOptimize: true,
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: tickLineStyle,
        z2: 2,
        silent: true
      });
      tickEls.push(tickEl);
    }
    return tickEls;
  }
  function buildAxisMajorTicks(axisBuilder, axisModel, opt) {
    var axis2 = axisModel.axis;
    var tickModel = axisModel.getModel("axisTick");
    if (!tickModel.get("show") || axis2.scale.isBlank()) {
      return;
    }
    var lineStyleModel = tickModel.getModel("lineStyle");
    var tickEndCoord = opt.tickDirection * tickModel.get("length");
    var ticksCoords = axis2.getTicksCoords();
    var ticksEls = createTicks(ticksCoords, axisBuilder._transform, tickEndCoord, defaults2(lineStyleModel.getLineStyle(), {
      stroke: axisModel.get("axisLine.lineStyle.color")
    }), "ticks");
    for (var i = 0; i < ticksEls.length; i++) {
      axisBuilder.group.add(ticksEls[i]);
    }
    return ticksEls;
  }
  function buildAxisMinorTicks(axisBuilder, axisModel, opt) {
    var axis2 = axisModel.axis;
    var minorTickModel = axisModel.getModel("minorTick");
    if (!minorTickModel.get("show") || axis2.scale.isBlank()) {
      return;
    }
    var minorTicksCoords = axis2.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    var lineStyleModel = minorTickModel.getModel("lineStyle");
    var tickEndCoord = opt.tickDirection * minorTickModel.get("length");
    var minorTickLineStyle = defaults2(lineStyleModel.getLineStyle(), defaults2(axisModel.getModel("axisTick").getLineStyle(), {
      stroke: axisModel.get("axisLine.lineStyle.color")
    }));
    for (var i = 0; i < minorTicksCoords.length; i++) {
      var minorTicksEls = createTicks(minorTicksCoords[i], axisBuilder._transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
      for (var k = 0; k < minorTicksEls.length; k++) {
        axisBuilder.group.add(minorTicksEls[k]);
      }
    }
  }
  function buildAxisLabel(axisBuilder, axisModel, opt) {
    var axis2 = axisModel.axis;
    var show = retrieve4(opt.axisLabelShow, axisModel.get("axisLabel.show"));
    if (!show || axis2.scale.isBlank()) {
      return;
    }
    var labelModel = axisModel.getModel("axisLabel");
    var labelMargin = labelModel.get("margin");
    var labels = axis2.getViewLabels();
    var labelRotation = (retrieve4(opt.labelRotate, labelModel.get("rotate")) || 0) * PI3 / 180;
    var labelLayout2 = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
    var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
    var labelEls = [];
    var silent = isLabelSilent(axisModel);
    var triggerEvent = axisModel.get("triggerEvent");
    each2(labels, function(labelItem, index2) {
      var tickValue = labelItem.tickValue;
      var formattedLabel = labelItem.formattedLabel;
      var rawLabel = labelItem.rawLabel;
      var itemLabelModel = labelModel;
      if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
        itemLabelModel = new Model2(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);
      }
      var textColor = itemLabelModel.getTextColor() || axisModel.get("axisLine.lineStyle.color");
      var tickCoord = axis2.dataToCoord(tickValue);
      var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];
      var textEl = new graphic2.Text({
        // Id for animation
        anid: "label_" + tickValue,
        position: pos,
        rotation: labelLayout2.rotation,
        silent,
        z2: 10
      });
      graphic2.setTextStyle(textEl.style, itemLabelModel, {
        text: formattedLabel,
        textAlign: itemLabelModel.getShallow("align", true) || labelLayout2.textAlign,
        textVerticalAlign: itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout2.textVerticalAlign,
        textFill: typeof textColor === "function" ? textColor(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user repalce ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          axis2.type === "category" ? rawLabel : axis2.type === "value" ? tickValue + "" : tickValue,
          index2
        ) : textColor
      });
      if (triggerEvent) {
        textEl.eventData = makeAxisEventDataBase(axisModel);
        textEl.eventData.targetType = "axisLabel";
        textEl.eventData.value = rawLabel;
      }
      axisBuilder._dumbGroup.add(textEl);
      textEl.updateTransform();
      labelEls.push(textEl);
      axisBuilder.group.add(textEl);
      textEl.decomposeTransform();
    });
    return labelEls;
  }
  var _default2 = AxisBuilder;
  AxisBuilder_1 = _default2;
  return AxisBuilder_1;
}
var modelHelper = {};
var hasRequiredModelHelper;
function requireModelHelper() {
  if (hasRequiredModelHelper)
    return modelHelper;
  hasRequiredModelHelper = 1;
  var zrUtil2 = util$6;
  var Model2 = requireModel();
  var each2 = zrUtil2.each;
  var curry2 = zrUtil2.curry;
  function collect(ecModel, api) {
    var result = {
      /**
       * key: makeKey(axis.model)
       * value: {
       *      axis,
       *      coordSys,
       *      axisPointerModel,
       *      triggerTooltip,
       *      involveSeries,
       *      snap,
       *      seriesModels,
       *      seriesDataCount
       * }
       */
      axesInfo: {},
      seriesInvolved: false,
      /**
       * key: makeKey(coordSys.model)
       * value: Object: key makeKey(axis.model), value: axisInfo
       */
      coordSysAxesInfo: {},
      coordSysMap: {}
    };
    collectAxesInfo(result, ecModel, api);
    result.seriesInvolved && collectSeriesInfo(result, ecModel);
    return result;
  }
  function collectAxesInfo(result, ecModel, api) {
    var globalTooltipModel = ecModel.getComponent("tooltip");
    var globalAxisPointerModel = ecModel.getComponent("axisPointer");
    var linksOption = globalAxisPointerModel.get("link", true) || [];
    var linkGroups = [];
    each2(api.getCoordinateSystems(), function(coordSys) {
      if (!coordSys.axisPointerEnabled) {
        return;
      }
      var coordSysKey = makeKey(coordSys.model);
      var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
      result.coordSysMap[coordSysKey] = coordSys;
      var coordSysModel = coordSys.model;
      var baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
      each2(coordSys.getAxes(), curry2(saveTooltipAxisInfo, false, null));
      if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
        var triggerAxis = baseTooltipModel.get("trigger") === "axis";
        var cross = baseTooltipModel.get("axisPointer.type") === "cross";
        var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get("axisPointer.axis"));
        if (triggerAxis || cross) {
          each2(tooltipAxes.baseAxes, curry2(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
        }
        if (cross) {
          each2(tooltipAxes.otherAxes, curry2(saveTooltipAxisInfo, "cross", false));
        }
      }
      function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis2) {
        var axisPointerModel = axis2.model.getModel("axisPointer", globalAxisPointerModel);
        var axisPointerShow = axisPointerModel.get("show");
        if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
          return;
        }
        if (triggerTooltip == null) {
          triggerTooltip = axisPointerModel.get("triggerTooltip");
        }
        axisPointerModel = fromTooltip ? makeAxisPointerModel(axis2, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
        var snap = axisPointerModel.get("snap");
        var key = makeKey(axis2.model);
        var involveSeries = triggerTooltip || snap || axis2.type === "category";
        var axisInfo = result.axesInfo[key] = {
          key,
          axis: axis2,
          coordSys,
          axisPointerModel,
          triggerTooltip,
          involveSeries,
          snap,
          useHandle: isHandleTrigger(axisPointerModel),
          seriesModels: []
        };
        axesInfoInCoordSys[key] = axisInfo;
        result.seriesInvolved |= involveSeries;
        var groupIndex = getLinkGroupIndex(linksOption, axis2);
        if (groupIndex != null) {
          var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
            axesInfo: {}
          });
          linkGroup.axesInfo[key] = axisInfo;
          linkGroup.mapper = linksOption[groupIndex].mapper;
          axisInfo.linkGroup = linkGroup;
        }
      }
    });
  }
  function makeAxisPointerModel(axis2, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
    var tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
    var volatileOption = {};
    each2(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function(field) {
      volatileOption[field] = zrUtil2.clone(tooltipAxisPointerModel.get(field));
    });
    volatileOption.snap = axis2.type !== "category" && !!triggerTooltip;
    if (tooltipAxisPointerModel.get("type") === "cross") {
      volatileOption.type = "line";
    }
    var labelOption = volatileOption.label || (volatileOption.label = {});
    labelOption.show == null && (labelOption.show = false);
    if (fromTooltip === "cross") {
      var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get("label.show");
      labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
      if (!triggerTooltip) {
        var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
        crossStyle && zrUtil2.defaults(labelOption, crossStyle.textStyle);
      }
    }
    return axis2.model.getModel("axisPointer", new Model2(volatileOption, globalAxisPointerModel, ecModel));
  }
  function collectSeriesInfo(result, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesTooltipTrigger = seriesModel.get("tooltip.trigger", true);
      var seriesTooltipShow = seriesModel.get("tooltip.show", true);
      if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get("axisPointer.show", true) === false) {
        return;
      }
      each2(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
        var axis2 = axisInfo.axis;
        if (coordSys.getAxis(axis2.dim) === axis2) {
          axisInfo.seriesModels.push(seriesModel);
          axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
          axisInfo.seriesDataCount += seriesModel.getData().count();
        }
      });
    }, this);
  }
  function getLinkGroupIndex(linksOption, axis2) {
    var axisModel = axis2.model;
    var dim = axis2.dim;
    for (var i = 0; i < linksOption.length; i++) {
      var linkOption = linksOption[i] || {};
      if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
        return i;
      }
    }
  }
  function checkPropInLink(linkPropValue, axisPropValue) {
    return linkPropValue === "all" || zrUtil2.isArray(linkPropValue) && zrUtil2.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
  }
  function fixValue(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    if (!axisInfo) {
      return;
    }
    var axisPointerModel = axisInfo.axisPointerModel;
    var scale = axisInfo.axis.scale;
    var option = axisPointerModel.option;
    var status = axisPointerModel.get("status");
    var value = axisPointerModel.get("value");
    if (value != null) {
      value = scale.parse(value);
    }
    var useHandle = isHandleTrigger(axisPointerModel);
    if (status == null) {
      option.status = useHandle ? "show" : "hide";
    }
    var extent = scale.getExtent().slice();
    extent[0] > extent[1] && extent.reverse();
    if (
      // Pick a value on axis when initializing.
      value == null || value > extent[1]
    ) {
      value = extent[1];
    }
    if (value < extent[0]) {
      value = extent[0];
    }
    option.value = value;
    if (useHandle) {
      option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
    }
  }
  function getAxisInfo(axisModel) {
    var coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
  }
  function getAxisPointerModel(axisModel) {
    var axisInfo = getAxisInfo(axisModel);
    return axisInfo && axisInfo.axisPointerModel;
  }
  function isHandleTrigger(axisPointerModel) {
    return !!axisPointerModel.get("handle.show");
  }
  function makeKey(model2) {
    return model2.type + "||" + model2.id;
  }
  modelHelper.collect = collect;
  modelHelper.fixValue = fixValue;
  modelHelper.getAxisInfo = getAxisInfo;
  modelHelper.getAxisPointerModel = getAxisPointerModel;
  modelHelper.makeKey = makeKey;
  return modelHelper;
}
var AxisView_1;
var hasRequiredAxisView;
function requireAxisView() {
  if (hasRequiredAxisView)
    return AxisView_1;
  hasRequiredAxisView = 1;
  var echarts$12 = echarts;
  var axisPointerModelHelper = requireModelHelper();
  var AxisView = echarts$12.extendComponentView({
    type: "axis",
    /**
     * @private
     */
    _axisPointer: null,
    /**
     * @protected
     * @type {string}
     */
    axisPointerClass: null,
    /**
     * @override
     */
    render: function(axisModel, ecModel, api, payload) {
      this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
      AxisView.superApply(this, "render", arguments);
      updateAxisPointer(this, axisModel, ecModel, api, payload, true);
    },
    /**
     * Action handler.
     * @public
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/model/Global} ecModel
     * @param {module:echarts/ExtensionAPI} api
     * @param {Object} payload
     */
    updateAxisPointer: function(axisModel, ecModel, api, payload, force) {
      updateAxisPointer(this, axisModel, ecModel, api, payload, false);
    },
    /**
     * @override
     */
    remove: function(ecModel, api) {
      var axisPointer2 = this._axisPointer;
      axisPointer2 && axisPointer2.remove(api);
      AxisView.superApply(this, "remove", arguments);
    },
    /**
     * @override
     */
    dispose: function(ecModel, api) {
      disposeAxisPointer(this, api);
      AxisView.superApply(this, "dispose", arguments);
    }
  });
  function updateAxisPointer(axisView, axisModel, ecModel, api, payload, forceRender) {
    var Clazz = AxisView.getAxisPointerClass(axisView.axisPointerClass);
    if (!Clazz) {
      return;
    }
    var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
    axisPointerModel ? (axisView._axisPointer || (axisView._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : disposeAxisPointer(axisView, api);
  }
  function disposeAxisPointer(axisView, ecModel, api) {
    var axisPointer2 = axisView._axisPointer;
    axisPointer2 && axisPointer2.dispose(ecModel, api);
    axisView._axisPointer = null;
  }
  var axisPointerClazz = [];
  AxisView.registerAxisPointerClass = function(type, clazz2) {
    axisPointerClazz[type] = clazz2;
  };
  AxisView.getAxisPointerClass = function(type) {
    return type && axisPointerClazz[type];
  };
  var _default2 = AxisView;
  AxisView_1 = _default2;
  return AxisView_1;
}
var cartesianAxisHelper = {};
var hasRequiredCartesianAxisHelper;
function requireCartesianAxisHelper() {
  if (hasRequiredCartesianAxisHelper)
    return cartesianAxisHelper;
  hasRequiredCartesianAxisHelper = 1;
  var zrUtil2 = util$6;
  function layout2(gridModel, axisModel, opt) {
    opt = opt || {};
    var grid2 = gridModel.coordinateSystem;
    var axis2 = axisModel.axis;
    var layout3 = {};
    var otherAxisOnZeroOf = axis2.getAxesOnZeroOf()[0];
    var rawAxisPosition = axis2.position;
    var axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
    var axisDim = axis2.dim;
    var rect = grid2.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var idx = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    };
    var axisOffset = axisModel.get("offset") || 0;
    var posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
    if (otherAxisOnZeroOf) {
      var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
      posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
    }
    layout3.position = [axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0], axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]];
    layout3.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
    var dirMap = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    };
    layout3.labelDirection = layout3.tickDirection = layout3.nameDirection = dirMap[rawAxisPosition];
    layout3.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
    if (axisModel.get("axisTick.inside")) {
      layout3.tickDirection = -layout3.tickDirection;
    }
    if (zrUtil2.retrieve(opt.labelInside, axisModel.get("axisLabel.inside"))) {
      layout3.labelDirection = -layout3.labelDirection;
    }
    var labelRotate = axisModel.get("axisLabel.rotate");
    layout3.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
    layout3.z2 = 1;
    return layout3;
  }
  cartesianAxisHelper.layout = layout2;
  return cartesianAxisHelper;
}
var axisSplitHelper = {};
var hasRequiredAxisSplitHelper;
function requireAxisSplitHelper() {
  if (hasRequiredAxisSplitHelper)
    return axisSplitHelper;
  hasRequiredAxisSplitHelper = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
    var axis2 = axisModel.axis;
    if (axis2.scale.isBlank()) {
      return;
    }
    var splitAreaModel = axisModel.getModel("splitArea");
    var areaStyleModel = splitAreaModel.getModel("areaStyle");
    var areaColors = areaStyleModel.get("color");
    var gridRect = gridModel.coordinateSystem.getRect();
    var ticksCoords = axis2.getTicksCoords({
      tickModel: splitAreaModel,
      clamp: true
    });
    if (!ticksCoords.length) {
      return;
    }
    var areaColorsLen = areaColors.length;
    var lastSplitAreaColors = axisView.__splitAreaColors;
    var newSplitAreaColors = zrUtil2.createHashMap();
    var colorIndex = 0;
    if (lastSplitAreaColors) {
      for (var i = 0; i < ticksCoords.length; i++) {
        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
        if (cIndex != null) {
          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
          break;
        }
      }
    }
    var prev = axis2.toGlobalCoord(ticksCoords[0].coord);
    var areaStyle2 = areaStyleModel.getAreaStyle();
    areaColors = zrUtil2.isArray(areaColors) ? areaColors : [areaColors];
    for (var i = 1; i < ticksCoords.length; i++) {
      var tickCoord = axis2.toGlobalCoord(ticksCoords[i].coord);
      var x;
      var y;
      var width;
      var height;
      if (axis2.isHorizontal()) {
        x = prev;
        y = gridRect.y;
        width = tickCoord - x;
        height = gridRect.height;
        prev = x + width;
      } else {
        x = gridRect.x;
        y = prev;
        width = gridRect.width;
        height = tickCoord - y;
        prev = y + height;
      }
      var tickValue = ticksCoords[i - 1].tickValue;
      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
      axisGroup.add(new graphic2.Rect({
        anid: tickValue != null ? "area_" + tickValue : null,
        shape: {
          x,
          y,
          width,
          height
        },
        style: zrUtil2.defaults({
          fill: areaColors[colorIndex]
        }, areaStyle2),
        silent: true
      }));
      colorIndex = (colorIndex + 1) % areaColorsLen;
    }
    axisView.__splitAreaColors = newSplitAreaColors;
  }
  function rectCoordAxisHandleRemove(axisView) {
    axisView.__splitAreaColors = null;
  }
  axisSplitHelper.rectCoordAxisBuildSplitArea = rectCoordAxisBuildSplitArea;
  axisSplitHelper.rectCoordAxisHandleRemove = rectCoordAxisHandleRemove;
  return axisSplitHelper;
}
var hasRequiredCartesianAxisView;
function requireCartesianAxisView() {
  if (hasRequiredCartesianAxisView)
    return CartesianAxisView;
  hasRequiredCartesianAxisView = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var AxisBuilder = requireAxisBuilder();
  var AxisView = requireAxisView();
  var cartesianAxisHelper2 = requireCartesianAxisHelper();
  var _axisSplitHelper = requireAxisSplitHelper();
  var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
  var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
  var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
  var selfBuilderAttrs = ["splitArea", "splitLine", "minorSplitLine"];
  var CartesianAxisView$1 = AxisView.extend({
    type: "cartesianAxis",
    axisPointerClass: "CartesianAxisPointer",
    /**
     * @override
     */
    render: function(axisModel, ecModel, api, payload) {
      this.group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new graphic2.Group();
      this.group.add(this._axisGroup);
      if (!axisModel.get("show")) {
        return;
      }
      var gridModel = axisModel.getCoordSysModel();
      var layout2 = cartesianAxisHelper2.layout(gridModel, axisModel);
      var axisBuilder = new AxisBuilder(axisModel, layout2);
      zrUtil2.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      this._axisGroup.add(axisBuilder.getGroup());
      zrUtil2.each(selfBuilderAttrs, function(name2) {
        if (axisModel.get(name2 + ".show")) {
          this["_" + name2](axisModel, gridModel);
        }
      }, this);
      graphic2.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
      CartesianAxisView$1.superCall(this, "render", axisModel, ecModel, api, payload);
    },
    remove: function() {
      rectCoordAxisHandleRemove(this);
    },
    /**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @private
     */
    _splitLine: function(axisModel, gridModel) {
      var axis2 = axisModel.axis;
      if (axis2.scale.isBlank()) {
        return;
      }
      var splitLineModel = axisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      lineColors = zrUtil2.isArray(lineColors) ? lineColors : [lineColors];
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis2.isHorizontal();
      var lineCount = 0;
      var ticksCoords = axis2.getTicksCoords({
        tickModel: splitLineModel
      });
      var p1 = [];
      var p2 = [];
      var lineStyle2 = lineStyleModel.getLineStyle();
      for (var i = 0; i < ticksCoords.length; i++) {
        var tickCoord = axis2.toGlobalCoord(ticksCoords[i].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = lineCount++ % lineColors.length;
        var tickValue = ticksCoords[i].tickValue;
        this._axisGroup.add(new graphic2.Line({
          anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
          subPixelOptimize: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: zrUtil2.defaults({
            stroke: lineColors[colorIndex]
          }, lineStyle2),
          silent: true
        }));
      }
    },
    /**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @private
     */
    _minorSplitLine: function(axisModel, gridModel) {
      var axis2 = axisModel.axis;
      var minorSplitLineModel = axisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var gridRect = gridModel.coordinateSystem.getRect();
      var isHorizontal = axis2.isHorizontal();
      var minorTicksCoords = axis2.getMinorTicksCoords();
      if (!minorTicksCoords.length) {
        return;
      }
      var p1 = [];
      var p2 = [];
      var lineStyle2 = lineStyleModel.getLineStyle();
      for (var i = 0; i < minorTicksCoords.length; i++) {
        for (var k = 0; k < minorTicksCoords[i].length; k++) {
          var tickCoord = axis2.toGlobalCoord(minorTicksCoords[i][k].coord);
          if (isHorizontal) {
            p1[0] = tickCoord;
            p1[1] = gridRect.y;
            p2[0] = tickCoord;
            p2[1] = gridRect.y + gridRect.height;
          } else {
            p1[0] = gridRect.x;
            p1[1] = tickCoord;
            p2[0] = gridRect.x + gridRect.width;
            p2[1] = tickCoord;
          }
          this._axisGroup.add(new graphic2.Line({
            anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
            subPixelOptimize: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: lineStyle2,
            silent: true
          }));
        }
      }
    },
    /**
     * @param {module:echarts/coord/cartesian/AxisModel} axisModel
     * @param {module:echarts/coord/cartesian/GridModel} gridModel
     * @private
     */
    _splitArea: function(axisModel, gridModel) {
      rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, gridModel);
    }
  });
  CartesianAxisView$1.extend({
    type: "xAxis"
  });
  CartesianAxisView$1.extend({
    type: "yAxis"
  });
  return CartesianAxisView;
}
var hasRequiredAxis;
function requireAxis() {
  if (hasRequiredAxis)
    return axis;
  hasRequiredAxis = 1;
  requireAxisModel$3();
  requireCartesianAxisView();
  return axis;
}
var hasRequiredGridSimple;
function requireGridSimple() {
  if (hasRequiredGridSimple)
    return gridSimple;
  hasRequiredGridSimple = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  requireGrid$1();
  requireAxis();
  echarts$12.extendComponentView({
    type: "grid",
    render: function(gridModel, ecModel) {
      this.group.removeAll();
      if (gridModel.get("show")) {
        this.group.add(new graphic2.Rect({
          shape: gridModel.coordinateSystem.getRect(),
          style: zrUtil2.defaults({
            fill: gridModel.get("backgroundColor")
          }, gridModel.getItemStyle()),
          silent: true,
          z2: -1
        }));
      }
    }
  });
  echarts$12.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
  return gridSimple;
}
var hasRequiredLine$1;
function requireLine$1() {
  if (hasRequiredLine$1)
    return line;
  hasRequiredLine$1 = 1;
  var echarts$12 = echarts;
  requireLineSeries();
  requireLineView();
  var visualSymbol = requireSymbol();
  var layoutPoints = requirePoints();
  var dataSample2 = requireDataSample();
  requireGridSimple();
  echarts$12.registerVisual(visualSymbol("line", "circle", "line"));
  echarts$12.registerLayout(layoutPoints("line"));
  echarts$12.registerProcessor(echarts$12.PRIORITY.PROCESSOR.STATISTIC, dataSample2("line"));
  return line;
}
var bar = {};
var BaseBarSeries;
var hasRequiredBaseBarSeries;
function requireBaseBarSeries() {
  if (hasRequiredBaseBarSeries)
    return BaseBarSeries;
  hasRequiredBaseBarSeries = 1;
  var SeriesModel2 = Series;
  var createListFromArray = requireCreateListFromArray();
  var _default2 = SeriesModel2.extend({
    type: "series.__base_bar__",
    getInitialData: function(option, ecModel) {
      return createListFromArray(this.getSource(), this, {
        useEncodeDefaulter: true
      });
    },
    getMarkerPosition: function(value) {
      var coordSys = this.coordinateSystem;
      if (coordSys) {
        var pt = coordSys.dataToPoint(coordSys.clampData(value));
        var data = this.getData();
        var offset = data.getLayout("offset");
        var size2 = data.getLayout("size");
        var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
        pt[offsetIndex] += offset + size2 / 2;
        return pt;
      }
      return [NaN, NaN];
    },
    defaultOption: {
      zlevel: 0,
      // 一级层叠
      z: 2,
      // 二级层叠
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // 最小高度改为0
      barMinHeight: 0,
      // 最小角度为0，仅对极坐标系下的柱状图有效
      barMinAngle: 0,
      // cursor: null,
      large: false,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod",
      // barMaxWidth: null,
      // In cartesian, the default value is 1. Otherwise null.
      // barMinWidth: null,
      // 默认自适应
      // barWidth: null,
      // 柱间距离，默认为柱形宽度的30%，可设固定值
      // barGap: '30%',
      // 类目间柱形距离，默认为类目间距的20%，可设固定值
      // barCategoryGap: '20%',
      // label: {
      //      show: false
      // },
      itemStyle: {},
      emphasis: {}
    }
  });
  BaseBarSeries = _default2;
  return BaseBarSeries;
}
var BarSeries;
var hasRequiredBarSeries;
function requireBarSeries() {
  if (hasRequiredBarSeries)
    return BarSeries;
  hasRequiredBarSeries = 1;
  var BaseBarSeries2 = requireBaseBarSeries();
  var _default2 = BaseBarSeries2.extend({
    type: "series.bar",
    dependencies: ["grid", "polar"],
    brushSelector: "rect",
    /**
     * @override
     */
    getProgressive: function() {
      return this.get("large") ? this.get("progressive") : false;
    },
    /**
     * @override
     */
    getProgressiveThreshold: function() {
      var progressiveThreshold = this.get("progressiveThreshold");
      var largeThreshold = this.get("largeThreshold");
      if (largeThreshold > progressiveThreshold) {
        progressiveThreshold = largeThreshold;
      }
      return progressiveThreshold;
    },
    defaultOption: {
      // If clipped
      // Only available on cartesian2d
      clip: true,
      // If use caps on two sides of bars
      // Only available on tangential polar bar
      roundCap: false,
      showBackground: false,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      }
    }
  });
  BarSeries = _default2;
  return BarSeries;
}
var helper$2 = {};
var hasRequiredHelper$2;
function requireHelper$2() {
  if (hasRequiredHelper$2)
    return helper$2;
  hasRequiredHelper$2 = 1;
  var graphic2 = graphic$4;
  var _labelHelper = requireLabelHelper();
  var getDefaultLabel = _labelHelper.getDefaultLabel;
  function setLabel(normalStyle, hoverStyle, itemModel, color2, seriesModel, dataIndex, labelPositionOutside) {
    var labelModel = itemModel.getModel("label");
    var hoverLabelModel = itemModel.getModel("emphasis.label");
    graphic2.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {
      labelFetcher: seriesModel,
      labelDataIndex: dataIndex,
      defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
      isRectText: true,
      autoColor: color2
    });
    fixPosition(normalStyle);
    fixPosition(hoverStyle);
  }
  function fixPosition(style, labelPositionOutside) {
    if (style.textPosition === "outside") {
      style.textPosition = labelPositionOutside;
    }
  }
  helper$2.setLabel = setLabel;
  return helper$2;
}
var barItemStyle;
var hasRequiredBarItemStyle;
function requireBarItemStyle() {
  if (hasRequiredBarItemStyle)
    return barItemStyle;
  hasRequiredBarItemStyle = 1;
  var makeStyleMapper2 = requireMakeStyleMapper();
  var getBarItemStyle = makeStyleMapper2([
    ["fill", "color"],
    ["stroke", "borderColor"],
    ["lineWidth", "borderWidth"],
    // Compatitable with 2
    ["stroke", "barBorderColor"],
    ["lineWidth", "barBorderWidth"],
    ["opacity"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"]
  ]);
  var _default2 = {
    getBarItemStyle: function(excludes) {
      var style = getBarItemStyle(this, excludes);
      if (this.getBorderLineDash) {
        var lineDash = this.getBorderLineDash();
        lineDash && (style.lineDash = lineDash);
      }
      return style;
    }
  };
  barItemStyle = _default2;
  return barItemStyle;
}
var sausage;
var hasRequiredSausage;
function requireSausage() {
  if (hasRequiredSausage)
    return sausage;
  hasRequiredSausage = 1;
  var _graphic = graphic$4;
  var extendShape2 = _graphic.extendShape;
  var _default2 = extendShape2({
    type: "sausage",
    shape: {
      cx: 0,
      cy: 0,
      r0: 0,
      r: 0,
      startAngle: 0,
      endAngle: Math.PI * 2,
      clockwise: true
    },
    buildPath: function(ctx, shape) {
      var x = shape.cx;
      var y = shape.cy;
      var r0 = Math.max(shape.r0 || 0, 0);
      var r = Math.max(shape.r, 0);
      var dr = (r - r0) * 0.5;
      var rCenter = r0 + dr;
      var startAngle = shape.startAngle;
      var endAngle = shape.endAngle;
      var clockwise = shape.clockwise;
      var unitStartX = Math.cos(startAngle);
      var unitStartY = Math.sin(startAngle);
      var unitEndX = Math.cos(endAngle);
      var unitEndY = Math.sin(endAngle);
      var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;
      if (lessThanCircle) {
        ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
        ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
      }
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
      ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
      ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
      if (r0 !== 0) {
        ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
        ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
      }
      ctx.closePath();
    }
  });
  sausage = _default2;
  return sausage;
}
var BarView;
var hasRequiredBarView;
function requireBarView() {
  if (hasRequiredBarView)
    return BarView;
  hasRequiredBarView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var _helper = requireHelper$2();
  var setLabel = _helper.setLabel;
  var Model2 = requireModel();
  var barItemStyle2 = requireBarItemStyle();
  var Path2 = Path_1;
  var Group2 = Group_1;
  var _throttle = throttle$1;
  var throttle2 = _throttle.throttle;
  var _createClipPathFromCoordSys = requireCreateClipPathFromCoordSys();
  var createClipPath = _createClipPathFromCoordSys.createClipPath;
  var Sausage = requireSausage();
  var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "barBorderWidth"];
  var _eventPos = [0, 0];
  zrUtil2.extend(Model2.prototype, barItemStyle2);
  function getClipArea(coord, data) {
    var coordSysClipArea = coord.getArea && coord.getArea();
    if (coord.type === "cartesian2d") {
      var baseAxis = coord.getBaseAxis();
      if (baseAxis.type !== "category" || !baseAxis.onBand) {
        var expandWidth = data.getLayout("bandWidth");
        if (baseAxis.isHorizontal()) {
          coordSysClipArea.x -= expandWidth;
          coordSysClipArea.width += expandWidth * 2;
        } else {
          coordSysClipArea.y -= expandWidth;
          coordSysClipArea.height += expandWidth * 2;
        }
      }
    }
    return coordSysClipArea;
  }
  var _default2 = echarts$12.extendChartView({
    type: "bar",
    render: function(seriesModel, ecModel, api) {
      this._updateDrawMode(seriesModel);
      var coordinateSystemType = seriesModel.get("coordinateSystem");
      if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
        this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api);
      }
      return this.group;
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
      this._clear();
      this._updateDrawMode(seriesModel);
    },
    incrementalRender: function(params, seriesModel, ecModel, api) {
      this._incrementalRenderLarge(params, seriesModel);
    },
    _updateDrawMode: function(seriesModel) {
      var isLargeDraw = seriesModel.pipelineContext.large;
      if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
        this._isLargeDraw = isLargeDraw;
        this._clear();
      }
    },
    _renderNormal: function(seriesModel, ecModel, api) {
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      var coord = seriesModel.coordinateSystem;
      var baseAxis = coord.getBaseAxis();
      var isHorizontalOrRadial;
      if (coord.type === "cartesian2d") {
        isHorizontalOrRadial = baseAxis.isHorizontal();
      } else if (coord.type === "polar") {
        isHorizontalOrRadial = baseAxis.dim === "angle";
      }
      var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
      var needsClip = seriesModel.get("clip", true);
      var coordSysClipArea = getClipArea(coord, data);
      group.removeClipPath();
      var roundCap = seriesModel.get("roundCap", true);
      var drawBackground2 = seriesModel.get("showBackground", true);
      var backgroundModel = seriesModel.getModel("backgroundStyle");
      var barBorderRadius = backgroundModel.get("barBorderRadius") || 0;
      var bgEls = [];
      var oldBgEls = this._backgroundEls || [];
      var createBackground = function(dataIndex) {
        var bgLayout = getLayout[coord.type](data, dataIndex);
        var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
        bgEl.useStyle(backgroundModel.getBarItemStyle());
        if (coord.type === "cartesian2d") {
          bgEl.setShape("r", barBorderRadius);
        }
        bgEls[dataIndex] = bgEl;
        return bgEl;
      };
      data.diff(oldData).add(function(dataIndex) {
        var itemModel = data.getItemModel(dataIndex);
        var layout2 = getLayout[coord.type](data, dataIndex, itemModel);
        if (drawBackground2) {
          createBackground(dataIndex);
        }
        if (!data.hasValue(dataIndex)) {
          return;
        }
        if (needsClip) {
          var isClipped = clip[coord.type](coordSysClipArea, layout2);
          if (isClipped) {
            group.remove(el);
            return;
          }
        }
        var el = elementCreator[coord.type](dataIndex, layout2, isHorizontalOrRadial, animationModel, false, roundCap);
        data.setItemGraphicEl(dataIndex, el);
        group.add(el);
        updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }).update(function(newIndex, oldIndex) {
        var itemModel = data.getItemModel(newIndex);
        var layout2 = getLayout[coord.type](data, newIndex, itemModel);
        if (drawBackground2) {
          var bgEl;
          if (oldBgEls.length === 0) {
            bgEl = createBackground(oldIndex);
          } else {
            bgEl = oldBgEls[oldIndex];
            bgEl.useStyle(backgroundModel.getBarItemStyle());
            if (coord.type === "cartesian2d") {
              bgEl.setShape("r", barBorderRadius);
            }
            bgEls[newIndex] = bgEl;
          }
          var bgLayout = getLayout[coord.type](data, newIndex);
          var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
          graphic2.updateProps(bgEl, {
            shape
          }, animationModel, newIndex);
        }
        var el = oldData.getItemGraphicEl(oldIndex);
        if (!data.hasValue(newIndex)) {
          group.remove(el);
          return;
        }
        if (needsClip) {
          var isClipped = clip[coord.type](coordSysClipArea, layout2);
          if (isClipped) {
            group.remove(el);
            return;
          }
        }
        if (el) {
          graphic2.updateProps(el, {
            shape: layout2
          }, animationModel, newIndex);
        } else {
          el = elementCreator[coord.type](newIndex, layout2, isHorizontalOrRadial, animationModel, true, roundCap);
        }
        data.setItemGraphicEl(newIndex, el);
        group.add(el);
        updateStyle(el, data, newIndex, itemModel, layout2, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }).remove(function(dataIndex) {
        var el = oldData.getItemGraphicEl(dataIndex);
        if (coord.type === "cartesian2d") {
          el && removeRect(dataIndex, animationModel, el);
        } else {
          el && removeSector(dataIndex, animationModel, el);
        }
      }).execute();
      var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group2());
      bgGroup.removeAll();
      for (var i = 0; i < bgEls.length; ++i) {
        bgGroup.add(bgEls[i]);
      }
      group.add(bgGroup);
      this._backgroundEls = bgEls;
      this._data = data;
    },
    _renderLarge: function(seriesModel, ecModel, api) {
      this._clear();
      createLarge(seriesModel, this.group);
      var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
      if (clipPath) {
        this.group.setClipPath(clipPath);
      } else {
        this.group.removeClipPath();
      }
    },
    _incrementalRenderLarge: function(params, seriesModel) {
      this._removeBackground();
      createLarge(seriesModel, this.group, true);
    },
    dispose: zrUtil2.noop,
    remove: function(ecModel) {
      this._clear(ecModel);
    },
    _clear: function(ecModel) {
      var group = this.group;
      var data = this._data;
      if (ecModel && ecModel.get("animation") && data && !this._isLargeDraw) {
        this._removeBackground();
        this._backgroundEls = [];
        data.eachItemGraphicEl(function(el) {
          if (el.type === "sector") {
            removeSector(el.dataIndex, ecModel, el);
          } else {
            removeRect(el.dataIndex, ecModel, el);
          }
        });
      } else {
        group.removeAll();
      }
      this._data = null;
    },
    _removeBackground: function() {
      this.group.remove(this._backgroundGroup);
      this._backgroundGroup = null;
    }
  });
  var mathMax2 = Math.max;
  var mathMin2 = Math.min;
  var clip = {
    cartesian2d: function(coordSysBoundingRect, layout2) {
      var signWidth = layout2.width < 0 ? -1 : 1;
      var signHeight = layout2.height < 0 ? -1 : 1;
      if (signWidth < 0) {
        layout2.x += layout2.width;
        layout2.width = -layout2.width;
      }
      if (signHeight < 0) {
        layout2.y += layout2.height;
        layout2.height = -layout2.height;
      }
      var x = mathMax2(layout2.x, coordSysBoundingRect.x);
      var x2 = mathMin2(layout2.x + layout2.width, coordSysBoundingRect.x + coordSysBoundingRect.width);
      var y = mathMax2(layout2.y, coordSysBoundingRect.y);
      var y2 = mathMin2(layout2.y + layout2.height, coordSysBoundingRect.y + coordSysBoundingRect.height);
      layout2.x = x;
      layout2.y = y;
      layout2.width = x2 - x;
      layout2.height = y2 - y;
      var clipped = layout2.width < 0 || layout2.height < 0;
      if (signWidth < 0) {
        layout2.x += layout2.width;
        layout2.width = -layout2.width;
      }
      if (signHeight < 0) {
        layout2.y += layout2.height;
        layout2.height = -layout2.height;
      }
      return clipped;
    },
    polar: function(coordSysClipArea, layout2) {
      var signR = layout2.r0 <= layout2.r ? 1 : -1;
      if (signR < 0) {
        var r = layout2.r;
        layout2.r = layout2.r0;
        layout2.r0 = r;
      }
      var r = mathMin2(layout2.r, coordSysClipArea.r);
      var r0 = mathMax2(layout2.r0, coordSysClipArea.r0);
      layout2.r = r;
      layout2.r0 = r0;
      var clipped = r - r0 < 0;
      if (signR < 0) {
        var r = layout2.r;
        layout2.r = layout2.r0;
        layout2.r0 = r;
      }
      return clipped;
    }
  };
  var elementCreator = {
    cartesian2d: function(dataIndex, layout2, isHorizontal, animationModel, isUpdate) {
      var rect = new graphic2.Rect({
        shape: zrUtil2.extend({}, layout2),
        z2: 1
      });
      rect.name = "item";
      if (animationModel) {
        var rectShape = rect.shape;
        var animateProperty = isHorizontal ? "height" : "width";
        var animateTarget = {};
        rectShape[animateProperty] = 0;
        animateTarget[animateProperty] = layout2[animateProperty];
        graphic2[isUpdate ? "updateProps" : "initProps"](rect, {
          shape: animateTarget
        }, animationModel, dataIndex);
      }
      return rect;
    },
    polar: function(dataIndex, layout2, isRadial, animationModel, isUpdate, roundCap) {
      var clockwise = layout2.startAngle < layout2.endAngle;
      var ShapeClass = !isRadial && roundCap ? Sausage : graphic2.Sector;
      var sector = new ShapeClass({
        shape: zrUtil2.defaults({
          clockwise
        }, layout2),
        z2: 1
      });
      sector.name = "item";
      if (animationModel) {
        var sectorShape = sector.shape;
        var animateProperty = isRadial ? "r" : "endAngle";
        var animateTarget = {};
        sectorShape[animateProperty] = isRadial ? 0 : layout2.startAngle;
        animateTarget[animateProperty] = layout2[animateProperty];
        graphic2[isUpdate ? "updateProps" : "initProps"](sector, {
          shape: animateTarget
        }, animationModel, dataIndex);
      }
      return sector;
    }
  };
  function removeRect(dataIndex, animationModel, el) {
    el.style.text = null;
    graphic2.updateProps(el, {
      shape: {
        width: 0
      }
    }, animationModel, dataIndex, function() {
      el.parent && el.parent.remove(el);
    });
  }
  function removeSector(dataIndex, animationModel, el) {
    el.style.text = null;
    graphic2.updateProps(el, {
      shape: {
        r: el.shape.r0
      }
    }, animationModel, dataIndex, function() {
      el.parent && el.parent.remove(el);
    });
  }
  var getLayout = {
    // itemModel is only used to get borderWidth, which is not needed
    // when calculating bar background layout.
    cartesian2d: function(data, dataIndex, itemModel) {
      var layout2 = data.getItemLayout(dataIndex);
      var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout2) : 0;
      var signX = layout2.width > 0 ? 1 : -1;
      var signY = layout2.height > 0 ? 1 : -1;
      return {
        x: layout2.x + signX * fixedLineWidth / 2,
        y: layout2.y + signY * fixedLineWidth / 2,
        width: layout2.width - signX * fixedLineWidth,
        height: layout2.height - signY * fixedLineWidth
      };
    },
    polar: function(data, dataIndex, itemModel) {
      var layout2 = data.getItemLayout(dataIndex);
      return {
        cx: layout2.cx,
        cy: layout2.cy,
        r0: layout2.r0,
        r: layout2.r,
        startAngle: layout2.startAngle,
        endAngle: layout2.endAngle
      };
    }
  };
  function isZeroOnPolar(layout2) {
    return layout2.startAngle != null && layout2.endAngle != null && layout2.startAngle === layout2.endAngle;
  }
  function updateStyle(el, data, dataIndex, itemModel, layout2, seriesModel, isHorizontal, isPolar) {
    var color2 = data.getItemVisual(dataIndex, "color");
    var opacity = data.getItemVisual(dataIndex, "opacity");
    var stroke = data.getVisual("borderColor");
    var itemStyleModel = itemModel.getModel("itemStyle");
    var hoverStyle = itemModel.getModel("emphasis.itemStyle").getBarItemStyle();
    if (!isPolar) {
      el.setShape("r", itemStyleModel.get("barBorderRadius") || 0);
    }
    el.useStyle(zrUtil2.defaults({
      stroke: isZeroOnPolar(layout2) ? "none" : stroke,
      fill: isZeroOnPolar(layout2) ? "none" : color2,
      opacity
    }, itemStyleModel.getBarItemStyle()));
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && el.attr("cursor", cursorStyle);
    var labelPositionOutside = isHorizontal ? layout2.height > 0 ? "bottom" : "top" : layout2.width > 0 ? "left" : "right";
    if (!isPolar) {
      setLabel(el.style, hoverStyle, itemModel, color2, seriesModel, dataIndex, labelPositionOutside);
    }
    if (isZeroOnPolar(layout2)) {
      hoverStyle.fill = hoverStyle.stroke = "none";
    }
    graphic2.setHoverStyle(el, hoverStyle);
  }
  function getLineWidth(itemModel, rawLayout) {
    var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
    var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
    var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
    return Math.min(lineWidth, width, height);
  }
  var LargePath = Path2.extend({
    type: "largeBar",
    shape: {
      points: []
    },
    buildPath: function(ctx, shape) {
      var points2 = shape.points;
      var startPoint = this.__startPoint;
      var baseDimIdx = this.__baseDimIdx;
      for (var i = 0; i < points2.length; i += 2) {
        startPoint[baseDimIdx] = points2[i + baseDimIdx];
        ctx.moveTo(startPoint[0], startPoint[1]);
        ctx.lineTo(points2[i], points2[i + 1]);
      }
    }
  });
  function createLarge(seriesModel, group, incremental) {
    var data = seriesModel.getData();
    var startPoint = [];
    var baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
    startPoint[1 - baseDimIdx] = data.getLayout("valueAxisStart");
    var largeDataIndices = data.getLayout("largeDataIndices");
    var barWidth = data.getLayout("barWidth");
    var backgroundModel = seriesModel.getModel("backgroundStyle");
    var drawBackground2 = seriesModel.get("showBackground", true);
    if (drawBackground2) {
      var points2 = data.getLayout("largeBackgroundPoints");
      var backgroundStartPoint = [];
      backgroundStartPoint[1 - baseDimIdx] = data.getLayout("backgroundStart");
      var bgEl = new LargePath({
        shape: {
          points: points2
        },
        incremental: !!incremental,
        __startPoint: backgroundStartPoint,
        __baseDimIdx: baseDimIdx,
        __largeDataIndices: largeDataIndices,
        __barWidth: barWidth,
        silent: true,
        z2: 0
      });
      setLargeBackgroundStyle(bgEl, backgroundModel, data);
      group.add(bgEl);
    }
    var el = new LargePath({
      shape: {
        points: data.getLayout("largePoints")
      },
      incremental: !!incremental,
      __startPoint: startPoint,
      __baseDimIdx: baseDimIdx,
      __largeDataIndices: largeDataIndices,
      __barWidth: barWidth
    });
    group.add(el);
    setLargeStyle(el, seriesModel, data);
    el.seriesIndex = seriesModel.seriesIndex;
    if (!seriesModel.get("silent")) {
      el.on("mousedown", largePathUpdateDataIndex);
      el.on("mousemove", largePathUpdateDataIndex);
    }
  }
  var largePathUpdateDataIndex = throttle2(function(event2) {
    var largePath = this;
    var dataIndex = largePathFindDataIndex(largePath, event2.offsetX, event2.offsetY);
    largePath.dataIndex = dataIndex >= 0 ? dataIndex : null;
  }, 30, false);
  function largePathFindDataIndex(largePath, x, y) {
    var baseDimIdx = largePath.__baseDimIdx;
    var valueDimIdx = 1 - baseDimIdx;
    var points2 = largePath.shape.points;
    var largeDataIndices = largePath.__largeDataIndices;
    var barWidthHalf = Math.abs(largePath.__barWidth / 2);
    var startValueVal = largePath.__startPoint[valueDimIdx];
    _eventPos[0] = x;
    _eventPos[1] = y;
    var pointerBaseVal = _eventPos[baseDimIdx];
    var pointerValueVal = _eventPos[1 - baseDimIdx];
    var baseLowerBound = pointerBaseVal - barWidthHalf;
    var baseUpperBound = pointerBaseVal + barWidthHalf;
    for (var i = 0, len = points2.length / 2; i < len; i++) {
      var ii = i * 2;
      var barBaseVal = points2[ii + baseDimIdx];
      var barValueVal = points2[ii + valueDimIdx];
      if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
        return largeDataIndices[i];
      }
    }
    return -1;
  }
  function setLargeStyle(el, seriesModel, data) {
    var borderColor = data.getVisual("borderColor") || data.getVisual("color");
    var itemStyle2 = seriesModel.getModel("itemStyle").getItemStyle(["color", "borderColor"]);
    el.useStyle(itemStyle2);
    el.style.fill = null;
    el.style.stroke = borderColor;
    el.style.lineWidth = data.getLayout("barWidth");
  }
  function setLargeBackgroundStyle(el, backgroundModel, data) {
    var borderColor = backgroundModel.get("borderColor") || backgroundModel.get("color");
    var itemStyle2 = backgroundModel.getItemStyle(["color", "borderColor"]);
    el.useStyle(itemStyle2);
    el.style.fill = null;
    el.style.stroke = borderColor;
    el.style.lineWidth = data.getLayout("barWidth");
  }
  function createBackgroundShape(isHorizontalOrRadial, layout2, coord) {
    var coordLayout;
    var isPolar = coord.type === "polar";
    if (isPolar) {
      coordLayout = coord.getArea();
    } else {
      coordLayout = coord.grid.getRect();
    }
    if (isPolar) {
      return {
        cx: coordLayout.cx,
        cy: coordLayout.cy,
        r0: isHorizontalOrRadial ? coordLayout.r0 : layout2.r0,
        r: isHorizontalOrRadial ? coordLayout.r : layout2.r,
        startAngle: isHorizontalOrRadial ? layout2.startAngle : 0,
        endAngle: isHorizontalOrRadial ? layout2.endAngle : Math.PI * 2
      };
    } else {
      return {
        x: isHorizontalOrRadial ? layout2.x : coordLayout.x,
        y: isHorizontalOrRadial ? coordLayout.y : layout2.y,
        width: isHorizontalOrRadial ? layout2.width : coordLayout.width,
        height: isHorizontalOrRadial ? coordLayout.height : layout2.height
      };
    }
  }
  function createBackgroundEl(coord, isHorizontalOrRadial, layout2) {
    var ElementClz = coord.type === "polar" ? graphic2.Sector : graphic2.Rect;
    return new ElementClz({
      shape: createBackgroundShape(isHorizontalOrRadial, layout2, coord),
      silent: true,
      z2: 0
    });
  }
  BarView = _default2;
  return BarView;
}
var hasRequiredBar;
function requireBar() {
  if (hasRequiredBar)
    return bar;
  hasRequiredBar = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var _barGrid = requireBarGrid();
  var layout2 = _barGrid.layout;
  var largeLayout = _barGrid.largeLayout;
  requireGrid$1();
  requireBarSeries();
  requireBarView();
  requireGridSimple();
  echarts$12.registerLayout(echarts$12.PRIORITY.VISUAL.LAYOUT, zrUtil2.curry(layout2, "bar"));
  echarts$12.registerLayout(echarts$12.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, largeLayout);
  echarts$12.registerVisual({
    seriesType: "bar",
    reset: function(seriesModel) {
      seriesModel.getData().setVisual("legendSymbol", "roundRect");
    }
  });
  return bar;
}
var pie = {};
var createListSimply;
var hasRequiredCreateListSimply;
function requireCreateListSimply() {
  if (hasRequiredCreateListSimply)
    return createListSimply;
  hasRequiredCreateListSimply = 1;
  var createDimensions2 = requireCreateDimensions();
  var List = requireList();
  var _util2 = util$6;
  var extend2 = _util2.extend;
  var isArray2 = _util2.isArray;
  function _default2(seriesModel, opt, nameList) {
    opt = isArray2(opt) && {
      coordDimensions: opt
    } || extend2({}, opt);
    var source = seriesModel.getSource();
    var dimensionsInfo = createDimensions2(source, opt);
    var list = new List(dimensionsInfo, seriesModel);
    list.initData(source, nameList);
    return list;
  }
  createListSimply = _default2;
  return createListSimply;
}
var selectableMixin;
var hasRequiredSelectableMixin;
function requireSelectableMixin() {
  if (hasRequiredSelectableMixin)
    return selectableMixin;
  hasRequiredSelectableMixin = 1;
  var zrUtil2 = util$6;
  var _default2 = {
    /**
     * @param {Array.<Object>} targetList [{name, value, selected}, ...]
     *        If targetList is an array, it should like [{name: ..., value: ...}, ...].
     *        If targetList is a "List", it must have coordDim: 'value' dimension and name.
     */
    updateSelectedMap: function(targetList) {
      this._targetList = zrUtil2.isArray(targetList) ? targetList.slice() : [];
      this._selectTargetMap = zrUtil2.reduce(targetList || [], function(targetMap2, target) {
        targetMap2.set(target.name, target);
        return targetMap2;
      }, zrUtil2.createHashMap());
    },
    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    // PENGING If selectedMode is null ?
    select: function(name2, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
      var selectedMode = this.get("selectedMode");
      if (selectedMode === "single") {
        this._selectTargetMap.each(function(target2) {
          target2.selected = false;
        });
      }
      target && (target.selected = true);
    },
    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    unSelect: function(name2, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
      target && (target.selected = false);
    },
    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    toggleSelected: function(name2, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
      if (target != null) {
        this[target.selected ? "unSelect" : "select"](name2, id);
        return target.selected;
      }
    },
    /**
     * Either name or id should be passed as input here.
     * If both of them are defined, id is used.
     *
     * @param {string|undefined} name name of data
     * @param {number|undefined} id dataIndex of data
     */
    isSelected: function(name2, id) {
      var target = id != null ? this._targetList[id] : this._selectTargetMap.get(name2);
      return target && target.selected;
    }
  };
  selectableMixin = _default2;
  return selectableMixin;
}
var LegendVisualProvider_1;
var hasRequiredLegendVisualProvider;
function requireLegendVisualProvider() {
  if (hasRequiredLegendVisualProvider)
    return LegendVisualProvider_1;
  hasRequiredLegendVisualProvider = 1;
  function LegendVisualProvider(getDataWithEncodedVisual, getRawData) {
    this.getAllNames = function() {
      var rawData = getRawData();
      return rawData.mapArray(rawData.getName);
    };
    this.containName = function(name2) {
      var rawData = getRawData();
      return rawData.indexOfName(name2) >= 0;
    };
    this.indexOfName = function(name2) {
      var dataWithEncodedVisual = getDataWithEncodedVisual();
      return dataWithEncodedVisual.indexOfName(name2);
    };
    this.getItemVisual = function(dataIndex, key) {
      var dataWithEncodedVisual = getDataWithEncodedVisual();
      return dataWithEncodedVisual.getItemVisual(dataIndex, key);
    };
  }
  var _default2 = LegendVisualProvider;
  LegendVisualProvider_1 = _default2;
  return LegendVisualProvider_1;
}
var PieSeries_1;
var hasRequiredPieSeries;
function requirePieSeries() {
  if (hasRequiredPieSeries)
    return PieSeries_1;
  hasRequiredPieSeries = 1;
  var echarts$12 = echarts;
  var createListSimply2 = requireCreateListSimply();
  var zrUtil2 = util$6;
  var modelUtil2 = model;
  var _number2 = requireNumber();
  var getPercentWithPrecision = _number2.getPercentWithPrecision;
  var dataSelectableMixin = requireSelectableMixin();
  var _dataProvider2 = dataProvider;
  var retrieveRawAttr2 = _dataProvider2.retrieveRawAttr;
  var _sourceHelper2 = requireSourceHelper();
  var makeSeriesEncodeForNameBased = _sourceHelper2.makeSeriesEncodeForNameBased;
  var LegendVisualProvider = requireLegendVisualProvider();
  var PieSeries = echarts$12.extendSeriesModel({
    type: "series.pie",
    // Overwrite
    init: function(option) {
      PieSeries.superApply(this, "init", arguments);
      this.legendVisualProvider = new LegendVisualProvider(zrUtil2.bind(this.getData, this), zrUtil2.bind(this.getRawData, this));
      this.updateSelectedMap(this._createSelectableList());
      this._defaultLabelLine(option);
    },
    // Overwrite
    mergeOption: function(newOption) {
      PieSeries.superCall(this, "mergeOption", newOption);
      this.updateSelectedMap(this._createSelectableList());
    },
    getInitialData: function(option, ecModel) {
      return createListSimply2(this, {
        coordDimensions: ["value"],
        encodeDefaulter: zrUtil2.curry(makeSeriesEncodeForNameBased, this)
      });
    },
    _createSelectableList: function() {
      var data = this.getRawData();
      var valueDim = data.mapDimension("value");
      var targetList = [];
      for (var i = 0, len = data.count(); i < len; i++) {
        targetList.push({
          name: data.getName(i),
          value: data.get(valueDim, i),
          selected: retrieveRawAttr2(data, i, "selected")
        });
      }
      return targetList;
    },
    // Overwrite
    getDataParams: function(dataIndex) {
      var data = this.getData();
      var params = PieSeries.superCall(this, "getDataParams", dataIndex);
      var valueList = [];
      data.each(data.mapDimension("value"), function(value) {
        valueList.push(value);
      });
      params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get("percentPrecision"));
      params.$vars.push("percent");
      return params;
    },
    _defaultLabelLine: function(option) {
      modelUtil2.defaultEmphasis(option, "labelLine", ["show"]);
      var labelLineNormalOpt = option.labelLine;
      var labelLineEmphasisOpt = option.emphasis.labelLine;
      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      hoverAnimation: true,
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: true,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 选中时扇区偏移量
      selectedOffset: 10,
      // 高亮扇区偏移量
      hoverOffset: 10,
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: true,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: true,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // If rotate around circle
        rotate: false,
        show: true,
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        margin: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
        // 默认使用全局文本样式，详见TEXTSTYLE
        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: true,
        // 引导线两段中的第一段长度
        length: 15,
        // 引导线两段中的第二段长度
        length2: 15,
        smooth: false,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1
      },
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasing: "cubicOut"
    }
  });
  zrUtil2.mixin(PieSeries, dataSelectableMixin);
  var _default2 = PieSeries;
  PieSeries_1 = _default2;
  return PieSeries_1;
}
var PieView_1;
var hasRequiredPieView;
function requirePieView() {
  if (hasRequiredPieView)
    return PieView_1;
  hasRequiredPieView = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var ChartView = Chart_1;
  function updateDataSelected(uid2, seriesModel, hasAnimation, api) {
    var data = seriesModel.getData();
    var dataIndex = this.dataIndex;
    var name2 = data.getName(dataIndex);
    var selectedOffset = seriesModel.get("selectedOffset");
    api.dispatchAction({
      type: "pieToggleSelect",
      from: uid2,
      name: name2,
      seriesId: seriesModel.id
    });
    data.each(function(idx) {
      toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
    });
  }
  function toggleItemSelected(el, layout2, isSelected, selectedOffset, hasAnimation) {
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var dx = Math.cos(midAngle);
    var dy = Math.sin(midAngle);
    var offset = isSelected ? selectedOffset : 0;
    var position = [dx * offset, dy * offset];
    hasAnimation ? el.animate().when(200, {
      position
    }).start("bounceOut") : el.attr("position", position);
  }
  function PiePiece(data, idx) {
    graphic2.Group.call(this);
    var sector = new graphic2.Sector({
      z2: 2
    });
    var polyline = new graphic2.Polyline();
    var text2 = new graphic2.Text();
    this.add(sector);
    this.add(polyline);
    this.add(text2);
    this.updateData(data, idx, true);
  }
  var piePieceProto = PiePiece.prototype;
  piePieceProto.updateData = function(data, idx, firstCreate) {
    var sector = this.childAt(0);
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var sectorShape = zrUtil2.extend({}, layout2);
    sectorShape.label = null;
    var animationTypeUpdate = seriesModel.getShallow("animationTypeUpdate");
    if (firstCreate) {
      sector.setShape(sectorShape);
      var animationType = seriesModel.getShallow("animationType");
      if (animationType === "scale") {
        sector.shape.r = layout2.r0;
        graphic2.initProps(sector, {
          shape: {
            r: layout2.r
          }
        }, seriesModel, idx);
      } else {
        sector.shape.endAngle = layout2.startAngle;
        graphic2.updateProps(sector, {
          shape: {
            endAngle: layout2.endAngle
          }
        }, seriesModel, idx);
      }
    } else {
      if (animationTypeUpdate === "expansion") {
        sector.setShape(sectorShape);
      } else {
        graphic2.updateProps(sector, {
          shape: sectorShape
        }, seriesModel, idx);
      }
    }
    var visualColor = data.getItemVisual(idx, "color");
    sector.useStyle(zrUtil2.defaults({
      lineJoin: "bevel",
      fill: visualColor
    }, itemModel.getModel("itemStyle").getItemStyle()));
    sector.hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    toggleItemSelected(this, data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), seriesModel.get("selectedOffset"), seriesModel.get("animation"));
    var withAnimation = !firstCreate && animationTypeUpdate === "transition";
    this._updateLabel(data, idx, withAnimation);
    this.highDownOnUpdate = !seriesModel.get("silent") ? function(fromState, toState) {
      var hasAnimation = seriesModel.isAnimationEnabled() && itemModel.get("hoverAnimation");
      if (toState === "emphasis") {
        labelLine.ignore = labelLine.hoverIgnore;
        labelText.ignore = labelText.hoverIgnore;
        if (hasAnimation) {
          sector.stopAnimation(true);
          sector.animateTo({
            shape: {
              r: layout2.r + seriesModel.get("hoverOffset")
            }
          }, 300, "elasticOut");
        }
      } else {
        labelLine.ignore = labelLine.normalIgnore;
        labelText.ignore = labelText.normalIgnore;
        if (hasAnimation) {
          sector.stopAnimation(true);
          sector.animateTo({
            shape: {
              r: layout2.r
            }
          }, 300, "elasticOut");
        }
      }
    } : null;
    graphic2.setHoverStyle(this);
  };
  piePieceProto._updateLabel = function(data, idx, withAnimation) {
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var labelLayout2 = layout2.label;
    var visualColor = data.getItemVisual(idx, "color");
    if (!labelLayout2 || isNaN(labelLayout2.x) || isNaN(labelLayout2.y)) {
      labelText.ignore = labelText.normalIgnore = labelText.hoverIgnore = labelLine.ignore = labelLine.normalIgnore = labelLine.hoverIgnore = true;
      return;
    }
    var targetLineShape = {
      points: labelLayout2.linePoints || [[labelLayout2.x, labelLayout2.y], [labelLayout2.x, labelLayout2.y], [labelLayout2.x, labelLayout2.y]]
    };
    var targetTextStyle = {
      x: labelLayout2.x,
      y: labelLayout2.y
    };
    if (withAnimation) {
      graphic2.updateProps(labelLine, {
        shape: targetLineShape
      }, seriesModel, idx);
      graphic2.updateProps(labelText, {
        style: targetTextStyle
      }, seriesModel, idx);
    } else {
      labelLine.attr({
        shape: targetLineShape
      });
      labelText.attr({
        style: targetTextStyle
      });
    }
    labelText.attr({
      rotation: labelLayout2.rotation,
      origin: [labelLayout2.x, labelLayout2.y],
      z2: 10
    });
    var labelModel = itemModel.getModel("label");
    var labelHoverModel = itemModel.getModel("emphasis.label");
    var labelLineModel = itemModel.getModel("labelLine");
    var labelLineHoverModel = itemModel.getModel("emphasis.labelLine");
    var visualColor = data.getItemVisual(idx, "color");
    graphic2.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultText: labelLayout2.text,
      autoColor: visualColor,
      useInsideStyle: !!labelLayout2.inside
    }, {
      textAlign: labelLayout2.textAlign,
      textVerticalAlign: labelLayout2.verticalAlign,
      opacity: data.getItemVisual(idx, "opacity")
    });
    labelText.ignore = labelText.normalIgnore = !labelModel.get("show");
    labelText.hoverIgnore = !labelHoverModel.get("show");
    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get("show");
    labelLine.hoverIgnore = !labelLineHoverModel.get("show");
    labelLine.setStyle({
      stroke: visualColor,
      opacity: data.getItemVisual(idx, "opacity")
    });
    labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle());
    labelLine.hoverStyle = labelLineHoverModel.getModel("lineStyle").getLineStyle();
    var smooth = labelLineModel.get("smooth");
    if (smooth && smooth === true) {
      smooth = 0.4;
    }
    labelLine.setShape({
      smooth
    });
  };
  zrUtil2.inherits(PiePiece, graphic2.Group);
  var PieView = ChartView.extend({
    type: "pie",
    init: function() {
      var sectorGroup = new graphic2.Group();
      this._sectorGroup = sectorGroup;
    },
    render: function(seriesModel, ecModel, api, payload) {
      if (payload && payload.from === this.uid) {
        return;
      }
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      var hasAnimation = ecModel.get("animation");
      var isFirstRender = !oldData;
      var animationType = seriesModel.get("animationType");
      var animationTypeUpdate = seriesModel.get("animationTypeUpdate");
      var onSectorClick = zrUtil2.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
      var selectedMode = seriesModel.get("selectedMode");
      data.diff(oldData).add(function(idx) {
        var piePiece = new PiePiece(data, idx);
        if (isFirstRender && animationType !== "scale") {
          piePiece.eachChild(function(child) {
            child.stopAnimation(true);
          });
        }
        selectedMode && piePiece.on("click", onSectorClick);
        data.setItemGraphicEl(idx, piePiece);
        group.add(piePiece);
      }).update(function(newIdx, oldIdx) {
        var piePiece = oldData.getItemGraphicEl(oldIdx);
        if (!isFirstRender && animationTypeUpdate !== "transition") {
          piePiece.eachChild(function(child) {
            child.stopAnimation(true);
          });
        }
        piePiece.updateData(data, newIdx);
        piePiece.off("click");
        selectedMode && piePiece.on("click", onSectorClick);
        group.add(piePiece);
        data.setItemGraphicEl(newIdx, piePiece);
      }).remove(function(idx) {
        var piePiece = oldData.getItemGraphicEl(idx);
        group.remove(piePiece);
      }).execute();
      if (hasAnimation && data.count() > 0 && (isFirstRender ? animationType !== "scale" : animationTypeUpdate !== "transition")) {
        var shape = data.getItemLayout(0);
        for (var s = 1; isNaN(shape.startAngle) && s < data.count(); ++s) {
          shape = data.getItemLayout(s);
        }
        var r = Math.max(api.getWidth(), api.getHeight()) / 2;
        var removeClipPath = zrUtil2.bind(group.removeClipPath, group);
        group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel, isFirstRender));
      } else {
        group.removeClipPath();
      }
      this._data = data;
    },
    dispose: function() {
    },
    _createClipPath: function(cx, cy, r, startAngle, clockwise, cb, seriesModel, isFirstRender) {
      var clipPath = new graphic2.Sector({
        shape: {
          cx,
          cy,
          r0: 0,
          r,
          startAngle,
          endAngle: startAngle,
          clockwise
        }
      });
      var initOrUpdate = isFirstRender ? graphic2.initProps : graphic2.updateProps;
      initOrUpdate(clipPath, {
        shape: {
          endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2
        }
      }, seriesModel, cb);
      return clipPath;
    },
    /**
     * @implement
     */
    containPoint: function(point, seriesModel) {
      var data = seriesModel.getData();
      var itemLayout = data.getItemLayout(0);
      if (itemLayout) {
        var dx = point[0] - itemLayout.cx;
        var dy = point[1] - itemLayout.cy;
        var radius = Math.sqrt(dx * dx + dy * dy);
        return radius <= itemLayout.r && radius >= itemLayout.r0;
      }
    }
  });
  var _default2 = PieView;
  PieView_1 = _default2;
  return PieView_1;
}
var createDataSelectAction;
var hasRequiredCreateDataSelectAction;
function requireCreateDataSelectAction() {
  if (hasRequiredCreateDataSelectAction)
    return createDataSelectAction;
  hasRequiredCreateDataSelectAction = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  function _default2(seriesType2, actionInfos) {
    zrUtil2.each(actionInfos, function(actionInfo) {
      actionInfo.update = "updateView";
      echarts$12.registerAction(actionInfo, function(payload, ecModel) {
        var selected = {};
        ecModel.eachComponent({
          mainType: "series",
          subType: seriesType2,
          query: payload
        }, function(seriesModel) {
          if (seriesModel[actionInfo.method]) {
            seriesModel[actionInfo.method](payload.name, payload.dataIndex);
          }
          var data = seriesModel.getData();
          data.each(function(idx) {
            var name2 = data.getName(idx);
            selected[name2] = seriesModel.isSelected(name2) || false;
          });
        });
        return {
          name: payload.name,
          selected,
          seriesId: payload.seriesId
        };
      });
    });
  }
  createDataSelectAction = _default2;
  return createDataSelectAction;
}
var dataColor;
var hasRequiredDataColor;
function requireDataColor() {
  if (hasRequiredDataColor)
    return dataColor;
  hasRequiredDataColor = 1;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  function _default2(seriesType2) {
    return {
      getTargetSeries: function(ecModel) {
        var paletteScope = {};
        var seiresModelMap = createHashMap2();
        ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
          seriesModel.__paletteScope = paletteScope;
          seiresModelMap.set(seriesModel.uid, seriesModel);
        });
        return seiresModelMap;
      },
      reset: function(seriesModel, ecModel) {
        var dataAll = seriesModel.getRawData();
        var idxMap = {};
        var data = seriesModel.getData();
        data.each(function(idx) {
          var rawIdx = data.getRawIndex(idx);
          idxMap[rawIdx] = idx;
        });
        dataAll.each(function(rawIdx) {
          var filteredIdx = idxMap[rawIdx];
          var singleDataColor = filteredIdx != null && data.getItemVisual(filteredIdx, "color", true);
          var singleDataBorderColor = filteredIdx != null && data.getItemVisual(filteredIdx, "borderColor", true);
          var itemModel;
          if (!singleDataColor || !singleDataBorderColor) {
            itemModel = dataAll.getItemModel(rawIdx);
          }
          if (!singleDataColor) {
            var color2 = itemModel.get("itemStyle.color") || seriesModel.getColorFromPalette(dataAll.getName(rawIdx) || rawIdx + "", seriesModel.__paletteScope, dataAll.count());
            if (filteredIdx != null) {
              data.setItemVisual(filteredIdx, "color", color2);
            }
          }
          if (!singleDataBorderColor) {
            var borderColor = itemModel.get("itemStyle.borderColor");
            if (filteredIdx != null) {
              data.setItemVisual(filteredIdx, "borderColor", borderColor);
            }
          }
        });
      }
    };
  }
  dataColor = _default2;
  return dataColor;
}
var labelLayout;
var hasRequiredLabelLayout;
function requireLabelLayout() {
  if (hasRequiredLabelLayout)
    return labelLayout;
  hasRequiredLabelLayout = 1;
  var textContain2 = text;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var RADIAN = Math.PI / 180;
  function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
    list.sort(function(a, b) {
      return a.y - b.y;
    });
    function shiftDown(start, end, delta2, dir2) {
      for (var j = start; j < end; j++) {
        if (list[j].y + delta2 > viewTop + viewHeight) {
          break;
        }
        list[j].y += delta2;
        if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
          shiftUp(j, delta2 / 2);
          return;
        }
      }
      shiftUp(end - 1, delta2 / 2);
    }
    function shiftUp(end, delta2) {
      for (var j = end; j >= 0; j--) {
        if (list[j].y - delta2 < viewTop) {
          break;
        }
        list[j].y -= delta2;
        if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
          break;
        }
      }
    }
    function changeX(list2, isDownList, cx2, cy2, r2, dir2) {
      var lastDeltaX = dir2 > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;
      for (var i2 = 0, l = list2.length; i2 < l; i2++) {
        if (list2[i2].labelAlignTo !== "none") {
          continue;
        }
        var deltaY = Math.abs(list2[i2].y - cy2);
        var length = list2[i2].len;
        var length2 = list2[i2].len2;
        var deltaX = deltaY < r2 + length ? Math.sqrt((r2 + length + length2) * (r2 + length + length2) - deltaY * deltaY) : Math.abs(list2[i2].x - cx2);
        if (isDownList && deltaX >= lastDeltaX) {
          deltaX = lastDeltaX - 10;
        }
        if (!isDownList && deltaX <= lastDeltaX) {
          deltaX = lastDeltaX + 10;
        }
        list2[i2].x = cx2 + deltaX * dir2;
        lastDeltaX = deltaX;
      }
    }
    var lastY = 0;
    var delta;
    var len = list.length;
    var upList = [];
    var downList = [];
    for (var i = 0; i < len; i++) {
      if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
        var dx = list[i].x - farthestX;
        list[i].linePoints[1][0] += dx;
        list[i].x = farthestX;
      }
      delta = list[i].y - lastY;
      if (delta < 0) {
        shiftDown(i, len, -delta);
      }
      lastY = list[i].y + list[i].height;
    }
    if (viewHeight - lastY < 0) {
      shiftUp(len - 1, lastY - viewHeight);
    }
    for (var i = 0; i < len; i++) {
      if (list[i].y >= cy) {
        downList.push(list[i]);
      } else {
        upList.push(list[i]);
      }
    }
    changeX(upList, false, cx, cy, r, dir);
    changeX(downList, true, cx, cy, r, dir);
  }
  function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
    var leftList = [];
    var rightList = [];
    var leftmostX = Number.MAX_VALUE;
    var rightmostX = -Number.MAX_VALUE;
    for (var i = 0; i < labelLayoutList.length; i++) {
      if (isPositionCenter(labelLayoutList[i])) {
        continue;
      }
      if (labelLayoutList[i].x < cx) {
        leftmostX = Math.min(leftmostX, labelLayoutList[i].x);
        leftList.push(labelLayoutList[i]);
      } else {
        rightmostX = Math.max(rightmostX, labelLayoutList[i].x);
        rightList.push(labelLayoutList[i]);
      }
    }
    adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
    adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
    for (var i = 0; i < labelLayoutList.length; i++) {
      var layout2 = labelLayoutList[i];
      if (isPositionCenter(layout2)) {
        continue;
      }
      var linePoints = layout2.linePoints;
      if (linePoints) {
        var isAlignToEdge = layout2.labelAlignTo === "edge";
        var realTextWidth = layout2.textRect.width;
        var targetTextWidth;
        if (isAlignToEdge) {
          if (layout2.x < cx) {
            targetTextWidth = linePoints[2][0] - layout2.labelDistance - viewLeft - layout2.labelMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - layout2.labelMargin - linePoints[2][0] - layout2.labelDistance;
          }
        } else {
          if (layout2.x < cx) {
            targetTextWidth = layout2.x - viewLeft - layout2.bleedMargin;
          } else {
            targetTextWidth = viewLeft + viewWidth - layout2.x - layout2.bleedMargin;
          }
        }
        if (targetTextWidth < layout2.textRect.width) {
          layout2.text = textContain2.truncateText(layout2.text, targetTextWidth, layout2.font);
          if (layout2.labelAlignTo === "edge") {
            realTextWidth = textContain2.getWidth(layout2.text, layout2.font);
          }
        }
        var dist2 = linePoints[1][0] - linePoints[2][0];
        if (isAlignToEdge) {
          if (layout2.x < cx) {
            linePoints[2][0] = viewLeft + layout2.labelMargin + realTextWidth + layout2.labelDistance;
          } else {
            linePoints[2][0] = viewLeft + viewWidth - layout2.labelMargin - realTextWidth - layout2.labelDistance;
          }
        } else {
          if (layout2.x < cx) {
            linePoints[2][0] = layout2.x + layout2.labelDistance;
          } else {
            linePoints[2][0] = layout2.x - layout2.labelDistance;
          }
          linePoints[1][0] = linePoints[2][0] + dist2;
        }
        linePoints[1][1] = linePoints[2][1] = layout2.y;
      }
    }
  }
  function isPositionCenter(layout2) {
    return layout2.position === "center";
  }
  function _default2(seriesModel, r, viewWidth, viewHeight, viewLeft, viewTop) {
    var data = seriesModel.getData();
    var labelLayoutList = [];
    var cx;
    var cy;
    var hasLabelRotate = false;
    var minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN;
    data.each(function(idx) {
      var layout2 = data.getItemLayout(idx);
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel("label");
      var labelPosition = labelModel.get("position") || itemModel.get("emphasis.label.position");
      var labelDistance = labelModel.get("distanceToLabelLine");
      var labelAlignTo = labelModel.get("alignTo");
      var labelMargin = parsePercent2(labelModel.get("margin"), viewWidth);
      var bleedMargin = labelModel.get("bleedMargin");
      var font = labelModel.getFont();
      var labelLineModel = itemModel.getModel("labelLine");
      var labelLineLen = labelLineModel.get("length");
      labelLineLen = parsePercent2(labelLineLen, viewWidth);
      var labelLineLen2 = labelLineModel.get("length2");
      labelLineLen2 = parsePercent2(labelLineLen2, viewWidth);
      if (layout2.angle < minShowLabelRadian) {
        return;
      }
      var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
      var dx = Math.cos(midAngle);
      var dy = Math.sin(midAngle);
      var textX;
      var textY;
      var linePoints;
      var textAlign;
      cx = layout2.cx;
      cy = layout2.cy;
      var text2 = seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx);
      var textRect = textContain2.getBoundingRect(text2, font, textAlign, "top");
      var isLabelInside = labelPosition === "inside" || labelPosition === "inner";
      if (labelPosition === "center") {
        textX = layout2.cx;
        textY = layout2.cy;
        textAlign = "center";
      } else {
        var x1 = (isLabelInside ? (layout2.r + layout2.r0) / 2 * dx : layout2.r * dx) + cx;
        var y1 = (isLabelInside ? (layout2.r + layout2.r0) / 2 * dy : layout2.r * dy) + cy;
        textX = x1 + dx * 3;
        textY = y1 + dy * 3;
        if (!isLabelInside) {
          var x2 = x1 + dx * (labelLineLen + r - layout2.r);
          var y2 = y1 + dy * (labelLineLen + r - layout2.r);
          var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;
          var y3 = y2;
          if (labelAlignTo === "edge") {
            textX = dx < 0 ? viewLeft + labelMargin : viewLeft + viewWidth - labelMargin;
          } else {
            textX = x3 + (dx < 0 ? -labelDistance : labelDistance);
          }
          textY = y3;
          linePoints = [[x1, y1], [x2, y2], [x3, y3]];
        }
        textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? dx > 0 ? "right" : "left" : dx > 0 ? "left" : "right";
      }
      var labelRotate;
      var rotate = labelModel.get("rotate");
      if (typeof rotate === "number") {
        labelRotate = rotate * (Math.PI / 180);
      } else {
        labelRotate = rotate ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;
      }
      hasLabelRotate = !!labelRotate;
      layout2.label = {
        x: textX,
        y: textY,
        position: labelPosition,
        height: textRect.height,
        len: labelLineLen,
        len2: labelLineLen2,
        linePoints,
        textAlign,
        verticalAlign: "middle",
        rotation: labelRotate,
        inside: isLabelInside,
        labelDistance,
        labelAlignTo,
        labelMargin,
        bleedMargin,
        textRect,
        text: text2,
        font
      };
      if (!isLabelInside) {
        labelLayoutList.push(layout2.label);
      }
    });
    if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
      avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
    }
  }
  labelLayout = _default2;
  return labelLayout;
}
var pieLayout;
var hasRequiredPieLayout;
function requirePieLayout() {
  if (hasRequiredPieLayout)
    return pieLayout;
  hasRequiredPieLayout = 1;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var linearMap = _number2.linearMap;
  var layout2 = layout$1;
  var labelLayout2 = requireLabelLayout();
  var zrUtil2 = util$6;
  var PI22 = Math.PI * 2;
  var RADIAN = Math.PI / 180;
  function getViewRect(seriesModel, api) {
    return layout2.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function _default2(seriesType2, ecModel, api, payload) {
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var viewRect2 = getViewRect(seriesModel, api);
      var center2 = seriesModel.get("center");
      var radius = seriesModel.get("radius");
      if (!zrUtil2.isArray(radius)) {
        radius = [0, radius];
      }
      if (!zrUtil2.isArray(center2)) {
        center2 = [center2, center2];
      }
      var width = parsePercent2(viewRect2.width, api.getWidth());
      var height = parsePercent2(viewRect2.height, api.getHeight());
      var size2 = Math.min(width, height);
      var cx = parsePercent2(center2[0], width) + viewRect2.x;
      var cy = parsePercent2(center2[1], height) + viewRect2.y;
      var r0 = parsePercent2(radius[0], size2 / 2);
      var r = parsePercent2(radius[1], size2 / 2);
      var startAngle = -seriesModel.get("startAngle") * RADIAN;
      var minAngle = seriesModel.get("minAngle") * RADIAN;
      var validDataCount = 0;
      data.each(valueDim, function(value) {
        !isNaN(value) && validDataCount++;
      });
      var sum = data.getSum(valueDim);
      var unitRadian = Math.PI / (sum || validDataCount) * 2;
      var clockwise = seriesModel.get("clockwise");
      var roseType = seriesModel.get("roseType");
      var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
      var extent = data.getDataExtent(valueDim);
      extent[0] = 0;
      var restAngle = PI22;
      var valueSumLargerThanMinAngle = 0;
      var currentAngle = startAngle;
      var dir = clockwise ? 1 : -1;
      data.each(valueDim, function(value, idx) {
        var angle2;
        if (isNaN(value)) {
          data.setItemLayout(idx, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise,
            cx,
            cy,
            r0,
            r: roseType ? NaN : r,
            viewRect: viewRect2
          });
          return;
        }
        if (roseType !== "area") {
          angle2 = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        } else {
          angle2 = PI22 / validDataCount;
        }
        if (angle2 < minAngle) {
          angle2 = minAngle;
          restAngle -= minAngle;
        } else {
          valueSumLargerThanMinAngle += value;
        }
        var endAngle = currentAngle + dir * angle2;
        data.setItemLayout(idx, {
          angle: angle2,
          startAngle: currentAngle,
          endAngle,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? linearMap(value, extent, [r0, r]) : r,
          viewRect: viewRect2
        });
        currentAngle = endAngle;
      });
      if (restAngle < PI22 && validDataCount) {
        if (restAngle <= 1e-3) {
          var angle = PI22 / validDataCount;
          data.each(valueDim, function(value, idx) {
            if (!isNaN(value)) {
              var layout3 = data.getItemLayout(idx);
              layout3.angle = angle;
              layout3.startAngle = startAngle + dir * idx * angle;
              layout3.endAngle = startAngle + dir * (idx + 1) * angle;
            }
          });
        } else {
          unitRadian = restAngle / valueSumLargerThanMinAngle;
          currentAngle = startAngle;
          data.each(valueDim, function(value, idx) {
            if (!isNaN(value)) {
              var layout3 = data.getItemLayout(idx);
              var angle2 = layout3.angle === minAngle ? minAngle : value * unitRadian;
              layout3.startAngle = currentAngle;
              layout3.endAngle = currentAngle + dir * angle2;
              currentAngle += dir * angle2;
            }
          });
        }
      }
      labelLayout2(seriesModel, r, viewRect2.width, viewRect2.height, viewRect2.x, viewRect2.y);
    });
  }
  pieLayout = _default2;
  return pieLayout;
}
var dataFilter;
var hasRequiredDataFilter;
function requireDataFilter() {
  if (hasRequiredDataFilter)
    return dataFilter;
  hasRequiredDataFilter = 1;
  function _default2(seriesType2) {
    return {
      seriesType: seriesType2,
      reset: function(seriesModel, ecModel) {
        var legendModels = ecModel.findComponents({
          mainType: "legend"
        });
        if (!legendModels || !legendModels.length) {
          return;
        }
        var data = seriesModel.getData();
        data.filterSelf(function(idx) {
          var name2 = data.getName(idx);
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(name2)) {
              return false;
            }
          }
          return true;
        });
      }
    };
  }
  dataFilter = _default2;
  return dataFilter;
}
var hasRequiredPie;
function requirePie() {
  if (hasRequiredPie)
    return pie;
  hasRequiredPie = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  requirePieSeries();
  requirePieView();
  var createDataSelectAction2 = requireCreateDataSelectAction();
  var dataColor2 = requireDataColor();
  var pieLayout2 = requirePieLayout();
  var dataFilter2 = requireDataFilter();
  createDataSelectAction2("pie", [{
    type: "pieToggleSelect",
    event: "pieselectchanged",
    method: "toggleSelected"
  }, {
    type: "pieSelect",
    event: "pieselected",
    method: "select"
  }, {
    type: "pieUnSelect",
    event: "pieunselected",
    method: "unSelect"
  }]);
  echarts$12.registerVisual(dataColor2("pie"));
  echarts$12.registerLayout(zrUtil2.curry(pieLayout2, "pie"));
  echarts$12.registerProcessor(dataFilter2("pie"));
  return pie;
}
var scatter = {};
var ScatterSeries;
var hasRequiredScatterSeries;
function requireScatterSeries() {
  if (hasRequiredScatterSeries)
    return ScatterSeries;
  hasRequiredScatterSeries = 1;
  var createListFromArray = requireCreateListFromArray();
  var SeriesModel2 = Series;
  var _default2 = SeriesModel2.extend({
    type: "series.scatter",
    dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
    getInitialData: function(option, ecModel) {
      return createListFromArray(this.getSource(), this, {
        useEncodeDefaulter: true
      });
    },
    brushSelector: "point",
    getProgressive: function() {
      var progressive = this.option.progressive;
      if (progressive == null) {
        return this.option.large ? 5e3 : this.get("progressive");
      }
      return progressive;
    },
    getProgressiveThreshold: function() {
      var progressiveThreshold = this.option.progressiveThreshold;
      if (progressiveThreshold == null) {
        return this.option.large ? 1e4 : this.get("progressiveThreshold");
      }
      return progressiveThreshold;
    },
    defaultOption: {
      coordinateSystem: "cartesian2d",
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      hoverAnimation: true,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10,
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      large: false,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      // label: {
      // show: false
      // distance: 5,
      // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
      //           'inside'|'left'|'right'|'top'|'bottom'
      // 默认使用全局文本样式，详见TEXTSTYLE
      // },
      itemStyle: {
        opacity: 0.8
        // color: 各异
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: true
      // progressive: null
    }
  });
  ScatterSeries = _default2;
  return ScatterSeries;
}
var ScatterView = {};
var LargeSymbolDraw_1;
var hasRequiredLargeSymbolDraw;
function requireLargeSymbolDraw() {
  if (hasRequiredLargeSymbolDraw)
    return LargeSymbolDraw_1;
  hasRequiredLargeSymbolDraw = 1;
  var graphic2 = graphic$4;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var IncrementalDisplayable2 = IncrementalDisplayable$1;
  var BOOST_SIZE_THRESHOLD = 4;
  var LargeSymbolPath = graphic2.extendShape({
    shape: {
      points: null
    },
    symbolProxy: null,
    softClipShape: null,
    buildPath: function(path2, shape) {
      var points2 = shape.points;
      var size2 = shape.size;
      var symbolProxy = this.symbolProxy;
      var symbolProxyShape = symbolProxy.shape;
      var ctx = path2.getContext ? path2.getContext() : path2;
      var canBoost = ctx && size2[0] < BOOST_SIZE_THRESHOLD;
      if (canBoost) {
        return;
      }
      for (var i = 0; i < points2.length; ) {
        var x = points2[i++];
        var y = points2[i++];
        if (isNaN(x) || isNaN(y)) {
          continue;
        }
        if (this.softClipShape && !this.softClipShape.contain(x, y)) {
          continue;
        }
        symbolProxyShape.x = x - size2[0] / 2;
        symbolProxyShape.y = y - size2[1] / 2;
        symbolProxyShape.width = size2[0];
        symbolProxyShape.height = size2[1];
        symbolProxy.buildPath(path2, symbolProxyShape, true);
      }
    },
    afterBrush: function(ctx) {
      var shape = this.shape;
      var points2 = shape.points;
      var size2 = shape.size;
      var canBoost = size2[0] < BOOST_SIZE_THRESHOLD;
      if (!canBoost) {
        return;
      }
      this.setTransform(ctx);
      for (var i = 0; i < points2.length; ) {
        var x = points2[i++];
        var y = points2[i++];
        if (isNaN(x) || isNaN(y)) {
          continue;
        }
        if (this.softClipShape && !this.softClipShape.contain(x, y)) {
          continue;
        }
        ctx.fillRect(x - size2[0] / 2, y - size2[1] / 2, size2[0], size2[1]);
      }
      this.restoreTransform(ctx);
    },
    findDataIndex: function(x, y) {
      var shape = this.shape;
      var points2 = shape.points;
      var size2 = shape.size;
      var w = Math.max(size2[0], 4);
      var h = Math.max(size2[1], 4);
      for (var idx = points2.length / 2 - 1; idx >= 0; idx--) {
        var i = idx * 2;
        var x0 = points2[i] - w / 2;
        var y0 = points2[i + 1] - h / 2;
        if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
          return idx;
        }
      }
      return -1;
    }
  });
  function LargeSymbolDraw() {
    this.group = new graphic2.Group();
  }
  var largeSymbolProto = LargeSymbolDraw.prototype;
  largeSymbolProto.isPersistent = function() {
    return !this._incremental;
  };
  largeSymbolProto.updateData = function(data, opt) {
    this.group.removeAll();
    var symbolEl = new LargeSymbolPath({
      rectHover: true,
      cursor: "default"
    });
    symbolEl.setShape({
      points: data.getLayout("symbolPoints")
    });
    this._setCommon(symbolEl, data, false, opt);
    this.group.add(symbolEl);
    this._incremental = null;
  };
  largeSymbolProto.updateLayout = function(data) {
    if (this._incremental) {
      return;
    }
    var points2 = data.getLayout("symbolPoints");
    this.group.eachChild(function(child) {
      if (child.startIndex != null) {
        var len = (child.endIndex - child.startIndex) * 2;
        var byteOffset = child.startIndex * 4 * 2;
        points2 = new Float32Array(points2.buffer, byteOffset, len);
      }
      child.setShape("points", points2);
    });
  };
  largeSymbolProto.incrementalPrepareUpdate = function(data) {
    this.group.removeAll();
    this._clearIncremental();
    if (data.count() > 2e6) {
      if (!this._incremental) {
        this._incremental = new IncrementalDisplayable2({
          silent: true
        });
      }
      this.group.add(this._incremental);
    } else {
      this._incremental = null;
    }
  };
  largeSymbolProto.incrementalUpdate = function(taskParams, data, opt) {
    var symbolEl;
    if (this._incremental) {
      symbolEl = new LargeSymbolPath();
      this._incremental.addDisplayable(symbolEl, true);
    } else {
      symbolEl = new LargeSymbolPath({
        rectHover: true,
        cursor: "default",
        startIndex: taskParams.start,
        endIndex: taskParams.end
      });
      symbolEl.incremental = true;
      this.group.add(symbolEl);
    }
    symbolEl.setShape({
      points: data.getLayout("symbolPoints")
    });
    this._setCommon(symbolEl, data, !!this._incremental, opt);
  };
  largeSymbolProto._setCommon = function(symbolEl, data, isIncremental, opt) {
    var hostModel = data.hostModel;
    opt = opt || {};
    var size2 = data.getVisual("symbolSize");
    symbolEl.setShape("size", size2 instanceof Array ? size2 : [size2, size2]);
    symbolEl.softClipShape = opt.clipShape || null;
    symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
    symbolEl.setColor = symbolEl.symbolProxy.setColor;
    var extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
    symbolEl.useStyle(
      // Draw shadow when doing fillRect is extremely slow.
      hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"])
    );
    var visualColor = data.getVisual("color");
    if (visualColor) {
      symbolEl.setColor(visualColor);
    }
    if (!isIncremental) {
      symbolEl.seriesIndex = hostModel.seriesIndex;
      symbolEl.on("mousemove", function(e2) {
        symbolEl.dataIndex = null;
        var dataIndex = symbolEl.findDataIndex(e2.offsetX, e2.offsetY);
        if (dataIndex >= 0) {
          symbolEl.dataIndex = dataIndex + (symbolEl.startIndex || 0);
        }
      });
    }
  };
  largeSymbolProto.remove = function() {
    this._clearIncremental();
    this._incremental = null;
    this.group.removeAll();
  };
  largeSymbolProto._clearIncremental = function() {
    var incremental = this._incremental;
    if (incremental) {
      incremental.clearDisplaybles();
    }
  };
  var _default2 = LargeSymbolDraw;
  LargeSymbolDraw_1 = _default2;
  return LargeSymbolDraw_1;
}
var hasRequiredScatterView;
function requireScatterView() {
  if (hasRequiredScatterView)
    return ScatterView;
  hasRequiredScatterView = 1;
  var echarts$12 = echarts;
  var SymbolDraw = requireSymbolDraw();
  var LargeSymbolDraw = requireLargeSymbolDraw();
  var pointsLayout = requirePoints();
  echarts$12.extendChartView({
    type: "scatter",
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var symbolDraw = this._updateSymbolDraw(data, seriesModel);
      symbolDraw.updateData(data, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(seriesModel)
      });
      this._finished = true;
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var symbolDraw = this._updateSymbolDraw(data, seriesModel);
      symbolDraw.incrementalPrepareUpdate(data);
      this._finished = false;
    },
    incrementalRender: function(taskParams, seriesModel, ecModel) {
      this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
        clipShape: this._getClipShape(seriesModel)
      });
      this._finished = taskParams.end === seriesModel.getData().count();
    },
    updateTransform: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      this.group.dirty();
      if (!this._finished || data.count() > 1e4 || !this._symbolDraw.isPersistent()) {
        return {
          update: true
        };
      } else {
        var res = pointsLayout().reset(seriesModel);
        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count()
          }, data);
        }
        this._symbolDraw.updateLayout(data);
      }
    },
    _getClipShape: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var clipArea = coordSys && coordSys.getArea && coordSys.getArea();
      return seriesModel.get("clip", true) ? clipArea : null;
    },
    _updateSymbolDraw: function(data, seriesModel) {
      var symbolDraw = this._symbolDraw;
      var pipelineContext = seriesModel.pipelineContext;
      var isLargeDraw = pipelineContext.large;
      if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
        symbolDraw && symbolDraw.remove();
        symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw();
        this._isLargeDraw = isLargeDraw;
        this.group.removeAll();
      }
      this.group.add(symbolDraw.group);
      return symbolDraw;
    },
    remove: function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove(true);
      this._symbolDraw = null;
    },
    dispose: function() {
    }
  });
  return ScatterView;
}
var hasRequiredScatter;
function requireScatter() {
  if (hasRequiredScatter)
    return scatter;
  hasRequiredScatter = 1;
  var echarts$12 = echarts;
  requireScatterSeries();
  requireScatterView();
  var visualSymbol = requireSymbol();
  var layoutPoints = requirePoints();
  requireGridSimple();
  echarts$12.registerVisual(visualSymbol("scatter", "circle"));
  echarts$12.registerLayout(layoutPoints("scatter"));
  return scatter;
}
var radar$1 = {};
var radar = {};
var IndicatorAxis_1;
var hasRequiredIndicatorAxis;
function requireIndicatorAxis() {
  if (hasRequiredIndicatorAxis)
    return IndicatorAxis_1;
  hasRequiredIndicatorAxis = 1;
  var zrUtil2 = util$6;
  var Axis = requireAxis$1();
  function IndicatorAxis(dim, scale, radiusExtent) {
    Axis.call(this, dim, scale, radiusExtent);
    this.type = "value";
    this.angle = 0;
    this.name = "";
    this.model;
  }
  zrUtil2.inherits(IndicatorAxis, Axis);
  var _default2 = IndicatorAxis;
  IndicatorAxis_1 = _default2;
  return IndicatorAxis_1;
}
var Radar_1;
var hasRequiredRadar$2;
function requireRadar$2() {
  if (hasRequiredRadar$2)
    return Radar_1;
  hasRequiredRadar$2 = 1;
  var zrUtil2 = util$6;
  var IndicatorAxis = requireIndicatorAxis();
  var IntervalScale = requireInterval();
  var numberUtil = requireNumber();
  var _axisHelper = requireAxisHelper();
  var getScaleExtent = _axisHelper.getScaleExtent;
  var niceScaleExtent = _axisHelper.niceScaleExtent;
  var CoordinateSystem$1 = CoordinateSystem;
  var LogScale = requireLog();
  function Radar(radarModel, ecModel, api) {
    this._model = radarModel;
    this.dimensions = [];
    this._indicatorAxes = zrUtil2.map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      var dim = "indicator_" + idx;
      var indicatorAxis = new IndicatorAxis(dim, indicatorModel.get("axisType") === "log" ? new LogScale() : new IntervalScale());
      indicatorAxis.name = indicatorModel.get("name");
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api);
    this.cx;
    this.cy;
    this.r;
    this.r0;
    this.startAngle;
  }
  Radar.prototype.getIndicatorAxes = function() {
    return this._indicatorAxes;
  };
  Radar.prototype.dataToPoint = function(value, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  };
  Radar.prototype.coordToPoint = function(coord, indicatorIndex) {
    var indicatorAxis = this._indicatorAxes[indicatorIndex];
    var angle = indicatorAxis.angle;
    var x = this.cx + coord * Math.cos(angle);
    var y = this.cy - coord * Math.sin(angle);
    return [x, y];
  };
  Radar.prototype.pointToData = function(pt) {
    var dx = pt[0] - this.cx;
    var dy = pt[1] - this.cy;
    var radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    var radian = Math.atan2(-dy, dx);
    var minRadianDiff = Infinity;
    var closestAxis;
    var closestAxisIdx = -1;
    for (var i = 0; i < this._indicatorAxes.length; i++) {
      var indicatorAxis = this._indicatorAxes[i];
      var diff2 = Math.abs(radian - indicatorAxis.angle);
      if (diff2 < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff2;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  };
  Radar.prototype.resize = function(radarModel, api) {
    var center2 = radarModel.get("center");
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = numberUtil.parsePercent(center2[0], viewWidth);
    this.cy = numberUtil.parsePercent(center2[1], viewHeight);
    this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
    var radius = radarModel.get("radius");
    if (typeof radius === "string" || typeof radius === "number") {
      radius = [0, radius];
    }
    this.r0 = numberUtil.parsePercent(radius[0], viewSize);
    this.r = numberUtil.parsePercent(radius[1], viewSize);
    zrUtil2.each(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  };
  Radar.prototype.update = function(ecModel, api) {
    var indicatorAxes = this._indicatorAxes;
    var radarModel = this._model;
    zrUtil2.each(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
      if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
        return;
      }
      var data = radarSeries.getData();
      zrUtil2.each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    var splitNumber = radarModel.get("splitNumber");
    function increaseInterval(interval) {
      var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));
      var f2 = interval / exp10;
      if (f2 === 2) {
        f2 = 5;
      } else {
        f2 *= 2;
      }
      return f2 * exp10;
    }
    zrUtil2.each(indicatorAxes, function(indicatorAxis, idx) {
      var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model).extent;
      niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);
      var axisModel = indicatorAxis.model;
      var scale = indicatorAxis.scale;
      var fixedMin = axisModel.getMin();
      var fixedMax = axisModel.getMax();
      var interval = scale.getInterval();
      if (fixedMin != null && fixedMax != null) {
        scale.setExtent(+fixedMin, +fixedMax);
        scale.setInterval((fixedMax - fixedMin) / splitNumber);
      } else if (fixedMin != null) {
        var max3;
        do {
          max3 = fixedMin + interval * splitNumber;
          scale.setExtent(+fixedMin, max3);
          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1]));
      } else if (fixedMax != null) {
        var min3;
        do {
          min3 = fixedMax - interval * splitNumber;
          scale.setExtent(min3, +fixedMax);
          scale.setInterval(interval);
          interval = increaseInterval(interval);
        } while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0]));
      } else {
        var nicedSplitNumber = scale.getTicks().length - 1;
        if (nicedSplitNumber > splitNumber) {
          interval = increaseInterval(interval);
        }
        var max3 = Math.ceil(rawExtent[1] / interval) * interval;
        var min3 = numberUtil.round(max3 - interval * splitNumber);
        scale.setExtent(min3, max3);
        scale.setInterval(interval);
      }
    });
  };
  Radar.dimensions = [];
  Radar.create = function(ecModel, api) {
    var radarList = [];
    ecModel.eachComponent("radar", function(radarModel) {
      var radar2 = new Radar(radarModel, ecModel, api);
      radarList.push(radar2);
      radarModel.coordinateSystem = radar2;
    });
    ecModel.eachSeriesByType("radar", function(radarSeries) {
      if (radarSeries.get("coordinateSystem") === "radar") {
        radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
      }
    });
    return radarList;
  };
  CoordinateSystem$1.register("radar", Radar);
  var _default2 = Radar;
  Radar_1 = _default2;
  return Radar_1;
}
var RadarModel_1;
var hasRequiredRadarModel;
function requireRadarModel() {
  if (hasRequiredRadarModel)
    return RadarModel_1;
  hasRequiredRadarModel = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var axisDefault = requireAxisDefault();
  var Model2 = requireModel();
  var axisModelCommonMixin2 = requireAxisModelCommonMixin();
  var valueAxisDefault = axisDefault.valueAxis;
  function defaultsShow(opt, show) {
    return zrUtil2.defaults({
      show
    }, opt);
  }
  var RadarModel = echarts$12.extendComponentModel({
    type: "radar",
    optionUpdated: function() {
      var boundaryGap = this.get("boundaryGap");
      var splitNumber = this.get("splitNumber");
      var scale = this.get("scale");
      var axisLine = this.get("axisLine");
      var axisTick = this.get("axisTick");
      var axisType = this.get("axisType");
      var axisLabel = this.get("axisLabel");
      var nameTextStyle = this.get("name");
      var showName = this.get("name.show");
      var nameFormatter = this.get("name.formatter");
      var nameGap = this.get("nameGap");
      var triggerEvent = this.get("triggerEvent");
      var indicatorModels = zrUtil2.map(this.get("indicator") || [], function(indicatorOpt) {
        if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
          indicatorOpt.min = 0;
        } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
          indicatorOpt.max = 0;
        }
        var iNameTextStyle = nameTextStyle;
        if (indicatorOpt.color != null) {
          iNameTextStyle = zrUtil2.defaults({
            color: indicatorOpt.color
          }, nameTextStyle);
        }
        indicatorOpt = zrUtil2.merge(zrUtil2.clone(indicatorOpt), {
          boundaryGap,
          splitNumber,
          scale,
          axisLine,
          axisTick,
          axisType,
          axisLabel,
          // Compatible with 2 and use text
          name: indicatorOpt.text,
          nameLocation: "end",
          nameGap,
          // min: 0,
          nameTextStyle: iNameTextStyle,
          triggerEvent
        }, false);
        if (!showName) {
          indicatorOpt.name = "";
        }
        if (typeof nameFormatter === "string") {
          var indName = indicatorOpt.name;
          indicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
        } else if (typeof nameFormatter === "function") {
          indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);
        }
        var model2 = zrUtil2.extend(new Model2(indicatorOpt, null, this.ecModel), axisModelCommonMixin2);
        model2.mainType = "radar";
        model2.componentIndex = this.componentIndex;
        return model2;
      }, this);
      this.getIndicatorModels = function() {
        return indicatorModels;
      };
    },
    defaultOption: {
      zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      name: {
        show: true
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      nameGap: 15,
      scale: false,
      // Polygon or circle
      shape: "polygon",
      axisLine: zrUtil2.merge({
        lineStyle: {
          color: "#bbb"
        }
      }, valueAxisDefault.axisLine),
      axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
      axisTick: defaultsShow(valueAxisDefault.axisTick, false),
      axisType: "interval",
      splitLine: defaultsShow(valueAxisDefault.splitLine, true),
      splitArea: defaultsShow(valueAxisDefault.splitArea, true),
      // {text, min, max}
      indicator: []
    }
  });
  var _default2 = RadarModel;
  RadarModel_1 = _default2;
  return RadarModel_1;
}
var RadarView$1;
var hasRequiredRadarView$1;
function requireRadarView$1() {
  if (hasRequiredRadarView$1)
    return RadarView$1;
  hasRequiredRadarView$1 = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var AxisBuilder = requireAxisBuilder();
  var graphic2 = graphic$4;
  var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
  var _default2 = echarts$12.extendComponentView({
    type: "radar",
    render: function(radarModel, ecModel, api) {
      var group = this.group;
      group.removeAll();
      this._buildAxes(radarModel);
      this._buildSplitLineAndArea(radarModel);
    },
    _buildAxes: function(radarModel) {
      var radar2 = radarModel.coordinateSystem;
      var indicatorAxes = radar2.getIndicatorAxes();
      var axisBuilders = zrUtil2.map(indicatorAxes, function(indicatorAxis) {
        var axisBuilder = new AxisBuilder(indicatorAxis.model, {
          position: [radar2.cx, radar2.cy],
          rotation: indicatorAxis.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return axisBuilder;
      });
      zrUtil2.each(axisBuilders, function(axisBuilder) {
        zrUtil2.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
        this.group.add(axisBuilder.getGroup());
      }, this);
    },
    _buildSplitLineAndArea: function(radarModel) {
      var radar2 = radarModel.coordinateSystem;
      var indicatorAxes = radar2.getIndicatorAxes();
      if (!indicatorAxes.length) {
        return;
      }
      var shape = radarModel.get("shape");
      var splitLineModel = radarModel.getModel("splitLine");
      var splitAreaModel = radarModel.getModel("splitArea");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var showSplitLine = splitLineModel.get("show");
      var showSplitArea = splitAreaModel.get("show");
      var splitLineColors = lineStyleModel.get("color");
      var splitAreaColors = areaStyleModel.get("color");
      splitLineColors = zrUtil2.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
      splitAreaColors = zrUtil2.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
      var splitLines = [];
      var splitAreas = [];
      function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
        var colorIndex2 = idx % areaOrLineColorList.length;
        areaOrLine[colorIndex2] = areaOrLine[colorIndex2] || [];
        return colorIndex2;
      }
      if (shape === "circle") {
        var ticksRadius = indicatorAxes[0].getTicksCoords();
        var cx = radar2.cx;
        var cy = radar2.cy;
        for (var i = 0; i < ticksRadius.length; i++) {
          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColors, i);
            splitLines[colorIndex].push(new graphic2.Circle({
              shape: {
                cx,
                cy,
                r: ticksRadius[i].coord
              }
            }));
          }
          if (showSplitArea && i < ticksRadius.length - 1) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
            splitAreas[colorIndex].push(new graphic2.Ring({
              shape: {
                cx,
                cy,
                r0: ticksRadius[i].coord,
                r: ticksRadius[i + 1].coord
              }
            }));
          }
        }
      } else {
        var realSplitNumber;
        var axesTicksPoints = zrUtil2.map(indicatorAxes, function(indicatorAxis, idx) {
          var ticksCoords = indicatorAxis.getTicksCoords();
          realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);
          return zrUtil2.map(ticksCoords, function(tickCoord) {
            return radar2.coordToPoint(tickCoord.coord, idx);
          });
        });
        var prevPoints = [];
        for (var i = 0; i <= realSplitNumber; i++) {
          var points2 = [];
          for (var j = 0; j < indicatorAxes.length; j++) {
            points2.push(axesTicksPoints[j][i]);
          }
          if (points2[0]) {
            points2.push(points2[0].slice());
          }
          if (showSplitLine) {
            var colorIndex = getColorIndex(splitLines, splitLineColors, i);
            splitLines[colorIndex].push(new graphic2.Polyline({
              shape: {
                points: points2
              }
            }));
          }
          if (showSplitArea && prevPoints) {
            var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
            splitAreas[colorIndex].push(new graphic2.Polygon({
              shape: {
                points: points2.concat(prevPoints)
              }
            }));
          }
          prevPoints = points2.slice().reverse();
        }
      }
      var lineStyle2 = lineStyleModel.getLineStyle();
      var areaStyle2 = areaStyleModel.getAreaStyle();
      zrUtil2.each(splitAreas, function(splitAreas2, idx) {
        this.group.add(graphic2.mergePath(splitAreas2, {
          style: zrUtil2.defaults({
            stroke: "none",
            fill: splitAreaColors[idx % splitAreaColors.length]
          }, areaStyle2),
          silent: true
        }));
      }, this);
      zrUtil2.each(splitLines, function(splitLines2, idx) {
        this.group.add(graphic2.mergePath(splitLines2, {
          style: zrUtil2.defaults({
            fill: "none",
            stroke: splitLineColors[idx % splitLineColors.length]
          }, lineStyle2),
          silent: true
        }));
      }, this);
    }
  });
  RadarView$1 = _default2;
  return RadarView$1;
}
var hasRequiredRadar$1;
function requireRadar$1() {
  if (hasRequiredRadar$1)
    return radar;
  hasRequiredRadar$1 = 1;
  requireRadar$2();
  requireRadarModel();
  requireRadarView$1();
  return radar;
}
var RadarSeries_1;
var hasRequiredRadarSeries;
function requireRadarSeries() {
  if (hasRequiredRadarSeries)
    return RadarSeries_1;
  hasRequiredRadarSeries = 1;
  var SeriesModel2 = Series;
  var createListSimply2 = requireCreateListSimply();
  var zrUtil2 = util$6;
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var LegendVisualProvider = requireLegendVisualProvider();
  var RadarSeries = SeriesModel2.extend({
    type: "series.radar",
    dependencies: ["radar"],
    // Overwrite
    init: function(option) {
      RadarSeries.superApply(this, "init", arguments);
      this.legendVisualProvider = new LegendVisualProvider(zrUtil2.bind(this.getData, this), zrUtil2.bind(this.getRawData, this));
    },
    getInitialData: function(option, ecModel) {
      return createListSimply2(this, {
        generateCoord: "indicator_",
        generateCoordCount: Infinity
      });
    },
    formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
      var data = this.getData();
      var coordSys = this.coordinateSystem;
      var indicatorAxes = coordSys.getIndicatorAxes();
      var name2 = this.getData().getName(dataIndex);
      var newLine = renderMode === "html" ? "<br/>" : "\n";
      return encodeHTML2(name2 === "" ? this.name : name2) + newLine + zrUtil2.map(indicatorAxes, function(axis2, idx) {
        var val = data.get(data.mapDimension(axis2.dim), dataIndex);
        return encodeHTML2(axis2.name + " : " + val);
      }).join(newLine);
    },
    /**
     * @implement
     */
    getTooltipPosition: function(dataIndex) {
      if (dataIndex != null) {
        var data = this.getData();
        var coordSys = this.coordinateSystem;
        var values = data.getValues(zrUtil2.map(coordSys.dimensions, function(dim) {
          return data.mapDimension(dim);
        }), dataIndex, true);
        for (var i = 0, len = values.length; i < len; i++) {
          if (!isNaN(values[i])) {
            var indicatorAxes = coordSys.getIndicatorAxes();
            return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
          }
        }
      }
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "radar",
      legendHoverLink: true,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbol: "emptyCircle",
      symbolSize: 4
      // symbolRotate: null
    }
  });
  var _default2 = RadarSeries;
  RadarSeries_1 = _default2;
  return RadarSeries_1;
}
var RadarView;
var hasRequiredRadarView;
function requireRadarView() {
  if (hasRequiredRadarView)
    return RadarView;
  hasRequiredRadarView = 1;
  var echarts$12 = echarts;
  var graphic2 = graphic$4;
  var zrUtil2 = util$6;
  var symbolUtil = requireSymbol$1();
  function normalizeSymbolSize(symbolSize) {
    if (!zrUtil2.isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return symbolSize;
  }
  var _default2 = echarts$12.extendChartView({
    type: "radar",
    render: function(seriesModel, ecModel, api) {
      var polar2 = seriesModel.coordinateSystem;
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      function createSymbol(data2, idx) {
        var symbolType = data2.getItemVisual(idx, "symbol") || "circle";
        var color2 = data2.getItemVisual(idx, "color");
        if (symbolType === "none") {
          return;
        }
        var symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
        var symbolPath = symbolUtil.createSymbol(symbolType, -1, -1, 2, 2, color2);
        var symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
        symbolPath.attr({
          style: {
            strokeNoScale: true
          },
          z2: 100,
          scale: [symbolSize[0] / 2, symbolSize[1] / 2],
          rotation: symbolRotate * Math.PI / 180 || 0
        });
        return symbolPath;
      }
      function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
        symbolGroup.removeAll();
        for (var i = 0; i < newPoints.length - 1; i++) {
          var symbolPath = createSymbol(data2, idx);
          if (symbolPath) {
            symbolPath.__dimIdx = i;
            if (oldPoints[i]) {
              symbolPath.attr("position", oldPoints[i]);
              graphic2[isInit ? "initProps" : "updateProps"](symbolPath, {
                position: newPoints[i]
              }, seriesModel, idx);
            } else {
              symbolPath.attr("position", newPoints[i]);
            }
            symbolGroup.add(symbolPath);
          }
        }
      }
      function getInitialPoints(points2) {
        return zrUtil2.map(points2, function(pt) {
          return [polar2.cx, polar2.cy];
        });
      }
      data.diff(oldData).add(function(idx) {
        var points2 = data.getItemLayout(idx);
        if (!points2) {
          return;
        }
        var polygon2 = new graphic2.Polygon();
        var polyline = new graphic2.Polyline();
        var target = {
          shape: {
            points: points2
          }
        };
        polygon2.shape.points = getInitialPoints(points2);
        polyline.shape.points = getInitialPoints(points2);
        graphic2.initProps(polygon2, target, seriesModel, idx);
        graphic2.initProps(polyline, target, seriesModel, idx);
        var itemGroup = new graphic2.Group();
        var symbolGroup = new graphic2.Group();
        itemGroup.add(polyline);
        itemGroup.add(polygon2);
        itemGroup.add(symbolGroup);
        updateSymbols(polyline.shape.points, points2, symbolGroup, data, idx, true);
        data.setItemGraphicEl(idx, itemGroup);
      }).update(function(newIdx, oldIdx) {
        var itemGroup = oldData.getItemGraphicEl(oldIdx);
        var polyline = itemGroup.childAt(0);
        var polygon2 = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var target = {
          shape: {
            points: data.getItemLayout(newIdx)
          }
        };
        if (!target.shape.points) {
          return;
        }
        updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
        graphic2.updateProps(polyline, target, seriesModel);
        graphic2.updateProps(polygon2, target, seriesModel);
        data.setItemGraphicEl(newIdx, itemGroup);
      }).remove(function(idx) {
        group.remove(oldData.getItemGraphicEl(idx));
      }).execute();
      data.eachItemGraphicEl(function(itemGroup, idx) {
        var itemModel = data.getItemModel(idx);
        var polyline = itemGroup.childAt(0);
        var polygon2 = itemGroup.childAt(1);
        var symbolGroup = itemGroup.childAt(2);
        var color2 = data.getItemVisual(idx, "color");
        group.add(itemGroup);
        polyline.useStyle(zrUtil2.defaults(itemModel.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: color2
        }));
        polyline.hoverStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
        var areaStyleModel = itemModel.getModel("areaStyle");
        var hoverAreaStyleModel = itemModel.getModel("emphasis.areaStyle");
        var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
        var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();
        hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
        polygon2.ignore = polygonIgnore;
        polygon2.useStyle(zrUtil2.defaults(areaStyleModel.getAreaStyle(), {
          fill: color2,
          opacity: 0.7
        }));
        polygon2.hoverStyle = hoverAreaStyleModel.getAreaStyle();
        var itemStyle2 = itemModel.getModel("itemStyle").getItemStyle(["color"]);
        var itemHoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
        var labelModel = itemModel.getModel("label");
        var labelHoverModel = itemModel.getModel("emphasis.label");
        symbolGroup.eachChild(function(symbolPath) {
          symbolPath.setStyle(itemStyle2);
          symbolPath.hoverStyle = zrUtil2.clone(itemHoverStyle);
          var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
          (defaultText == null || isNaN(defaultText)) && (defaultText = "");
          graphic2.setLabelStyle(symbolPath.style, symbolPath.hoverStyle, labelModel, labelHoverModel, {
            labelFetcher: data.hostModel,
            labelDataIndex: idx,
            labelDimIndex: symbolPath.__dimIdx,
            defaultText,
            autoColor: color2,
            isRectText: true
          });
        });
        itemGroup.highDownOnUpdate = function(fromState, toState) {
          polygon2.attr("ignore", toState === "emphasis" ? hoverPolygonIgnore : polygonIgnore);
        };
        graphic2.setHoverStyle(itemGroup);
      });
      this._data = data;
    },
    remove: function() {
      this.group.removeAll();
      this._data = null;
    },
    dispose: function() {
    }
  });
  RadarView = _default2;
  return RadarView;
}
var radarLayout;
var hasRequiredRadarLayout;
function requireRadarLayout() {
  if (hasRequiredRadarLayout)
    return radarLayout;
  hasRequiredRadarLayout = 1;
  var zrUtil2 = util$6;
  function _default2(ecModel) {
    ecModel.eachSeriesByType("radar", function(seriesModel) {
      var data = seriesModel.getData();
      var points2 = [];
      var coordSys = seriesModel.coordinateSystem;
      if (!coordSys) {
        return;
      }
      var axes = coordSys.getIndicatorAxes();
      zrUtil2.each(axes, function(axis2, axisIndex) {
        data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
          points2[dataIndex] = points2[dataIndex] || [];
          var point = coordSys.dataToPoint(val, axisIndex);
          points2[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
        });
      });
      data.each(function(idx) {
        var firstPoint = zrUtil2.find(points2[idx], function(point) {
          return isValidPoint(point);
        }) || getValueMissingPoint(coordSys);
        points2[idx].push(firstPoint.slice());
        data.setItemLayout(idx, points2[idx]);
      });
    });
  }
  function isValidPoint(point) {
    return !isNaN(point[0]) && !isNaN(point[1]);
  }
  function getValueMissingPoint(coordSys) {
    return [coordSys.cx, coordSys.cy];
  }
  radarLayout = _default2;
  return radarLayout;
}
var backwardCompat$1;
var hasRequiredBackwardCompat$1;
function requireBackwardCompat$1() {
  if (hasRequiredBackwardCompat$1)
    return backwardCompat$1;
  hasRequiredBackwardCompat$1 = 1;
  var zrUtil2 = util$6;
  function _default2(option) {
    var polarOptArr = option.polar;
    if (polarOptArr) {
      if (!zrUtil2.isArray(polarOptArr)) {
        polarOptArr = [polarOptArr];
      }
      var polarNotRadar = [];
      zrUtil2.each(polarOptArr, function(polarOpt, idx) {
        if (polarOpt.indicator) {
          if (polarOpt.type && !polarOpt.shape) {
            polarOpt.shape = polarOpt.type;
          }
          option.radar = option.radar || [];
          if (!zrUtil2.isArray(option.radar)) {
            option.radar = [option.radar];
          }
          option.radar.push(polarOpt);
        } else {
          polarNotRadar.push(polarOpt);
        }
      });
      option.polar = polarNotRadar;
    }
    zrUtil2.each(option.series, function(seriesOpt) {
      if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
        seriesOpt.radarIndex = seriesOpt.polarIndex;
      }
    });
  }
  backwardCompat$1 = _default2;
  return backwardCompat$1;
}
var hasRequiredRadar;
function requireRadar() {
  if (hasRequiredRadar)
    return radar$1;
  hasRequiredRadar = 1;
  var echarts$12 = echarts;
  requireRadar$1();
  requireRadarSeries();
  requireRadarView();
  var dataColor2 = requireDataColor();
  var visualSymbol = requireSymbol();
  var radarLayout2 = requireRadarLayout();
  var dataFilter2 = requireDataFilter();
  var backwardCompat2 = requireBackwardCompat$1();
  echarts$12.registerVisual(dataColor2("radar"));
  echarts$12.registerVisual(visualSymbol("radar", "circle"));
  echarts$12.registerLayout(radarLayout2);
  echarts$12.registerProcessor(dataFilter2("radar"));
  echarts$12.registerPreprocessor(backwardCompat2);
  return radar$1;
}
var map = {};
var nanhai;
var hasRequiredNanhai;
function requireNanhai() {
  if (hasRequiredNanhai)
    return nanhai;
  hasRequiredNanhai = 1;
  var zrUtil2 = util$6;
  var Region = requireRegion();
  var geoCoord2 = [126, 25];
  var points2 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
  for (var i = 0; i < points2.length; i++) {
    for (var k = 0; k < points2[i].length; k++) {
      points2[i][k][0] /= 10.5;
      points2[i][k][1] /= -10.5 / 0.75;
      points2[i][k][0] += geoCoord2[0];
      points2[i][k][1] += geoCoord2[1];
    }
  }
  function _default2(mapType, regions) {
    if (mapType === "china") {
      regions.push(new Region("南海诸岛", zrUtil2.map(points2, function(exterior) {
        return {
          type: "polygon",
          exterior
        };
      }), geoCoord2));
    }
  }
  nanhai = _default2;
  return nanhai;
}
var textCoord;
var hasRequiredTextCoord;
function requireTextCoord() {
  if (hasRequiredTextCoord)
    return textCoord;
  hasRequiredTextCoord = 1;
  var coordsOffsetMap = {
    "南海诸岛": [32, 80],
    // 全国
    "广东": [0, -10],
    "香港": [10, 5],
    "澳门": [-10, 10],
    //'北京': [-10, 0],
    "天津": [5, 5]
  };
  function _default2(mapType, region) {
    if (mapType === "china") {
      var coordFix = coordsOffsetMap[region.name];
      if (coordFix) {
        var cp = region.center;
        cp[0] += coordFix[0] / 10.5;
        cp[1] += -coordFix[1] / (10.5 / 0.75);
      }
    }
  }
  textCoord = _default2;
  return textCoord;
}
var geoCoord;
var hasRequiredGeoCoord;
function requireGeoCoord() {
  if (hasRequiredGeoCoord)
    return geoCoord;
  hasRequiredGeoCoord = 1;
  var geoCoordMap = {
    "Russia": [100, 60],
    "United States": [-99, 38],
    "United States of America": [-99, 38]
  };
  function _default2(mapType, region) {
    if (mapType === "world") {
      var geoCoord2 = geoCoordMap[region.name];
      if (geoCoord2) {
        var cp = region.center;
        cp[0] = geoCoord2[0];
        cp[1] = geoCoord2[1];
      }
    }
  }
  geoCoord = _default2;
  return geoCoord;
}
var diaoyuIsland;
var hasRequiredDiaoyuIsland;
function requireDiaoyuIsland() {
  if (hasRequiredDiaoyuIsland)
    return diaoyuIsland;
  hasRequiredDiaoyuIsland = 1;
  var points2 = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
  function _default2(mapType, region) {
    if (mapType === "china" && region.name === "台湾") {
      region.geometries.push({
        type: "polygon",
        exterior: points2[0]
      });
    }
  }
  diaoyuIsland = _default2;
  return diaoyuIsland;
}
var geoJSONLoader;
var hasRequiredGeoJSONLoader;
function requireGeoJSONLoader() {
  if (hasRequiredGeoJSONLoader)
    return geoJSONLoader;
  hasRequiredGeoJSONLoader = 1;
  var _util2 = util$6;
  var each2 = _util2.each;
  var parseGeoJson2 = requireParseGeoJson();
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var fixNanhai = requireNanhai();
  var fixTextCoord = requireTextCoord();
  var fixGeoCoord = requireGeoCoord();
  var fixDiaoyuIsland = requireDiaoyuIsland();
  var inner2 = makeInner2();
  var _default2 = {
    /**
     * @param {string} mapName
     * @param {Object} mapRecord {specialAreas, geoJSON}
     * @param {string} nameProperty
     * @return {Object} {regions, boundingRect}
     */
    load: function(mapName, mapRecord, nameProperty) {
      var parsed = inner2(mapRecord).parsed;
      if (parsed) {
        return parsed;
      }
      var specialAreas = mapRecord.specialAreas || {};
      var geoJSON = mapRecord.geoJSON;
      var regions;
      try {
        regions = geoJSON ? parseGeoJson2(geoJSON, nameProperty) : [];
      } catch (e2) {
        throw new Error("Invalid geoJson format\n" + e2.message);
      }
      fixNanhai(mapName, regions);
      each2(regions, function(region) {
        var regionName = region.name;
        fixTextCoord(mapName, region);
        fixGeoCoord(mapName, region);
        fixDiaoyuIsland(mapName, region);
        var specialArea = specialAreas[regionName];
        if (specialArea) {
          region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
        }
      });
      return inner2(mapRecord).parsed = {
        regions,
        boundingRect: getBoundingRect2(regions)
      };
    }
  };
  function getBoundingRect2(regions) {
    var rect;
    for (var i = 0; i < regions.length; i++) {
      var regionRect = regions[i].getBoundingRect();
      rect = rect || regionRect.clone();
      rect.union(regionRect);
    }
    return rect;
  }
  geoJSONLoader = _default2;
  return geoJSONLoader;
}
var geoSVGLoader;
var hasRequiredGeoSVGLoader;
function requireGeoSVGLoader() {
  if (hasRequiredGeoSVGLoader)
    return geoSVGLoader;
  hasRequiredGeoSVGLoader = 1;
  var _parseSVG2 = parseSVG$1;
  var parseSVG2 = _parseSVG2.parseSVG;
  var makeViewBoxTransform2 = _parseSVG2.makeViewBoxTransform;
  var Group2 = Group_1;
  var Rect2 = Rect$2;
  var _util2 = util$6;
  var assert2 = _util2.assert;
  var createHashMap2 = _util2.createHashMap;
  var BoundingRect2 = BoundingRect_1;
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var inner2 = makeInner2();
  var _default2 = {
    /**
     * @param {string} mapName
     * @param {Object} mapRecord {specialAreas, geoJSON}
     * @return {Object} {root, boundingRect}
     */
    load: function(mapName, mapRecord) {
      var originRoot = inner2(mapRecord).originRoot;
      if (originRoot) {
        return {
          root: originRoot,
          boundingRect: inner2(mapRecord).boundingRect
        };
      }
      var graphic2 = buildGraphic(mapRecord);
      inner2(mapRecord).originRoot = graphic2.root;
      inner2(mapRecord).boundingRect = graphic2.boundingRect;
      return graphic2;
    },
    makeGraphic: function(mapName, mapRecord, hostKey) {
      var field = inner2(mapRecord);
      var rootMap = field.rootMap || (field.rootMap = createHashMap2());
      var root = rootMap.get(hostKey);
      if (root) {
        return root;
      }
      var originRoot = field.originRoot;
      var boundingRect = field.boundingRect;
      if (!field.originRootHostKey) {
        field.originRootHostKey = hostKey;
        root = originRoot;
      } else {
        root = buildGraphic(mapRecord, boundingRect).root;
      }
      return rootMap.set(hostKey, root);
    },
    removeGraphic: function(mapName, mapRecord, hostKey) {
      var field = inner2(mapRecord);
      var rootMap = field.rootMap;
      rootMap && rootMap.removeKey(hostKey);
      if (hostKey === field.originRootHostKey) {
        field.originRootHostKey = null;
      }
    }
  };
  function buildGraphic(mapRecord, boundingRect) {
    var svgXML = mapRecord.svgXML;
    var result;
    var root;
    try {
      result = svgXML && parseSVG2(svgXML, {
        ignoreViewBox: true,
        ignoreRootClip: true
      }) || {};
      root = result.root;
      assert2(root != null);
    } catch (e2) {
      throw new Error("Invalid svg format\n" + e2.message);
    }
    var svgWidth = result.width;
    var svgHeight = result.height;
    var viewBoxRect = result.viewBoxRect;
    if (!boundingRect) {
      boundingRect = svgWidth == null || svgHeight == null ? (
        // If svg width / height not specified, calculate
        // bounding rect as the width / height
        root.getBoundingRect()
      ) : new BoundingRect2(0, 0, 0, 0);
      if (svgWidth != null) {
        boundingRect.width = svgWidth;
      }
      if (svgHeight != null) {
        boundingRect.height = svgHeight;
      }
    }
    if (viewBoxRect) {
      var viewBoxTransform = makeViewBoxTransform2(viewBoxRect, boundingRect.width, boundingRect.height);
      var elRoot = root;
      root = new Group2();
      root.add(elRoot);
      elRoot.scale = viewBoxTransform.scale;
      elRoot.position = viewBoxTransform.position;
    }
    root.setClipPath(new Rect2({
      shape: boundingRect.plain()
    }));
    return {
      root,
      boundingRect
    };
  }
  geoSVGLoader = _default2;
  return geoSVGLoader;
}
var geoSourceManager;
var hasRequiredGeoSourceManager;
function requireGeoSourceManager() {
  if (hasRequiredGeoSourceManager)
    return geoSourceManager;
  hasRequiredGeoSourceManager = 1;
  var _util2 = util$6;
  var each2 = _util2.each;
  var createHashMap2 = _util2.createHashMap;
  var mapDataStorage$1 = mapDataStorage;
  var geoJSONLoader2 = requireGeoJSONLoader();
  var geoSVGLoader2 = requireGeoSVGLoader();
  var BoundingRect2 = BoundingRect_1;
  var loaders = {
    geoJSON: geoJSONLoader2,
    svg: geoSVGLoader2
  };
  var _default2 = {
    /**
     * @param {string} mapName
     * @param {Object} nameMap
     * @param {string} nameProperty
     * @return {Object} source {regions, regionsMap, nameCoordMap, boundingRect}
     */
    load: function(mapName, nameMap, nameProperty) {
      var regions = [];
      var regionsMap = createHashMap2();
      var nameCoordMap = createHashMap2();
      var boundingRect;
      var mapRecords = retrieveMap(mapName);
      each2(mapRecords, function(record) {
        var singleSource = loaders[record.type].load(mapName, record, nameProperty);
        each2(singleSource.regions, function(region) {
          var regionName = region.name;
          if (nameMap && nameMap.hasOwnProperty(regionName)) {
            region = region.cloneShallow(regionName = nameMap[regionName]);
          }
          regions.push(region);
          regionsMap.set(regionName, region);
          nameCoordMap.set(regionName, region.center);
        });
        var rect = singleSource.boundingRect;
        if (rect) {
          boundingRect ? boundingRect.union(rect) : boundingRect = rect.clone();
        }
      });
      return {
        regions,
        regionsMap,
        nameCoordMap,
        // FIXME Always return new ?
        boundingRect: boundingRect || new BoundingRect2(0, 0, 0, 0)
      };
    },
    /**
     * @param {string} mapName
     * @param {string} hostKey For cache.
     * @return {Array.<module:zrender/Element>} Roots.
     */
    makeGraphic: makeInvoker("makeGraphic"),
    /**
     * @param {string} mapName
     * @param {string} hostKey For cache.
     */
    removeGraphic: makeInvoker("removeGraphic")
  };
  function makeInvoker(methodName) {
    return function(mapName, hostKey) {
      var mapRecords = retrieveMap(mapName);
      var results = [];
      each2(mapRecords, function(record) {
        var method = loaders[record.type][methodName];
        method && results.push(method(mapName, record, hostKey));
      });
      return results;
    };
  }
  function retrieveMap(mapName) {
    var mapRecords = mapDataStorage$1.retrieveMap(mapName) || [];
    return mapRecords;
  }
  geoSourceManager = _default2;
  return geoSourceManager;
}
var MapSeries_1;
var hasRequiredMapSeries;
function requireMapSeries() {
  if (hasRequiredMapSeries)
    return MapSeries_1;
  hasRequiredMapSeries = 1;
  var zrUtil2 = util$6;
  var createListSimply2 = requireCreateListSimply();
  var SeriesModel2 = Series;
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var addCommas2 = _format2.addCommas;
  var dataSelectableMixin = requireSelectableMixin();
  var _dataProvider2 = dataProvider;
  var retrieveRawAttr2 = _dataProvider2.retrieveRawAttr;
  var geoSourceManager2 = requireGeoSourceManager();
  var _sourceHelper2 = requireSourceHelper();
  var makeSeriesEncodeForNameBased = _sourceHelper2.makeSeriesEncodeForNameBased;
  var MapSeries = SeriesModel2.extend({
    type: "series.map",
    dependencies: ["geo"],
    layoutMode: "box",
    /**
     * Only first map series of same mapType will drawMap
     * @type {boolean}
     */
    needsDrawMap: false,
    /**
     * Group of all map series with same mapType
     * @type {boolean}
     */
    seriesGroup: [],
    getInitialData: function(option) {
      var data = createListSimply2(this, {
        coordDimensions: ["value"],
        encodeDefaulter: zrUtil2.curry(makeSeriesEncodeForNameBased, this)
      });
      var valueDim = data.mapDimension("value");
      var dataNameMap = zrUtil2.createHashMap();
      var selectTargetList = [];
      var toAppendNames = [];
      for (var i = 0, len = data.count(); i < len; i++) {
        var name2 = data.getName(i);
        dataNameMap.set(name2, true);
        selectTargetList.push({
          name: name2,
          value: data.get(valueDim, i),
          selected: retrieveRawAttr2(data, i, "selected")
        });
      }
      var geoSource = geoSourceManager2.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      zrUtil2.each(geoSource.regions, function(region) {
        var name3 = region.name;
        if (!dataNameMap.get(name3)) {
          selectTargetList.push({
            name: name3
          });
          toAppendNames.push(name3);
        }
      });
      this.updateSelectedMap(selectTargetList);
      data.appendValues([], toAppendNames);
      return data;
    },
    /**
     * If no host geo model, return null, which means using a
     * inner exclusive geo model.
     */
    getHostGeoModel: function() {
      var geoIndex = this.option.geoIndex;
      return geoIndex != null ? this.dependentModels.geo[geoIndex] : null;
    },
    getMapType: function() {
      return (this.getHostGeoModel() || this).option.map;
    },
    // _fillOption: function (option, mapName) {
    // Shallow clone
    // option = zrUtil.extend({}, option);
    // option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);
    // return option;
    // },
    getRawValue: function(dataIndex) {
      var data = this.getData();
      return data.get(data.mapDimension("value"), dataIndex);
    },
    /**
     * Get model of region
     * @param  {string} name
     * @return {module:echarts/model/Model}
     */
    getRegionModel: function(regionName) {
      var data = this.getData();
      return data.getItemModel(data.indexOfName(regionName));
    },
    /**
     * Map tooltip formatter
     *
     * @param {number} dataIndex
     */
    formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
      var data = this.getData();
      var formattedValue = addCommas2(this.getRawValue(dataIndex));
      var name2 = data.getName(dataIndex);
      var seriesGroup = this.seriesGroup;
      var seriesNames = [];
      for (var i = 0; i < seriesGroup.length; i++) {
        var otherIndex = seriesGroup[i].originalData.indexOfName(name2);
        var valueDim = data.mapDimension("value");
        if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
          seriesNames.push(encodeHTML2(seriesGroup[i].name));
        }
      }
      var newLine = renderMode === "html" ? "<br/>" : "\n";
      return seriesNames.join(", ") + newLine + encodeHTML2(name2 + " : " + formattedValue);
    },
    /**
     * @implement
     */
    getTooltipPosition: function(dataIndex) {
      if (dataIndex != null) {
        var name2 = this.getData().getName(dataIndex);
        var geo2 = this.coordinateSystem;
        var region = geo2.getRegion(name2);
        return region && geo2.dataToPoint(region.center);
      }
    },
    setZoom: function(zoom) {
      this.option.zoom = zoom;
    },
    setCenter: function(center2) {
      this.option.center = center2;
    },
    defaultOption: {
      // 一级层叠
      zlevel: 0,
      // 二级层叠
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      aspectScale: 0.75,
      ///// Layout with center and size
      // If you wan't to put map in a fixed size box with right aspect ratio
      // This two properties may more conveninet
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      // 数值合并方式，默认加和，可选为：
      // 'sum' | 'average' | 'max' | 'min'
      // mapValueCalculation: 'sum',
      // 地图数值计算结果小数精度
      // mapValuePrecision: 0,
      // 显示图例颜色标识（系列标识的小圆点），图例开启时有效
      showLegendSymbol: true,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      dataRangeHoverLink: true,
      // 是否开启缩放及漫游模式
      // roam: false,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      label: {
        show: false,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }
  });
  zrUtil2.mixin(MapSeries, dataSelectableMixin);
  var _default2 = MapSeries;
  MapSeries_1 = _default2;
  return MapSeries_1;
}
var interactionMutex = {};
var hasRequiredInteractionMutex;
function requireInteractionMutex() {
  if (hasRequiredInteractionMutex)
    return interactionMutex;
  hasRequiredInteractionMutex = 1;
  var echarts$12 = echarts;
  var ATTR = "\0_ec_interaction_mutex";
  function take(zr, resourceKey, userKey) {
    var store = getStore(zr);
    store[resourceKey] = userKey;
  }
  function release(zr, resourceKey, userKey) {
    var store = getStore(zr);
    var uKey = store[resourceKey];
    if (uKey === userKey) {
      store[resourceKey] = null;
    }
  }
  function isTaken(zr, resourceKey) {
    return !!getStore(zr)[resourceKey];
  }
  function getStore(zr) {
    return zr[ATTR] || (zr[ATTR] = {});
  }
  echarts$12.registerAction({
    type: "takeGlobalCursor",
    event: "globalCursorTaken",
    update: "update"
  }, function() {
  });
  interactionMutex.take = take;
  interactionMutex.release = release;
  interactionMutex.isTaken = isTaken;
  return interactionMutex;
}
var RoamController_1;
var hasRequiredRoamController;
function requireRoamController() {
  if (hasRequiredRoamController)
    return RoamController_1;
  hasRequiredRoamController = 1;
  var zrUtil2 = util$6;
  var Eventful2 = Eventful_1;
  var eventTool2 = event;
  var interactionMutex2 = requireInteractionMutex();
  function RoamController(zr) {
    this.pointerChecker;
    this._zr = zr;
    this._opt = {};
    var bind2 = zrUtil2.bind;
    var mousedownHandler = bind2(mousedown, this);
    var mousemoveHandler = bind2(mousemove, this);
    var mouseupHandler = bind2(mouseup, this);
    var mousewheelHandler = bind2(mousewheel, this);
    var pinchHandler = bind2(pinch, this);
    Eventful2.call(this);
    this.setPointerChecker = function(pointerChecker) {
      this.pointerChecker = pointerChecker;
    };
    this.enable = function(controlType, opt) {
      this.disable();
      this._opt = zrUtil2.defaults(zrUtil2.clone(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        // By default, wheel do not trigger move.
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });
      if (controlType == null) {
        controlType = true;
      }
      if (controlType === true || controlType === "move" || controlType === "pan") {
        zr.on("mousedown", mousedownHandler);
        zr.on("mousemove", mousemoveHandler);
        zr.on("mouseup", mouseupHandler);
      }
      if (controlType === true || controlType === "scale" || controlType === "zoom") {
        zr.on("mousewheel", mousewheelHandler);
        zr.on("pinch", pinchHandler);
      }
    };
    this.disable = function() {
      zr.off("mousedown", mousedownHandler);
      zr.off("mousemove", mousemoveHandler);
      zr.off("mouseup", mouseupHandler);
      zr.off("mousewheel", mousewheelHandler);
      zr.off("pinch", pinchHandler);
    };
    this.dispose = this.disable;
    this.isDragging = function() {
      return this._dragging;
    };
    this.isPinching = function() {
      return this._pinching;
    };
  }
  zrUtil2.mixin(RoamController, Eventful2);
  function mousedown(e2) {
    if (eventTool2.isMiddleOrRightButtonOnMouseUpDown(e2) || e2.target && e2.target.draggable) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    if (this.pointerChecker && this.pointerChecker(e2, x, y)) {
      this._x = x;
      this._y = y;
      this._dragging = true;
    }
  }
  function mousemove(e2) {
    if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt) || e2.gestureEvent === "pinch" || interactionMutex2.isTaken(this._zr, "globalPan")) {
      return;
    }
    var x = e2.offsetX;
    var y = e2.offsetY;
    var oldX = this._x;
    var oldY = this._y;
    var dx = x - oldX;
    var dy = y - oldY;
    this._x = x;
    this._y = y;
    this._opt.preventDefaultMouseMove && eventTool2.stop(e2.event);
    trigger2(this, "pan", "moveOnMouseMove", e2, {
      dx,
      dy,
      oldX,
      oldY,
      newX: x,
      newY: y
    });
  }
  function mouseup(e2) {
    if (!eventTool2.isMiddleOrRightButtonOnMouseUpDown(e2)) {
      this._dragging = false;
    }
  }
  function mousewheel(e2) {
    var shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
    var shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
    var wheelDelta = e2.wheelDelta;
    var absWheelDeltaDelta = Math.abs(wheelDelta);
    var originX = e2.offsetX;
    var originY = e2.offsetY;
    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    }
    if (shouldZoom) {
      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      var scale = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e2, {
        scale,
        originX,
        originY
      });
    }
    if (shouldMove) {
      var absDelta = Math.abs(wheelDelta);
      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e2, {
        scrollDelta,
        originX,
        originY
      });
    }
  }
  function pinch(e2) {
    if (interactionMutex2.isTaken(this._zr, "globalPan")) {
      return;
    }
    var scale = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, "zoom", null, e2, {
      scale,
      originX: e2.pinchX,
      originY: e2.pinchY
    });
  }
  function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
    if (controller.pointerChecker && controller.pointerChecker(e2, contollerEvent.originX, contollerEvent.originY)) {
      eventTool2.stop(e2.event);
      trigger2(controller, eventName, behaviorToCheck, e2, contollerEvent);
    }
  }
  function trigger2(controller, eventName, behaviorToCheck, e2, contollerEvent) {
    contollerEvent.isAvailableBehavior = zrUtil2.bind(isAvailableBehavior, null, behaviorToCheck, e2);
    controller.trigger(eventName, contollerEvent);
  }
  function isAvailableBehavior(behaviorToCheck, e2, settings) {
    var setting = settings[behaviorToCheck];
    return !behaviorToCheck || setting && (!zrUtil2.isString(setting) || e2.event[setting + "Key"]);
  }
  var _default2 = RoamController;
  RoamController_1 = _default2;
  return RoamController_1;
}
var roamHelper$1 = {};
var hasRequiredRoamHelper$1;
function requireRoamHelper$1() {
  if (hasRequiredRoamHelper$1)
    return roamHelper$1;
  hasRequiredRoamHelper$1 = 1;
  function updateViewOnPan(controllerHost, dx, dy) {
    var target = controllerHost.target;
    var pos = target.position;
    pos[0] += dx;
    pos[1] += dy;
    target.dirty();
  }
  function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
    var target = controllerHost.target;
    var zoomLimit = controllerHost.zoomLimit;
    var pos = target.position;
    var scale = target.scale;
    var newZoom = controllerHost.zoom = controllerHost.zoom || 1;
    newZoom *= zoomDelta;
    if (zoomLimit) {
      var zoomMin = zoomLimit.min || 0;
      var zoomMax = zoomLimit.max || Infinity;
      newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
    }
    var zoomScale = newZoom / controllerHost.zoom;
    controllerHost.zoom = newZoom;
    pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
    pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
    scale[0] *= zoomScale;
    scale[1] *= zoomScale;
    target.dirty();
  }
  roamHelper$1.updateViewOnPan = updateViewOnPan;
  roamHelper$1.updateViewOnZoom = updateViewOnZoom;
  return roamHelper$1;
}
var cursorHelper = {};
var hasRequiredCursorHelper;
function requireCursorHelper() {
  if (hasRequiredCursorHelper)
    return cursorHelper;
  hasRequiredCursorHelper = 1;
  var IRRELEVANT_EXCLUDES = {
    "axisPointer": 1,
    "tooltip": 1,
    "brush": 1
  };
  function onIrrelevantElement(e2, api, targetCoordSysModel) {
    var model2 = api.getComponentByElement(e2.topTarget);
    var coordSys = model2 && model2.coordinateSystem;
    return model2 && model2 !== targetCoordSysModel && !IRRELEVANT_EXCLUDES[model2.mainType] && coordSys && coordSys.model !== targetCoordSysModel;
  }
  cursorHelper.onIrrelevantElement = onIrrelevantElement;
  return cursorHelper;
}
var MapDraw_1;
var hasRequiredMapDraw;
function requireMapDraw() {
  if (hasRequiredMapDraw)
    return MapDraw_1;
  hasRequiredMapDraw = 1;
  var zrUtil2 = util$6;
  var RoamController = requireRoamController();
  var roamHelper2 = requireRoamHelper$1();
  var _cursorHelper = requireCursorHelper();
  var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
  var graphic2 = graphic$4;
  var geoSourceManager2 = requireGeoSourceManager();
  var _component2 = component;
  var getUID2 = _component2.getUID;
  var Transformable2 = Transformable_1;
  function getFixedItemStyle(model2) {
    var itemStyle2 = model2.getItemStyle();
    var areaColor = model2.get("areaColor");
    if (areaColor != null) {
      itemStyle2.fill = areaColor;
    }
    return itemStyle2;
  }
  function updateMapSelectHandler(mapDraw, mapOrGeoModel, regionsGroup, api, fromView) {
    regionsGroup.off("click");
    regionsGroup.off("mousedown");
    if (mapOrGeoModel.get("selectedMode")) {
      regionsGroup.on("mousedown", function() {
        mapDraw._mouseDownFlag = true;
      });
      regionsGroup.on("click", function(e2) {
        if (!mapDraw._mouseDownFlag) {
          return;
        }
        mapDraw._mouseDownFlag = false;
        var el = e2.target;
        while (!el.__regions) {
          el = el.parent;
        }
        if (!el) {
          return;
        }
        var action = {
          type: (mapOrGeoModel.mainType === "geo" ? "geo" : "map") + "ToggleSelect",
          batch: zrUtil2.map(el.__regions, function(region) {
            return {
              name: region.name,
              from: fromView.uid
            };
          })
        };
        action[mapOrGeoModel.mainType + "Id"] = mapOrGeoModel.id;
        api.dispatchAction(action);
        updateMapSelected(mapOrGeoModel, regionsGroup);
      });
    }
  }
  function updateMapSelected(mapOrGeoModel, regionsGroup) {
    regionsGroup.eachChild(function(otherRegionEl) {
      zrUtil2.each(otherRegionEl.__regions, function(region) {
        otherRegionEl.trigger(mapOrGeoModel.isSelected(region.name) ? "emphasis" : "normal");
      });
    });
  }
  function MapDraw(api, updateGroup) {
    var group = new graphic2.Group();
    this.uid = getUID2("ec_map_draw");
    this._controller = new RoamController(api.getZr());
    this._controllerHost = {
      target: updateGroup ? group : null
    };
    this.group = group;
    this._updateGroup = updateGroup;
    this._mouseDownFlag;
    this._mapName;
    this._initialized;
    group.add(this._regionsGroup = new graphic2.Group());
    group.add(this._backgroundGroup = new graphic2.Group());
  }
  MapDraw.prototype = {
    constructor: MapDraw,
    draw: function(mapOrGeoModel, ecModel, api, fromView, payload) {
      var isGeo = mapOrGeoModel.mainType === "geo";
      var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
      isGeo && ecModel.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(mapSeries) {
        if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
          data = mapSeries.getData();
        }
      });
      var geo2 = mapOrGeoModel.coordinateSystem;
      this._updateBackground(geo2);
      var regionsGroup = this._regionsGroup;
      var group = this.group;
      var transformInfo = geo2.getTransformInfo();
      var isFirstDraw = !regionsGroup.childAt(0) || payload;
      var targetScale;
      if (isFirstDraw) {
        group.transform = transformInfo.roamTransform;
        group.decomposeTransform();
        group.dirty();
      } else {
        var target = new Transformable2();
        target.transform = transformInfo.roamTransform;
        target.decomposeTransform();
        var props = {
          scale: target.scale,
          position: target.position
        };
        targetScale = target.scale;
        graphic2.updateProps(group, props, mapOrGeoModel);
      }
      var scale = transformInfo.rawScale;
      var position = transformInfo.rawPosition;
      regionsGroup.removeAll();
      var itemStyleAccessPath = ["itemStyle"];
      var hoverItemStyleAccessPath = ["emphasis", "itemStyle"];
      var labelAccessPath = ["label"];
      var hoverLabelAccessPath = ["emphasis", "label"];
      var nameMap = zrUtil2.createHashMap();
      zrUtil2.each(geo2.regions, function(region) {
        var regionGroup = nameMap.get(region.name) || nameMap.set(region.name, new graphic2.Group());
        var compoundPath = new graphic2.CompoundPath({
          segmentIgnoreThreshold: 1,
          shape: {
            paths: []
          }
        });
        regionGroup.add(compoundPath);
        var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;
        var itemStyleModel = regionModel.getModel(itemStyleAccessPath);
        var hoverItemStyleModel = regionModel.getModel(hoverItemStyleAccessPath);
        var itemStyle2 = getFixedItemStyle(itemStyleModel);
        var hoverItemStyle = getFixedItemStyle(hoverItemStyleModel);
        var labelModel = regionModel.getModel(labelAccessPath);
        var hoverLabelModel = regionModel.getModel(hoverLabelAccessPath);
        var dataIdx;
        if (data) {
          dataIdx = data.indexOfName(region.name);
          var visualColor = data.getItemVisual(dataIdx, "color", true);
          if (visualColor) {
            itemStyle2.fill = visualColor;
          }
        }
        var transformPoint = function(point) {
          return [point[0] * scale[0] + position[0], point[1] * scale[1] + position[1]];
        };
        zrUtil2.each(region.geometries, function(geometry) {
          if (geometry.type !== "polygon") {
            return;
          }
          var points2 = [];
          for (var i = 0; i < geometry.exterior.length; ++i) {
            points2.push(transformPoint(geometry.exterior[i]));
          }
          compoundPath.shape.paths.push(new graphic2.Polygon({
            segmentIgnoreThreshold: 1,
            shape: {
              points: points2
            }
          }));
          for (var i = 0; i < (geometry.interiors ? geometry.interiors.length : 0); ++i) {
            var interior = geometry.interiors[i];
            var points2 = [];
            for (var j = 0; j < interior.length; ++j) {
              points2.push(transformPoint(interior[j]));
            }
            compoundPath.shape.paths.push(new graphic2.Polygon({
              segmentIgnoreThreshold: 1,
              shape: {
                points: points2
              }
            }));
          }
        });
        compoundPath.setStyle(itemStyle2);
        compoundPath.style.strokeNoScale = true;
        compoundPath.culling = true;
        var showLabel = labelModel.get("show");
        var hoverShowLabel = hoverLabelModel.get("show");
        var isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
        var itemLayout = data && data.getItemLayout(dataIdx);
        if (isGeo || isDataNaN && (showLabel || hoverShowLabel) || itemLayout && itemLayout.showLabel) {
          var query = !isGeo ? dataIdx : region.name;
          var labelFetcher;
          if (!data || dataIdx >= 0) {
            labelFetcher = mapOrGeoModel;
          }
          var textEl = new graphic2.Text({
            position: transformPoint(region.center.slice()),
            // FIXME
            // label rotation is not support yet in geo or regions of series-map
            // that has no data. The rotation will be effected by this `scale`.
            // So needed to change to RectText?
            scale: [1 / group.scale[0], 1 / group.scale[1]],
            z2: 10,
            silent: true
          });
          graphic2.setLabelStyle(textEl.style, textEl.hoverStyle = {}, labelModel, hoverLabelModel, {
            labelFetcher,
            labelDataIndex: query,
            defaultText: region.name,
            useInsideStyle: false
          }, {
            textAlign: "center",
            textVerticalAlign: "middle"
          });
          if (!isFirstDraw) {
            var textScale = [1 / targetScale[0], 1 / targetScale[1]];
            graphic2.updateProps(textEl, {
              scale: textScale
            }, mapOrGeoModel);
          }
          regionGroup.add(textEl);
        }
        if (data) {
          data.setItemGraphicEl(dataIdx, regionGroup);
        } else {
          var regionModel = mapOrGeoModel.getRegionModel(region.name);
          compoundPath.eventData = {
            componentType: "geo",
            componentIndex: mapOrGeoModel.componentIndex,
            geoIndex: mapOrGeoModel.componentIndex,
            name: region.name,
            region: regionModel && regionModel.option || {}
          };
        }
        var groupRegions = regionGroup.__regions || (regionGroup.__regions = []);
        groupRegions.push(region);
        regionGroup.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
        graphic2.setHoverStyle(regionGroup, hoverItemStyle);
        regionsGroup.add(regionGroup);
      });
      this._updateController(mapOrGeoModel, ecModel, api);
      updateMapSelectHandler(this, mapOrGeoModel, regionsGroup, api, fromView);
      updateMapSelected(mapOrGeoModel, regionsGroup);
    },
    remove: function() {
      this._regionsGroup.removeAll();
      this._backgroundGroup.removeAll();
      this._controller.dispose();
      this._mapName && geoSourceManager2.removeGraphic(this._mapName, this.uid);
      this._mapName = null;
      this._controllerHost = {};
    },
    _updateBackground: function(geo2) {
      var mapName = geo2.map;
      if (this._mapName !== mapName) {
        zrUtil2.each(geoSourceManager2.makeGraphic(mapName, this.uid), function(root) {
          this._backgroundGroup.add(root);
        }, this);
      }
      this._mapName = mapName;
    },
    _updateController: function(mapOrGeoModel, ecModel, api) {
      var geo2 = mapOrGeoModel.coordinateSystem;
      var controller = this._controller;
      var controllerHost = this._controllerHost;
      controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
      controllerHost.zoom = geo2.getZoom();
      controller.enable(mapOrGeoModel.get("roam") || false);
      var mainType = mapOrGeoModel.mainType;
      function makeActionBase() {
        var action = {
          type: "geoRoam",
          componentType: mainType
        };
        action[mainType + "Id"] = mapOrGeoModel.id;
        return action;
      }
      controller.off("pan").on("pan", function(e2) {
        this._mouseDownFlag = false;
        roamHelper2.updateViewOnPan(controllerHost, e2.dx, e2.dy);
        api.dispatchAction(zrUtil2.extend(makeActionBase(), {
          dx: e2.dx,
          dy: e2.dy
        }));
      }, this);
      controller.off("zoom").on("zoom", function(e2) {
        this._mouseDownFlag = false;
        roamHelper2.updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
        api.dispatchAction(zrUtil2.extend(makeActionBase(), {
          zoom: e2.scale,
          originX: e2.originX,
          originY: e2.originY
        }));
        if (this._updateGroup) {
          var scale = this.group.scale;
          this._regionsGroup.traverse(function(el) {
            if (el.type === "text") {
              el.attr("scale", [1 / scale[0], 1 / scale[1]]);
            }
          });
        }
      }, this);
      controller.setPointerChecker(function(e2, x, y) {
        return geo2.getViewRectAfterRoam().contain(x, y) && !onIrrelevantElement(e2, api, mapOrGeoModel);
      });
    }
  };
  var _default2 = MapDraw;
  MapDraw_1 = _default2;
  return MapDraw_1;
}
var MapView;
var hasRequiredMapView;
function requireMapView() {
  if (hasRequiredMapView)
    return MapView;
  hasRequiredMapView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var MapDraw = requireMapDraw();
  var HIGH_DOWN_PROP = "__seriesMapHighDown";
  var RECORD_VERSION_PROP = "__seriesMapCallKey";
  var _default2 = echarts$12.extendChartView({
    type: "map",
    render: function(mapModel, ecModel, api, payload) {
      if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
        return;
      }
      var group = this.group;
      group.removeAll();
      if (mapModel.getHostGeoModel()) {
        return;
      }
      if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
        if (mapModel.needsDrawMap) {
          var mapDraw = this._mapDraw || new MapDraw(api, true);
          group.add(mapDraw.group);
          mapDraw.draw(mapModel, ecModel, api, this, payload);
          this._mapDraw = mapDraw;
        } else {
          this._mapDraw && this._mapDraw.remove();
          this._mapDraw = null;
        }
      } else {
        var mapDraw = this._mapDraw;
        mapDraw && group.add(mapDraw.group);
      }
      mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api);
    },
    remove: function() {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      this.group.removeAll();
    },
    dispose: function() {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
    },
    _renderSymbols: function(mapModel, ecModel, api) {
      var originalData = mapModel.originalData;
      var group = this.group;
      originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
        if (isNaN(value)) {
          return;
        }
        var layout2 = originalData.getItemLayout(originalDataIndex);
        if (!layout2 || !layout2.point) {
          return;
        }
        var point = layout2.point;
        var offset = layout2.offset;
        var circle = new graphic2.Circle({
          style: {
            // Because the special of map draw.
            // Which needs statistic of multiple series and draw on one map.
            // And each series also need a symbol with legend color
            //
            // Layout and visual are put one the different data
            fill: mapModel.getData().getVisual("color")
          },
          shape: {
            cx: point[0] + offset * 9,
            cy: point[1],
            r: 3
          },
          silent: true,
          // Do not overlap the first series, on which labels are displayed.
          z2: 8 + (!offset ? graphic2.Z2_EMPHASIS_LIFT + 1 : 0)
        });
        if (!offset) {
          var fullData = mapModel.mainSeries.getData();
          var name2 = originalData.getName(originalDataIndex);
          var fullIndex = fullData.indexOfName(name2);
          var itemModel = originalData.getItemModel(originalDataIndex);
          var labelModel = itemModel.getModel("label");
          var hoverLabelModel = itemModel.getModel("emphasis.label");
          var regionGroup = fullData.getItemGraphicEl(fullIndex);
          var normalText = zrUtil2.retrieve2(mapModel.getFormattedLabel(fullIndex, "normal"), name2);
          var emphasisText = zrUtil2.retrieve2(mapModel.getFormattedLabel(fullIndex, "emphasis"), normalText);
          var highDownRecord = regionGroup[HIGH_DOWN_PROP];
          var recordVersion = Math.random();
          if (!highDownRecord) {
            highDownRecord = regionGroup[HIGH_DOWN_PROP] = {};
            var onEmphasis = zrUtil2.curry(onRegionHighDown, true);
            var onNormal = zrUtil2.curry(onRegionHighDown, false);
            regionGroup.on("mouseover", onEmphasis).on("mouseout", onNormal).on("emphasis", onEmphasis).on("normal", onNormal);
          }
          regionGroup[RECORD_VERSION_PROP] = recordVersion;
          zrUtil2.extend(highDownRecord, {
            recordVersion,
            circle,
            labelModel,
            hoverLabelModel,
            emphasisText,
            normalText
          });
          enterRegionHighDown(highDownRecord, false);
        }
        group.add(circle);
      });
    }
  });
  function onRegionHighDown(toHighOrDown) {
    var highDownRecord = this[HIGH_DOWN_PROP];
    if (highDownRecord && highDownRecord.recordVersion === this[RECORD_VERSION_PROP]) {
      enterRegionHighDown(highDownRecord, toHighOrDown);
    }
  }
  function enterRegionHighDown(highDownRecord, toHighOrDown) {
    var circle = highDownRecord.circle;
    var labelModel = highDownRecord.labelModel;
    var hoverLabelModel = highDownRecord.hoverLabelModel;
    var emphasisText = highDownRecord.emphasisText;
    var normalText = highDownRecord.normalText;
    if (toHighOrDown) {
      circle.style.extendFrom(graphic2.setTextStyle({}, hoverLabelModel, {
        text: hoverLabelModel.get("show") ? emphasisText : null
      }, {
        isRectText: true,
        useInsideStyle: false
      }, true));
      circle.__mapOriginalZ2 = circle.z2;
      circle.z2 += graphic2.Z2_EMPHASIS_LIFT;
    } else {
      graphic2.setTextStyle(circle.style, labelModel, {
        text: labelModel.get("show") ? normalText : null,
        textPosition: labelModel.getShallow("position") || "bottom"
      }, {
        isRectText: true,
        useInsideStyle: false
      });
      circle.dirty(false);
      if (circle.__mapOriginalZ2 != null) {
        circle.z2 = circle.__mapOriginalZ2;
        circle.__mapOriginalZ2 = null;
      }
    }
  }
  MapView = _default2;
  return MapView;
}
var geoRoam = {};
var roamHelper = {};
var hasRequiredRoamHelper;
function requireRoamHelper() {
  if (hasRequiredRoamHelper)
    return roamHelper;
  hasRequiredRoamHelper = 1;
  function updateCenterAndZoom(view, payload, zoomLimit) {
    var previousZoom = view.getZoom();
    var center2 = view.getCenter();
    var zoom = payload.zoom;
    var point = view.dataToPoint(center2);
    if (payload.dx != null && payload.dy != null) {
      point[0] -= payload.dx;
      point[1] -= payload.dy;
      var center2 = view.pointToData(point);
      view.setCenter(center2);
    }
    if (zoom != null) {
      if (zoomLimit) {
        var zoomMin = zoomLimit.min || 0;
        var zoomMax = zoomLimit.max || Infinity;
        zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
      }
      view.scale[0] *= zoom;
      view.scale[1] *= zoom;
      var position = view.position;
      var fixX = (payload.originX - position[0]) * (zoom - 1);
      var fixY = (payload.originY - position[1]) * (zoom - 1);
      position[0] -= fixX;
      position[1] -= fixY;
      view.updateTransform();
      var center2 = view.pointToData(point);
      view.setCenter(center2);
      view.setZoom(zoom * previousZoom);
    }
    return {
      center: view.getCenter(),
      zoom: view.getZoom()
    };
  }
  roamHelper.updateCenterAndZoom = updateCenterAndZoom;
  return roamHelper;
}
var hasRequiredGeoRoam;
function requireGeoRoam() {
  if (hasRequiredGeoRoam)
    return geoRoam;
  hasRequiredGeoRoam = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var _roamHelper = requireRoamHelper();
  var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
  echarts$12.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(payload, ecModel) {
    var componentType = payload.componentType || "series";
    ecModel.eachComponent({
      mainType: componentType,
      query: payload
    }, function(componentModel) {
      var geo2 = componentModel.coordinateSystem;
      if (geo2.type !== "geo") {
        return;
      }
      var res = updateCenterAndZoom(geo2, payload, componentModel.get("scaleLimit"));
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom);
      if (componentType === "series") {
        zrUtil2.each(componentModel.seriesGroup, function(seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
  return geoRoam;
}
var View_1;
var hasRequiredView;
function requireView() {
  if (hasRequiredView)
    return View_1;
  hasRequiredView = 1;
  var zrUtil2 = util$6;
  var vector2 = requireVector();
  var matrix2 = requireMatrix();
  var BoundingRect2 = BoundingRect_1;
  var Transformable2 = Transformable_1;
  var v2ApplyTransform2 = vector2.applyTransform;
  function TransformDummy() {
    Transformable2.call(this);
  }
  zrUtil2.mixin(TransformDummy, Transformable2);
  function View(name2) {
    this.name = name2;
    this.zoomLimit;
    Transformable2.call(this);
    this._roamTransformable = new TransformDummy();
    this._rawTransformable = new TransformDummy();
    this._center;
    this._zoom;
  }
  View.prototype = {
    constructor: View,
    type: "view",
    /**
     * @param {Array.<string>}
     * @readOnly
     */
    dimensions: ["x", "y"],
    /**
     * Set bounding rect
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    // PENDING to getRect
    setBoundingRect: function(x, y, width, height) {
      this._rect = new BoundingRect2(x, y, width, height);
      return this._rect;
    },
    /**
     * @return {module:zrender/core/BoundingRect}
     */
    // PENDING to getRect
    getBoundingRect: function() {
      return this._rect;
    },
    /**
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    setViewRect: function(x, y, width, height) {
      this.transformTo(x, y, width, height);
      this._viewRect = new BoundingRect2(x, y, width, height);
    },
    /**
     * Transformed to particular position and size
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     */
    transformTo: function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var rawTransform = this._rawTransformable;
      rawTransform.transform = rect.calculateTransform(new BoundingRect2(x, y, width, height));
      rawTransform.decomposeTransform();
      this._updateTransform();
    },
    /**
     * Set center of view
     * @param {Array.<number>} [centerCoord]
     */
    setCenter: function(centerCoord) {
      if (!centerCoord) {
        return;
      }
      this._center = centerCoord;
      this._updateCenterAndZoom();
    },
    /**
     * @param {number} zoom
     */
    setZoom: function(zoom) {
      zoom = zoom || 1;
      var zoomLimit = this.zoomLimit;
      if (zoomLimit) {
        if (zoomLimit.max != null) {
          zoom = Math.min(zoomLimit.max, zoom);
        }
        if (zoomLimit.min != null) {
          zoom = Math.max(zoomLimit.min, zoom);
        }
      }
      this._zoom = zoom;
      this._updateCenterAndZoom();
    },
    /**
     * Get default center without roam
     */
    getDefaultCenter: function() {
      var rawRect = this.getBoundingRect();
      var cx = rawRect.x + rawRect.width / 2;
      var cy = rawRect.y + rawRect.height / 2;
      return [cx, cy];
    },
    getCenter: function() {
      return this._center || this.getDefaultCenter();
    },
    getZoom: function() {
      return this._zoom || 1;
    },
    /**
     * @return {Array.<number}
     */
    getRoamTransform: function() {
      return this._roamTransformable.getLocalTransform();
    },
    /**
     * Remove roam
     */
    _updateCenterAndZoom: function() {
      var rawTransformMatrix = this._rawTransformable.getLocalTransform();
      var roamTransform = this._roamTransformable;
      var defaultCenter = this.getDefaultCenter();
      var center2 = this.getCenter();
      var zoom = this.getZoom();
      center2 = vector2.applyTransform([], center2, rawTransformMatrix);
      defaultCenter = vector2.applyTransform([], defaultCenter, rawTransformMatrix);
      roamTransform.origin = center2;
      roamTransform.position = [defaultCenter[0] - center2[0], defaultCenter[1] - center2[1]];
      roamTransform.scale = [zoom, zoom];
      this._updateTransform();
    },
    /**
     * Update transform from roam and mapLocation
     * @private
     */
    _updateTransform: function() {
      var roamTransformable = this._roamTransformable;
      var rawTransformable = this._rawTransformable;
      rawTransformable.parent = roamTransformable;
      roamTransformable.updateTransform();
      rawTransformable.updateTransform();
      matrix2.copy(this.transform || (this.transform = []), rawTransformable.transform || matrix2.create());
      this._rawTransform = rawTransformable.getLocalTransform();
      this.invTransform = this.invTransform || [];
      matrix2.invert(this.invTransform, this.transform);
      this.decomposeTransform();
    },
    getTransformInfo: function() {
      var roamTransform = this._roamTransformable.transform;
      var rawTransformable = this._rawTransformable;
      return {
        roamTransform: roamTransform ? zrUtil2.slice(roamTransform) : matrix2.create(),
        rawScale: zrUtil2.slice(rawTransformable.scale),
        rawPosition: zrUtil2.slice(rawTransformable.position)
      };
    },
    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getViewRect: function() {
      return this._viewRect;
    },
    /**
     * Get view rect after roam transform
     * @return {module:zrender/core/BoundingRect}
     */
    getViewRectAfterRoam: function() {
      var rect = this.getBoundingRect().clone();
      rect.applyTransform(this.transform);
      return rect;
    },
    /**
     * Convert a single (lon, lat) data item to (x, y) point.
     * @param {Array.<number>} data
     * @param {boolean} noRoam
     * @param {Array.<number>} [out]
     * @return {Array.<number>}
     */
    dataToPoint: function(data, noRoam, out2) {
      var transform = noRoam ? this._rawTransform : this.transform;
      out2 = out2 || [];
      return transform ? v2ApplyTransform2(out2, data, transform) : vector2.copy(out2, data);
    },
    /**
     * Convert a (x, y) point to (lon, lat) data
     * @param {Array.<number>} point
     * @return {Array.<number>}
     */
    pointToData: function(point) {
      var invTransform = this.invTransform;
      return invTransform ? v2ApplyTransform2([], point, invTransform) : [point[0], point[1]];
    },
    /**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */
    convertToPixel: zrUtil2.curry(doConvert, "dataToPoint"),
    /**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */
    convertFromPixel: zrUtil2.curry(doConvert, "pointToData"),
    /**
     * @implements
     * see {module:echarts/CoodinateSystem}
     */
    containPoint: function(point) {
      return this.getViewRectAfterRoam().contain(point[0], point[1]);
    }
    /**
     * @return {number}
     */
    // getScalarScale: function () {
    //     // Use determinant square root of transform to mutiply scalar
    //     var m = this.transform;
    //     var det = Math.sqrt(Math.abs(m[0] * m[3] - m[2] * m[1]));
    //     return det;
    // }
  };
  zrUtil2.mixin(View, Transformable2);
  function doConvert(methodName, ecModel, finder, value) {
    var seriesModel = finder.seriesModel;
    var coordSys = seriesModel ? seriesModel.coordinateSystem : null;
    return coordSys === this ? coordSys[methodName](value) : null;
  }
  var _default2 = View;
  View_1 = _default2;
  return View_1;
}
var Geo_1;
var hasRequiredGeo$1;
function requireGeo$1() {
  if (hasRequiredGeo$1)
    return Geo_1;
  hasRequiredGeo$1 = 1;
  var zrUtil2 = util$6;
  var BoundingRect2 = BoundingRect_1;
  var View = requireView();
  var geoSourceManager2 = requireGeoSourceManager();
  function Geo(name2, map2, nameMap, invertLongitute) {
    View.call(this, name2);
    this.map = map2;
    var source = geoSourceManager2.load(map2, nameMap);
    this._nameCoordMap = source.nameCoordMap;
    this._regionsMap = source.regionsMap;
    this._invertLongitute = invertLongitute == null ? true : invertLongitute;
    this.regions = source.regions;
    this._rect = source.boundingRect;
  }
  Geo.prototype = {
    constructor: Geo,
    type: "geo",
    /**
     * @param {Array.<string>}
     * @readOnly
     */
    dimensions: ["lng", "lat"],
    /**
     * If contain given lng,lat coord
     * @param {Array.<number>}
     * @readOnly
     */
    containCoord: function(coord) {
      var regions = this.regions;
      for (var i = 0; i < regions.length; i++) {
        if (regions[i].contain(coord)) {
          return true;
        }
      }
      return false;
    },
    /**
     * @override
     */
    transformTo: function(x, y, width, height) {
      var rect = this.getBoundingRect();
      var invertLongitute = this._invertLongitute;
      rect = rect.clone();
      if (invertLongitute) {
        rect.y = -rect.y - rect.height;
      }
      var rawTransformable = this._rawTransformable;
      rawTransformable.transform = rect.calculateTransform(new BoundingRect2(x, y, width, height));
      rawTransformable.decomposeTransform();
      if (invertLongitute) {
        var scale = rawTransformable.scale;
        scale[1] = -scale[1];
      }
      rawTransformable.updateTransform();
      this._updateTransform();
    },
    /**
     * @param {string} name
     * @return {module:echarts/coord/geo/Region}
     */
    getRegion: function(name2) {
      return this._regionsMap.get(name2);
    },
    getRegionByCoord: function(coord) {
      var regions = this.regions;
      for (var i = 0; i < regions.length; i++) {
        if (regions[i].contain(coord)) {
          return regions[i];
        }
      }
    },
    /**
     * Add geoCoord for indexing by name
     * @param {string} name
     * @param {Array.<number>} geoCoord
     */
    addGeoCoord: function(name2, geoCoord2) {
      this._nameCoordMap.set(name2, geoCoord2);
    },
    /**
     * Get geoCoord by name
     * @param {string} name
     * @return {Array.<number>}
     */
    getGeoCoord: function(name2) {
      return this._nameCoordMap.get(name2);
    },
    /**
     * @override
     */
    getBoundingRect: function() {
      return this._rect;
    },
    /**
     * @param {string|Array.<number>} data
     * @param {boolean} noRoam
     * @param {Array.<number>} [out]
     * @return {Array.<number>}
     */
    dataToPoint: function(data, noRoam, out2) {
      if (typeof data === "string") {
        data = this.getGeoCoord(data);
      }
      if (data) {
        return View.prototype.dataToPoint.call(this, data, noRoam, out2);
      }
    },
    /**
     * @override
     */
    convertToPixel: zrUtil2.curry(doConvert, "dataToPoint"),
    /**
     * @override
     */
    convertFromPixel: zrUtil2.curry(doConvert, "pointToData")
  };
  zrUtil2.mixin(Geo, View);
  function doConvert(methodName, ecModel, finder, value) {
    var geoModel = finder.geoModel;
    var seriesModel = finder.seriesModel;
    var coordSys = geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo")[0] || {}).coordinateSystem : null;
    return coordSys === this ? coordSys[methodName](value) : null;
  }
  var _default2 = Geo;
  Geo_1 = _default2;
  return Geo_1;
}
var geoCreator_1;
var hasRequiredGeoCreator;
function requireGeoCreator() {
  if (hasRequiredGeoCreator)
    return geoCreator_1;
  hasRequiredGeoCreator = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var Geo = requireGeo$1();
  var layout2 = layout$1;
  var numberUtil = requireNumber();
  var geoSourceManager2 = requireGeoSourceManager();
  var mapDataStorage$1 = mapDataStorage;
  function resizeGeo(geoModel, api) {
    var boundingCoords = geoModel.get("boundingCoords");
    if (boundingCoords != null) {
      var leftTop = boundingCoords[0];
      var rightBottom = boundingCoords[1];
      if (isNaN(leftTop[0]) || isNaN(leftTop[1]) || isNaN(rightBottom[0]) || isNaN(rightBottom[1]))
        ;
      else {
        this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);
      }
    }
    var rect = this.getBoundingRect();
    var boxLayoutOption;
    var center2 = geoModel.get("layoutCenter");
    var size2 = geoModel.get("layoutSize");
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    var aspect = rect.width / rect.height * this.aspectScale;
    var useCenterAndSize = false;
    if (center2 && size2) {
      center2 = [numberUtil.parsePercent(center2[0], viewWidth), numberUtil.parsePercent(center2[1], viewHeight)];
      size2 = numberUtil.parsePercent(size2, Math.min(viewWidth, viewHeight));
      if (!isNaN(center2[0]) && !isNaN(center2[1]) && !isNaN(size2)) {
        useCenterAndSize = true;
      }
    }
    var viewRect2;
    if (useCenterAndSize) {
      var viewRect2 = {};
      if (aspect > 1) {
        viewRect2.width = size2;
        viewRect2.height = size2 / aspect;
      } else {
        viewRect2.height = size2;
        viewRect2.width = size2 * aspect;
      }
      viewRect2.y = center2[1] - viewRect2.height / 2;
      viewRect2.x = center2[0] - viewRect2.width / 2;
    } else {
      boxLayoutOption = geoModel.getBoxLayoutParams();
      boxLayoutOption.aspect = aspect;
      viewRect2 = layout2.getLayoutRect(boxLayoutOption, {
        width: viewWidth,
        height: viewHeight
      });
    }
    this.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
    this.setCenter(geoModel.get("center"));
    this.setZoom(geoModel.get("zoom"));
  }
  function setGeoCoords(geo2, model2) {
    zrUtil2.each(model2.get("geoCoord"), function(geoCoord2, name2) {
      geo2.addGeoCoord(name2, geoCoord2);
    });
  }
  var geoCreator = {
    // For deciding which dimensions to use when creating list data
    dimensions: Geo.prototype.dimensions,
    create: function(ecModel, api) {
      var geoList = [];
      ecModel.eachComponent("geo", function(geoModel, idx) {
        var name2 = geoModel.get("map");
        var aspectScale = geoModel.get("aspectScale");
        var invertLongitute = true;
        var mapRecords = mapDataStorage$1.retrieveMap(name2);
        if (mapRecords && mapRecords[0] && mapRecords[0].type === "svg") {
          aspectScale == null && (aspectScale = 1);
          invertLongitute = false;
        } else {
          aspectScale == null && (aspectScale = 0.75);
        }
        var geo2 = new Geo(name2 + idx, name2, geoModel.get("nameMap"), invertLongitute);
        geo2.aspectScale = aspectScale;
        geo2.zoomLimit = geoModel.get("scaleLimit");
        geoList.push(geo2);
        setGeoCoords(geo2, geoModel);
        geoModel.coordinateSystem = geo2;
        geo2.model = geoModel;
        geo2.resize = resizeGeo;
        geo2.resize(geoModel, api);
      });
      ecModel.eachSeries(function(seriesModel) {
        var coordSys = seriesModel.get("coordinateSystem");
        if (coordSys === "geo") {
          var geoIndex = seriesModel.get("geoIndex") || 0;
          seriesModel.coordinateSystem = geoList[geoIndex];
        }
      });
      var mapModelGroupBySeries = {};
      ecModel.eachSeriesByType("map", function(seriesModel) {
        if (!seriesModel.getHostGeoModel()) {
          var mapType = seriesModel.getMapType();
          mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
          mapModelGroupBySeries[mapType].push(seriesModel);
        }
      });
      zrUtil2.each(mapModelGroupBySeries, function(mapSeries, mapType) {
        var nameMapList = zrUtil2.map(mapSeries, function(singleMapSeries) {
          return singleMapSeries.get("nameMap");
        });
        var geo2 = new Geo(mapType, mapType, zrUtil2.mergeAll(nameMapList));
        geo2.zoomLimit = zrUtil2.retrieve.apply(null, zrUtil2.map(mapSeries, function(singleMapSeries) {
          return singleMapSeries.get("scaleLimit");
        }));
        geoList.push(geo2);
        geo2.resize = resizeGeo;
        geo2.aspectScale = mapSeries[0].get("aspectScale");
        geo2.resize(mapSeries[0], api);
        zrUtil2.each(mapSeries, function(singleMapSeries) {
          singleMapSeries.coordinateSystem = geo2;
          setGeoCoords(geo2, singleMapSeries);
        });
      });
      return geoList;
    },
    /**
     * Fill given regions array
     * @param  {Array.<Object>} originRegionArr
     * @param  {string} mapName
     * @param  {Object} [nameMap]
     * @return {Array}
     */
    getFilledRegions: function(originRegionArr, mapName, nameMap) {
      var regionsArr = (originRegionArr || []).slice();
      var dataNameMap = zrUtil2.createHashMap();
      for (var i = 0; i < regionsArr.length; i++) {
        dataNameMap.set(regionsArr[i].name, regionsArr[i]);
      }
      var source = geoSourceManager2.load(mapName, nameMap);
      zrUtil2.each(source.regions, function(region) {
        var name2 = region.name;
        !dataNameMap.get(name2) && regionsArr.push({
          name: name2
        });
      });
      return regionsArr;
    }
  };
  echarts$12.registerCoordinateSystem("geo", geoCreator);
  var _default2 = geoCreator;
  geoCreator_1 = _default2;
  return geoCreator_1;
}
var mapSymbolLayout;
var hasRequiredMapSymbolLayout;
function requireMapSymbolLayout() {
  if (hasRequiredMapSymbolLayout)
    return mapSymbolLayout;
  hasRequiredMapSymbolLayout = 1;
  var zrUtil2 = util$6;
  function _default2(ecModel) {
    var processedMapType = {};
    ecModel.eachSeriesByType("map", function(mapSeries) {
      var mapType = mapSeries.getMapType();
      if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
        return;
      }
      var mapSymbolOffsets = {};
      zrUtil2.each(mapSeries.seriesGroup, function(subMapSeries) {
        var geo2 = subMapSeries.coordinateSystem;
        var data2 = subMapSeries.originalData;
        if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
          data2.each(data2.mapDimension("value"), function(value, idx) {
            var name2 = data2.getName(idx);
            var region = geo2.getRegion(name2);
            if (!region || isNaN(value)) {
              return;
            }
            var offset = mapSymbolOffsets[name2] || 0;
            var point = geo2.dataToPoint(region.center);
            mapSymbolOffsets[name2] = offset + 1;
            data2.setItemLayout(idx, {
              point,
              offset
            });
          });
        }
      });
      var data = mapSeries.getData();
      data.each(function(idx) {
        var name2 = data.getName(idx);
        var layout2 = data.getItemLayout(idx) || {};
        layout2.showLabel = !mapSymbolOffsets[name2];
        data.setItemLayout(idx, layout2);
      });
      processedMapType[mapType] = true;
    });
  }
  mapSymbolLayout = _default2;
  return mapSymbolLayout;
}
var mapVisual;
var hasRequiredMapVisual;
function requireMapVisual() {
  if (hasRequiredMapVisual)
    return mapVisual;
  hasRequiredMapVisual = 1;
  function _default2(ecModel) {
    ecModel.eachSeriesByType("map", function(seriesModel) {
      var colorList = seriesModel.get("color");
      var itemStyleModel = seriesModel.getModel("itemStyle");
      var areaColor = itemStyleModel.get("areaColor");
      var color2 = itemStyleModel.get("color") || colorList[seriesModel.seriesIndex % colorList.length];
      seriesModel.getData().setVisual({
        "areaColor": areaColor,
        "color": color2
      });
    });
  }
  mapVisual = _default2;
  return mapVisual;
}
var mapDataStatistic;
var hasRequiredMapDataStatistic;
function requireMapDataStatistic() {
  if (hasRequiredMapDataStatistic)
    return mapDataStatistic;
  hasRequiredMapDataStatistic = 1;
  var zrUtil2 = util$6;
  function dataStatistics(datas, statisticType) {
    var dataNameMap = {};
    zrUtil2.each(datas, function(data) {
      data.each(data.mapDimension("value"), function(value, idx) {
        var mapKey = "ec-" + data.getName(idx);
        dataNameMap[mapKey] = dataNameMap[mapKey] || [];
        if (!isNaN(value)) {
          dataNameMap[mapKey].push(value);
        }
      });
    });
    return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
      var mapKey = "ec-" + datas[0].getName(idx);
      var sum = 0;
      var min3 = Infinity;
      var max3 = -Infinity;
      var len = dataNameMap[mapKey].length;
      for (var i = 0; i < len; i++) {
        min3 = Math.min(min3, dataNameMap[mapKey][i]);
        max3 = Math.max(max3, dataNameMap[mapKey][i]);
        sum += dataNameMap[mapKey][i];
      }
      var result;
      if (statisticType === "min") {
        result = min3;
      } else if (statisticType === "max") {
        result = max3;
      } else if (statisticType === "average") {
        result = sum / len;
      } else {
        result = sum;
      }
      return len === 0 ? NaN : result;
    });
  }
  function _default2(ecModel) {
    var seriesGroups = {};
    ecModel.eachSeriesByType("map", function(seriesModel) {
      var hostGeoModel = seriesModel.getHostGeoModel();
      var key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
      (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
    });
    zrUtil2.each(seriesGroups, function(seriesList, key) {
      var data = dataStatistics(zrUtil2.map(seriesList, function(seriesModel) {
        return seriesModel.getData();
      }), seriesList[0].get("mapValueCalculation"));
      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].originalData = seriesList[i].getData();
      }
      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].seriesGroup = seriesList;
        seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
        seriesList[i].setData(data.cloneShallow());
        seriesList[i].mainSeries = seriesList[0];
      }
    });
  }
  mapDataStatistic = _default2;
  return mapDataStatistic;
}
var backwardCompat;
var hasRequiredBackwardCompat;
function requireBackwardCompat() {
  if (hasRequiredBackwardCompat)
    return backwardCompat;
  hasRequiredBackwardCompat = 1;
  var zrUtil2 = util$6;
  function _default2(option) {
    zrUtil2.each(option.series, function(seriesOpt) {
      if (seriesOpt && seriesOpt.type === "map") {
        seriesOpt.map = seriesOpt.map || seriesOpt.mapType;
        zrUtil2.defaults(seriesOpt, seriesOpt.mapLocation);
      }
    });
  }
  backwardCompat = _default2;
  return backwardCompat;
}
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return map;
  hasRequiredMap = 1;
  var echarts$12 = echarts;
  requireMapSeries();
  requireMapView();
  requireGeoRoam();
  requireGeoCreator();
  var mapSymbolLayout2 = requireMapSymbolLayout();
  var mapVisual2 = requireMapVisual();
  var mapDataStatistic2 = requireMapDataStatistic();
  var backwardCompat2 = requireBackwardCompat();
  var createDataSelectAction2 = requireCreateDataSelectAction();
  echarts$12.registerLayout(mapSymbolLayout2);
  echarts$12.registerVisual(mapVisual2);
  echarts$12.registerProcessor(echarts$12.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic2);
  echarts$12.registerPreprocessor(backwardCompat2);
  createDataSelectAction2("map", [{
    type: "mapToggleSelect",
    event: "mapselectchanged",
    method: "toggleSelected"
  }, {
    type: "mapSelect",
    event: "mapselected",
    method: "select"
  }, {
    type: "mapUnSelect",
    event: "mapunselected",
    method: "unSelect"
  }]);
  return map;
}
var tree = {};
var linkList_1;
var hasRequiredLinkList;
function requireLinkList() {
  if (hasRequiredLinkList)
    return linkList_1;
  hasRequiredLinkList = 1;
  var zrUtil2 = util$6;
  var each2 = zrUtil2.each;
  var DATAS = "\0__link_datas";
  var MAIN_DATA = "\0__link_mainData";
  function linkList(opt) {
    var mainData = opt.mainData;
    var datas = opt.datas;
    if (!datas) {
      datas = {
        main: mainData
      };
      opt.datasAttr = {
        main: "data"
      };
    }
    opt.datas = opt.mainData = null;
    linkAll(mainData, datas, opt);
    each2(datas, function(data) {
      each2(mainData.TRANSFERABLE_METHODS, function(methodName) {
        data.wrapMethod(methodName, zrUtil2.curry(transferInjection, opt));
      });
    });
    mainData.wrapMethod("cloneShallow", zrUtil2.curry(cloneShallowInjection, opt));
    each2(mainData.CHANGABLE_METHODS, function(methodName) {
      mainData.wrapMethod(methodName, zrUtil2.curry(changeInjection, opt));
    });
    zrUtil2.assert(datas[mainData.dataType] === mainData);
  }
  function transferInjection(opt, res) {
    if (isMainData(this)) {
      var datas = zrUtil2.extend({}, this[DATAS]);
      datas[this.dataType] = res;
      linkAll(res, datas, opt);
    } else {
      linkSingle(res, this.dataType, this[MAIN_DATA], opt);
    }
    return res;
  }
  function changeInjection(opt, res) {
    opt.struct && opt.struct.update(this);
    return res;
  }
  function cloneShallowInjection(opt, res) {
    each2(res[DATAS], function(data, dataType) {
      data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
    });
    return res;
  }
  function getLinkedData(dataType) {
    var mainData = this[MAIN_DATA];
    return dataType == null || mainData == null ? mainData : mainData[DATAS][dataType];
  }
  function isMainData(data) {
    return data[MAIN_DATA] === data;
  }
  function linkAll(mainData, datas, opt) {
    mainData[DATAS] = {};
    each2(datas, function(data, dataType) {
      linkSingle(data, dataType, mainData, opt);
    });
  }
  function linkSingle(data, dataType, mainData, opt) {
    mainData[DATAS][dataType] = data;
    data[MAIN_DATA] = mainData;
    data.dataType = dataType;
    if (opt.struct) {
      data[opt.structAttr] = opt.struct;
      opt.struct[opt.datasAttr[dataType]] = data;
    }
    data.getLinkedData = getLinkedData;
  }
  var _default2 = linkList;
  linkList_1 = _default2;
  return linkList_1;
}
var Tree_1;
var hasRequiredTree$1;
function requireTree$1() {
  if (hasRequiredTree$1)
    return Tree_1;
  hasRequiredTree$1 = 1;
  var zrUtil2 = util$6;
  var linkList = requireLinkList();
  var List = requireList();
  var createDimensions2 = requireCreateDimensions();
  var TreeNode = function(name2, hostTree) {
    this.name = name2 || "";
    this.depth = 0;
    this.height = 0;
    this.parentNode = null;
    this.dataIndex = -1;
    this.children = [];
    this.viewChildren = [];
    this.hostTree = hostTree;
  };
  TreeNode.prototype = {
    constructor: TreeNode,
    /**
     * The node is removed.
     * @return {boolean} is removed.
     */
    isRemoved: function() {
      return this.dataIndex < 0;
    },
    /**
     * Travel this subtree (include this node).
     * Usage:
     *    node.eachNode(function () { ... }); // preorder
     *    node.eachNode('preorder', function () { ... }); // preorder
     *    node.eachNode('postorder', function () { ... }); // postorder
     *    node.eachNode(
     *        {order: 'postorder', attr: 'viewChildren'},
     *        function () { ... }
     *    ); // postorder
     *
     * @param {(Object|string)} options If string, means order.
     * @param {string=} options.order 'preorder' or 'postorder'
     * @param {string=} options.attr 'children' or 'viewChildren'
     * @param {Function} cb If in preorder and return false,
     *                      its subtree will not be visited.
     * @param {Object} [context]
     */
    eachNode: function(options, cb, context) {
      if (typeof options === "function") {
        context = cb;
        cb = options;
        options = null;
      }
      options = options || {};
      if (zrUtil2.isString(options)) {
        options = {
          order: options
        };
      }
      var order = options.order || "preorder";
      var children = this[options.attr || "children"];
      var suppressVisitSub;
      order === "preorder" && (suppressVisitSub = cb.call(context, this));
      for (var i = 0; !suppressVisitSub && i < children.length; i++) {
        children[i].eachNode(options, cb, context);
      }
      order === "postorder" && cb.call(context, this);
    },
    /**
     * Update depth and height of this subtree.
     *
     * @param  {number} depth
     */
    updateDepthAndHeight: function(depth) {
      var height = 0;
      this.depth = depth;
      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.updateDepthAndHeight(depth + 1);
        if (child.height > height) {
          height = child.height;
        }
      }
      this.height = height + 1;
    },
    /**
     * @param  {string} id
     * @return {module:echarts/data/Tree~TreeNode}
     */
    getNodeById: function(id) {
      if (this.getId() === id) {
        return this;
      }
      for (var i = 0, children = this.children, len = children.length; i < len; i++) {
        var res = children[i].getNodeById(id);
        if (res) {
          return res;
        }
      }
    },
    /**
     * @param {module:echarts/data/Tree~TreeNode} node
     * @return {boolean}
     */
    contains: function(node) {
      if (node === this) {
        return true;
      }
      for (var i = 0, children = this.children, len = children.length; i < len; i++) {
        var res = children[i].contains(node);
        if (res) {
          return res;
        }
      }
    },
    /**
     * @param {boolean} includeSelf Default false.
     * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]
     */
    getAncestors: function(includeSelf) {
      var ancestors = [];
      var node = includeSelf ? this : this.parentNode;
      while (node) {
        ancestors.push(node);
        node = node.parentNode;
      }
      ancestors.reverse();
      return ancestors;
    },
    /**
     * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3
     * @return {number} Value.
     */
    getValue: function(dimension) {
      var data = this.hostTree.data;
      return data.get(data.getDimension(dimension || "value"), this.dataIndex);
    },
    /**
     * @param {Object} layout
     * @param {boolean=} [merge=false]
     */
    setLayout: function(layout2, merge2) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout2, merge2);
    },
    /**
     * @return {Object} layout
     */
    getLayout: function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    },
    /**
     * @param {string} [path]
     * @return {module:echarts/model/Model}
     */
    getModel: function(path2) {
      if (this.dataIndex < 0) {
        return;
      }
      var hostTree = this.hostTree;
      var itemModel = hostTree.data.getItemModel(this.dataIndex);
      return itemModel.getModel(path2);
    },
    /**
     * @example
     *  setItemVisual('color', color);
     *  setItemVisual({
     *      'color': color
     *  });
     */
    setVisual: function(key, value) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
    },
    /**
     * Get item visual
     */
    getVisual: function(key, ignoreParent) {
      return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
    },
    /**
     * @public
     * @return {number}
     */
    getRawIndex: function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    },
    /**
     * @public
     * @return {string}
     */
    getId: function() {
      return this.hostTree.data.getId(this.dataIndex);
    },
    /**
     * if this is an ancestor of another node
     *
     * @public
     * @param {TreeNode} node another node
     * @return {boolean} if is ancestor
     */
    isAncestorOf: function(node) {
      var parent = node.parentNode;
      while (parent) {
        if (parent === this) {
          return true;
        }
        parent = parent.parentNode;
      }
      return false;
    },
    /**
     * if this is an descendant of another node
     *
     * @public
     * @param {TreeNode} node another node
     * @return {boolean} if is descendant
     */
    isDescendantOf: function(node) {
      return node !== this && node.isAncestorOf(this);
    }
  };
  function Tree(hostModel) {
    this.root;
    this.data;
    this._nodes = [];
    this.hostModel = hostModel;
  }
  Tree.prototype = {
    constructor: Tree,
    type: "tree",
    /**
     * Travel this subtree (include this node).
     * Usage:
     *    node.eachNode(function () { ... }); // preorder
     *    node.eachNode('preorder', function () { ... }); // preorder
     *    node.eachNode('postorder', function () { ... }); // postorder
     *    node.eachNode(
     *        {order: 'postorder', attr: 'viewChildren'},
     *        function () { ... }
     *    ); // postorder
     *
     * @param {(Object|string)} options If string, means order.
     * @param {string=} options.order 'preorder' or 'postorder'
     * @param {string=} options.attr 'children' or 'viewChildren'
     * @param {Function} cb
     * @param {Object}   [context]
     */
    eachNode: function(options, cb, context) {
      this.root.eachNode(options, cb, context);
    },
    /**
     * @param {number} dataIndex
     * @return {module:echarts/data/Tree~TreeNode}
     */
    getNodeByDataIndex: function(dataIndex) {
      var rawIndex = this.data.getRawIndex(dataIndex);
      return this._nodes[rawIndex];
    },
    /**
     * @param {string} name
     * @return {module:echarts/data/Tree~TreeNode}
     */
    getNodeByName: function(name2) {
      return this.root.getNodeByName(name2);
    },
    /**
     * Update item available by list,
     * when list has been performed options like 'filterSelf' or 'map'.
     */
    update: function() {
      var data = this.data;
      var nodes = this._nodes;
      for (var i = 0, len = nodes.length; i < len; i++) {
        nodes[i].dataIndex = -1;
      }
      for (var i = 0, len = data.count(); i < len; i++) {
        nodes[data.getRawIndex(i)].dataIndex = i;
      }
    },
    /**
     * Clear all layouts
     */
    clearLayouts: function() {
      this.data.clearItemLayouts();
    }
  };
  Tree.createTree = function(dataRoot, hostModel, beforeLink) {
    var tree2 = new Tree(hostModel);
    var listData = [];
    var dimMax = 1;
    buildHierarchy(dataRoot);
    function buildHierarchy(dataNode, parentNode) {
      var value = dataNode.value;
      dimMax = Math.max(dimMax, zrUtil2.isArray(value) ? value.length : 1);
      listData.push(dataNode);
      var node = new TreeNode(dataNode.name, tree2);
      parentNode ? addChild(node, parentNode) : tree2.root = node;
      tree2._nodes.push(node);
      var children = dataNode.children;
      if (children) {
        for (var i = 0; i < children.length; i++) {
          buildHierarchy(children[i], node);
        }
      }
    }
    tree2.root.updateDepthAndHeight(0);
    var dimensionsInfo = createDimensions2(listData, {
      coordDimensions: ["value"],
      dimensionsCount: dimMax
    });
    var list = new List(dimensionsInfo, hostModel);
    list.initData(listData);
    beforeLink && beforeLink(list);
    linkList({
      mainData: list,
      struct: tree2,
      structAttr: "tree"
    });
    tree2.update();
    return tree2;
  };
  function addChild(child, node) {
    var children = node.children;
    if (child.parentNode === node) {
      return;
    }
    children.push(child);
    child.parentNode = node;
  }
  var _default2 = Tree;
  Tree_1 = _default2;
  return Tree_1;
}
var TreeSeries;
var hasRequiredTreeSeries;
function requireTreeSeries() {
  if (hasRequiredTreeSeries)
    return TreeSeries;
  hasRequiredTreeSeries = 1;
  var SeriesModel2 = Series;
  var Tree = requireTree$1();
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var Model2 = requireModel();
  var _default2 = SeriesModel2.extend({
    type: "series.tree",
    layoutInfo: null,
    // can support the position parameters 'left', 'top','right','bottom', 'width',
    // 'height' in the setOption() with 'merge' mode normal.
    layoutMode: "box",
    /**
     * Init a tree data structure from data in option series
     * @param  {Object} option  the object used to config echarts view
     * @return {module:echarts/data/List} storage initial data
     */
    getInitialData: function(option) {
      var root = {
        name: option.name,
        children: option.data
      };
      var leaves = option.leaves || {};
      var leavesModel = new Model2(leaves, this, this.ecModel);
      var tree2 = Tree.createTree(root, this, beforeLink);
      function beforeLink(nodeData) {
        nodeData.wrapMethod("getItemModel", function(model2, idx) {
          var node = tree2.getNodeByDataIndex(idx);
          if (!node.children.length || !node.isExpand) {
            model2.parentModel = leavesModel;
          }
          return model2;
        });
      }
      var treeDepth = 0;
      tree2.eachNode("preorder", function(node) {
        if (node.depth > treeDepth) {
          treeDepth = node.depth;
        }
      });
      var expandAndCollapse = option.expandAndCollapse;
      var expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
      tree2.root.eachNode("preorder", function(node) {
        var item = node.hostTree.data.getRawDataItem(node.dataIndex);
        node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
      });
      return tree2.data;
    },
    /**
     * Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.
     * @returns {string} orient
     */
    getOrient: function() {
      var orient = this.get("orient");
      if (orient === "horizontal") {
        orient = "LR";
      } else if (orient === "vertical") {
        orient = "TB";
      }
      return orient;
    },
    setZoom: function(zoom) {
      this.option.zoom = zoom;
    },
    setCenter: function(center2) {
      this.option.center = center2;
    },
    /**
     * @override
     * @param {number} dataIndex
     */
    formatTooltip: function(dataIndex) {
      var tree2 = this.getData().tree;
      var realRoot = tree2.root.children[0];
      var node = tree2.getNodeByDataIndex(dataIndex);
      var value = node.getValue();
      var name2 = node.name;
      while (node && node !== realRoot) {
        name2 = node.parentNode.name + "." + name2;
        node = node.parentNode;
      }
      return encodeHTML2(name2 + (isNaN(value) || value == null ? "" : " : " + value));
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: false,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      // The orient of orthoginal layout, can be setted to 'LR', 'TB', 'RL', 'BT'.
      // and the backward compatibility configuration 'horizontal = LR', 'vertical = TB'.
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: true,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        borderColor: "#c23531",
        borderWidth: 1.5
      },
      label: {
        show: true,
        color: "#555"
      },
      leaves: {
        label: {
          show: true
        }
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 1e3
    }
  });
  TreeSeries = _default2;
  return TreeSeries;
}
var layoutHelper = {};
var hasRequiredLayoutHelper;
function requireLayoutHelper() {
  if (hasRequiredLayoutHelper)
    return layoutHelper;
  hasRequiredLayoutHelper = 1;
  var layout2 = layout$1;
  function init2(root) {
    root.hierNode = {
      defaultAncestor: null,
      ancestor: root,
      prelim: 0,
      modifier: 0,
      change: 0,
      shift: 0,
      i: 0,
      thread: null
    };
    var nodes = [root];
    var node;
    var children;
    while (node = nodes.pop()) {
      children = node.children;
      if (node.isExpand && children.length) {
        var n = children.length;
        for (var i = n - 1; i >= 0; i--) {
          var child = children[i];
          child.hierNode = {
            defaultAncestor: null,
            ancestor: child,
            prelim: 0,
            modifier: 0,
            change: 0,
            shift: 0,
            i,
            thread: null
          };
          nodes.push(child);
        }
      }
    }
  }
  function firstWalk(node, separation2) {
    var children = node.isExpand ? node.children : [];
    var siblings = node.parentNode.children;
    var subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
    if (children.length) {
      executeShifts(node);
      var midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
      if (subtreeW) {
        node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
        node.hierNode.modifier = node.hierNode.prelim - midPoint;
      } else {
        node.hierNode.prelim = midPoint;
      }
    } else if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
    }
    node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
  }
  function secondWalk(node) {
    var nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
    node.setLayout({
      x: nodeX
    }, true);
    node.hierNode.modifier += node.parentNode.hierNode.modifier;
  }
  function separation(cb) {
    return arguments.length ? cb : defaultSeparation;
  }
  function radialCoordinate(x, y) {
    var radialCoor = {};
    x -= Math.PI / 2;
    radialCoor.x = y * Math.cos(x);
    radialCoor.y = y * Math.sin(x);
    return radialCoor;
  }
  function getViewRect(seriesModel, api) {
    return layout2.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function executeShifts(node) {
    var children = node.children;
    var n = children.length;
    var shift = 0;
    var change = 0;
    while (--n >= 0) {
      var child = children[n];
      child.hierNode.prelim += shift;
      child.hierNode.modifier += shift;
      change += child.hierNode.change;
      shift += child.hierNode.shift + change;
    }
  }
  function apportion(subtreeV, subtreeW, ancestor, separation2) {
    if (subtreeW) {
      var nodeOutRight = subtreeV;
      var nodeInRight = subtreeV;
      var nodeOutLeft = nodeInRight.parentNode.children[0];
      var nodeInLeft = subtreeW;
      var sumOutRight = nodeOutRight.hierNode.modifier;
      var sumInRight = nodeInRight.hierNode.modifier;
      var sumOutLeft = nodeOutLeft.hierNode.modifier;
      var sumInLeft = nodeInLeft.hierNode.modifier;
      while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
        nodeOutRight = nextRight(nodeOutRight);
        nodeOutLeft = nextLeft(nodeOutLeft);
        nodeOutRight.hierNode.ancestor = subtreeV;
        var shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
        if (shift > 0) {
          moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
          sumInRight += shift;
          sumOutRight += shift;
        }
        sumInLeft += nodeInLeft.hierNode.modifier;
        sumInRight += nodeInRight.hierNode.modifier;
        sumOutRight += nodeOutRight.hierNode.modifier;
        sumOutLeft += nodeOutLeft.hierNode.modifier;
      }
      if (nodeInLeft && !nextRight(nodeOutRight)) {
        nodeOutRight.hierNode.thread = nodeInLeft;
        nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
      }
      if (nodeInRight && !nextLeft(nodeOutLeft)) {
        nodeOutLeft.hierNode.thread = nodeInRight;
        nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
        ancestor = subtreeV;
      }
    }
    return ancestor;
  }
  function nextRight(node) {
    var children = node.children;
    return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
  }
  function nextLeft(node) {
    var children = node.children;
    return children.length && node.isExpand ? children[0] : node.hierNode.thread;
  }
  function nextAncestor(nodeInLeft, node, ancestor) {
    return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
  }
  function moveSubtree(wl, wr, shift) {
    var change = shift / (wr.hierNode.i - wl.hierNode.i);
    wr.hierNode.change -= change;
    wr.hierNode.shift += shift;
    wr.hierNode.modifier += shift;
    wr.hierNode.prelim += shift;
    wl.hierNode.change += change;
  }
  function defaultSeparation(node1, node2) {
    return node1.parentNode === node2.parentNode ? 1 : 2;
  }
  layoutHelper.init = init2;
  layoutHelper.firstWalk = firstWalk;
  layoutHelper.secondWalk = secondWalk;
  layoutHelper.separation = separation;
  layoutHelper.radialCoordinate = radialCoordinate;
  layoutHelper.getViewRect = getViewRect;
  return layoutHelper;
}
var TreeView;
var hasRequiredTreeView;
function requireTreeView() {
  if (hasRequiredTreeView)
    return TreeView;
  hasRequiredTreeView = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var SymbolClz = require_Symbol();
  var _layoutHelper = requireLayoutHelper();
  var radialCoordinate = _layoutHelper.radialCoordinate;
  var echarts$12 = echarts;
  var bbox2 = requireBbox();
  var View = requireView();
  var roamHelper2 = requireRoamHelper$1();
  var RoamController = requireRoamController();
  var _cursorHelper = requireCursorHelper();
  var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var TreeShape = graphic2.extendShape({
    shape: {
      parentPoint: [],
      childPoints: [],
      orient: "",
      forkPosition: ""
    },
    style: {
      stroke: "#000",
      fill: null
    },
    buildPath: function(ctx, shape) {
      var childPoints = shape.childPoints;
      var childLen = childPoints.length;
      var parentPoint = shape.parentPoint;
      var firstChildPos = childPoints[0];
      var lastChildPos = childPoints[childLen - 1];
      if (childLen === 1) {
        ctx.moveTo(parentPoint[0], parentPoint[1]);
        ctx.lineTo(firstChildPos[0], firstChildPos[1]);
        return;
      }
      var orient = shape.orient;
      var forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
      var otherDim = 1 - forkDim;
      var forkPosition = parsePercent2(shape.forkPosition, 1);
      var tmpPoint = [];
      tmpPoint[forkDim] = parentPoint[forkDim];
      tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
      ctx.moveTo(parentPoint[0], parentPoint[1]);
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      ctx.moveTo(firstChildPos[0], firstChildPos[1]);
      tmpPoint[forkDim] = firstChildPos[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      tmpPoint[forkDim] = lastChildPos[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      ctx.lineTo(lastChildPos[0], lastChildPos[1]);
      for (var i = 1; i < childLen - 1; i++) {
        var point = childPoints[i];
        ctx.moveTo(point[0], point[1]);
        tmpPoint[forkDim] = point[forkDim];
        ctx.lineTo(tmpPoint[0], tmpPoint[1]);
      }
    }
  });
  var _default2 = echarts$12.extendChartView({
    type: "tree",
    /**
     * Init the chart
     * @override
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */
    init: function(ecModel, api) {
      this._oldTree;
      this._mainGroup = new graphic2.Group();
      this._controller = new RoamController(api.getZr());
      this._controllerHost = {
        target: this.group
      };
      this.group.add(this._mainGroup);
    },
    render: function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var layoutInfo = seriesModel.layoutInfo;
      var group = this._mainGroup;
      var layout2 = seriesModel.get("layout");
      if (layout2 === "radial") {
        group.attr("position", [layoutInfo.x + layoutInfo.width / 2, layoutInfo.y + layoutInfo.height / 2]);
      } else {
        group.attr("position", [layoutInfo.x, layoutInfo.y]);
      }
      this._updateViewCoordSys(seriesModel, layoutInfo, layout2);
      this._updateController(seriesModel, ecModel, api);
      var oldData = this._data;
      var seriesScope = {
        expandAndCollapse: seriesModel.get("expandAndCollapse"),
        layout: layout2,
        edgeShape: seriesModel.get("edgeShape"),
        edgeForkPosition: seriesModel.get("edgeForkPosition"),
        orient: seriesModel.getOrient(),
        curvature: seriesModel.get("lineStyle.curveness"),
        symbolRotate: seriesModel.get("symbolRotate"),
        symbolOffset: seriesModel.get("symbolOffset"),
        hoverAnimation: seriesModel.get("hoverAnimation"),
        useNameLabel: true,
        fadeIn: true
      };
      data.diff(oldData).add(function(newIdx) {
        if (symbolNeedsDraw(data, newIdx)) {
          updateNode(data, newIdx, null, group, seriesModel, seriesScope);
        }
      }).update(function(newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        if (!symbolNeedsDraw(data, newIdx)) {
          symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
          return;
        }
        updateNode(data, newIdx, symbolEl, group, seriesModel, seriesScope);
      }).remove(function(oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        if (symbolEl) {
          removeNode(oldData, oldIdx, symbolEl, group, seriesModel, seriesScope);
        }
      }).execute();
      this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
      this._updateNodeAndLinkScale(seriesModel);
      if (seriesScope.expandAndCollapse === true) {
        data.eachItemGraphicEl(function(el, dataIndex) {
          el.off("click").on("click", function() {
            api.dispatchAction({
              type: "treeExpandAndCollapse",
              seriesId: seriesModel.id,
              dataIndex
            });
          });
        });
      }
      this._data = data;
    },
    _updateViewCoordSys: function(seriesModel) {
      var data = seriesModel.getData();
      var points2 = [];
      data.each(function(idx) {
        var layout2 = data.getItemLayout(idx);
        if (layout2 && !isNaN(layout2.x) && !isNaN(layout2.y)) {
          points2.push([+layout2.x, +layout2.y]);
        }
      });
      var min3 = [];
      var max3 = [];
      bbox2.fromPoints(points2, min3, max3);
      var oldMin = this._min;
      var oldMax = this._max;
      if (max3[0] - min3[0] === 0) {
        min3[0] = oldMin ? oldMin[0] : min3[0] - 1;
        max3[0] = oldMax ? oldMax[0] : max3[0] + 1;
      }
      if (max3[1] - min3[1] === 0) {
        min3[1] = oldMin ? oldMin[1] : min3[1] - 1;
        max3[1] = oldMax ? oldMax[1] : max3[1] + 1;
      }
      var viewCoordSys = seriesModel.coordinateSystem = new View();
      viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
      viewCoordSys.setBoundingRect(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
      viewCoordSys.setCenter(seriesModel.get("center"));
      viewCoordSys.setZoom(seriesModel.get("zoom"));
      this.group.attr({
        position: viewCoordSys.position,
        scale: viewCoordSys.scale
      });
      this._viewCoordSys = viewCoordSys;
      this._min = min3;
      this._max = max3;
    },
    _updateController: function(seriesModel, ecModel, api) {
      var controller = this._controller;
      var controllerHost = this._controllerHost;
      var group = this.group;
      controller.setPointerChecker(function(e2, x, y) {
        var rect = group.getBoundingRect();
        rect.applyTransform(group.transform);
        return rect.contain(x, y) && !onIrrelevantElement(e2, api, seriesModel);
      });
      controller.enable(seriesModel.get("roam"));
      controllerHost.zoomLimit = seriesModel.get("scaleLimit");
      controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
      controller.off("pan").off("zoom").on("pan", function(e2) {
        roamHelper2.updateViewOnPan(controllerHost, e2.dx, e2.dy);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "treeRoam",
          dx: e2.dx,
          dy: e2.dy
        });
      }, this).on("zoom", function(e2) {
        roamHelper2.updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "treeRoam",
          zoom: e2.scale,
          originX: e2.originX,
          originY: e2.originY
        });
        this._updateNodeAndLinkScale(seriesModel);
      }, this);
    },
    _updateNodeAndLinkScale: function(seriesModel) {
      var data = seriesModel.getData();
      var nodeScale = this._getNodeGlobalScale(seriesModel);
      var invScale = [nodeScale, nodeScale];
      data.eachItemGraphicEl(function(el, idx) {
        el.attr("scale", invScale);
      });
    },
    _getNodeGlobalScale: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type !== "view") {
        return 1;
      }
      var nodeScaleRatio = this._nodeScaleRatio;
      var groupScale = coordSys.scale;
      var groupZoom = groupScale && groupScale[0] || 1;
      var roamZoom = coordSys.getZoom();
      var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
      return nodeScale / groupZoom;
    },
    dispose: function() {
      this._controller && this._controller.dispose();
      this._controllerHost = {};
    },
    remove: function() {
      this._mainGroup.removeAll();
      this._data = null;
    }
  });
  function symbolNeedsDraw(data, dataIndex) {
    var layout2 = data.getItemLayout(dataIndex);
    return layout2 && !isNaN(layout2.x) && !isNaN(layout2.y) && data.getItemVisual(dataIndex, "symbol") !== "none";
  }
  function getTreeNodeStyle(node, itemModel, seriesScope) {
    seriesScope.itemModel = itemModel;
    seriesScope.itemStyle = itemModel.getModel("itemStyle").getItemStyle();
    seriesScope.hoverItemStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
    seriesScope.lineStyle = itemModel.getModel("lineStyle").getLineStyle();
    seriesScope.labelModel = itemModel.getModel("label");
    seriesScope.hoverLabelModel = itemModel.getModel("emphasis.label");
    if (node.isExpand === false && node.children.length !== 0) {
      seriesScope.symbolInnerColor = seriesScope.itemStyle.fill;
    } else {
      seriesScope.symbolInnerColor = "#fff";
    }
    return seriesScope;
  }
  function updateNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
    var isInit = !symbolEl;
    var node = data.tree.getNodeByDataIndex(dataIndex);
    var itemModel = node.getModel();
    var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
    var virtualRoot = data.tree.root;
    var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
    var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
    var sourceLayout = source.getLayout();
    var sourceOldLayout = sourceSymbolEl ? {
      x: sourceSymbolEl.position[0],
      y: sourceSymbolEl.position[1],
      rawX: sourceSymbolEl.__radialOldRawX,
      rawY: sourceSymbolEl.__radialOldRawY
    } : sourceLayout;
    var targetLayout = node.getLayout();
    if (isInit) {
      symbolEl = new SymbolClz(data, dataIndex, seriesScope);
      symbolEl.attr("position", [sourceOldLayout.x, sourceOldLayout.y]);
    } else {
      symbolEl.updateData(data, dataIndex, seriesScope);
    }
    symbolEl.__radialOldRawX = symbolEl.__radialRawX;
    symbolEl.__radialOldRawY = symbolEl.__radialRawY;
    symbolEl.__radialRawX = targetLayout.rawX;
    symbolEl.__radialRawY = targetLayout.rawY;
    group.add(symbolEl);
    data.setItemGraphicEl(dataIndex, symbolEl);
    graphic2.updateProps(symbolEl, {
      position: [targetLayout.x, targetLayout.y]
    }, seriesModel);
    var symbolPath = symbolEl.getSymbolPath();
    if (seriesScope.layout === "radial") {
      var realRoot = virtualRoot.children[0];
      var rootLayout = realRoot.getLayout();
      var length = realRoot.children.length;
      var rad;
      var isLeft;
      if (targetLayout.x === rootLayout.x && node.isExpand === true) {
        var center2 = {};
        center2.x = (realRoot.children[0].getLayout().x + realRoot.children[length - 1].getLayout().x) / 2;
        center2.y = (realRoot.children[0].getLayout().y + realRoot.children[length - 1].getLayout().y) / 2;
        rad = Math.atan2(center2.y - rootLayout.y, center2.x - rootLayout.x);
        if (rad < 0) {
          rad = Math.PI * 2 + rad;
        }
        isLeft = center2.x < rootLayout.x;
        if (isLeft) {
          rad = rad - Math.PI;
        }
      } else {
        rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
        if (rad < 0) {
          rad = Math.PI * 2 + rad;
        }
        if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
          isLeft = targetLayout.x < rootLayout.x;
          if (isLeft) {
            rad = rad - Math.PI;
          }
        } else {
          isLeft = targetLayout.x > rootLayout.x;
          if (!isLeft) {
            rad = rad - Math.PI;
          }
        }
      }
      var textPosition = isLeft ? "left" : "right";
      var rotate = seriesScope.labelModel.get("rotate");
      var labelRotateRadian = rotate * (Math.PI / 180);
      symbolPath.setStyle({
        textPosition: seriesScope.labelModel.get("position") || textPosition,
        textRotation: rotate == null ? -rad : labelRotateRadian,
        textOrigin: "center",
        verticalAlign: "middle"
      });
    }
    drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope);
  }
  function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group, seriesScope) {
    var edgeShape = seriesScope.edgeShape;
    var edge = symbolEl.__edge;
    if (edgeShape === "curve") {
      if (node.parentNode && node.parentNode !== virtualRoot) {
        if (!edge) {
          edge = symbolEl.__edge = new graphic2.BezierCurve({
            shape: getEdgeShape(seriesScope, sourceOldLayout, sourceOldLayout),
            style: zrUtil2.defaults({
              opacity: 0,
              strokeNoScale: true
            }, seriesScope.lineStyle)
          });
        }
        graphic2.updateProps(edge, {
          shape: getEdgeShape(seriesScope, sourceLayout, targetLayout),
          style: zrUtil2.defaults({
            opacity: 1
          }, seriesScope.lineStyle)
        }, seriesModel);
      }
    } else if (edgeShape === "polyline") {
      if (seriesScope.layout === "orthogonal") {
        if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
          var children = node.children;
          var childPoints = [];
          for (var i = 0; i < children.length; i++) {
            var childLayout = children[i].getLayout();
            childPoints.push([childLayout.x, childLayout.y]);
          }
          if (!edge) {
            edge = symbolEl.__edge = new TreeShape({
              shape: {
                parentPoint: [targetLayout.x, targetLayout.y],
                childPoints: [[targetLayout.x, targetLayout.y]],
                orient: seriesScope.orient,
                forkPosition: seriesScope.edgeForkPosition
              },
              style: zrUtil2.defaults({
                opacity: 0,
                strokeNoScale: true
              }, seriesScope.lineStyle)
            });
          }
          graphic2.updateProps(edge, {
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints
            },
            style: zrUtil2.defaults({
              opacity: 1
            }, seriesScope.lineStyle)
          }, seriesModel);
        }
      }
    }
    group.add(edge);
  }
  function removeNode(data, dataIndex, symbolEl, group, seriesModel, seriesScope) {
    var node = data.tree.getNodeByDataIndex(dataIndex);
    var virtualRoot = data.tree.root;
    var itemModel = node.getModel();
    var seriesScope = getTreeNodeStyle(node, itemModel, seriesScope);
    var source = node.parentNode === virtualRoot ? node : node.parentNode || node;
    var edgeShape = seriesScope.edgeShape;
    var sourceLayout;
    while (sourceLayout = source.getLayout(), sourceLayout == null) {
      source = source.parentNode === virtualRoot ? source : source.parentNode || source;
    }
    graphic2.updateProps(symbolEl, {
      position: [sourceLayout.x + 1, sourceLayout.y + 1]
    }, seriesModel, function() {
      group.remove(symbolEl);
      data.setItemGraphicEl(dataIndex, null);
    });
    symbolEl.fadeOut(null, {
      keepLabel: true
    });
    var sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
    var sourceEdge = sourceSymbolEl.__edge;
    var edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
    var edgeShape = seriesScope.edgeShape;
    if (edge) {
      if (edgeShape === "curve") {
        graphic2.updateProps(edge, {
          shape: getEdgeShape(seriesScope, sourceLayout, sourceLayout),
          style: {
            opacity: 0
          }
        }, seriesModel, function() {
          group.remove(edge);
        });
      } else if (edgeShape === "polyline" && seriesScope.layout === "orthogonal") {
        graphic2.updateProps(edge, {
          shape: {
            parentPoint: [sourceLayout.x, sourceLayout.y],
            childPoints: [[sourceLayout.x, sourceLayout.y]]
          },
          style: {
            opacity: 0
          }
        }, seriesModel, function() {
          group.remove(edge);
        });
      }
    }
  }
  function getEdgeShape(seriesScope, sourceLayout, targetLayout) {
    var cpx1;
    var cpy1;
    var cpx2;
    var cpy2;
    var orient = seriesScope.orient;
    var x1;
    var x2;
    var y1;
    var y2;
    if (seriesScope.layout === "radial") {
      x1 = sourceLayout.rawX;
      y1 = sourceLayout.rawY;
      x2 = targetLayout.rawX;
      y2 = targetLayout.rawY;
      var radialCoor1 = radialCoordinate(x1, y1);
      var radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * seriesScope.curvature);
      var radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * seriesScope.curvature);
      var radialCoor4 = radialCoordinate(x2, y2);
      return {
        x1: radialCoor1.x,
        y1: radialCoor1.y,
        x2: radialCoor4.x,
        y2: radialCoor4.y,
        cpx1: radialCoor2.x,
        cpy1: radialCoor2.y,
        cpx2: radialCoor3.x,
        cpy2: radialCoor3.y
      };
    } else {
      x1 = sourceLayout.x;
      y1 = sourceLayout.y;
      x2 = targetLayout.x;
      y2 = targetLayout.y;
      if (orient === "LR" || orient === "RL") {
        cpx1 = x1 + (x2 - x1) * seriesScope.curvature;
        cpy1 = y1;
        cpx2 = x2 + (x1 - x2) * seriesScope.curvature;
        cpy2 = y2;
      }
      if (orient === "TB" || orient === "BT") {
        cpx1 = x1;
        cpy1 = y1 + (y2 - y1) * seriesScope.curvature;
        cpx2 = x2;
        cpy2 = y2 + (y1 - y2) * seriesScope.curvature;
      }
    }
    return {
      x1,
      y1,
      x2,
      y2,
      cpx1,
      cpy1,
      cpx2,
      cpy2
    };
  }
  TreeView = _default2;
  return TreeView;
}
var treeAction = {};
var hasRequiredTreeAction;
function requireTreeAction() {
  if (hasRequiredTreeAction)
    return treeAction;
  hasRequiredTreeAction = 1;
  var echarts$12 = echarts;
  var _roamHelper = requireRoamHelper();
  var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
  echarts$12.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      var dataIndex = payload.dataIndex;
      var tree2 = seriesModel.getData().tree;
      var node = tree2.getNodeByDataIndex(dataIndex);
      node.isExpand = !node.isExpand;
    });
  });
  echarts$12.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = updateCenterAndZoom(coordSys, payload);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
  return treeAction;
}
var traversalHelper = {};
var hasRequiredTraversalHelper;
function requireTraversalHelper() {
  if (hasRequiredTraversalHelper)
    return traversalHelper;
  hasRequiredTraversalHelper = 1;
  function eachAfter(root, callback, separation) {
    var nodes = [root];
    var next = [];
    var node;
    while (node = nodes.pop()) {
      next.push(node);
      if (node.isExpand) {
        var children = node.children;
        if (children.length) {
          for (var i = 0; i < children.length; i++) {
            nodes.push(children[i]);
          }
        }
      }
    }
    while (node = next.pop()) {
      callback(node, separation);
    }
  }
  function eachBefore(root, callback) {
    var nodes = [root];
    var node;
    while (node = nodes.pop()) {
      callback(node);
      if (node.isExpand) {
        var children = node.children;
        if (children.length) {
          for (var i = children.length - 1; i >= 0; i--) {
            nodes.push(children[i]);
          }
        }
      }
    }
  }
  traversalHelper.eachAfter = eachAfter;
  traversalHelper.eachBefore = eachBefore;
  return traversalHelper;
}
var treeLayout;
var hasRequiredTreeLayout;
function requireTreeLayout() {
  if (hasRequiredTreeLayout)
    return treeLayout;
  hasRequiredTreeLayout = 1;
  var _traversalHelper = requireTraversalHelper();
  var eachAfter = _traversalHelper.eachAfter;
  var eachBefore = _traversalHelper.eachBefore;
  var _layoutHelper = requireLayoutHelper();
  var init2 = _layoutHelper.init;
  var firstWalk = _layoutHelper.firstWalk;
  var secondWalk = _layoutHelper.secondWalk;
  var sep = _layoutHelper.separation;
  var radialCoordinate = _layoutHelper.radialCoordinate;
  var getViewRect = _layoutHelper.getViewRect;
  function _default2(ecModel, api) {
    ecModel.eachSeriesByType("tree", function(seriesModel) {
      commonLayout(seriesModel, api);
    });
  }
  function commonLayout(seriesModel, api) {
    var layoutInfo = getViewRect(seriesModel, api);
    seriesModel.layoutInfo = layoutInfo;
    var layout2 = seriesModel.get("layout");
    var width = 0;
    var height = 0;
    var separation = null;
    if (layout2 === "radial") {
      width = 2 * Math.PI;
      height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
      separation = sep(function(node1, node2) {
        return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
      });
    } else {
      width = layoutInfo.width;
      height = layoutInfo.height;
      separation = sep();
    }
    var virtualRoot = seriesModel.getData().tree.root;
    var realRoot = virtualRoot.children[0];
    if (realRoot) {
      init2(virtualRoot);
      eachAfter(realRoot, firstWalk, separation);
      virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
      eachBefore(realRoot, secondWalk);
      var left = realRoot;
      var right = realRoot;
      var bottom = realRoot;
      eachBefore(realRoot, function(node) {
        var x = node.getLayout().x;
        if (x < left.getLayout().x) {
          left = node;
        }
        if (x > right.getLayout().x) {
          right = node;
        }
        if (node.depth > bottom.depth) {
          bottom = node;
        }
      });
      var delta = left === right ? 1 : separation(left, right) / 2;
      var tx = delta - left.getLayout().x;
      var kx = 0;
      var ky = 0;
      var coorX = 0;
      var coorY = 0;
      if (layout2 === "radial") {
        kx = width / (right.getLayout().x + delta + tx);
        ky = height / (bottom.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorX = (node.getLayout().x + tx) * kx;
          coorY = (node.depth - 1) * ky;
          var finalCoor = radialCoordinate(coorX, coorY);
          node.setLayout({
            x: finalCoor.x,
            y: finalCoor.y,
            rawX: coorX,
            rawY: coorY
          }, true);
        });
      } else {
        var orient = seriesModel.getOrient();
        if (orient === "RL" || orient === "LR") {
          ky = height / (right.getLayout().x + delta + tx);
          kx = width / (bottom.depth - 1 || 1);
          eachBefore(realRoot, function(node) {
            coorY = (node.getLayout().x + tx) * ky;
            coorX = orient === "LR" ? (node.depth - 1) * kx : width - (node.depth - 1) * kx;
            node.setLayout({
              x: coorX,
              y: coorY
            }, true);
          });
        } else if (orient === "TB" || orient === "BT") {
          kx = width / (right.getLayout().x + delta + tx);
          ky = height / (bottom.depth - 1 || 1);
          eachBefore(realRoot, function(node) {
            coorX = (node.getLayout().x + tx) * kx;
            coorY = orient === "TB" ? (node.depth - 1) * ky : height - (node.depth - 1) * ky;
            node.setLayout({
              x: coorX,
              y: coorY
            }, true);
          });
        }
      }
    }
  }
  treeLayout = _default2;
  return treeLayout;
}
var hasRequiredTree;
function requireTree() {
  if (hasRequiredTree)
    return tree;
  hasRequiredTree = 1;
  var echarts$12 = echarts;
  requireTreeSeries();
  requireTreeView();
  requireTreeAction();
  var visualSymbol = requireSymbol();
  var treeLayout2 = requireTreeLayout();
  echarts$12.registerVisual(visualSymbol("tree", "circle"));
  echarts$12.registerLayout(treeLayout2);
  return tree;
}
var treemap = {};
var treeHelper = {};
var hasRequiredTreeHelper;
function requireTreeHelper() {
  if (hasRequiredTreeHelper)
    return treeHelper;
  hasRequiredTreeHelper = 1;
  var zrUtil2 = util$6;
  function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
    if (payload && zrUtil2.indexOf(validPayloadTypes, payload.type) >= 0) {
      var root = seriesModel.getData().tree.root;
      var targetNode = payload.targetNode;
      if (typeof targetNode === "string") {
        targetNode = root.getNodeById(targetNode);
      }
      if (targetNode && root.contains(targetNode)) {
        return {
          node: targetNode
        };
      }
      var targetNodeId = payload.targetNodeId;
      if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
        return {
          node: targetNode
        };
      }
    }
  }
  function getPathToRoot(node) {
    var path2 = [];
    while (node) {
      node = node.parentNode;
      node && path2.push(node);
    }
    return path2.reverse();
  }
  function aboveViewRoot(viewRoot, node) {
    var viewPath = getPathToRoot(viewRoot);
    return zrUtil2.indexOf(viewPath, node) >= 0;
  }
  function wrapTreePathInfo(node, seriesModel) {
    var treePathInfo = [];
    while (node) {
      var nodeDataIndex = node.dataIndex;
      treePathInfo.push({
        name: node.name,
        dataIndex: nodeDataIndex,
        value: seriesModel.getRawValue(nodeDataIndex)
      });
      node = node.parentNode;
    }
    treePathInfo.reverse();
    return treePathInfo;
  }
  treeHelper.retrieveTargetInfo = retrieveTargetInfo;
  treeHelper.getPathToRoot = getPathToRoot;
  treeHelper.aboveViewRoot = aboveViewRoot;
  treeHelper.wrapTreePathInfo = wrapTreePathInfo;
  return treeHelper;
}
var TreemapSeries;
var hasRequiredTreemapSeries;
function requireTreemapSeries() {
  if (hasRequiredTreemapSeries)
    return TreemapSeries;
  hasRequiredTreemapSeries = 1;
  var zrUtil2 = util$6;
  var SeriesModel2 = Series;
  var Tree = requireTree$1();
  var Model2 = requireModel();
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var addCommas2 = _format2.addCommas;
  var _treeHelper = requireTreeHelper();
  var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
  var _default2 = SeriesModel2.extend({
    type: "series.treemap",
    layoutMode: "box",
    dependencies: ["grid", "polar"],
    preventUsingHoverLayer: true,
    /**
     * @type {module:echarts/data/Tree~Node}
     */
    _viewRoot: null,
    defaultOption: {
      // Disable progressive rendering
      progressive: 0,
      // center: ['50%', '50%'],          // not supported in ec3.
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      right: null,
      bottom: null,
      width: "80%",
      height: "80%",
      sort: true,
      // Can be null or false or true
      // (order by desc default, asc not supported yet (strange effect))
      clipWindow: "origin",
      // Size of clipped window when zooming. 'origin' or 'fullscreen'
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      // golden ratio
      leafDepth: null,
      // Nodes on depth from root are regarded as leaves.
      // Count from zero (zero represents only view root).
      drillDownIcon: "▶",
      // Use html character temporarily because it is complicated
      // to align specialized icon. ▷▶❒❐▼✚
      zoomToNodeRatio: 0.32 * 0.32,
      // Be effective when using zoomToNode. Specify the proportion of the
      // target node area in the view area.
      roam: true,
      // true, false, 'scale' or 'zoom', 'move'.
      nodeClick: "zoomToNode",
      // Leaf node click behaviour: 'zoomToNode', 'link', false.
      // If leafDepth is set and clicking a node which has children but
      // be on left depth, the behaviour would be changing root. Otherwise
      // use behavious defined above.
      animation: true,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: true,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        // Width of empty node.
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          //'#5793f3',
          borderColor: "rgba(255,255,255,0.7)",
          borderWidth: 1,
          shadowColor: "rgba(150,150,150,1)",
          shadowBlur: 3,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          textStyle: {}
        }
      },
      label: {
        show: true,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...
        // formatter: null,
        color: "#fff",
        ellipsis: true
        // align
        // verticalAlign
      },
      upperLabel: {
        // Label when node is parent.
        show: false,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        color: "#fff",
        ellipsis: true,
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        // Can be 'none' if not necessary.
        colorAlpha: null,
        // Can be 'none' if not necessary.
        colorSaturation: null,
        // Can be 'none' if not necessary.
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: true,
          position: [0, "50%"],
          color: "#fff",
          ellipsis: true,
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      // Can be 0, 1, 2, 3.
      visualMin: null,
      visualMax: null,
      color: [],
      // + treemapSeries.color should not be modified. Please only modified
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      // Array. Specify color alpha range of each level, like [0.2, 0.8]
      colorSaturation: null,
      // Array. Specify color saturation of each level, like [0.2, 0.5]
      colorMappingBy: "index",
      // 'value' or 'index' or 'id'.
      visibleMin: 10,
      // If area less than this threshold (unit: pixel^2), node will not
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // If area of a node less than this threshold (unit: pixel^2),
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
      // data: {
      //      value: [],
      //      children: [],
      //      link: 'http://xxx.xxx.xxx',
      //      target: 'blank' or 'self'
      // }
    },
    /**
     * @override
     */
    getInitialData: function(option, ecModel) {
      var root = {
        name: option.name,
        children: option.data
      };
      completeTreeValue(root);
      var levels = option.levels || [];
      var designatedVisualItemStyle = this.designatedVisualItemStyle = {};
      var designatedVisualModel = new Model2({
        itemStyle: designatedVisualItemStyle
      }, this, ecModel);
      levels = option.levels = setDefault(levels, ecModel);
      var levelModels = zrUtil2.map(levels || [], function(levelDefine) {
        return new Model2(levelDefine, designatedVisualModel, ecModel);
      }, this);
      var tree2 = Tree.createTree(root, this, beforeLink);
      function beforeLink(nodeData) {
        nodeData.wrapMethod("getItemModel", function(model2, idx) {
          var node = tree2.getNodeByDataIndex(idx);
          var levelModel = levelModels[node.depth];
          model2.parentModel = levelModel || designatedVisualModel;
          return model2;
        });
      }
      return tree2.data;
    },
    optionUpdated: function() {
      this.resetViewRoot();
    },
    /**
     * @override
     * @param {number} dataIndex
     * @param {boolean} [mutipleSeries=false]
     */
    formatTooltip: function(dataIndex) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var formattedValue = zrUtil2.isArray(value) ? addCommas2(value[0]) : addCommas2(value);
      var name2 = data.getName(dataIndex);
      return encodeHTML2(name2 + ": " + formattedValue);
    },
    /**
     * Add tree path to tooltip param
     *
     * @override
     * @param {number} dataIndex
     * @return {Object}
     */
    getDataParams: function(dataIndex) {
      var params = SeriesModel2.prototype.getDataParams.apply(this, arguments);
      var node = this.getData().tree.getNodeByDataIndex(dataIndex);
      params.treePathInfo = wrapTreePathInfo(node, this);
      return params;
    },
    /**
     * @public
     * @param {Object} layoutInfo {
     *                                x: containerGroup x
     *                                y: containerGroup y
     *                                width: containerGroup width
     *                                height: containerGroup height
     *                            }
     */
    setLayoutInfo: function(layoutInfo) {
      this.layoutInfo = this.layoutInfo || {};
      zrUtil2.extend(this.layoutInfo, layoutInfo);
    },
    /**
     * @param  {string} id
     * @return {number} index
     */
    mapIdToIndex: function(id) {
      var idIndexMap = this._idIndexMap;
      if (!idIndexMap) {
        idIndexMap = this._idIndexMap = zrUtil2.createHashMap();
        this._idIndexMapCount = 0;
      }
      var index2 = idIndexMap.get(id);
      if (index2 == null) {
        idIndexMap.set(id, index2 = this._idIndexMapCount++);
      }
      return index2;
    },
    getViewRoot: function() {
      return this._viewRoot;
    },
    /**
     * @param {module:echarts/data/Tree~Node} [viewRoot]
     */
    resetViewRoot: function(viewRoot) {
      viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
      var root = this.getRawData().tree.root;
      if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
        this._viewRoot = root;
      }
    }
  });
  function completeTreeValue(dataNode) {
    var sum = 0;
    zrUtil2.each(dataNode.children, function(child) {
      completeTreeValue(child);
      var childValue = child.value;
      zrUtil2.isArray(childValue) && (childValue = childValue[0]);
      sum += childValue;
    });
    var thisValue = dataNode.value;
    if (zrUtil2.isArray(thisValue)) {
      thisValue = thisValue[0];
    }
    if (thisValue == null || isNaN(thisValue)) {
      thisValue = sum;
    }
    if (thisValue < 0) {
      thisValue = 0;
    }
    zrUtil2.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
  }
  function setDefault(levels, ecModel) {
    var globalColorList = ecModel.get("color");
    if (!globalColorList) {
      return;
    }
    levels = levels || [];
    var hasColorDefine;
    zrUtil2.each(levels, function(levelDefine) {
      var model2 = new Model2(levelDefine);
      var modelColor = model2.get("color");
      if (model2.get("itemStyle.color") || modelColor && modelColor !== "none") {
        hasColorDefine = true;
      }
    });
    if (!hasColorDefine) {
      var level0 = levels[0] || (levels[0] = {});
      level0.color = globalColorList.slice();
    }
    return levels;
  }
  TreemapSeries = _default2;
  return TreemapSeries;
}
var Breadcrumb_1;
var hasRequiredBreadcrumb;
function requireBreadcrumb() {
  if (hasRequiredBreadcrumb)
    return Breadcrumb_1;
  hasRequiredBreadcrumb = 1;
  var graphic2 = graphic$4;
  var layout2 = layout$1;
  var zrUtil2 = util$6;
  var _treeHelper = requireTreeHelper();
  var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
  var TEXT_PADDING = 8;
  var ITEM_GAP = 8;
  var ARRAY_LENGTH = 5;
  function Breadcrumb(containerGroup) {
    this.group = new graphic2.Group();
    containerGroup.add(this.group);
  }
  Breadcrumb.prototype = {
    constructor: Breadcrumb,
    render: function(seriesModel, api, targetNode, onSelect) {
      var model2 = seriesModel.getModel("breadcrumb");
      var thisGroup = this.group;
      thisGroup.removeAll();
      if (!model2.get("show") || !targetNode) {
        return;
      }
      var normalStyleModel = model2.getModel("itemStyle");
      var textStyleModel = normalStyleModel.getModel("textStyle");
      var layoutParam = {
        pos: {
          left: model2.get("left"),
          right: model2.get("right"),
          top: model2.get("top"),
          bottom: model2.get("bottom")
        },
        box: {
          width: api.getWidth(),
          height: api.getHeight()
        },
        emptyItemWidth: model2.get("emptyItemWidth"),
        totalWidth: 0,
        renderList: []
      };
      this._prepare(targetNode, layoutParam, textStyleModel);
      this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);
      layout2.positionElement(thisGroup, layoutParam.pos, layoutParam.box);
    },
    /**
     * Prepare render list and total width
     * @private
     */
    _prepare: function(targetNode, layoutParam, textStyleModel) {
      for (var node = targetNode; node; node = node.parentNode) {
        var text2 = node.getModel().get("name");
        var textRect = textStyleModel.getTextRect(text2);
        var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
        layoutParam.totalWidth += itemWidth + ITEM_GAP;
        layoutParam.renderList.push({
          node,
          text: text2,
          width: itemWidth
        });
      }
    },
    /**
     * @private
     */
    _renderContent: function(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
      var lastX = 0;
      var emptyItemWidth = layoutParam.emptyItemWidth;
      var height = seriesModel.get("breadcrumb.height");
      var availableSize = layout2.getAvailableSize(layoutParam.pos, layoutParam.box);
      var totalWidth = layoutParam.totalWidth;
      var renderList = layoutParam.renderList;
      for (var i = renderList.length - 1; i >= 0; i--) {
        var item = renderList[i];
        var itemNode = item.node;
        var itemWidth = item.width;
        var text2 = item.text;
        if (totalWidth > availableSize.width) {
          totalWidth -= itemWidth - emptyItemWidth;
          itemWidth = emptyItemWidth;
          text2 = null;
        }
        var el = new graphic2.Polygon({
          shape: {
            points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
          },
          style: zrUtil2.defaults(normalStyleModel.getItemStyle(), {
            lineJoin: "bevel",
            text: text2,
            textFill: textStyleModel.getTextColor(),
            textFont: textStyleModel.getFont()
          }),
          z: 10,
          onclick: zrUtil2.curry(onSelect, itemNode)
        });
        this.group.add(el);
        packEventData(el, seriesModel, itemNode);
        lastX += itemWidth + ITEM_GAP;
      }
    },
    /**
     * @override
     */
    remove: function() {
      this.group.removeAll();
    }
  };
  function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
    var points2 = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]];
    !tail && points2.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
    !head && points2.push([x, y + itemHeight / 2]);
    return points2;
  }
  function packEventData(el, seriesModel, itemNode) {
    el.eventData = {
      componentType: "series",
      componentSubType: "treemap",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.componentIndex,
      seriesName: seriesModel.name,
      seriesType: "treemap",
      selfType: "breadcrumb",
      // Distinguish with click event on treemap node.
      nodeData: {
        dataIndex: itemNode && itemNode.dataIndex,
        name: itemNode && itemNode.name
      },
      treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
    };
  }
  var _default2 = Breadcrumb;
  Breadcrumb_1 = _default2;
  return Breadcrumb_1;
}
var animation = {};
var hasRequiredAnimation;
function requireAnimation() {
  if (hasRequiredAnimation)
    return animation;
  hasRequiredAnimation = 1;
  var zrUtil2 = util$6;
  function createWrap() {
    var storage2 = [];
    var elExistsMap = {};
    var doneCallback;
    return {
      /**
       * Caution: a el can only be added once, otherwise 'done'
       * might not be called. This method checks this (by el.id),
       * suppresses adding and returns false when existing el found.
       *
       * @param {modele:zrender/Element} el
       * @param {Object} target
       * @param {number} [time=500]
       * @param {number} [delay=0]
       * @param {string} [easing='linear']
       * @return {boolean} Whether adding succeeded.
       *
       * @example
       *     add(el, target, time, delay, easing);
       *     add(el, target, time, easing);
       *     add(el, target, time);
       *     add(el, target);
       */
      add: function(el, target, time, delay, easing2) {
        if (zrUtil2.isString(delay)) {
          easing2 = delay;
          delay = 0;
        }
        if (elExistsMap[el.id]) {
          return false;
        }
        elExistsMap[el.id] = 1;
        storage2.push({
          el,
          target,
          time,
          delay,
          easing: easing2
        });
        return true;
      },
      /**
       * Only execute when animation finished. Will not execute when any
       * of 'stop' or 'stopAnimation' called.
       *
       * @param {Function} callback
       */
      done: function(callback) {
        doneCallback = callback;
        return this;
      },
      /**
       * Will stop exist animation firstly.
       */
      start: function() {
        var count = storage2.length;
        for (var i = 0, len = storage2.length; i < len; i++) {
          var item = storage2[i];
          item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
        }
        return this;
        function done() {
          count--;
          if (!count) {
            storage2.length = 0;
            elExistsMap = {};
            doneCallback && doneCallback();
          }
        }
      }
    };
  }
  animation.createWrap = createWrap;
  return animation;
}
var TreemapView;
var hasRequiredTreemapView;
function requireTreemapView() {
  if (hasRequiredTreemapView)
    return TreemapView;
  hasRequiredTreemapView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var DataDiffer = requireDataDiffer();
  var helper2 = requireTreeHelper();
  var Breadcrumb = requireBreadcrumb();
  var RoamController = requireRoamController();
  var BoundingRect2 = BoundingRect_1;
  var matrix2 = requireMatrix();
  var animationUtil = requireAnimation();
  var makeStyleMapper2 = requireMakeStyleMapper();
  var _format2 = requireFormat();
  var windowOpen = _format2.windowOpen;
  var bind2 = zrUtil2.bind;
  var Group2 = graphic2.Group;
  var Rect2 = graphic2.Rect;
  var each2 = zrUtil2.each;
  var DRAG_THRESHOLD = 3;
  var PATH_LABEL_NOAMAL = ["label"];
  var PATH_LABEL_EMPHASIS = ["emphasis", "label"];
  var PATH_UPPERLABEL_NORMAL = ["upperLabel"];
  var PATH_UPPERLABEL_EMPHASIS = ["emphasis", "upperLabel"];
  var Z_BASE = 10;
  var Z_BG = 1;
  var Z_CONTENT = 2;
  var getItemStyleEmphasis = makeStyleMapper2([
    ["fill", "color"],
    // `borderColor` and `borderWidth` has been occupied,
    // so use `stroke` to indicate the stroke of the rect.
    ["stroke", "strokeColor"],
    ["lineWidth", "strokeWidth"],
    ["shadowBlur"],
    ["shadowOffsetX"],
    ["shadowOffsetY"],
    ["shadowColor"]
  ]);
  var getItemStyleNormal = function(model2) {
    var itemStyle2 = getItemStyleEmphasis(model2);
    itemStyle2.stroke = itemStyle2.fill = itemStyle2.lineWidth = null;
    return itemStyle2;
  };
  var _default2 = echarts$12.extendChartView({
    type: "treemap",
    /**
     * @override
     */
    init: function(o2, api) {
      this._containerGroup;
      this._storage = createStorage();
      this._oldTree;
      this._breadcrumb;
      this._controller;
      this._state = "ready";
    },
    /**
     * @override
     */
    render: function(seriesModel, ecModel, api, payload) {
      var models = ecModel.findComponents({
        mainType: "series",
        subType: "treemap",
        query: payload
      });
      if (zrUtil2.indexOf(models, seriesModel) < 0) {
        return;
      }
      this.seriesModel = seriesModel;
      this.api = api;
      this.ecModel = ecModel;
      var types = ["treemapZoomToNode", "treemapRootToNode"];
      var targetInfo = helper2.retrieveTargetInfo(payload, types, seriesModel);
      var payloadType = payload && payload.type;
      var layoutInfo = seriesModel.layoutInfo;
      var isInit = !this._oldTree;
      var thisStorage = this._storage;
      var reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
        rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
        direction: payload.direction
      } : null;
      var containerGroup = this._giveContainerGroup(layoutInfo);
      var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
      !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
      this._resetController(api);
      this._renderBreadcrumb(seriesModel, api, targetInfo);
    },
    /**
     * @private
     */
    _giveContainerGroup: function(layoutInfo) {
      var containerGroup = this._containerGroup;
      if (!containerGroup) {
        containerGroup = this._containerGroup = new Group2();
        this._initEvents(containerGroup);
        this.group.add(containerGroup);
      }
      containerGroup.attr("position", [layoutInfo.x, layoutInfo.y]);
      return containerGroup;
    },
    /**
     * @private
     */
    _doRender: function(containerGroup, seriesModel, reRoot) {
      var thisTree = seriesModel.getData().tree;
      var oldTree = this._oldTree;
      var lastsForAnimation = createStorage();
      var thisStorage = createStorage();
      var oldStorage = this._storage;
      var willInvisibleEls = [];
      var doRenderNode = zrUtil2.curry(renderNode, seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls);
      dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
      var willDeleteEls = clearStorage(oldStorage);
      this._oldTree = thisTree;
      this._storage = thisStorage;
      return {
        lastsForAnimation,
        willDeleteEls,
        renderFinally
      };
      function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
        if (sameTree) {
          oldViewChildren = thisViewChildren;
          each2(thisViewChildren, function(child, index2) {
            !child.isRemoved() && processNode(index2, index2);
          });
        } else {
          new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil2.curry(processNode, null)).execute();
        }
        function getKey(node) {
          return node.getId();
        }
        function processNode(newIndex, oldIndex) {
          var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
          var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
          var group = doRenderNode(thisNode, oldNode, parentGroup, depth);
          group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
        }
      }
      function clearStorage(storage2) {
        var willDeleteEls2 = createStorage();
        storage2 && each2(storage2, function(store, storageName) {
          var delEls = willDeleteEls2[storageName];
          each2(store, function(el) {
            el && (delEls.push(el), el.__tmWillDelete = 1);
          });
        });
        return willDeleteEls2;
      }
      function renderFinally() {
        each2(willDeleteEls, function(els) {
          each2(els, function(el) {
            el.parent && el.parent.remove(el);
          });
        });
        each2(willInvisibleEls, function(el) {
          el.invisible = true;
          el.dirty();
        });
      }
    },
    /**
     * @private
     */
    _doAnimation: function(containerGroup, renderResult, seriesModel, reRoot) {
      if (!seriesModel.get("animation")) {
        return;
      }
      var duration = seriesModel.get("animationDurationUpdate");
      var easing2 = seriesModel.get("animationEasing");
      var animationWrap = animationUtil.createWrap();
      each2(renderResult.willDeleteEls, function(store, storageName) {
        each2(store, function(el, rawIndex) {
          if (el.invisible) {
            return;
          }
          var parent = el.parent;
          var target;
          if (reRoot && reRoot.direction === "drillDown") {
            target = parent === reRoot.rootNodeGroup ? {
              shape: {
                x: 0,
                y: 0,
                width: parent.__tmNodeWidth,
                height: parent.__tmNodeHeight
              },
              style: {
                opacity: 0
              }
              // Others.
            } : {
              style: {
                opacity: 0
              }
            };
          } else {
            var targetX = 0;
            var targetY = 0;
            if (!parent.__tmWillDelete) {
              targetX = parent.__tmNodeWidth / 2;
              targetY = parent.__tmNodeHeight / 2;
            }
            target = storageName === "nodeGroup" ? {
              position: [targetX, targetY],
              style: {
                opacity: 0
              }
            } : {
              shape: {
                x: targetX,
                y: targetY,
                width: 0,
                height: 0
              },
              style: {
                opacity: 0
              }
            };
          }
          target && animationWrap.add(el, target, duration, easing2);
        });
      });
      each2(this._storage, function(store, storageName) {
        each2(store, function(el, rawIndex) {
          var last = renderResult.lastsForAnimation[storageName][rawIndex];
          var target = {};
          if (!last) {
            return;
          }
          if (storageName === "nodeGroup") {
            if (last.old) {
              target.position = el.position.slice();
              el.attr("position", last.old);
            }
          } else {
            if (last.old) {
              target.shape = zrUtil2.extend({}, el.shape);
              el.setShape(last.old);
            }
            if (last.fadein) {
              el.setStyle("opacity", 0);
              target.style = {
                opacity: 1
              };
            } else if (el.style.opacity !== 1) {
              target.style = {
                opacity: 1
              };
            }
          }
          animationWrap.add(el, target, duration, easing2);
        });
      }, this);
      this._state = "animating";
      animationWrap.done(bind2(function() {
        this._state = "ready";
        renderResult.renderFinally();
      }, this)).start();
    },
    /**
     * @private
     */
    _resetController: function(api) {
      var controller = this._controller;
      if (!controller) {
        controller = this._controller = new RoamController(api.getZr());
        controller.enable(this.seriesModel.get("roam"));
        controller.on("pan", bind2(this._onPan, this));
        controller.on("zoom", bind2(this._onZoom, this));
      }
      var rect = new BoundingRect2(0, 0, api.getWidth(), api.getHeight());
      controller.setPointerChecker(function(e2, x, y) {
        return rect.contain(x, y);
      });
    },
    /**
     * @private
     */
    _clearController: function() {
      var controller = this._controller;
      if (controller) {
        controller.dispose();
        controller = null;
      }
    },
    /**
     * @private
     */
    _onPan: function(e2) {
      if (this._state !== "animating" && (Math.abs(e2.dx) > DRAG_THRESHOLD || Math.abs(e2.dy) > DRAG_THRESHOLD)) {
        var root = this.seriesModel.getData().tree.root;
        if (!root) {
          return;
        }
        var rootLayout = root.getLayout();
        if (!rootLayout) {
          return;
        }
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: rootLayout.x + e2.dx,
            y: rootLayout.y + e2.dy,
            width: rootLayout.width,
            height: rootLayout.height
          }
        });
      }
    },
    /**
     * @private
     */
    _onZoom: function(e2) {
      var mouseX = e2.originX;
      var mouseY = e2.originY;
      if (this._state !== "animating") {
        var root = this.seriesModel.getData().tree.root;
        if (!root) {
          return;
        }
        var rootLayout = root.getLayout();
        if (!rootLayout) {
          return;
        }
        var rect = new BoundingRect2(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
        var layoutInfo = this.seriesModel.layoutInfo;
        mouseX -= layoutInfo.x;
        mouseY -= layoutInfo.y;
        var m2 = matrix2.create();
        matrix2.translate(m2, m2, [-mouseX, -mouseY]);
        matrix2.scale(m2, m2, [e2.scale, e2.scale]);
        matrix2.translate(m2, m2, [mouseX, mouseY]);
        rect.applyTransform(m2);
        this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          }
        });
      }
    },
    /**
     * @private
     */
    _initEvents: function(containerGroup) {
      containerGroup.on("click", function(e2) {
        if (this._state !== "ready") {
          return;
        }
        var nodeClick = this.seriesModel.get("nodeClick", true);
        if (!nodeClick) {
          return;
        }
        var targetInfo = this.findTarget(e2.offsetX, e2.offsetY);
        if (!targetInfo) {
          return;
        }
        var node = targetInfo.node;
        if (node.getLayout().isLeafRoot) {
          this._rootToNode(targetInfo);
        } else {
          if (nodeClick === "zoomToNode") {
            this._zoomToNode(targetInfo);
          } else if (nodeClick === "link") {
            var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
            var link = itemModel.get("link", true);
            var linkTarget = itemModel.get("target", true) || "blank";
            link && windowOpen(link, linkTarget);
          }
        }
      }, this);
    },
    /**
     * @private
     */
    _renderBreadcrumb: function(seriesModel, api, targetInfo) {
      if (!targetInfo) {
        targetInfo = seriesModel.get("leafDepth", true) != null ? {
          node: seriesModel.getViewRoot()
          // FIXME
          // better way?
          // Find breadcrumb tail on center of containerGroup.
        } : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
        if (!targetInfo) {
          targetInfo = {
            node: seriesModel.getData().tree.root
          };
        }
      }
      (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, bind2(onSelect, this));
      function onSelect(node) {
        if (this._state !== "animating") {
          helper2.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({
            node
          }) : this._zoomToNode({
            node
          });
        }
      }
    },
    /**
     * @override
     */
    remove: function() {
      this._clearController();
      this._containerGroup && this._containerGroup.removeAll();
      this._storage = createStorage();
      this._state = "ready";
      this._breadcrumb && this._breadcrumb.remove();
    },
    dispose: function() {
      this._clearController();
    },
    /**
     * @private
     */
    _zoomToNode: function(targetInfo) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: targetInfo.node
      });
    },
    /**
     * @private
     */
    _rootToNode: function(targetInfo) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: targetInfo.node
      });
    },
    /**
     * @public
     * @param {number} x Global coord x.
     * @param {number} y Global coord y.
     * @return {Object} info If not found, return undefined;
     * @return {number} info.node Target node.
     * @return {number} info.offsetX x refer to target node.
     * @return {number} info.offsetY y refer to target node.
     */
    findTarget: function(x, y) {
      var targetInfo;
      var viewRoot = this.seriesModel.getViewRoot();
      viewRoot.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(node) {
        var bgEl = this._storage.background[node.getRawIndex()];
        if (bgEl) {
          var point = bgEl.transformCoordToLocal(x, y);
          var shape = bgEl.shape;
          if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
            targetInfo = {
              node,
              offsetX: point[0],
              offsetY: point[1]
            };
          } else {
            return false;
          }
        }
      }, this);
      return targetInfo;
    }
  });
  function createStorage() {
    return {
      nodeGroup: [],
      background: [],
      content: []
    };
  }
  function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
    if (!thisNode) {
      return;
    }
    var thisLayout = thisNode.getLayout();
    var data = seriesModel.getData();
    data.setItemGraphicEl(thisNode.dataIndex, null);
    if (!thisLayout || !thisLayout.isInView) {
      return;
    }
    var thisWidth = thisLayout.width;
    var thisHeight = thisLayout.height;
    var borderWidth = thisLayout.borderWidth;
    var thisInvisible = thisLayout.invisible;
    var thisRawIndex = thisNode.getRawIndex();
    var oldRawIndex = oldNode && oldNode.getRawIndex();
    var thisViewChildren = thisNode.viewChildren;
    var upperHeight = thisLayout.upperHeight;
    var isParent = thisViewChildren && thisViewChildren.length;
    var itemStyleNormalModel = thisNode.getModel("itemStyle");
    var itemStyleEmphasisModel = thisNode.getModel("emphasis.itemStyle");
    var group = giveGraphic("nodeGroup", Group2);
    if (!group) {
      return;
    }
    parentGroup.add(group);
    group.attr("position", [thisLayout.x || 0, thisLayout.y || 0]);
    group.__tmNodeWidth = thisWidth;
    group.__tmNodeHeight = thisHeight;
    if (thisLayout.isAboveViewRoot) {
      return group;
    }
    var nodeModel = thisNode.getModel();
    var bg = giveGraphic("background", Rect2, depth, Z_BG);
    bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
    if (isParent) {
      if (graphic2.isHighDownDispatcher(group)) {
        graphic2.setAsHighDownDispatcher(group, false);
      }
      if (bg) {
        graphic2.setAsHighDownDispatcher(bg, true);
        data.setItemGraphicEl(thisNode.dataIndex, bg);
      }
    } else {
      var content = giveGraphic("content", Rect2, depth, Z_CONTENT);
      content && renderContent(group, content);
      if (bg && graphic2.isHighDownDispatcher(bg)) {
        graphic2.setAsHighDownDispatcher(bg, false);
      }
      graphic2.setAsHighDownDispatcher(group, true);
      data.setItemGraphicEl(thisNode.dataIndex, group);
    }
    return group;
    function renderBackground(group2, bg2, useUpperLabel) {
      bg2.dataIndex = thisNode.dataIndex;
      bg2.seriesIndex = seriesModel.seriesIndex;
      bg2.setShape({
        x: 0,
        y: 0,
        width: thisWidth,
        height: thisHeight
      });
      if (thisInvisible) {
        processInvisible(bg2);
      } else {
        bg2.invisible = false;
        var visualBorderColor = thisNode.getVisual("borderColor", true);
        var emphasisBorderColor = itemStyleEmphasisModel.get("borderColor");
        var normalStyle = getItemStyleNormal(itemStyleNormalModel);
        normalStyle.fill = visualBorderColor;
        var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
        emphasisStyle.fill = emphasisBorderColor;
        if (useUpperLabel) {
          var upperLabelWidth = thisWidth - 2 * borderWidth;
          prepareText(normalStyle, emphasisStyle, visualBorderColor, upperLabelWidth, upperHeight, {
            x: borderWidth,
            y: 0,
            width: upperLabelWidth,
            height: upperHeight
          });
        } else {
          normalStyle.text = emphasisStyle.text = null;
        }
        bg2.setStyle(normalStyle);
        graphic2.setElementHoverStyle(bg2, emphasisStyle);
      }
      group2.add(bg2);
    }
    function renderContent(group2, content2) {
      content2.dataIndex = thisNode.dataIndex;
      content2.seriesIndex = seriesModel.seriesIndex;
      var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
      var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
      content2.culling = true;
      content2.setShape({
        x: borderWidth,
        y: borderWidth,
        width: contentWidth,
        height: contentHeight
      });
      if (thisInvisible) {
        processInvisible(content2);
      } else {
        content2.invisible = false;
        var visualColor = thisNode.getVisual("color", true);
        var normalStyle = getItemStyleNormal(itemStyleNormalModel);
        normalStyle.fill = visualColor;
        var emphasisStyle = getItemStyleEmphasis(itemStyleEmphasisModel);
        prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);
        content2.setStyle(normalStyle);
        graphic2.setElementHoverStyle(content2, emphasisStyle);
      }
      group2.add(content2);
    }
    function processInvisible(element) {
      !element.invisible && willInvisibleEls.push(element);
    }
    function prepareText(normalStyle, emphasisStyle, visualColor, width, height, upperLabelRect) {
      var defaultText = nodeModel.get("name");
      var normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
      var emphasisLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_EMPHASIS : PATH_LABEL_EMPHASIS);
      var isShow = normalLabelModel.getShallow("show");
      graphic2.setLabelStyle(normalStyle, emphasisStyle, normalLabelModel, emphasisLabelModel, {
        defaultText: isShow ? defaultText : null,
        autoColor: visualColor,
        isRectText: true,
        labelFetcher: seriesModel,
        labelDataIndex: thisNode.dataIndex,
        labelProp: upperLabelRect ? "upperLabel" : "label"
      });
      addDrillDownIcon(normalStyle, upperLabelRect, thisLayout);
      addDrillDownIcon(emphasisStyle, upperLabelRect, thisLayout);
      upperLabelRect && (normalStyle.textRect = zrUtil2.clone(upperLabelRect));
      normalStyle.truncate = isShow && normalLabelModel.get("ellipsis") ? {
        outerWidth: width,
        outerHeight: height,
        minChar: 2
      } : null;
    }
    function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
      var text2 = style.text;
      if (!upperLabelRect && thisLayout2.isLeafRoot && text2 != null) {
        var iconChar = seriesModel.get("drillDownIcon", true);
        style.text = iconChar ? iconChar + " " + text2 : text2;
      }
    }
    function giveGraphic(storageName, Ctor, depth2, z) {
      var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
      var lasts = lastsForAnimation[storageName];
      if (element) {
        oldStorage[storageName][oldRawIndex] = null;
        prepareAnimationWhenHasOld(lasts, element, storageName);
      } else if (!thisInvisible) {
        element = new Ctor({
          z: calculateZ(depth2, z)
        });
        element.__tmDepth = depth2;
        element.__tmStorageName = storageName;
        prepareAnimationWhenNoOld(lasts, element, storageName);
      }
      return thisStorage[storageName][thisRawIndex] = element;
    }
    function prepareAnimationWhenHasOld(lasts, element, storageName) {
      var lastCfg = lasts[thisRawIndex] = {};
      lastCfg.old = storageName === "nodeGroup" ? element.position.slice() : zrUtil2.extend({}, element.shape);
    }
    function prepareAnimationWhenNoOld(lasts, element, storageName) {
      var lastCfg = lasts[thisRawIndex] = {};
      var parentNode = thisNode.parentNode;
      if (parentNode && (!reRoot || reRoot.direction === "drillDown")) {
        var parentOldX = 0;
        var parentOldY = 0;
        var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];
        if (!reRoot && parentOldBg && parentOldBg.old) {
          parentOldX = parentOldBg.old.width;
          parentOldY = parentOldBg.old.height;
        }
        lastCfg.old = storageName === "nodeGroup" ? [0, parentOldY] : {
          x: parentOldX,
          y: parentOldY,
          width: 0,
          height: 0
        };
      }
      lastCfg.fadein = storageName !== "nodeGroup";
    }
  }
  function calculateZ(depth, zInLevel) {
    var zb = depth * Z_BASE + zInLevel;
    return (zb - 1) / zb;
  }
  TreemapView = _default2;
  return TreemapView;
}
var treemapAction = {};
var hasRequiredTreemapAction;
function requireTreemapAction() {
  if (hasRequiredTreemapAction)
    return treemapAction;
  hasRequiredTreemapAction = 1;
  var echarts$12 = echarts;
  var helper2 = requireTreeHelper();
  var noop2 = function() {
  };
  var actionTypes = ["treemapZoomToNode", "treemapRender", "treemapMove"];
  for (var i = 0; i < actionTypes.length; i++) {
    echarts$12.registerAction({
      type: actionTypes[i],
      update: "updateView"
    }, noop2);
  }
  echarts$12.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: payload
    }, handleRootToNode);
    function handleRootToNode(model2, index2) {
      var types = ["treemapZoomToNode", "treemapRootToNode"];
      var targetInfo = helper2.retrieveTargetInfo(payload, types, model2);
      if (targetInfo) {
        var originViewRoot = model2.getViewRoot();
        if (originViewRoot) {
          payload.direction = helper2.aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model2.resetViewRoot(targetInfo.node);
      }
    }
  });
  return treemapAction;
}
var VisualMapping_1;
var hasRequiredVisualMapping;
function requireVisualMapping() {
  if (hasRequiredVisualMapping)
    return VisualMapping_1;
  hasRequiredVisualMapping = 1;
  var zrUtil2 = util$6;
  var zrColor = color$1;
  var _number2 = requireNumber();
  var linearMap = _number2.linearMap;
  var each2 = zrUtil2.each;
  var isObject2 = zrUtil2.isObject;
  var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
  var VisualMapping = function(option) {
    var mappingMethod = option.mappingMethod;
    var visualType = option.type;
    var thisOption = this.option = zrUtil2.clone(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    var visualHandler = visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._doMap = visualHandler._doMap[mappingMethod];
    if (mappingMethod === "piecewise") {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === "category") {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
    } else {
      zrUtil2.assert(mappingMethod !== "linear" || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  };
  VisualMapping.prototype = {
    constructor: VisualMapping,
    mapValueToVisual: function(value) {
      var normalized = this._normalizeData(value);
      return this._doMap(normalized, value);
    },
    getNormalizer: function() {
      return zrUtil2.bind(this._normalizeData, this);
    }
  };
  var visualHandlers = VisualMapping.visualHandlers = {
    color: {
      applyVisual: makeApplyVisual("color"),
      /**
       * Create a mapper function
       * @return {Function}
       */
      getColorMapper: function() {
        var thisOption = this.option;
        return zrUtil2.bind(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
          !isNormalized && (value = this._normalizeData(value));
          return doMapCategory.call(this, value);
        } : function(value, isNormalized, out2) {
          var returnRGBArray = !!out2;
          !isNormalized && (value = this._normalizeData(value));
          out2 = zrColor.fastLerp(value, thisOption.parsedVisual, out2);
          return returnRGBArray ? out2 : zrColor.stringify(out2, "rgba");
        }, this);
      },
      _doMap: {
        linear: function(normalized) {
          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba");
        },
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), "rgba");
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    colorHue: makePartialColorVisualHandler(function(color2, value) {
      return zrColor.modifyHSL(color2, value);
    }),
    colorSaturation: makePartialColorVisualHandler(function(color2, value) {
      return zrColor.modifyHSL(color2, null, value);
    }),
    colorLightness: makePartialColorVisualHandler(function(color2, value) {
      return zrColor.modifyHSL(color2, null, null, value);
    }),
    colorAlpha: makePartialColorVisualHandler(function(color2, value) {
      return zrColor.modifyAlpha(color2, value);
    }),
    opacity: {
      applyVisual: makeApplyVisual("opacity"),
      _doMap: makeDoMap([0, 1])
    },
    liftZ: {
      applyVisual: makeApplyVisual("liftZ"),
      _doMap: {
        linear: doMapFixed,
        category: doMapFixed,
        piecewise: doMapFixed,
        fixed: doMapFixed
      }
    },
    symbol: {
      applyVisual: function(value, getter, setter) {
        var symbolCfg = this.mapValueToVisual(value);
        if (zrUtil2.isString(symbolCfg)) {
          setter("symbol", symbolCfg);
        } else if (isObject2(symbolCfg)) {
          for (var name2 in symbolCfg) {
            if (symbolCfg.hasOwnProperty(name2)) {
              setter(name2, symbolCfg[name2]);
            }
          }
        }
      },
      _doMap: {
        linear: doMapToArray,
        category: doMapCategory,
        piecewise: function(normalized, value) {
          var result = getSpecifiedVisual.call(this, value);
          if (result == null) {
            result = doMapToArray.call(this, normalized);
          }
          return result;
        },
        fixed: doMapFixed
      }
    },
    symbolSize: {
      applyVisual: makeApplyVisual("symbolSize"),
      _doMap: makeDoMap([0, 1])
    }
  };
  function preprocessForPiecewise(thisOption) {
    var pieceList = thisOption.pieceList;
    thisOption.hasSpecialVisual = false;
    zrUtil2.each(pieceList, function(piece, index2) {
      piece.originIndex = index2;
      if (piece.visual != null) {
        thisOption.hasSpecialVisual = true;
      }
    });
  }
  function preprocessForSpecifiedCategory(thisOption) {
    var categories = thisOption.categories;
    var visual = thisOption.visual;
    var categoryMap = thisOption.categoryMap = {};
    each2(categories, function(cate, index2) {
      categoryMap[cate] = index2;
    });
    if (!zrUtil2.isArray(visual)) {
      var visualArr = [];
      if (zrUtil2.isObject(visual)) {
        each2(visual, function(v, cate) {
          var index2 = categoryMap[cate];
          visualArr[index2 != null ? index2 : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
        });
      } else {
        visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
      }
      visual = setVisualToOption(thisOption, visualArr);
    }
    for (var i = categories.length - 1; i >= 0; i--) {
      if (visual[i] == null) {
        delete categoryMap[categories[i]];
        categories.pop();
      }
    }
  }
  function normalizeVisualRange(thisOption, isCategory) {
    var visual = thisOption.visual;
    var visualArr = [];
    if (zrUtil2.isObject(visual)) {
      each2(visual, function(v) {
        visualArr.push(v);
      });
    } else if (visual != null) {
      visualArr.push(visual);
    }
    var doNotNeedPair = {
      color: 1,
      symbol: 1
    };
    if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
      visualArr[1] = visualArr[0];
    }
    setVisualToOption(thisOption, visualArr);
  }
  function makePartialColorVisualHandler(applyValue) {
    return {
      applyVisual: function(value, getter, setter) {
        value = this.mapValueToVisual(value);
        setter("color", applyValue(getter("color"), value));
      },
      _doMap: makeDoMap([0, 1])
    };
  }
  function doMapToArray(normalized) {
    var visual = this.option.visual;
    return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
  }
  function makeApplyVisual(visualType) {
    return function(value, getter, setter) {
      setter(visualType, this.mapValueToVisual(value));
    };
  }
  function doMapCategory(normalized) {
    var visual = this.option.visual;
    return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
  }
  function doMapFixed() {
    return this.option.visual[0];
  }
  function makeDoMap(sourceExtent) {
    return {
      linear: function(normalized) {
        return linearMap(normalized, sourceExtent, this.option.visual, true);
      },
      category: doMapCategory,
      piecewise: function(normalized, value) {
        var result = getSpecifiedVisual.call(this, value);
        if (result == null) {
          result = linearMap(normalized, sourceExtent, this.option.visual, true);
        }
        return result;
      },
      fixed: doMapFixed
    };
  }
  function getSpecifiedVisual(value) {
    var thisOption = this.option;
    var pieceList = thisOption.pieceList;
    if (thisOption.hasSpecialVisual) {
      var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
      var piece = pieceList[pieceIndex];
      if (piece && piece.visual) {
        return piece.visual[this.type];
      }
    }
  }
  function setVisualToOption(thisOption, visualArr) {
    thisOption.visual = visualArr;
    if (thisOption.type === "color") {
      thisOption.parsedVisual = zrUtil2.map(visualArr, function(item) {
        return zrColor.parse(item);
      });
    }
    return visualArr;
  }
  var normalizers = {
    linear: function(value) {
      return linearMap(value, this.option.dataExtent, [0, 1], true);
    },
    piecewise: function(value) {
      var pieceList = this.option.pieceList;
      var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
      if (pieceIndex != null) {
        return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
      }
    },
    category: function(value) {
      var index2 = this.option.categories ? this.option.categoryMap[value] : value;
      return index2 == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index2;
    },
    fixed: zrUtil2.noop
  };
  VisualMapping.listVisualTypes = function() {
    var visualTypes = [];
    zrUtil2.each(visualHandlers, function(handler, key) {
      visualTypes.push(key);
    });
    return visualTypes;
  };
  VisualMapping.addVisualHandler = function(name2, handler) {
    visualHandlers[name2] = handler;
  };
  VisualMapping.isValidType = function(visualType) {
    return visualHandlers.hasOwnProperty(visualType);
  };
  VisualMapping.eachVisual = function(visual, callback, context) {
    if (zrUtil2.isObject(visual)) {
      zrUtil2.each(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  };
  VisualMapping.mapVisual = function(visual, callback, context) {
    var isPrimary;
    var newVisual = zrUtil2.isArray(visual) ? [] : zrUtil2.isObject(visual) ? {} : (isPrimary = true, null);
    VisualMapping.eachVisual(visual, function(v, key) {
      var newVal = callback.call(context, v, key);
      isPrimary ? newVisual = newVal : newVisual[key] = newVal;
    });
    return newVisual;
  };
  VisualMapping.retrieveVisuals = function(obj) {
    var ret = {};
    var hasVisual;
    obj && each2(visualHandlers, function(h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  };
  VisualMapping.prepareVisualTypes = function(visualTypes) {
    if (isObject2(visualTypes)) {
      var types = [];
      each2(visualTypes, function(item, type) {
        types.push(type);
      });
      visualTypes = types;
    } else if (zrUtil2.isArray(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else {
      return [];
    }
    visualTypes.sort(function(type1, type2) {
      return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
    });
    return visualTypes;
  };
  VisualMapping.dependsOn = function(visualType1, visualType2) {
    return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  };
  VisualMapping.findPieceIndex = function(value, pieceList, findClosestWhenOutside) {
    var possibleI;
    var abs2 = Infinity;
    for (var i = 0, len = pieceList.length; i < len; i++) {
      var pieceValue = pieceList[i].value;
      if (pieceValue != null) {
        if (pieceValue === value || typeof pieceValue === "string" && pieceValue === value + "") {
          return i;
        }
        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }
    for (var i = 0, len = pieceList.length; i < len; i++) {
      var piece = pieceList[i];
      var interval = piece.interval;
      var close = piece.close;
      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
          return i;
        }
        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }
    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }
    function updatePossible(val, index2) {
      var newAbs = Math.abs(val - value);
      if (newAbs < abs2) {
        abs2 = newAbs;
        possibleI = index2;
      }
    }
  };
  function littleThan(close, a, b) {
    return close ? a <= b : a < b;
  }
  var _default2 = VisualMapping;
  VisualMapping_1 = _default2;
  return VisualMapping_1;
}
var treemapVisual;
var hasRequiredTreemapVisual;
function requireTreemapVisual() {
  if (hasRequiredTreemapVisual)
    return treemapVisual;
  hasRequiredTreemapVisual = 1;
  var VisualMapping = requireVisualMapping();
  var zrColor = color$1;
  var zrUtil2 = util$6;
  var isArray2 = zrUtil2.isArray;
  var ITEM_STYLE_NORMAL = "itemStyle";
  var _default2 = {
    seriesType: "treemap",
    reset: function(seriesModel, ecModel, api, payload) {
      var tree2 = seriesModel.getData().tree;
      var root = tree2.root;
      if (root.isRemoved()) {
        return;
      }
      travelTree(
        root,
        // Visual should calculate from tree root but not view root.
        {},
        seriesModel.getViewRoot().getAncestors(),
        seriesModel
      );
    }
  };
  function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
    var nodeModel = node.getModel();
    var nodeLayout = node.getLayout();
    if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
      return;
    }
    var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
    var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
    var borderColor = nodeItemStyleModel.get("borderColor");
    var borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
    var thisNodeColor;
    if (borderColorSaturation != null) {
      thisNodeColor = calculateColor(visuals);
      borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
    }
    node.setVisual("borderColor", borderColor);
    var viewChildren = node.viewChildren;
    if (!viewChildren || !viewChildren.length) {
      thisNodeColor = calculateColor(visuals);
      node.setVisual("color", thisNodeColor);
    } else {
      var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
      zrUtil2.each(viewChildren, function(child, index2) {
        if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
          var childVisual = mapVisual2(nodeModel, visuals, child, index2, mapping, seriesModel);
          travelTree(child, childVisual, viewRootAncestors, seriesModel);
        }
      });
    }
  }
  function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
    var visuals = zrUtil2.extend({}, designatedVisual);
    var designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
    zrUtil2.each(["color", "colorAlpha", "colorSaturation"], function(visualName) {
      designatedVisualItemStyle[visualName] = designatedVisual[visualName];
      var val = nodeItemStyleModel.get(visualName);
      designatedVisualItemStyle[visualName] = null;
      val != null && (visuals[visualName] = val);
    });
    return visuals;
  }
  function calculateColor(visuals) {
    var color2 = getValueVisualDefine(visuals, "color");
    if (color2) {
      var colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
      var colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
      if (colorSaturation) {
        color2 = zrColor.modifyHSL(color2, null, null, colorSaturation);
      }
      if (colorAlpha) {
        color2 = zrColor.modifyAlpha(color2, colorAlpha);
      }
      return color2;
    }
  }
  function calculateBorderColor(borderColorSaturation, thisNodeColor) {
    return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
  }
  function getValueVisualDefine(visuals, name2) {
    var value = visuals[name2];
    if (value != null && value !== "none") {
      return value;
    }
  }
  function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
    if (!viewChildren || !viewChildren.length) {
      return;
    }
    var rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
    if (!rangeVisual) {
      return;
    }
    var visualMin = nodeModel.get("visualMin");
    var visualMax = nodeModel.get("visualMax");
    var dataExtent = nodeLayout.dataExtent.slice();
    visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
    visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
    var colorMappingBy = nodeModel.get("colorMappingBy");
    var opt = {
      type: rangeVisual.name,
      dataExtent,
      visual: rangeVisual.range
    };
    if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
      opt.mappingMethod = "category";
      opt.loop = true;
    } else {
      opt.mappingMethod = "linear";
    }
    var mapping = new VisualMapping(opt);
    mapping.__drColorMappingBy = colorMappingBy;
    return mapping;
  }
  function getRangeVisual(nodeModel, name2) {
    var range = nodeModel.get(name2);
    return isArray2(range) && range.length ? {
      name: name2,
      range
    } : null;
  }
  function mapVisual2(nodeModel, visuals, child, index2, mapping, seriesModel) {
    var childVisuals = zrUtil2.extend({}, visuals);
    if (mapping) {
      var mappingType = mapping.type;
      var colorMappingBy = mappingType === "color" && mapping.__drColorMappingBy;
      var value = colorMappingBy === "index" ? index2 : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
      childVisuals[mappingType] = mapping.mapValueToVisual(value);
    }
    return childVisuals;
  }
  treemapVisual = _default2;
  return treemapVisual;
}
var treemapLayout;
var hasRequiredTreemapLayout;
function requireTreemapLayout() {
  if (hasRequiredTreemapLayout)
    return treemapLayout;
  hasRequiredTreemapLayout = 1;
  var zrUtil2 = util$6;
  var BoundingRect2 = BoundingRect_1;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var MAX_SAFE_INTEGER = _number2.MAX_SAFE_INTEGER;
  var layout2 = layout$1;
  var helper2 = requireTreeHelper();
  var mathMax2 = Math.max;
  var mathMin2 = Math.min;
  var retrieveValue = zrUtil2.retrieve;
  var each2 = zrUtil2.each;
  var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
  var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
  var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
  var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
  var _default2 = {
    seriesType: "treemap",
    reset: function(seriesModel, ecModel, api, payload) {
      var ecWidth = api.getWidth();
      var ecHeight = api.getHeight();
      var seriesOption = seriesModel.option;
      var layoutInfo = layout2.getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      var size2 = seriesOption.size || [];
      var containerWidth = parsePercent2(retrieveValue(layoutInfo.width, size2[0]), ecWidth);
      var containerHeight = parsePercent2(retrieveValue(layoutInfo.height, size2[1]), ecHeight);
      var payloadType = payload && payload.type;
      var types = ["treemapZoomToNode", "treemapRootToNode"];
      var targetInfo = helper2.retrieveTargetInfo(payload, types, seriesModel);
      var rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
      var viewRoot = seriesModel.getViewRoot();
      var viewAbovePath = helper2.getPathToRoot(viewRoot);
      if (payloadType !== "treemapMove") {
        var rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
        var sort3 = seriesOption.sort;
        if (sort3 && sort3 !== "asc" && sort3 !== "desc") {
          sort3 = "desc";
        }
        var options = {
          squareRatio: seriesOption.squareRatio,
          sort: sort3,
          leafDepth: seriesOption.leafDepth
        };
        viewRoot.hostTree.clearLayouts();
        var viewRootLayout = {
          x: 0,
          y: 0,
          width: rootSize[0],
          height: rootSize[1],
          area: rootSize[0] * rootSize[1]
        };
        viewRoot.setLayout(viewRootLayout);
        squarify(viewRoot, options, false, 0);
        var viewRootLayout = viewRoot.getLayout();
        each2(viewAbovePath, function(node, index2) {
          var childValue = (viewAbovePath[index2 + 1] || viewRoot).getValue();
          node.setLayout(zrUtil2.extend({
            dataExtent: [childValue, childValue],
            borderWidth: 0,
            upperHeight: 0
          }, viewRootLayout));
        });
      }
      var treeRoot = seriesModel.getData().tree.root;
      treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
      seriesModel.setLayoutInfo(layoutInfo);
      prunning(
        treeRoot,
        // Transform to base element coordinate system.
        new BoundingRect2(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight),
        viewAbovePath,
        viewRoot,
        0
      );
    }
  };
  function squarify(node, options, hideChildren, depth) {
    var width;
    var height;
    if (node.isRemoved()) {
      return;
    }
    var thisLayout = node.getLayout();
    width = thisLayout.width;
    height = thisLayout.height;
    var nodeModel = node.getModel();
    var borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
    var halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
    var upperLabelHeight = getUpperLabelHeight(nodeModel);
    var upperHeight = Math.max(borderWidth, upperLabelHeight);
    var layoutOffset = borderWidth - halfGapWidth;
    var layoutOffsetUpper = upperHeight - halfGapWidth;
    var nodeModel = node.getModel();
    node.setLayout({
      borderWidth,
      upperHeight,
      upperLabelHeight
    }, true);
    width = mathMax2(width - 2 * layoutOffset, 0);
    height = mathMax2(height - layoutOffset - layoutOffsetUpper, 0);
    var totalArea = width * height;
    var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
    if (!viewChildren.length) {
      return;
    }
    var rect = {
      x: layoutOffset,
      y: layoutOffsetUpper,
      width,
      height
    };
    var rowFixedLength = mathMin2(width, height);
    var best = Infinity;
    var row = [];
    row.area = 0;
    for (var i = 0, len = viewChildren.length; i < len; ) {
      var child = viewChildren[i];
      row.push(child);
      row.area += child.getLayout().area;
      var score = worst(row, rowFixedLength, options.squareRatio);
      if (score <= best) {
        i++;
        best = score;
      } else {
        row.area -= row.pop().getLayout().area;
        position(row, rowFixedLength, rect, halfGapWidth, false);
        rowFixedLength = mathMin2(rect.width, rect.height);
        row.length = row.area = 0;
        best = Infinity;
      }
    }
    if (row.length) {
      position(row, rowFixedLength, rect, halfGapWidth, true);
    }
    if (!hideChildren) {
      var childrenVisibleMin = nodeModel.get("childrenVisibleMin");
      if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
        hideChildren = true;
      }
    }
    for (var i = 0, len = viewChildren.length; i < len; i++) {
      squarify(viewChildren[i], options, hideChildren, depth + 1);
    }
  }
  function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
    var viewChildren = node.children || [];
    var orderBy = options.sort;
    orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
    var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
    if (hideChildren && !overLeafDepth) {
      return node.viewChildren = [];
    }
    viewChildren = zrUtil2.filter(viewChildren, function(child) {
      return !child.isRemoved();
    });
    sort2(viewChildren, orderBy);
    var info = statistic(nodeModel, viewChildren, orderBy);
    if (info.sum === 0) {
      return node.viewChildren = [];
    }
    info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
    if (info.sum === 0) {
      return node.viewChildren = [];
    }
    for (var i = 0, len = viewChildren.length; i < len; i++) {
      var area = viewChildren[i].getValue() / info.sum * totalArea;
      viewChildren[i].setLayout({
        area
      });
    }
    if (overLeafDepth) {
      viewChildren.length && node.setLayout({
        isLeafRoot: true
      }, true);
      viewChildren.length = 0;
    }
    node.viewChildren = viewChildren;
    node.setLayout({
      dataExtent: info.dataExtent
    }, true);
    return viewChildren;
  }
  function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
    if (!orderBy) {
      return sum;
    }
    var visibleMin = nodeModel.get("visibleMin");
    var len = orderedChildren.length;
    var deletePoint = len;
    for (var i = len - 1; i >= 0; i--) {
      var value = orderedChildren[orderBy === "asc" ? len - i - 1 : i].getValue();
      if (value / sum * totalArea < visibleMin) {
        deletePoint = i;
        sum -= value;
      }
    }
    orderBy === "asc" ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
    return sum;
  }
  function sort2(viewChildren, orderBy) {
    if (orderBy) {
      viewChildren.sort(function(a, b) {
        var diff2 = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
        return diff2 === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff2;
      });
    }
    return viewChildren;
  }
  function statistic(nodeModel, children, orderBy) {
    var sum = 0;
    for (var i = 0, len = children.length; i < len; i++) {
      sum += children[i].getValue();
    }
    var dimension = nodeModel.get("visualDimension");
    var dataExtent;
    if (!children || !children.length) {
      dataExtent = [NaN, NaN];
    } else if (dimension === "value" && orderBy) {
      dataExtent = [children[children.length - 1].getValue(), children[0].getValue()];
      orderBy === "asc" && dataExtent.reverse();
    } else {
      var dataExtent = [Infinity, -Infinity];
      each2(children, function(child) {
        var value = child.getValue(dimension);
        value < dataExtent[0] && (dataExtent[0] = value);
        value > dataExtent[1] && (dataExtent[1] = value);
      });
    }
    return {
      sum,
      dataExtent
    };
  }
  function worst(row, rowFixedLength, ratio) {
    var areaMax = 0;
    var areaMin = Infinity;
    for (var i = 0, area, len = row.length; i < len; i++) {
      area = row[i].getLayout().area;
      if (area) {
        area < areaMin && (areaMin = area);
        area > areaMax && (areaMax = area);
      }
    }
    var squareArea = row.area * row.area;
    var f2 = rowFixedLength * rowFixedLength * ratio;
    return squareArea ? mathMax2(f2 * areaMax / squareArea, squareArea / (f2 * areaMin)) : Infinity;
  }
  function position(row, rowFixedLength, rect, halfGapWidth, flush) {
    var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
    var idx1WhenH = 1 - idx0WhenH;
    var xy = ["x", "y"];
    var wh = ["width", "height"];
    var last = rect[xy[idx0WhenH]];
    var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
    if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
      rowOtherLength = rect[wh[idx1WhenH]];
    }
    for (var i = 0, rowLen = row.length; i < rowLen; i++) {
      var node = row[i];
      var nodeLayout = {};
      var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
      var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax2(rowOtherLength - 2 * halfGapWidth, 0);
      var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
      var modWH = i === rowLen - 1 || remain < step ? remain : step;
      var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax2(modWH - 2 * halfGapWidth, 0);
      nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin2(halfGapWidth, wh1 / 2);
      nodeLayout[xy[idx0WhenH]] = last + mathMin2(halfGapWidth, wh0 / 2);
      last += modWH;
      node.setLayout(nodeLayout, true);
    }
    rect[xy[idx1WhenH]] += rowOtherLength;
    rect[wh[idx1WhenH]] -= rowOtherLength;
  }
  function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
    var currNode = (targetInfo || {}).node;
    var defaultSize = [containerWidth, containerHeight];
    if (!currNode || currNode === viewRoot) {
      return defaultSize;
    }
    var parent;
    var viewArea = containerWidth * containerHeight;
    var area = viewArea * seriesModel.option.zoomToNodeRatio;
    while (parent = currNode.parentNode) {
      var sum = 0;
      var siblings = parent.children;
      for (var i = 0, len = siblings.length; i < len; i++) {
        sum += siblings[i].getValue();
      }
      var currNodeValue = currNode.getValue();
      if (currNodeValue === 0) {
        return defaultSize;
      }
      area *= sum / currNodeValue;
      var parentModel = parent.getModel();
      var borderWidth = parentModel.get(PATH_BORDER_WIDTH);
      var upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
      area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
      area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
      currNode = parent;
    }
    area < viewArea && (area = viewArea);
    var scale = Math.pow(area / viewArea, 0.5);
    return [containerWidth * scale, containerHeight * scale];
  }
  function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
    if (rootRect) {
      return {
        x: rootRect.x,
        y: rootRect.y
      };
    }
    var defaultPosition = {
      x: 0,
      y: 0
    };
    if (!targetInfo) {
      return defaultPosition;
    }
    var targetNode = targetInfo.node;
    var layout3 = targetNode.getLayout();
    if (!layout3) {
      return defaultPosition;
    }
    var targetCenter = [layout3.width / 2, layout3.height / 2];
    var node = targetNode;
    while (node) {
      var nodeLayout = node.getLayout();
      targetCenter[0] += nodeLayout.x;
      targetCenter[1] += nodeLayout.y;
      node = node.parentNode;
    }
    return {
      x: layoutInfo.width / 2 - targetCenter[0],
      y: layoutInfo.height / 2 - targetCenter[1]
    };
  }
  function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
    var nodeLayout = node.getLayout();
    var nodeInViewAbovePath = viewAbovePath[depth];
    var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
    if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
      return;
    }
    node.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: true,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
      isAboveViewRoot
    }, true);
    var childClipRect = new BoundingRect2(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
    each2(node.viewChildren || [], function(child) {
      prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
    });
  }
  function getUpperLabelHeight(model2) {
    return model2.get(PATH_UPPER_LABEL_SHOW) ? model2.get(PATH_UPPER_LABEL_HEIGHT) : 0;
  }
  treemapLayout = _default2;
  return treemapLayout;
}
var hasRequiredTreemap;
function requireTreemap() {
  if (hasRequiredTreemap)
    return treemap;
  hasRequiredTreemap = 1;
  var echarts$12 = echarts;
  requireTreemapSeries();
  requireTreemapView();
  requireTreemapAction();
  var treemapVisual2 = requireTreemapVisual();
  var treemapLayout2 = requireTreemapLayout();
  echarts$12.registerVisual(treemapVisual2);
  echarts$12.registerLayout(treemapLayout2);
  return treemap;
}
var graph = {};
var Graph_1;
var hasRequiredGraph$1;
function requireGraph$1() {
  if (hasRequiredGraph$1)
    return Graph_1;
  hasRequiredGraph$1 = 1;
  var zrUtil2 = util$6;
  var _clazz2 = clazz;
  var enableClassCheck2 = _clazz2.enableClassCheck;
  function generateNodeKey(id) {
    return "_EC_" + id;
  }
  var Graph = function(directed) {
    this._directed = directed || false;
    this.nodes = [];
    this.edges = [];
    this._nodesMap = {};
    this._edgesMap = {};
    this.data;
    this.edgeData;
  };
  var graphProto = Graph.prototype;
  graphProto.type = "graph";
  graphProto.isDirected = function() {
    return this._directed;
  };
  graphProto.addNode = function(id, dataIndex) {
    id = id == null ? "" + dataIndex : "" + id;
    var nodesMap = this._nodesMap;
    if (nodesMap[generateNodeKey(id)]) {
      return;
    }
    var node = new Node(id, dataIndex);
    node.hostGraph = this;
    this.nodes.push(node);
    nodesMap[generateNodeKey(id)] = node;
    return node;
  };
  graphProto.getNodeByIndex = function(dataIndex) {
    var rawIdx = this.data.getRawIndex(dataIndex);
    return this.nodes[rawIdx];
  };
  graphProto.getNodeById = function(id) {
    return this._nodesMap[generateNodeKey(id)];
  };
  graphProto.addEdge = function(n1, n2, dataIndex) {
    var nodesMap = this._nodesMap;
    var edgesMap = this._edgesMap;
    if (typeof n1 === "number") {
      n1 = this.nodes[n1];
    }
    if (typeof n2 === "number") {
      n2 = this.nodes[n2];
    }
    if (!Node.isInstance(n1)) {
      n1 = nodesMap[generateNodeKey(n1)];
    }
    if (!Node.isInstance(n2)) {
      n2 = nodesMap[generateNodeKey(n2)];
    }
    if (!n1 || !n2) {
      return;
    }
    var key = n1.id + "-" + n2.id;
    var edge = new Edge(n1, n2, dataIndex);
    edge.hostGraph = this;
    if (this._directed) {
      n1.outEdges.push(edge);
      n2.inEdges.push(edge);
    }
    n1.edges.push(edge);
    if (n1 !== n2) {
      n2.edges.push(edge);
    }
    this.edges.push(edge);
    edgesMap[key] = edge;
    return edge;
  };
  graphProto.getEdgeByIndex = function(dataIndex) {
    var rawIdx = this.edgeData.getRawIndex(dataIndex);
    return this.edges[rawIdx];
  };
  graphProto.getEdge = function(n1, n2) {
    if (Node.isInstance(n1)) {
      n1 = n1.id;
    }
    if (Node.isInstance(n2)) {
      n2 = n2.id;
    }
    var edgesMap = this._edgesMap;
    if (this._directed) {
      return edgesMap[n1 + "-" + n2];
    } else {
      return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
    }
  };
  graphProto.eachNode = function(cb, context) {
    var nodes = this.nodes;
    var len = nodes.length;
    for (var i = 0; i < len; i++) {
      if (nodes[i].dataIndex >= 0) {
        cb.call(context, nodes[i], i);
      }
    }
  };
  graphProto.eachEdge = function(cb, context) {
    var edges = this.edges;
    var len = edges.length;
    for (var i = 0; i < len; i++) {
      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
        cb.call(context, edges[i], i);
      }
    }
  };
  graphProto.breadthFirstTraverse = function(cb, startNode, direction, context) {
    if (!Node.isInstance(startNode)) {
      startNode = this._nodesMap[generateNodeKey(startNode)];
    }
    if (!startNode) {
      return;
    }
    var edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
    for (var i = 0; i < this.nodes.length; i++) {
      this.nodes[i].__visited = false;
    }
    if (cb.call(context, startNode, null)) {
      return;
    }
    var queue2 = [startNode];
    while (queue2.length) {
      var currentNode = queue2.shift();
      var edges = currentNode[edgeType];
      for (var i = 0; i < edges.length; i++) {
        var e2 = edges[i];
        var otherNode = e2.node1 === currentNode ? e2.node2 : e2.node1;
        if (!otherNode.__visited) {
          if (cb.call(context, otherNode, currentNode)) {
            return;
          }
          queue2.push(otherNode);
          otherNode.__visited = true;
        }
      }
    }
  };
  graphProto.update = function() {
    var data = this.data;
    var edgeData = this.edgeData;
    var nodes = this.nodes;
    var edges = this.edges;
    for (var i = 0, len = nodes.length; i < len; i++) {
      nodes[i].dataIndex = -1;
    }
    for (var i = 0, len = data.count(); i < len; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
    edgeData.filterSelf(function(idx) {
      var edge = edges[edgeData.getRawIndex(idx)];
      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
    });
    for (var i = 0, len = edges.length; i < len; i++) {
      edges[i].dataIndex = -1;
    }
    for (var i = 0, len = edgeData.count(); i < len; i++) {
      edges[edgeData.getRawIndex(i)].dataIndex = i;
    }
  };
  graphProto.clone = function() {
    var graph2 = new Graph(this._directed);
    var nodes = this.nodes;
    var edges = this.edges;
    for (var i = 0; i < nodes.length; i++) {
      graph2.addNode(nodes[i].id, nodes[i].dataIndex);
    }
    for (var i = 0; i < edges.length; i++) {
      var e2 = edges[i];
      graph2.addEdge(e2.node1.id, e2.node2.id, e2.dataIndex);
    }
    return graph2;
  };
  function Node(id, dataIndex) {
    this.id = id == null ? "" : id;
    this.inEdges = [];
    this.outEdges = [];
    this.edges = [];
    this.hostGraph;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  Node.prototype = {
    constructor: Node,
    /**
     * @return {number}
     */
    degree: function() {
      return this.edges.length;
    },
    /**
     * @return {number}
     */
    inDegree: function() {
      return this.inEdges.length;
    },
    /**
    * @return {number}
    */
    outDegree: function() {
      return this.outEdges.length;
    },
    /**
     * @param {string} [path]
     * @return {module:echarts/model/Model}
     */
    getModel: function(path2) {
      if (this.dataIndex < 0) {
        return;
      }
      var graph2 = this.hostGraph;
      var itemModel = graph2.data.getItemModel(this.dataIndex);
      return itemModel.getModel(path2);
    }
  };
  function Edge(n1, n2, dataIndex) {
    this.node1 = n1;
    this.node2 = n2;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  Edge.prototype.getModel = function(path2) {
    if (this.dataIndex < 0) {
      return;
    }
    var graph2 = this.hostGraph;
    var itemModel = graph2.edgeData.getItemModel(this.dataIndex);
    return itemModel.getModel(path2);
  };
  var createGraphDataProxyMixin = function(hostName, dataName) {
    return {
      /**
       * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
       * @return {number}
       */
      getValue: function(dimension) {
        var data = this[hostName][dataName];
        return data.get(data.getDimension(dimension || "value"), this.dataIndex);
      },
      /**
       * @param {Object|string} key
       * @param {*} [value]
       */
      setVisual: function(key, value) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
      },
      /**
       * @param {string} key
       * @return {boolean}
       */
      getVisual: function(key, ignoreParent) {
        return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);
      },
      /**
       * @param {Object} layout
       * @return {boolean} [merge=false]
       */
      setLayout: function(layout2, merge2) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout2, merge2);
      },
      /**
       * @return {Object}
       */
      getLayout: function() {
        return this[hostName][dataName].getItemLayout(this.dataIndex);
      },
      /**
       * @return {module:zrender/Element}
       */
      getGraphicEl: function() {
        return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
      },
      /**
       * @return {number}
       */
      getRawIndex: function() {
        return this[hostName][dataName].getRawIndex(this.dataIndex);
      }
    };
  };
  zrUtil2.mixin(Node, createGraphDataProxyMixin("hostGraph", "data"));
  zrUtil2.mixin(Edge, createGraphDataProxyMixin("hostGraph", "edgeData"));
  Graph.Node = Node;
  Graph.Edge = Edge;
  enableClassCheck2(Node);
  enableClassCheck2(Edge);
  var _default2 = Graph;
  Graph_1 = _default2;
  return Graph_1;
}
var createGraphFromNodeEdge;
var hasRequiredCreateGraphFromNodeEdge;
function requireCreateGraphFromNodeEdge() {
  if (hasRequiredCreateGraphFromNodeEdge)
    return createGraphFromNodeEdge;
  hasRequiredCreateGraphFromNodeEdge = 1;
  var zrUtil2 = util$6;
  var List = requireList();
  var Graph = requireGraph$1();
  var linkList = requireLinkList();
  var createDimensions2 = requireCreateDimensions();
  var CoordinateSystem$1 = CoordinateSystem;
  var createListFromArray = requireCreateListFromArray();
  function _default2(nodes, edges, seriesModel, directed, beforeLink) {
    var graph2 = new Graph(directed);
    for (var i = 0; i < nodes.length; i++) {
      graph2.addNode(zrUtil2.retrieve(
        // Id, name, dataIndex
        nodes[i].id,
        nodes[i].name,
        i
      ), i);
    }
    var linkNameList = [];
    var validEdges = [];
    var linkCount = 0;
    for (var i = 0; i < edges.length; i++) {
      var link = edges[i];
      var source = link.source;
      var target = link.target;
      if (graph2.addEdge(source, target, linkCount)) {
        validEdges.push(link);
        linkNameList.push(zrUtil2.retrieve(link.id, source + " > " + target));
        linkCount++;
      }
    }
    var coordSys = seriesModel.get("coordinateSystem");
    var nodeData;
    if (coordSys === "cartesian2d" || coordSys === "polar") {
      nodeData = createListFromArray(nodes, seriesModel);
    } else {
      var coordSysCtor = CoordinateSystem$1.get(coordSys);
      var coordDimensions = coordSysCtor && coordSysCtor.type !== "view" ? coordSysCtor.dimensions || [] : [];
      if (zrUtil2.indexOf(coordDimensions, "value") < 0) {
        coordDimensions.concat(["value"]);
      }
      var dimensionNames = createDimensions2(nodes, {
        coordDimensions
      });
      nodeData = new List(dimensionNames, seriesModel);
      nodeData.initData(nodes);
    }
    var edgeData = new List(["value"], seriesModel);
    edgeData.initData(validEdges, linkNameList);
    beforeLink && beforeLink(nodeData, edgeData);
    linkList({
      mainData: nodeData,
      struct: graph2,
      structAttr: "graph",
      datas: {
        node: nodeData,
        edge: edgeData
      },
      datasAttr: {
        node: "data",
        edge: "edgeData"
      }
    });
    graph2.update();
    return graph2;
  }
  createGraphFromNodeEdge = _default2;
  return createGraphFromNodeEdge;
}
var multipleGraphEdgeHelper = {};
var hasRequiredMultipleGraphEdgeHelper;
function requireMultipleGraphEdgeHelper() {
  if (hasRequiredMultipleGraphEdgeHelper)
    return multipleGraphEdgeHelper;
  hasRequiredMultipleGraphEdgeHelper = 1;
  var zrUtil2 = util$6;
  var KEY_DELIMITER = "-->";
  var getAutoCurvenessParams = function(seriesModel) {
    return seriesModel.get("autoCurveness") || null;
  };
  var createCurveness = function(seriesModel, appendLength) {
    var autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
    var length = 20;
    var curvenessList = [];
    if (typeof autoCurvenessParmas === "number") {
      length = autoCurvenessParmas;
    } else if (zrUtil2.isArray(autoCurvenessParmas)) {
      seriesModel.__curvenessList = autoCurvenessParmas;
      return;
    }
    if (appendLength > length) {
      length = appendLength;
    }
    var len = length % 2 ? length + 2 : length + 3;
    curvenessList = [];
    for (var i = 0; i < len; i++) {
      curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
    }
    seriesModel.__curvenessList = curvenessList;
  };
  var getKeyOfEdges = function(n1, n2, seriesModel) {
    var source = [n1.id, n1.dataIndex].join(".");
    var target = [n2.id, n2.dataIndex].join(".");
    return [seriesModel.uid, source, target].join(KEY_DELIMITER);
  };
  var getOppositeKey = function(key) {
    var keys = key.split(KEY_DELIMITER);
    return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER);
  };
  var getEdgeFromMap = function(edge, seriesModel) {
    var key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
    return seriesModel.__edgeMap[key];
  };
  var getTotalLengthBetweenNodes = function(edge, seriesModel) {
    var len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
    var lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
    return len + lenV;
  };
  var getEdgeMapLengthWithKey = function(key, seriesModel) {
    var edgeMap = seriesModel.__edgeMap;
    return edgeMap[key] ? edgeMap[key].length : 0;
  };
  function initCurvenessList(seriesModel) {
    if (!getAutoCurvenessParams(seriesModel)) {
      return;
    }
    seriesModel.__curvenessList = [];
    seriesModel.__edgeMap = {};
    createCurveness(seriesModel);
  }
  function createEdgeMapForCurveness(n1, n2, seriesModel, index2) {
    if (!getAutoCurvenessParams(seriesModel)) {
      return;
    }
    var key = getKeyOfEdges(n1, n2, seriesModel);
    var edgeMap = seriesModel.__edgeMap;
    var oppositeEdges = edgeMap[getOppositeKey(key)];
    if (edgeMap[key] && !oppositeEdges) {
      edgeMap[key].isForward = true;
    } else if (oppositeEdges && edgeMap[key]) {
      oppositeEdges.isForward = true;
      edgeMap[key].isForward = false;
    }
    edgeMap[key] = edgeMap[key] || [];
    edgeMap[key].push(index2);
  }
  function getCurvenessForEdge(edge, seriesModel, index2, needReverse) {
    var autoCurvenessParams = getAutoCurvenessParams(seriesModel);
    var isArrayParam = zrUtil2.isArray(autoCurvenessParams);
    if (!autoCurvenessParams) {
      return null;
    }
    var edgeArray = getEdgeFromMap(edge, seriesModel);
    if (!edgeArray) {
      return null;
    }
    var edgeIndex = -1;
    for (var i = 0; i < edgeArray.length; i++) {
      if (edgeArray[i] === index2) {
        edgeIndex = i;
        break;
      }
    }
    var totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
    createCurveness(seriesModel, totalLen);
    edge.lineStyle = edge.lineStyle || {};
    var curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
    var curvenessList = seriesModel.__curvenessList;
    var parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
    if (!edgeArray.isForward) {
      var oppositeKey = getOppositeKey(curKey);
      var len = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
      var resValue = curvenessList[edgeIndex + len + parityCorrection];
      if (needReverse) {
        if (isArrayParam) {
          if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
            return (len + parityCorrection) % 2 ? resValue : -resValue;
          } else {
            return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
          }
        } else {
          return (len + parityCorrection) % 2 ? resValue : -resValue;
        }
      } else {
        return curvenessList[edgeIndex + len + parityCorrection];
      }
    } else {
      return curvenessList[parityCorrection + edgeIndex];
    }
  }
  multipleGraphEdgeHelper.initCurvenessList = initCurvenessList;
  multipleGraphEdgeHelper.createEdgeMapForCurveness = createEdgeMapForCurveness;
  multipleGraphEdgeHelper.getCurvenessForEdge = getCurvenessForEdge;
  return multipleGraphEdgeHelper;
}
var GraphSeries_1;
var hasRequiredGraphSeries;
function requireGraphSeries() {
  if (hasRequiredGraphSeries)
    return GraphSeries_1;
  hasRequiredGraphSeries = 1;
  var echarts$12 = echarts;
  var List = requireList();
  var zrUtil2 = util$6;
  var _model2 = model;
  var defaultEmphasis2 = _model2.defaultEmphasis;
  var Model2 = requireModel();
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var createGraphFromNodeEdge2 = requireCreateGraphFromNodeEdge();
  var LegendVisualProvider = requireLegendVisualProvider();
  var _multipleGraphEdgeHelper = requireMultipleGraphEdgeHelper();
  var initCurvenessList = _multipleGraphEdgeHelper.initCurvenessList;
  var createEdgeMapForCurveness = _multipleGraphEdgeHelper.createEdgeMapForCurveness;
  var GraphSeries = echarts$12.extendSeriesModel({
    type: "series.graph",
    init: function(option) {
      GraphSeries.superApply(this, "init", arguments);
      var self2 = this;
      function getCategoriesData() {
        return self2._categoriesData;
      }
      this.legendVisualProvider = new LegendVisualProvider(getCategoriesData, getCategoriesData);
      this.fillDataTextStyle(option.edges || option.links);
      this._updateCategoriesData();
    },
    mergeOption: function(option) {
      GraphSeries.superApply(this, "mergeOption", arguments);
      this.fillDataTextStyle(option.edges || option.links);
      this._updateCategoriesData();
    },
    mergeDefaultAndTheme: function(option) {
      GraphSeries.superApply(this, "mergeDefaultAndTheme", arguments);
      defaultEmphasis2(option, ["edgeLabel"], ["show"]);
    },
    getInitialData: function(option, ecModel) {
      var edges = option.edges || option.links || [];
      var nodes = option.data || option.nodes || [];
      var self2 = this;
      if (nodes && edges) {
        initCurvenessList(this);
        var graph2 = createGraphFromNodeEdge2(nodes, edges, this, true, beforeLink);
        zrUtil2.each(graph2.edges, function(edge) {
          createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
        }, this);
        return graph2.data;
      }
      function beforeLink(nodeData, edgeData) {
        nodeData.wrapMethod("getItemModel", function(model2) {
          var categoriesModels = self2._categoriesModels;
          var categoryIdx = model2.getShallow("category");
          var categoryModel = categoriesModels[categoryIdx];
          if (categoryModel) {
            categoryModel.parentModel = model2.parentModel;
            model2.parentModel = categoryModel;
          }
          return model2;
        });
        var edgeLabelModel = self2.getModel("edgeLabel");
        var fakeSeriesModel = new Model2({
          label: edgeLabelModel.option
        }, edgeLabelModel.parentModel, ecModel);
        var emphasisEdgeLabelModel = self2.getModel("emphasis.edgeLabel");
        var emphasisFakeSeriesModel = new Model2({
          emphasis: {
            label: emphasisEdgeLabelModel.option
          }
        }, emphasisEdgeLabelModel.parentModel, ecModel);
        edgeData.wrapMethod("getItemModel", function(model2) {
          model2.customizeGetParent(edgeGetParent);
          return model2;
        });
        function edgeGetParent(path2) {
          path2 = this.parsePath(path2);
          return path2 && path2[0] === "label" ? fakeSeriesModel : path2 && path2[0] === "emphasis" && path2[1] === "label" ? emphasisFakeSeriesModel : this.parentModel;
        }
      }
    },
    /**
     * @return {module:echarts/data/Graph}
     */
    getGraph: function() {
      return this.getData().graph;
    },
    /**
     * @return {module:echarts/data/List}
     */
    getEdgeData: function() {
      return this.getGraph().edgeData;
    },
    /**
     * @return {module:echarts/data/List}
     */
    getCategoriesData: function() {
      return this._categoriesData;
    },
    /**
     * @override
     */
    formatTooltip: function(dataIndex, multipleSeries, dataType) {
      if (dataType === "edge") {
        var nodeData = this.getData();
        var params = this.getDataParams(dataIndex, dataType);
        var edge = nodeData.graph.getEdgeByIndex(dataIndex);
        var sourceName = nodeData.getName(edge.node1.dataIndex);
        var targetName = nodeData.getName(edge.node2.dataIndex);
        var html = [];
        sourceName != null && html.push(sourceName);
        targetName != null && html.push(targetName);
        html = encodeHTML2(html.join(" > "));
        if (params.value) {
          html += " : " + encodeHTML2(params.value);
        }
        return html;
      } else {
        return GraphSeries.superApply(this, "formatTooltip", arguments);
      }
    },
    _updateCategoriesData: function() {
      var categories = zrUtil2.map(this.option.categories || [], function(category) {
        return category.value != null ? category : zrUtil2.extend({
          value: 0
        }, category);
      });
      var categoriesData = new List(["value"], this);
      categoriesData.initData(categories);
      this._categoriesData = categoriesData;
      this._categoriesModels = categoriesData.mapArray(function(idx) {
        return categoriesData.getItemModel(idx, true);
      });
    },
    setZoom: function(zoom) {
      this.option.zoom = zoom;
    },
    setCenter: function(center2) {
      this.option.center = center2;
    },
    isAnimationEnabled: function() {
      return GraphSeries.superCall(this, "isAnimationEnabled") && !(this.get("layout") === "force" && this.get("force.layoutAnimation"));
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: true,
      hoverAnimation: true,
      layout: null,
      focusNodeAdjacency: false,
      // Configuration of circular layout
      circular: {
        rotateLabel: false
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: true
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: false,
      roam: false,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: false,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }
  });
  var _default2 = GraphSeries;
  GraphSeries_1 = _default2;
  return GraphSeries_1;
}
var LinePath;
var hasRequiredLinePath;
function requireLinePath() {
  if (hasRequiredLinePath)
    return LinePath;
  hasRequiredLinePath = 1;
  var graphic2 = graphic$4;
  var vec22 = requireVector();
  var straightLineProto = graphic2.Line.prototype;
  var bezierCurveProto = graphic2.BezierCurve.prototype;
  function isLine(shape) {
    return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
  }
  var _default2 = graphic2.extendShape({
    type: "ec-line",
    style: {
      stroke: "#000",
      fill: null
    },
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      percent: 1,
      cpx1: null,
      cpy1: null
    },
    buildPath: function(ctx, shape) {
      this[isLine(shape) ? "_buildPathLine" : "_buildPathCurve"](ctx, shape);
    },
    _buildPathLine: straightLineProto.buildPath,
    _buildPathCurve: bezierCurveProto.buildPath,
    pointAt: function(t2) {
      return this[isLine(this.shape) ? "_pointAtLine" : "_pointAtCurve"](t2);
    },
    _pointAtLine: straightLineProto.pointAt,
    _pointAtCurve: bezierCurveProto.pointAt,
    tangentAt: function(t2) {
      var shape = this.shape;
      var p2 = isLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : this._tangentAtCurve(t2);
      return vec22.normalize(p2, p2);
    },
    _tangentAtCurve: bezierCurveProto.tangentAt
  });
  LinePath = _default2;
  return LinePath;
}
var Line_1;
var hasRequiredLine;
function requireLine() {
  if (hasRequiredLine)
    return Line_1;
  hasRequiredLine = 1;
  var zrUtil2 = util$6;
  var vector2 = requireVector();
  var symbolUtil = requireSymbol$1();
  var LinePath2 = requireLinePath();
  var graphic2 = graphic$4;
  var _number2 = requireNumber();
  var round2 = _number2.round;
  var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
  function makeSymbolTypeKey(symbolCategory) {
    return "_" + symbolCategory + "Type";
  }
  function createSymbol(name2, lineData, idx) {
    var symbolType = lineData.getItemVisual(idx, name2);
    if (!symbolType || symbolType === "none") {
      return;
    }
    var color2 = lineData.getItemVisual(idx, "color");
    var symbolSize = lineData.getItemVisual(idx, name2 + "Size");
    var symbolRotate = lineData.getItemVisual(idx, name2 + "Rotate");
    if (!zrUtil2.isArray(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    }
    var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color2);
    symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
    symbolPath.name = name2;
    return symbolPath;
  }
  function createLine(points2) {
    var line2 = new LinePath2({
      name: "line",
      subPixelOptimize: true
    });
    setLinePoints(line2.shape, points2);
    return line2;
  }
  function setLinePoints(targetShape, points2) {
    targetShape.x1 = points2[0][0];
    targetShape.y1 = points2[0][1];
    targetShape.x2 = points2[1][0];
    targetShape.y2 = points2[1][1];
    targetShape.percent = 1;
    var cp1 = points2[2];
    if (cp1) {
      targetShape.cpx1 = cp1[0];
      targetShape.cpy1 = cp1[1];
    } else {
      targetShape.cpx1 = NaN;
      targetShape.cpy1 = NaN;
    }
  }
  function updateSymbolAndLabelBeforeLineUpdate() {
    var lineGroup = this;
    var symbolFrom = lineGroup.childOfName("fromSymbol");
    var symbolTo = lineGroup.childOfName("toSymbol");
    var label = lineGroup.childOfName("label");
    if (!symbolFrom && !symbolTo && label.ignore) {
      return;
    }
    var invScale = 1;
    var parentNode = this.parent;
    while (parentNode) {
      if (parentNode.scale) {
        invScale /= parentNode.scale[0];
      }
      parentNode = parentNode.parent;
    }
    var line2 = lineGroup.childOfName("line");
    if (!this.__dirty && !line2.__dirty) {
      return;
    }
    var percent = line2.shape.percent;
    var fromPos = line2.pointAt(0);
    var toPos = line2.pointAt(percent);
    var d = vector2.sub([], toPos, fromPos);
    vector2.normalize(d, d);
    if (symbolFrom) {
      symbolFrom.attr("position", fromPos);
      var specifiedRotation = symbolFrom.__specifiedRotation;
      if (specifiedRotation == null) {
        var tangent = line2.tangentAt(0);
        symbolFrom.attr("rotation", Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      } else {
        symbolFrom.attr("rotation", specifiedRotation);
      }
      symbolFrom.attr("scale", [invScale * percent, invScale * percent]);
    }
    if (symbolTo) {
      symbolTo.attr("position", toPos);
      var specifiedRotation = symbolTo.__specifiedRotation;
      if (specifiedRotation == null) {
        var tangent = line2.tangentAt(1);
        symbolTo.attr("rotation", -Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      } else {
        symbolTo.attr("rotation", specifiedRotation);
      }
      symbolTo.attr("scale", [invScale * percent, invScale * percent]);
    }
    if (!label.ignore) {
      label.attr("position", toPos);
      var textPosition;
      var textAlign;
      var textVerticalAlign;
      var textOrigin;
      var distance = label.__labelDistance;
      var distanceX = distance[0] * invScale;
      var distanceY = distance[1] * invScale;
      var halfPercent = percent / 2;
      var tangent = line2.tangentAt(halfPercent);
      var n = [tangent[1], -tangent[0]];
      var cp = line2.pointAt(halfPercent);
      if (n[1] > 0) {
        n[0] = -n[0];
        n[1] = -n[1];
      }
      var dir = tangent[0] < 0 ? -1 : 1;
      if (label.__position !== "start" && label.__position !== "end") {
        var rotation = -Math.atan2(tangent[1], tangent[0]);
        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }
        label.attr("rotation", rotation);
      }
      var dy;
      switch (label.__position) {
        case "insideStartTop":
        case "insideMiddleTop":
        case "insideEndTop":
        case "middle":
          dy = -distanceY;
          textVerticalAlign = "bottom";
          break;
        case "insideStartBottom":
        case "insideMiddleBottom":
        case "insideEndBottom":
          dy = distanceY;
          textVerticalAlign = "top";
          break;
        default:
          dy = 0;
          textVerticalAlign = "middle";
      }
      switch (label.__position) {
        case "end":
          textPosition = [d[0] * distanceX + toPos[0], d[1] * distanceY + toPos[1]];
          textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
          textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
          break;
        case "start":
          textPosition = [-d[0] * distanceX + fromPos[0], -d[1] * distanceY + fromPos[1]];
          textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
          textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
          break;
        case "insideStartTop":
        case "insideStart":
        case "insideStartBottom":
          textPosition = [distanceX * dir + fromPos[0], fromPos[1] + dy];
          textAlign = tangent[0] < 0 ? "right" : "left";
          textOrigin = [-distanceX * dir, -dy];
          break;
        case "insideMiddleTop":
        case "insideMiddle":
        case "insideMiddleBottom":
        case "middle":
          textPosition = [cp[0], cp[1] + dy];
          textAlign = "center";
          textOrigin = [0, -dy];
          break;
        case "insideEndTop":
        case "insideEnd":
        case "insideEndBottom":
          textPosition = [-distanceX * dir + toPos[0], toPos[1] + dy];
          textAlign = tangent[0] >= 0 ? "right" : "left";
          textOrigin = [distanceX * dir, -dy];
          break;
      }
      label.attr({
        style: {
          // Use the user specified text align and baseline first
          textVerticalAlign: label.__verticalAlign || textVerticalAlign,
          textAlign: label.__textAlign || textAlign
        },
        position: textPosition,
        scale: [invScale, invScale],
        origin: textOrigin
      });
    }
  }
  function Line2(lineData, idx, seriesScope) {
    graphic2.Group.call(this);
    this._createLine(lineData, idx, seriesScope);
  }
  var lineProto = Line2.prototype;
  lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;
  lineProto._createLine = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var linePoints = lineData.getItemLayout(idx);
    var line2 = createLine(linePoints);
    line2.shape.percent = 0;
    graphic2.initProps(line2, {
      shape: {
        percent: 1
      }
    }, seriesModel, idx);
    this.add(line2);
    var label = new graphic2.Text({
      name: "label",
      // FIXME
      // Temporary solution for `focusNodeAdjacency`.
      // line label do not use the opacity of lineStyle.
      lineLabelOriginalOpacity: 1
    });
    this.add(label);
    zrUtil2.each(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbol2 = createSymbol(symbolCategory, lineData, idx);
      this.add(symbol2);
      this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  lineProto.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line2 = this.childOfName("line");
    var linePoints = lineData.getItemLayout(idx);
    var target = {
      shape: {}
    };
    setLinePoints(target.shape, linePoints);
    graphic2.updateProps(line2, target, seriesModel, idx);
    zrUtil2.each(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbolType = lineData.getItemVisual(idx, symbolCategory);
      var key = makeSymbolTypeKey(symbolCategory);
      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        var symbol2 = createSymbol(symbolCategory, lineData, idx);
        this.add(symbol2);
      }
      this[key] = symbolType;
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  lineProto._updateCommonStl = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line2 = this.childOfName("line");
    var lineStyle2 = seriesScope && seriesScope.lineStyle;
    var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
    var labelModel = seriesScope && seriesScope.labelModel;
    var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
    if (!seriesScope || lineData.hasItemOption) {
      var itemModel = lineData.getItemModel(idx);
      lineStyle2 = itemModel.getModel("lineStyle").getLineStyle();
      hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
      labelModel = itemModel.getModel("label");
      hoverLabelModel = itemModel.getModel("emphasis.label");
    }
    var visualColor = lineData.getItemVisual(idx, "color");
    var visualOpacity = zrUtil2.retrieve3(lineData.getItemVisual(idx, "opacity"), lineStyle2.opacity, 1);
    line2.useStyle(zrUtil2.defaults({
      strokeNoScale: true,
      fill: "none",
      stroke: visualColor,
      opacity: visualOpacity
    }, lineStyle2));
    line2.hoverStyle = hoverLineStyle;
    zrUtil2.each(SYMBOL_CATEGORIES, function(symbolCategory) {
      var symbol2 = this.childOfName(symbolCategory);
      if (symbol2) {
        symbol2.setColor(visualColor);
        symbol2.setStyle({
          opacity: visualOpacity
        });
      }
    }, this);
    var showLabel = labelModel.getShallow("show");
    var hoverShowLabel = hoverLabelModel.getShallow("show");
    var label = this.childOfName("label");
    var defaultLabelColor;
    var baseText;
    if (showLabel || hoverShowLabel) {
      defaultLabelColor = visualColor || "#000";
      baseText = seriesModel.getFormattedLabel(idx, "normal", lineData.dataType);
      if (baseText == null) {
        var rawVal = seriesModel.getRawValue(idx);
        baseText = rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round2(rawVal) : rawVal;
      }
    }
    var normalText = showLabel ? baseText : null;
    var emphasisText = hoverShowLabel ? zrUtil2.retrieve2(seriesModel.getFormattedLabel(idx, "emphasis", lineData.dataType), baseText) : null;
    var labelStyle = label.style;
    if (normalText != null || emphasisText != null) {
      graphic2.setTextStyle(label.style, labelModel, {
        text: normalText
      }, {
        autoColor: defaultLabelColor
      });
      label.__textAlign = labelStyle.textAlign;
      label.__verticalAlign = labelStyle.textVerticalAlign;
      label.__position = labelModel.get("position") || "middle";
      var distance = labelModel.get("distance");
      if (!zrUtil2.isArray(distance)) {
        distance = [distance, distance];
      }
      label.__labelDistance = distance;
    }
    if (emphasisText != null) {
      label.hoverStyle = {
        text: emphasisText,
        textFill: hoverLabelModel.getTextColor(true),
        // For merging hover style to normal style, do not use
        // `hoverLabelModel.getFont()` here.
        fontStyle: hoverLabelModel.getShallow("fontStyle"),
        fontWeight: hoverLabelModel.getShallow("fontWeight"),
        fontSize: hoverLabelModel.getShallow("fontSize"),
        fontFamily: hoverLabelModel.getShallow("fontFamily")
      };
    } else {
      label.hoverStyle = {
        text: null
      };
    }
    label.ignore = !showLabel && !hoverShowLabel;
    graphic2.setHoverStyle(this);
  };
  lineProto.highlight = function() {
    this.trigger("emphasis");
  };
  lineProto.downplay = function() {
    this.trigger("normal");
  };
  lineProto.updateLayout = function(lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  };
  lineProto.setLinePoints = function(points2) {
    var linePath = this.childOfName("line");
    setLinePoints(linePath.shape, points2);
    linePath.dirty();
  };
  zrUtil2.inherits(Line2, graphic2.Group);
  var _default2 = Line2;
  Line_1 = _default2;
  return Line_1;
}
var LineDraw_1;
var hasRequiredLineDraw;
function requireLineDraw() {
  if (hasRequiredLineDraw)
    return LineDraw_1;
  hasRequiredLineDraw = 1;
  var graphic2 = graphic$4;
  var LineGroup = requireLine();
  function LineDraw(ctor) {
    this._ctor = ctor || LineGroup;
    this.group = new graphic2.Group();
  }
  var lineDrawProto = LineDraw.prototype;
  lineDrawProto.isPersistent = function() {
    return true;
  };
  lineDrawProto.updateData = function(lineData) {
    var lineDraw = this;
    var group = lineDraw.group;
    var oldLineData = lineDraw._lineData;
    lineDraw._lineData = lineData;
    if (!oldLineData) {
      group.removeAll();
    }
    var seriesScope = makeSeriesScope(lineData);
    lineData.diff(oldLineData).add(function(idx) {
      doAdd(lineDraw, lineData, idx, seriesScope);
    }).update(function(newIdx, oldIdx) {
      doUpdate(lineDraw, oldLineData, lineData, oldIdx, newIdx, seriesScope);
    }).remove(function(idx) {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
  };
  function doAdd(lineDraw, lineData, idx, seriesScope) {
    var itemLayout = lineData.getItemLayout(idx);
    if (!lineNeedsDraw(itemLayout)) {
      return;
    }
    var el = new lineDraw._ctor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, el);
    lineDraw.group.add(el);
  }
  function doUpdate(lineDraw, oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
    var itemEl = oldLineData.getItemGraphicEl(oldIdx);
    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
      lineDraw.group.remove(itemEl);
      return;
    }
    if (!itemEl) {
      itemEl = new lineDraw._ctor(newLineData, newIdx, seriesScope);
    } else {
      itemEl.updateData(newLineData, newIdx, seriesScope);
    }
    newLineData.setItemGraphicEl(newIdx, itemEl);
    lineDraw.group.add(itemEl);
  }
  lineDrawProto.updateLayout = function() {
    var lineData = this._lineData;
    if (!lineData) {
      return;
    }
    lineData.eachItemGraphicEl(function(el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  };
  lineDrawProto.incrementalPrepareUpdate = function(lineData) {
    this._seriesScope = makeSeriesScope(lineData);
    this._lineData = null;
    this.group.removeAll();
  };
  function isEffectObject(el) {
    return el.animators && el.animators.length > 0;
  }
  lineDrawProto.incrementalUpdate = function(taskParams, lineData) {
    function updateIncrementalAndHover(el2) {
      if (!el2.isGroup && !isEffectObject(el2)) {
        el2.incremental = el2.useHoverLayer = true;
      }
    }
    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
      var itemLayout = lineData.getItemLayout(idx);
      if (lineNeedsDraw(itemLayout)) {
        var el = new this._ctor(lineData, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        this.group.add(el);
        lineData.setItemGraphicEl(idx, el);
      }
    }
  };
  function makeSeriesScope(lineData) {
    var hostModel = lineData.hostModel;
    return {
      lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
      hoverLineStyle: hostModel.getModel("emphasis.lineStyle").getLineStyle(),
      labelModel: hostModel.getModel("label"),
      hoverLabelModel: hostModel.getModel("emphasis.label")
    };
  }
  lineDrawProto.remove = function() {
    this._clearIncremental();
    this._incremental = null;
    this.group.removeAll();
  };
  lineDrawProto._clearIncremental = function() {
    var incremental = this._incremental;
    if (incremental) {
      incremental.clearDisplaybles();
    }
  };
  function isPointNaN(pt) {
    return isNaN(pt[0]) || isNaN(pt[1]);
  }
  function lineNeedsDraw(pts) {
    return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
  }
  var _default2 = LineDraw;
  LineDraw_1 = _default2;
  return LineDraw_1;
}
var graphHelper = {};
var hasRequiredGraphHelper;
function requireGraphHelper() {
  if (hasRequiredGraphHelper)
    return graphHelper;
  hasRequiredGraphHelper = 1;
  function getNodeGlobalScale(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys.type !== "view") {
      return 1;
    }
    var nodeScaleRatio = seriesModel.option.nodeScaleRatio;
    var groupScale = coordSys.scale;
    var groupZoom = groupScale && groupScale[0] || 1;
    var roamZoom = coordSys.getZoom();
    var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
    return nodeScale / groupZoom;
  }
  function getSymbolSize(node) {
    var symbolSize = node.getVisual("symbolSize");
    if (symbolSize instanceof Array) {
      symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
    }
    return +symbolSize;
  }
  graphHelper.getNodeGlobalScale = getNodeGlobalScale;
  graphHelper.getSymbolSize = getSymbolSize;
  return graphHelper;
}
var adjustEdge;
var hasRequiredAdjustEdge;
function requireAdjustEdge() {
  if (hasRequiredAdjustEdge)
    return adjustEdge;
  hasRequiredAdjustEdge = 1;
  var curveTool = curve$3;
  var vec22 = requireVector();
  var _graphHelper = requireGraphHelper();
  var getSymbolSize = _graphHelper.getSymbolSize;
  var v1 = [];
  var v2 = [];
  var v3 = [];
  var quadraticAt2 = curveTool.quadraticAt;
  var v2DistSquare2 = vec22.distSquare;
  var mathAbs2 = Math.abs;
  function intersectCurveCircle(curvePoints, center2, radius) {
    var p0 = curvePoints[0];
    var p1 = curvePoints[1];
    var p2 = curvePoints[2];
    var d = Infinity;
    var t2;
    var radiusSquare = radius * radius;
    var interval = 0.1;
    for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
      v1[0] = quadraticAt2(p0[0], p1[0], p2[0], _t);
      v1[1] = quadraticAt2(p0[1], p1[1], p2[1], _t);
      var diff2 = mathAbs2(v2DistSquare2(v1, center2) - radiusSquare);
      if (diff2 < d) {
        d = diff2;
        t2 = _t;
      }
    }
    for (var i = 0; i < 32; i++) {
      var next = t2 + interval;
      v2[0] = quadraticAt2(p0[0], p1[0], p2[0], t2);
      v2[1] = quadraticAt2(p0[1], p1[1], p2[1], t2);
      v3[0] = quadraticAt2(p0[0], p1[0], p2[0], next);
      v3[1] = quadraticAt2(p0[1], p1[1], p2[1], next);
      var diff2 = v2DistSquare2(v2, center2) - radiusSquare;
      if (mathAbs2(diff2) < 0.01) {
        break;
      }
      var nextDiff = v2DistSquare2(v3, center2) - radiusSquare;
      interval /= 2;
      if (diff2 < 0) {
        if (nextDiff >= 0) {
          t2 = t2 + interval;
        } else {
          t2 = t2 - interval;
        }
      } else {
        if (nextDiff >= 0) {
          t2 = t2 - interval;
        } else {
          t2 = t2 + interval;
        }
      }
    }
    return t2;
  }
  function _default2(graph2, scale) {
    var tmp0 = [];
    var quadraticSubdivide2 = curveTool.quadraticSubdivide;
    var pts = [[], [], []];
    var pts2 = [[], []];
    var v = [];
    scale /= 2;
    graph2.eachEdge(function(edge, idx) {
      var linePoints = edge.getLayout();
      var fromSymbol = edge.getVisual("fromSymbol");
      var toSymbol = edge.getVisual("toSymbol");
      if (!linePoints.__original) {
        linePoints.__original = [vec22.clone(linePoints[0]), vec22.clone(linePoints[1])];
        if (linePoints[2]) {
          linePoints.__original.push(vec22.clone(linePoints[2]));
        }
      }
      var originalPoints = linePoints.__original;
      if (linePoints[2] != null) {
        vec22.copy(pts[0], originalPoints[0]);
        vec22.copy(pts[1], originalPoints[2]);
        vec22.copy(pts[2], originalPoints[1]);
        if (fromSymbol && fromSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node1);
          var t2 = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale);
          quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t2, tmp0);
          pts[0][0] = tmp0[3];
          pts[1][0] = tmp0[4];
          quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t2, tmp0);
          pts[0][1] = tmp0[3];
          pts[1][1] = tmp0[4];
        }
        if (toSymbol && toSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node2);
          var t2 = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale);
          quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t2, tmp0);
          pts[1][0] = tmp0[1];
          pts[2][0] = tmp0[2];
          quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t2, tmp0);
          pts[1][1] = tmp0[1];
          pts[2][1] = tmp0[2];
        }
        vec22.copy(linePoints[0], pts[0]);
        vec22.copy(linePoints[1], pts[2]);
        vec22.copy(linePoints[2], pts[1]);
      } else {
        vec22.copy(pts2[0], originalPoints[0]);
        vec22.copy(pts2[1], originalPoints[1]);
        vec22.sub(v, pts2[1], pts2[0]);
        vec22.normalize(v, v);
        if (fromSymbol && fromSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node1);
          vec22.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);
        }
        if (toSymbol && toSymbol !== "none") {
          var symbolSize = getSymbolSize(edge.node2);
          vec22.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);
        }
        vec22.copy(linePoints[0], pts2[0]);
        vec22.copy(linePoints[1], pts2[1]);
      }
    });
  }
  adjustEdge = _default2;
  return adjustEdge;
}
var GraphView;
var hasRequiredGraphView;
function requireGraphView() {
  if (hasRequiredGraphView)
    return GraphView;
  hasRequiredGraphView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var SymbolDraw = requireSymbolDraw();
  var LineDraw = requireLineDraw();
  var RoamController = requireRoamController();
  var roamHelper2 = requireRoamHelper$1();
  var _cursorHelper = requireCursorHelper();
  var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
  var graphic2 = graphic$4;
  var adjustEdge2 = requireAdjustEdge();
  var _graphHelper = requireGraphHelper();
  var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;
  var FOCUS_ADJACENCY = "__focusNodeAdjacency";
  var UNFOCUS_ADJACENCY = "__unfocusNodeAdjacency";
  var nodeOpacityPath = ["itemStyle", "opacity"];
  var lineOpacityPath = ["lineStyle", "opacity"];
  function getItemOpacity(item, opacityPath) {
    var opacity = item.getVisual("opacity");
    return opacity != null ? opacity : item.getModel().get(opacityPath);
  }
  function fadeOutItem(item, opacityPath, opacityRatio) {
    var el = item.getGraphicEl();
    var opacity = getItemOpacity(item, opacityPath);
    if (opacityRatio != null) {
      opacity == null && (opacity = 1);
      opacity *= opacityRatio;
    }
    el.downplay && el.downplay();
    el.traverse(function(child) {
      if (!child.isGroup) {
        var opct = child.lineLabelOriginalOpacity;
        if (opct == null || opacityRatio != null) {
          opct = opacity;
        }
        child.setStyle("opacity", opct);
      }
    });
  }
  function fadeInItem(item, opacityPath) {
    var opacity = getItemOpacity(item, opacityPath);
    var el = item.getGraphicEl();
    el.traverse(function(child) {
      !child.isGroup && child.setStyle("opacity", opacity);
    });
    el.highlight && el.highlight();
  }
  var _default2 = echarts$12.extendChartView({
    type: "graph",
    init: function(ecModel, api) {
      var symbolDraw = new SymbolDraw();
      var lineDraw = new LineDraw();
      var group = this.group;
      this._controller = new RoamController(api.getZr());
      this._controllerHost = {
        target: group
      };
      group.add(symbolDraw.group);
      group.add(lineDraw.group);
      this._symbolDraw = symbolDraw;
      this._lineDraw = lineDraw;
      this._firstRender = true;
    },
    render: function(seriesModel, ecModel, api) {
      var graphView = this;
      var coordSys = seriesModel.coordinateSystem;
      this._model = seriesModel;
      var symbolDraw = this._symbolDraw;
      var lineDraw = this._lineDraw;
      var group = this.group;
      if (coordSys.type === "view") {
        var groupNewProp = {
          position: coordSys.position,
          scale: coordSys.scale
        };
        if (this._firstRender) {
          group.attr(groupNewProp);
        } else {
          graphic2.updateProps(group, groupNewProp, seriesModel);
        }
      }
      adjustEdge2(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
      var data = seriesModel.getData();
      symbolDraw.updateData(data);
      var edgeData = seriesModel.getEdgeData();
      lineDraw.updateData(edgeData);
      this._updateNodeAndLinkScale();
      this._updateController(seriesModel, ecModel, api);
      clearTimeout(this._layoutTimeout);
      var forceLayout = seriesModel.forceLayout;
      var layoutAnimation = seriesModel.get("force.layoutAnimation");
      if (forceLayout) {
        this._startForceLayoutIteration(forceLayout, layoutAnimation);
      }
      data.eachItemGraphicEl(function(el, idx) {
        var itemModel = data.getItemModel(idx);
        el.off("drag").off("dragend");
        var draggable = itemModel.get("draggable");
        if (draggable) {
          el.on("drag", function() {
            if (forceLayout) {
              forceLayout.warmUp();
              !this._layouting && this._startForceLayoutIteration(forceLayout, layoutAnimation);
              forceLayout.setFixed(idx);
              data.setItemLayout(idx, el.position);
            }
          }, this).on("dragend", function() {
            if (forceLayout) {
              forceLayout.setUnfixed(idx);
            }
          }, this);
        }
        el.setDraggable(draggable && forceLayout);
        el[FOCUS_ADJACENCY] && el.off("mouseover", el[FOCUS_ADJACENCY]);
        el[UNFOCUS_ADJACENCY] && el.off("mouseout", el[UNFOCUS_ADJACENCY]);
        if (itemModel.get("focusNodeAdjacency")) {
          el.on("mouseover", el[FOCUS_ADJACENCY] = function() {
            graphView._clearTimer();
            api.dispatchAction({
              type: "focusNodeAdjacency",
              seriesId: seriesModel.id,
              dataIndex: el.dataIndex
            });
          });
          el.on("mouseout", el[UNFOCUS_ADJACENCY] = function() {
            graphView._dispatchUnfocus(api);
          });
        }
      }, this);
      data.graph.eachEdge(function(edge) {
        var el = edge.getGraphicEl();
        el[FOCUS_ADJACENCY] && el.off("mouseover", el[FOCUS_ADJACENCY]);
        el[UNFOCUS_ADJACENCY] && el.off("mouseout", el[UNFOCUS_ADJACENCY]);
        if (edge.getModel().get("focusNodeAdjacency")) {
          el.on("mouseover", el[FOCUS_ADJACENCY] = function() {
            graphView._clearTimer();
            api.dispatchAction({
              type: "focusNodeAdjacency",
              seriesId: seriesModel.id,
              edgeDataIndex: edge.dataIndex
            });
          });
          el.on("mouseout", el[UNFOCUS_ADJACENCY] = function() {
            graphView._dispatchUnfocus(api);
          });
        }
      });
      var circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get("circular.rotateLabel");
      var cx = data.getLayout("cx");
      var cy = data.getLayout("cy");
      data.eachItemGraphicEl(function(el, idx) {
        var itemModel = data.getItemModel(idx);
        var labelRotate = itemModel.get("label.rotate") || 0;
        var symbolPath = el.getSymbolPath();
        if (circularRotateLabel) {
          var pos = data.getItemLayout(idx);
          var rad = Math.atan2(pos[1] - cy, pos[0] - cx);
          if (rad < 0) {
            rad = Math.PI * 2 + rad;
          }
          var isLeft = pos[0] < cx;
          if (isLeft) {
            rad = rad - Math.PI;
          }
          var textPosition = isLeft ? "left" : "right";
          graphic2.modifyLabelStyle(symbolPath, {
            textRotation: -rad,
            textPosition,
            textOrigin: "center"
          }, {
            textPosition
          });
        } else {
          graphic2.modifyLabelStyle(symbolPath, {
            textRotation: labelRotate *= Math.PI / 180
          });
        }
      });
      this._firstRender = false;
    },
    dispose: function() {
      this._controller && this._controller.dispose();
      this._controllerHost = {};
      this._clearTimer();
    },
    _dispatchUnfocus: function(api, opt) {
      var self2 = this;
      this._clearTimer();
      this._unfocusDelayTimer = setTimeout(function() {
        self2._unfocusDelayTimer = null;
        api.dispatchAction({
          type: "unfocusNodeAdjacency",
          seriesId: self2._model.id
        });
      }, 500);
    },
    _clearTimer: function() {
      if (this._unfocusDelayTimer) {
        clearTimeout(this._unfocusDelayTimer);
        this._unfocusDelayTimer = null;
      }
    },
    focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var graph2 = data.graph;
      var dataIndex = payload.dataIndex;
      var edgeDataIndex = payload.edgeDataIndex;
      var node = graph2.getNodeByIndex(dataIndex);
      var edge = graph2.getEdgeByIndex(edgeDataIndex);
      if (!node && !edge) {
        return;
      }
      graph2.eachNode(function(node2) {
        fadeOutItem(node2, nodeOpacityPath, 0.1);
      });
      graph2.eachEdge(function(edge2) {
        fadeOutItem(edge2, lineOpacityPath, 0.1);
      });
      if (node) {
        fadeInItem(node, nodeOpacityPath);
        zrUtil2.each(node.edges, function(adjacentEdge) {
          if (adjacentEdge.dataIndex < 0) {
            return;
          }
          fadeInItem(adjacentEdge, lineOpacityPath);
          fadeInItem(adjacentEdge.node1, nodeOpacityPath);
          fadeInItem(adjacentEdge.node2, nodeOpacityPath);
        });
      }
      if (edge) {
        fadeInItem(edge, lineOpacityPath);
        fadeInItem(edge.node1, nodeOpacityPath);
        fadeInItem(edge.node2, nodeOpacityPath);
      }
    },
    unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
      var graph2 = seriesModel.getData().graph;
      graph2.eachNode(function(node) {
        fadeOutItem(node, nodeOpacityPath);
      });
      graph2.eachEdge(function(edge) {
        fadeOutItem(edge, lineOpacityPath);
      });
    },
    _startForceLayoutIteration: function(forceLayout, layoutAnimation) {
      var self2 = this;
      (function step() {
        forceLayout.step(function(stopped) {
          self2.updateLayout(self2._model);
          (self2._layouting = !stopped) && (layoutAnimation ? self2._layoutTimeout = setTimeout(step, 16) : step());
        });
      })();
    },
    _updateController: function(seriesModel, ecModel, api) {
      var controller = this._controller;
      var controllerHost = this._controllerHost;
      var group = this.group;
      controller.setPointerChecker(function(e2, x, y) {
        var rect = group.getBoundingRect();
        rect.applyTransform(group.transform);
        return rect.contain(x, y) && !onIrrelevantElement(e2, api, seriesModel);
      });
      if (seriesModel.coordinateSystem.type !== "view") {
        controller.disable();
        return;
      }
      controller.enable(seriesModel.get("roam"));
      controllerHost.zoomLimit = seriesModel.get("scaleLimit");
      controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
      controller.off("pan").off("zoom").on("pan", function(e2) {
        roamHelper2.updateViewOnPan(controllerHost, e2.dx, e2.dy);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "graphRoam",
          dx: e2.dx,
          dy: e2.dy
        });
      }).on("zoom", function(e2) {
        roamHelper2.updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
        api.dispatchAction({
          seriesId: seriesModel.id,
          type: "graphRoam",
          zoom: e2.scale,
          originX: e2.originX,
          originY: e2.originY
        });
        this._updateNodeAndLinkScale();
        adjustEdge2(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
        this._lineDraw.updateLayout();
      }, this);
    },
    _updateNodeAndLinkScale: function() {
      var seriesModel = this._model;
      var data = seriesModel.getData();
      var nodeScale = getNodeGlobalScale(seriesModel);
      var invScale = [nodeScale, nodeScale];
      data.eachItemGraphicEl(function(el, idx) {
        el.attr("scale", invScale);
      });
    },
    updateLayout: function(seriesModel) {
      adjustEdge2(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
      this._symbolDraw.updateLayout();
      this._lineDraw.updateLayout();
    },
    remove: function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove();
      this._lineDraw && this._lineDraw.remove();
    }
  });
  GraphView = _default2;
  return GraphView;
}
var graphAction = {};
var focusNodeAdjacencyAction = {};
var hasRequiredFocusNodeAdjacencyAction;
function requireFocusNodeAdjacencyAction() {
  if (hasRequiredFocusNodeAdjacencyAction)
    return focusNodeAdjacencyAction;
  hasRequiredFocusNodeAdjacencyAction = 1;
  var echarts$12 = echarts;
  echarts$12.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, function() {
  });
  echarts$12.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, function() {
  });
  return focusNodeAdjacencyAction;
}
var hasRequiredGraphAction;
function requireGraphAction() {
  if (hasRequiredGraphAction)
    return graphAction;
  hasRequiredGraphAction = 1;
  var echarts$12 = echarts;
  var _roamHelper = requireRoamHelper();
  var updateCenterAndZoom = _roamHelper.updateCenterAndZoom;
  requireFocusNodeAdjacencyAction();
  var actionInfo = {
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  };
  echarts$12.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      query: payload
    }, function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var res = updateCenterAndZoom(coordSys, payload);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
  return graphAction;
}
var categoryFilter;
var hasRequiredCategoryFilter;
function requireCategoryFilter() {
  if (hasRequiredCategoryFilter)
    return categoryFilter;
  hasRequiredCategoryFilter = 1;
  function _default2(ecModel) {
    var legendModels = ecModel.findComponents({
      mainType: "legend"
    });
    if (!legendModels || !legendModels.length) {
      return;
    }
    ecModel.eachSeriesByType("graph", function(graphSeries) {
      var categoriesData = graphSeries.getCategoriesData();
      var graph2 = graphSeries.getGraph();
      var data = graph2.data;
      var categoryNames = categoriesData.mapArray(categoriesData.getName);
      data.filterSelf(function(idx) {
        var model2 = data.getItemModel(idx);
        var category = model2.getShallow("category");
        if (category != null) {
          if (typeof category === "number") {
            category = categoryNames[category];
          }
          for (var i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(category)) {
              return false;
            }
          }
        }
        return true;
      });
    }, this);
  }
  categoryFilter = _default2;
  return categoryFilter;
}
var categoryVisual;
var hasRequiredCategoryVisual;
function requireCategoryVisual() {
  if (hasRequiredCategoryVisual)
    return categoryVisual;
  hasRequiredCategoryVisual = 1;
  function _default2(ecModel) {
    var paletteScope = {};
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var categoriesData = seriesModel.getCategoriesData();
      var data = seriesModel.getData();
      var categoryNameIdxMap = {};
      categoriesData.each(function(idx) {
        var name2 = categoriesData.getName(idx);
        categoryNameIdxMap["ec-" + name2] = idx;
        var itemModel = categoriesData.getItemModel(idx);
        var color2 = itemModel.get("itemStyle.color") || seriesModel.getColorFromPalette(name2, paletteScope);
        categoriesData.setItemVisual(idx, "color", color2);
        var itemStyleList = ["opacity", "symbol", "symbolSize", "symbolKeepAspect"];
        for (var i = 0; i < itemStyleList.length; i++) {
          var itemStyle2 = itemModel.getShallow(itemStyleList[i], true);
          if (itemStyle2 != null) {
            categoriesData.setItemVisual(idx, itemStyleList[i], itemStyle2);
          }
        }
      });
      if (categoriesData.count()) {
        data.each(function(idx) {
          var model2 = data.getItemModel(idx);
          var category = model2.getShallow("category");
          if (category != null) {
            if (typeof category === "string") {
              category = categoryNameIdxMap["ec-" + category];
            }
            var itemStyleList = ["color", "opacity", "symbol", "symbolSize", "symbolKeepAspect"];
            for (var i = 0; i < itemStyleList.length; i++) {
              if (data.getItemVisual(idx, itemStyleList[i], true) == null) {
                data.setItemVisual(idx, itemStyleList[i], categoriesData.getItemVisual(category, itemStyleList[i]));
              }
            }
          }
        });
      }
    });
  }
  categoryVisual = _default2;
  return categoryVisual;
}
var edgeVisual;
var hasRequiredEdgeVisual;
function requireEdgeVisual() {
  if (hasRequiredEdgeVisual)
    return edgeVisual;
  hasRequiredEdgeVisual = 1;
  function normalize(a) {
    if (!(a instanceof Array)) {
      a = [a, a];
    }
    return a;
  }
  function _default2(ecModel) {
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var graph2 = seriesModel.getGraph();
      var edgeData = seriesModel.getEdgeData();
      var symbolType = normalize(seriesModel.get("edgeSymbol"));
      var symbolSize = normalize(seriesModel.get("edgeSymbolSize"));
      var colorQuery = "lineStyle.color".split(".");
      var opacityQuery = "lineStyle.opacity".split(".");
      edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
      edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
      edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
      edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
      edgeData.setVisual("color", seriesModel.get(colorQuery));
      edgeData.setVisual("opacity", seriesModel.get(opacityQuery));
      edgeData.each(function(idx) {
        var itemModel = edgeData.getItemModel(idx);
        var edge = graph2.getEdgeByIndex(idx);
        var symbolType2 = normalize(itemModel.getShallow("symbol", true));
        var symbolSize2 = normalize(itemModel.getShallow("symbolSize", true));
        var color2 = itemModel.get(colorQuery);
        var opacity = itemModel.get(opacityQuery);
        switch (color2) {
          case "source":
            color2 = edge.node1.getVisual("color");
            break;
          case "target":
            color2 = edge.node2.getVisual("color");
            break;
        }
        symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
        symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
        symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
        symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
        edge.setVisual("color", color2);
        edge.setVisual("opacity", opacity);
      });
    });
  }
  edgeVisual = _default2;
  return edgeVisual;
}
var simpleLayoutHelper = {};
var hasRequiredSimpleLayoutHelper;
function requireSimpleLayoutHelper() {
  if (hasRequiredSimpleLayoutHelper)
    return simpleLayoutHelper;
  hasRequiredSimpleLayoutHelper = 1;
  var vec22 = requireVector();
  var zrUtil2 = util$6;
  var _multipleGraphEdgeHelper = requireMultipleGraphEdgeHelper();
  var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
  function simpleLayout(seriesModel) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    var graph2 = seriesModel.getGraph();
    graph2.eachNode(function(node) {
      var model2 = node.getModel();
      node.setLayout([+model2.get("x"), +model2.get("y")]);
    });
    simpleLayoutEdge(graph2, seriesModel);
  }
  function simpleLayoutEdge(graph2, seriesModel) {
    graph2.eachEdge(function(edge, index2) {
      var curveness = zrUtil2.retrieve3(edge.getModel().get("lineStyle.curveness"), -getCurvenessForEdge(edge, seriesModel, index2, true), 0);
      var p1 = vec22.clone(edge.node1.getLayout());
      var p2 = vec22.clone(edge.node2.getLayout());
      var points2 = [p1, p2];
      if (+curveness) {
        points2.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness]);
      }
      edge.setLayout(points2);
    });
  }
  simpleLayoutHelper.simpleLayout = simpleLayout;
  simpleLayoutHelper.simpleLayoutEdge = simpleLayoutEdge;
  return simpleLayoutHelper;
}
var simpleLayout_1;
var hasRequiredSimpleLayout;
function requireSimpleLayout() {
  if (hasRequiredSimpleLayout)
    return simpleLayout_1;
  hasRequiredSimpleLayout = 1;
  var _util2 = util$6;
  var each2 = _util2.each;
  var _simpleLayoutHelper = requireSimpleLayoutHelper();
  var simpleLayout = _simpleLayoutHelper.simpleLayout;
  var simpleLayoutEdge = _simpleLayoutHelper.simpleLayoutEdge;
  function _default2(ecModel, api) {
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var layout2 = seriesModel.get("layout");
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        var data = seriesModel.getData();
        var dimensions = [];
        each2(coordSys.dimensions, function(coordDim) {
          dimensions = dimensions.concat(data.mapDimension(coordDim, true));
        });
        for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
          var value = [];
          var hasValue = false;
          for (var i = 0; i < dimensions.length; i++) {
            var val = data.get(dimensions[i], dataIndex);
            if (!isNaN(val)) {
              hasValue = true;
            }
            value.push(val);
          }
          if (hasValue) {
            data.setItemLayout(dataIndex, coordSys.dataToPoint(value));
          } else {
            data.setItemLayout(dataIndex, [NaN, NaN]);
          }
        }
        simpleLayoutEdge(data.graph, seriesModel);
      } else if (!layout2 || layout2 === "none") {
        simpleLayout(seriesModel);
      }
    });
  }
  simpleLayout_1 = _default2;
  return simpleLayout_1;
}
var circularLayoutHelper = {};
var hasRequiredCircularLayoutHelper;
function requireCircularLayoutHelper() {
  if (hasRequiredCircularLayoutHelper)
    return circularLayoutHelper;
  hasRequiredCircularLayoutHelper = 1;
  var vec22 = requireVector();
  var _graphHelper = requireGraphHelper();
  var getSymbolSize = _graphHelper.getSymbolSize;
  var getNodeGlobalScale = _graphHelper.getNodeGlobalScale;
  var zrUtil2 = util$6;
  var _multipleGraphEdgeHelper = requireMultipleGraphEdgeHelper();
  var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
  var PI3 = Math.PI;
  var _symbolRadiansHalf = [];
  function circularLayout(seriesModel, basedOn) {
    var coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    var rect = coordSys.getBoundingRect();
    var nodeData = seriesModel.getData();
    var graph2 = nodeData.graph;
    var cx = rect.width / 2 + rect.x;
    var cy = rect.height / 2 + rect.y;
    var r = Math.min(rect.width, rect.height) / 2;
    var count = nodeData.count();
    nodeData.setLayout({
      cx,
      cy
    });
    if (!count) {
      return;
    }
    _layoutNodesBasedOn[basedOn](seriesModel, coordSys, graph2, nodeData, r, cx, cy, count);
    graph2.eachEdge(function(edge, index2) {
      var curveness = zrUtil2.retrieve3(edge.getModel().get("lineStyle.curveness"), getCurvenessForEdge(edge, seriesModel, index2), 0);
      var p1 = vec22.clone(edge.node1.getLayout());
      var p2 = vec22.clone(edge.node2.getLayout());
      var cp1;
      var x12 = (p1[0] + p2[0]) / 2;
      var y12 = (p1[1] + p2[1]) / 2;
      if (+curveness) {
        curveness *= 3;
        cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)];
      }
      edge.setLayout([p1, p2, cp1]);
    });
  }
  var _layoutNodesBasedOn = {
    value: function(seriesModel, coordSys, graph2, nodeData, r, cx, cy, count) {
      var angle = 0;
      var sum = nodeData.getSum("value");
      var unitAngle = Math.PI * 2 / (sum || count);
      graph2.eachNode(function(node) {
        var value = node.getValue("value");
        var radianHalf = unitAngle * (sum ? value : 1) / 2;
        angle += radianHalf;
        node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
        angle += radianHalf;
      });
    },
    symbolSize: function(seriesModel, coordSys, graph2, nodeData, r, cx, cy, count) {
      var sumRadian = 0;
      _symbolRadiansHalf.length = count;
      var nodeScale = getNodeGlobalScale(seriesModel);
      graph2.eachNode(function(node) {
        var symbolSize = getSymbolSize(node);
        isNaN(symbolSize) && (symbolSize = 2);
        symbolSize < 0 && (symbolSize = 0);
        symbolSize *= nodeScale;
        var symbolRadianHalf = Math.asin(symbolSize / 2 / r);
        isNaN(symbolRadianHalf) && (symbolRadianHalf = PI3 / 2);
        _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
        sumRadian += symbolRadianHalf * 2;
      });
      var halfRemainRadian = (2 * PI3 - sumRadian) / count / 2;
      var angle = 0;
      graph2.eachNode(function(node) {
        var radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
        angle += radianHalf;
        node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy]);
        angle += radianHalf;
      });
    }
  };
  circularLayoutHelper.circularLayout = circularLayout;
  return circularLayoutHelper;
}
var circularLayout_1;
var hasRequiredCircularLayout;
function requireCircularLayout() {
  if (hasRequiredCircularLayout)
    return circularLayout_1;
  hasRequiredCircularLayout = 1;
  var _circularLayoutHelper = requireCircularLayoutHelper();
  var circularLayout = _circularLayoutHelper.circularLayout;
  function _default2(ecModel) {
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      if (seriesModel.get("layout") === "circular") {
        circularLayout(seriesModel, "symbolSize");
      }
    });
  }
  circularLayout_1 = _default2;
  return circularLayout_1;
}
var forceHelper = {};
var hasRequiredForceHelper;
function requireForceHelper() {
  if (hasRequiredForceHelper)
    return forceHelper;
  hasRequiredForceHelper = 1;
  var vec22 = requireVector();
  var scaleAndAdd = vec22.scaleAndAdd;
  function forceLayout(nodes, edges, opts) {
    var rect = opts.rect;
    var width = rect.width;
    var height = rect.height;
    var center2 = [rect.x + width / 2, rect.y + height / 2];
    var gravity = opts.gravity == null ? 0.1 : opts.gravity;
    for (var i = 0; i < nodes.length; i++) {
      var n = nodes[i];
      if (!n.p) {
        n.p = vec22.create(width * (Math.random() - 0.5) + center2[0], height * (Math.random() - 0.5) + center2[1]);
      }
      n.pp = vec22.clone(n.p);
      n.edges = null;
    }
    var initialFriction = opts.friction == null ? 0.6 : opts.friction;
    var friction = initialFriction;
    return {
      warmUp: function() {
        friction = initialFriction * 0.8;
      },
      setFixed: function(idx) {
        nodes[idx].fixed = true;
      },
      setUnfixed: function(idx) {
        nodes[idx].fixed = false;
      },
      /**
       * Some formulas were originally copied from "d3.js"
       * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
       * with some modifications made for this project.
       * See the license statement at the head of this file.
       */
      step: function(cb) {
        var v12 = [];
        var nLen = nodes.length;
        for (var i2 = 0; i2 < edges.length; i2++) {
          var e2 = edges[i2];
          if (e2.ignoreForceLayout) {
            continue;
          }
          var n1 = e2.n1;
          var n2 = e2.n2;
          vec22.sub(v12, n2.p, n1.p);
          var d = vec22.len(v12) - e2.d;
          var w = n2.w / (n1.w + n2.w);
          if (isNaN(w)) {
            w = 0;
          }
          vec22.normalize(v12, v12);
          !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
          !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
        }
        for (var i2 = 0; i2 < nLen; i2++) {
          var n3 = nodes[i2];
          if (!n3.fixed) {
            vec22.sub(v12, center2, n3.p);
            scaleAndAdd(n3.p, n3.p, v12, gravity * friction);
          }
        }
        for (var i2 = 0; i2 < nLen; i2++) {
          var n1 = nodes[i2];
          for (var j = i2 + 1; j < nLen; j++) {
            var n2 = nodes[j];
            vec22.sub(v12, n2.p, n1.p);
            var d = vec22.len(v12);
            if (d === 0) {
              vec22.set(v12, Math.random() - 0.5, Math.random() - 0.5);
              d = 1;
            }
            var repFact = (n1.rep + n2.rep) / d / d;
            !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
            !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
          }
        }
        var v = [];
        for (var i2 = 0; i2 < nLen; i2++) {
          var n3 = nodes[i2];
          if (!n3.fixed) {
            vec22.sub(v, n3.p, n3.pp);
            scaleAndAdd(n3.p, n3.p, v, friction);
            vec22.copy(n3.pp, n3.p);
          }
        }
        friction = friction * 0.992;
        cb && cb(nodes, edges, friction < 0.01);
      }
    };
  }
  forceHelper.forceLayout = forceLayout;
  return forceHelper;
}
var forceLayout_1;
var hasRequiredForceLayout;
function requireForceLayout() {
  if (hasRequiredForceLayout)
    return forceLayout_1;
  hasRequiredForceLayout = 1;
  var _forceHelper = requireForceHelper();
  var forceLayout = _forceHelper.forceLayout;
  var _simpleLayoutHelper = requireSimpleLayoutHelper();
  var simpleLayout = _simpleLayoutHelper.simpleLayout;
  var _circularLayoutHelper = requireCircularLayoutHelper();
  var circularLayout = _circularLayoutHelper.circularLayout;
  var _number2 = requireNumber();
  var linearMap = _number2.linearMap;
  var vec22 = requireVector();
  var zrUtil2 = util$6;
  var _multipleGraphEdgeHelper = requireMultipleGraphEdgeHelper();
  var getCurvenessForEdge = _multipleGraphEdgeHelper.getCurvenessForEdge;
  function _default2(ecModel) {
    ecModel.eachSeriesByType("graph", function(graphSeries) {
      var coordSys = graphSeries.coordinateSystem;
      if (coordSys && coordSys.type !== "view") {
        return;
      }
      if (graphSeries.get("layout") === "force") {
        var preservedPoints = graphSeries.preservedPoints || {};
        var graph2 = graphSeries.getGraph();
        var nodeData = graph2.data;
        var edgeData = graph2.edgeData;
        var forceModel = graphSeries.getModel("force");
        var initLayout = forceModel.get("initLayout");
        if (graphSeries.preservedPoints) {
          nodeData.each(function(idx) {
            var id = nodeData.getId(idx);
            nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
          });
        } else if (!initLayout || initLayout === "none") {
          simpleLayout(graphSeries);
        } else if (initLayout === "circular") {
          circularLayout(graphSeries, "value");
        }
        var nodeDataExtent = nodeData.getDataExtent("value");
        var edgeDataExtent = edgeData.getDataExtent("value");
        var repulsion = forceModel.get("repulsion");
        var edgeLength = forceModel.get("edgeLength");
        if (!zrUtil2.isArray(repulsion)) {
          repulsion = [repulsion, repulsion];
        }
        if (!zrUtil2.isArray(edgeLength)) {
          edgeLength = [edgeLength, edgeLength];
        }
        edgeLength = [edgeLength[1], edgeLength[0]];
        var nodes = nodeData.mapArray("value", function(value, idx) {
          var point = nodeData.getItemLayout(idx);
          var rep = linearMap(value, nodeDataExtent, repulsion);
          if (isNaN(rep)) {
            rep = (repulsion[0] + repulsion[1]) / 2;
          }
          return {
            w: rep,
            rep,
            fixed: nodeData.getItemModel(idx).get("fixed"),
            p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
          };
        });
        var edges = edgeData.mapArray("value", function(value, idx) {
          var edge = graph2.getEdgeByIndex(idx);
          var d = linearMap(value, edgeDataExtent, edgeLength);
          if (isNaN(d)) {
            d = (edgeLength[0] + edgeLength[1]) / 2;
          }
          var edgeModel = edge.getModel();
          var curveness = zrUtil2.retrieve3(edgeModel.get("lineStyle.curveness"), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
          return {
            n1: nodes[edge.node1.dataIndex],
            n2: nodes[edge.node2.dataIndex],
            d,
            curveness,
            ignoreForceLayout: edgeModel.get("ignoreForceLayout")
          };
        });
        var coordSys = graphSeries.coordinateSystem;
        var rect = coordSys.getBoundingRect();
        var forceInstance = forceLayout(nodes, edges, {
          rect,
          gravity: forceModel.get("gravity"),
          friction: forceModel.get("friction")
        });
        var oldStep = forceInstance.step;
        forceInstance.step = function(cb) {
          for (var i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].fixed) {
              vec22.copy(nodes[i].p, graph2.getNodeByIndex(i).getLayout());
            }
          }
          oldStep(function(nodes2, edges2, stopped) {
            for (var i2 = 0, l2 = nodes2.length; i2 < l2; i2++) {
              if (!nodes2[i2].fixed) {
                graph2.getNodeByIndex(i2).setLayout(nodes2[i2].p);
              }
              preservedPoints[nodeData.getId(i2)] = nodes2[i2].p;
            }
            for (var i2 = 0, l2 = edges2.length; i2 < l2; i2++) {
              var e2 = edges2[i2];
              var edge = graph2.getEdgeByIndex(i2);
              var p1 = e2.n1.p;
              var p2 = e2.n2.p;
              var points2 = edge.getLayout();
              points2 = points2 ? points2.slice() : [];
              points2[0] = points2[0] || [];
              points2[1] = points2[1] || [];
              vec22.copy(points2[0], p1);
              vec22.copy(points2[1], p2);
              if (+e2.curveness) {
                points2[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e2.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e2.curveness];
              }
              edge.setLayout(points2);
            }
            cb && cb(stopped);
          });
        };
        graphSeries.forceLayout = forceInstance;
        graphSeries.preservedPoints = preservedPoints;
        forceInstance.step();
      } else {
        graphSeries.forceLayout = null;
      }
    });
  }
  forceLayout_1 = _default2;
  return forceLayout_1;
}
var createView;
var hasRequiredCreateView;
function requireCreateView() {
  if (hasRequiredCreateView)
    return createView;
  hasRequiredCreateView = 1;
  var View = requireView();
  var _layout2 = layout$1;
  var getLayoutRect2 = _layout2.getLayoutRect;
  var bbox2 = requireBbox();
  function getViewRect(seriesModel, api, aspect) {
    var option = seriesModel.getBoxLayoutParams();
    option.aspect = aspect;
    return getLayoutRect2(option, {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function _default2(ecModel, api) {
    var viewList = [];
    ecModel.eachSeriesByType("graph", function(seriesModel) {
      var coordSysType = seriesModel.get("coordinateSystem");
      if (!coordSysType || coordSysType === "view") {
        var data = seriesModel.getData();
        var positions = data.mapArray(function(idx) {
          var itemModel = data.getItemModel(idx);
          return [+itemModel.get("x"), +itemModel.get("y")];
        });
        var min3 = [];
        var max3 = [];
        bbox2.fromPoints(positions, min3, max3);
        if (max3[0] - min3[0] === 0) {
          max3[0] += 1;
          min3[0] -= 1;
        }
        if (max3[1] - min3[1] === 0) {
          max3[1] += 1;
          min3[1] -= 1;
        }
        var aspect = (max3[0] - min3[0]) / (max3[1] - min3[1]);
        var viewRect2 = getViewRect(seriesModel, api, aspect);
        if (isNaN(aspect)) {
          min3 = [viewRect2.x, viewRect2.y];
          max3 = [viewRect2.x + viewRect2.width, viewRect2.y + viewRect2.height];
        }
        var bbWidth = max3[0] - min3[0];
        var bbHeight = max3[1] - min3[1];
        var viewWidth = viewRect2.width;
        var viewHeight = viewRect2.height;
        var viewCoordSys = seriesModel.coordinateSystem = new View();
        viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
        viewCoordSys.setBoundingRect(min3[0], min3[1], bbWidth, bbHeight);
        viewCoordSys.setViewRect(viewRect2.x, viewRect2.y, viewWidth, viewHeight);
        viewCoordSys.setCenter(seriesModel.get("center"));
        viewCoordSys.setZoom(seriesModel.get("zoom"));
        viewList.push(viewCoordSys);
      }
    });
    return viewList;
  }
  createView = _default2;
  return createView;
}
var hasRequiredGraph;
function requireGraph() {
  if (hasRequiredGraph)
    return graph;
  hasRequiredGraph = 1;
  var echarts$12 = echarts;
  requireGraphSeries();
  requireGraphView();
  requireGraphAction();
  var categoryFilter2 = requireCategoryFilter();
  var visualSymbol = requireSymbol();
  var categoryVisual2 = requireCategoryVisual();
  var edgeVisual2 = requireEdgeVisual();
  var simpleLayout = requireSimpleLayout();
  var circularLayout = requireCircularLayout();
  var forceLayout = requireForceLayout();
  var createView2 = requireCreateView();
  echarts$12.registerProcessor(categoryFilter2);
  echarts$12.registerVisual(visualSymbol("graph", "circle", null));
  echarts$12.registerVisual(categoryVisual2);
  echarts$12.registerVisual(edgeVisual2);
  echarts$12.registerLayout(simpleLayout);
  echarts$12.registerLayout(echarts$12.PRIORITY.VISUAL.POST_CHART_LAYOUT, circularLayout);
  echarts$12.registerLayout(forceLayout);
  echarts$12.registerCoordinateSystem("graphView", {
    create: createView2
  });
  return graph;
}
var gauge = {};
var GaugeSeries_1;
var hasRequiredGaugeSeries;
function requireGaugeSeries() {
  if (hasRequiredGaugeSeries)
    return GaugeSeries_1;
  hasRequiredGaugeSeries = 1;
  var createListSimply2 = requireCreateListSimply();
  var SeriesModel2 = Series;
  var GaugeSeries = SeriesModel2.extend({
    type: "series.gauge",
    getInitialData: function(option, ecModel) {
      return createListSimply2(this, ["value"]);
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      // 默认全局居中
      center: ["50%", "50%"],
      legendHoverLink: true,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: true,
      // 最小值
      min: 0,
      // 最大值
      max: 100,
      // 分割段数，默认为10
      splitNumber: 10,
      // 坐标轴线
      axisLine: {
        // 默认显示，属性show控制显示与否
        show: true,
        lineStyle: {
          // 属性lineStyle控制线条样式
          color: [[0.2, "#91c7ae"], [0.8, "#63869e"], [1, "#c23531"]],
          width: 30
        }
      },
      // 分隔线
      splitLine: {
        // 默认显示，属性show控制显示与否
        show: true,
        // 属性length控制线长
        length: 30,
        // 属性lineStyle（详见lineStyle）控制线条样式
        lineStyle: {
          color: "#eee",
          width: 2,
          type: "solid"
        }
      },
      // 坐标轴小标记
      axisTick: {
        // 属性show控制显示与否，默认不显示
        show: true,
        // 每份split细分多少段
        splitNumber: 5,
        // 属性length控制线长
        length: 8,
        // 属性lineStyle控制线条样式
        lineStyle: {
          color: "#eee",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: true,
        distance: 5,
        // formatter: null,
        color: "auto"
      },
      pointer: {
        show: true,
        length: "80%",
        width: 8
      },
      itemStyle: {
        color: "auto"
      },
      title: {
        show: true,
        // x, y，单位px
        offsetCenter: [0, "-40%"],
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#333",
        fontSize: 15
      },
      detail: {
        show: true,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        // self-adaption
        padding: [5, 10],
        // x, y，单位px
        offsetCenter: [0, "40%"],
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "auto",
        fontSize: 30
      }
    }
  });
  var _default2 = GaugeSeries;
  GaugeSeries_1 = _default2;
  return GaugeSeries_1;
}
var PointerPath;
var hasRequiredPointerPath;
function requirePointerPath() {
  if (hasRequiredPointerPath)
    return PointerPath;
  hasRequiredPointerPath = 1;
  var Path2 = Path_1;
  var _default2 = Path2.extend({
    type: "echartsGaugePointer",
    shape: {
      angle: 0,
      width: 10,
      r: 10,
      x: 0,
      y: 0
    },
    buildPath: function(ctx, shape) {
      var mathCos2 = Math.cos;
      var mathSin2 = Math.sin;
      var r = shape.r;
      var width = shape.width;
      var angle = shape.angle;
      var x = shape.x - mathCos2(angle) * width * (width >= r / 3 ? 1 : 2);
      var y = shape.y - mathSin2(angle) * width * (width >= r / 3 ? 1 : 2);
      angle = shape.angle - Math.PI / 2;
      ctx.moveTo(x, y);
      ctx.lineTo(shape.x + mathCos2(angle) * width, shape.y + mathSin2(angle) * width);
      ctx.lineTo(shape.x + mathCos2(shape.angle) * r, shape.y + mathSin2(shape.angle) * r);
      ctx.lineTo(shape.x - mathCos2(angle) * width, shape.y - mathSin2(angle) * width);
      ctx.lineTo(x, y);
      return;
    }
  });
  PointerPath = _default2;
  return PointerPath;
}
var GaugeView_1;
var hasRequiredGaugeView;
function requireGaugeView() {
  if (hasRequiredGaugeView)
    return GaugeView_1;
  hasRequiredGaugeView = 1;
  var PointerPath2 = requirePointerPath();
  var graphic2 = graphic$4;
  var ChartView = Chart_1;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var round2 = _number2.round;
  var linearMap = _number2.linearMap;
  function parsePosition(seriesModel, api) {
    var center2 = seriesModel.get("center");
    var width = api.getWidth();
    var height = api.getHeight();
    var size2 = Math.min(width, height);
    var cx = parsePercent2(center2[0], api.getWidth());
    var cy = parsePercent2(center2[1], api.getHeight());
    var r = parsePercent2(seriesModel.get("radius"), size2 / 2);
    return {
      cx,
      cy,
      r
    };
  }
  function formatLabel(label, labelFormatter) {
    if (labelFormatter) {
      if (typeof labelFormatter === "string") {
        label = labelFormatter.replace("{value}", label != null ? label : "");
      } else if (typeof labelFormatter === "function") {
        label = labelFormatter(label);
      }
    }
    return label;
  }
  var PI22 = Math.PI * 2;
  var GaugeView = ChartView.extend({
    type: "gauge",
    render: function(seriesModel, ecModel, api) {
      this.group.removeAll();
      var colorList = seriesModel.get("axisLine.lineStyle.color");
      var posInfo = parsePosition(seriesModel, api);
      this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
    },
    dispose: function() {
    },
    _renderMain: function(seriesModel, ecModel, api, colorList, posInfo) {
      var group = this.group;
      var axisLineModel = seriesModel.getModel("axisLine");
      var lineStyleModel = axisLineModel.getModel("lineStyle");
      var clockwise = seriesModel.get("clockwise");
      var startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
      var endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
      var angleRangeSpan = (endAngle - startAngle) % PI22;
      var prevEndAngle = startAngle;
      var axisLineWidth = lineStyleModel.get("width");
      var showAxis = axisLineModel.get("show");
      for (var i = 0; showAxis && i < colorList.length; i++) {
        var percent = Math.min(Math.max(colorList[i][0], 0), 1);
        var endAngle = startAngle + angleRangeSpan * percent;
        var sector = new graphic2.Sector({
          shape: {
            startAngle: prevEndAngle,
            endAngle,
            cx: posInfo.cx,
            cy: posInfo.cy,
            clockwise,
            r0: posInfo.r - axisLineWidth,
            r: posInfo.r
          },
          silent: true
        });
        sector.setStyle({
          fill: colorList[i][1]
        });
        sector.setStyle(lineStyleModel.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "borderWidth", "borderColor"]
        ));
        group.add(sector);
        prevEndAngle = endAngle;
      }
      var getColor = function(percent2) {
        if (percent2 <= 0) {
          return colorList[0][1];
        }
        for (var i2 = 0; i2 < colorList.length; i2++) {
          if (colorList[i2][0] >= percent2 && (i2 === 0 ? 0 : colorList[i2 - 1][0]) < percent2) {
            return colorList[i2][1];
          }
        }
        return colorList[i2 - 1][1];
      };
      if (!clockwise) {
        var tmp = startAngle;
        startAngle = endAngle;
        endAngle = tmp;
      }
      this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
      this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
      this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);
      this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);
    },
    _renderTicks: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
      var group = this.group;
      var cx = posInfo.cx;
      var cy = posInfo.cy;
      var r = posInfo.r;
      var minVal = +seriesModel.get("min");
      var maxVal = +seriesModel.get("max");
      var splitLineModel = seriesModel.getModel("splitLine");
      var tickModel = seriesModel.getModel("axisTick");
      var labelModel = seriesModel.getModel("axisLabel");
      var splitNumber = seriesModel.get("splitNumber");
      var subSplitNumber = tickModel.get("splitNumber");
      var splitLineLen = parsePercent2(splitLineModel.get("length"), r);
      var tickLen = parsePercent2(tickModel.get("length"), r);
      var angle = startAngle;
      var step = (endAngle - startAngle) / splitNumber;
      var subStep = step / subSplitNumber;
      var splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
      var tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
      for (var i = 0; i <= splitNumber; i++) {
        var unitX = Math.cos(angle);
        var unitY = Math.sin(angle);
        if (splitLineModel.get("show")) {
          var splitLine = new graphic2.Line({
            shape: {
              x1: unitX * r + cx,
              y1: unitY * r + cy,
              x2: unitX * (r - splitLineLen) + cx,
              y2: unitY * (r - splitLineLen) + cy
            },
            style: splitLineStyle,
            silent: true
          });
          if (splitLineStyle.stroke === "auto") {
            splitLine.setStyle({
              stroke: getColor(i / splitNumber)
            });
          }
          group.add(splitLine);
        }
        if (labelModel.get("show")) {
          var label = formatLabel(round2(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
          var distance = labelModel.get("distance");
          var autoColor = getColor(i / splitNumber);
          group.add(new graphic2.Text({
            style: graphic2.setTextStyle({}, labelModel, {
              text: label,
              x: unitX * (r - splitLineLen - distance) + cx,
              y: unitY * (r - splitLineLen - distance) + cy,
              textVerticalAlign: unitY < -0.4 ? "top" : unitY > 0.4 ? "bottom" : "middle",
              textAlign: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
            }, {
              autoColor
            }),
            silent: true
          }));
        }
        if (tickModel.get("show") && i !== splitNumber) {
          for (var j = 0; j <= subSplitNumber; j++) {
            var unitX = Math.cos(angle);
            var unitY = Math.sin(angle);
            var tickLine = new graphic2.Line({
              shape: {
                x1: unitX * r + cx,
                y1: unitY * r + cy,
                x2: unitX * (r - tickLen) + cx,
                y2: unitY * (r - tickLen) + cy
              },
              silent: true,
              style: tickLineStyle
            });
            if (tickLineStyle.stroke === "auto") {
              tickLine.setStyle({
                stroke: getColor((i + j / subSplitNumber) / splitNumber)
              });
            }
            group.add(tickLine);
            angle += subStep;
          }
          angle -= subStep;
        } else {
          angle += step;
        }
      }
    },
    _renderPointer: function(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
      var group = this.group;
      var oldData = this._data;
      if (!seriesModel.get("pointer.show")) {
        oldData && oldData.eachItemGraphicEl(function(el) {
          group.remove(el);
        });
        return;
      }
      var valueExtent = [+seriesModel.get("min"), +seriesModel.get("max")];
      var angleExtent = [startAngle, endAngle];
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      data.diff(oldData).add(function(idx) {
        var pointer = new PointerPath2({
          shape: {
            angle: startAngle
          }
        });
        graphic2.initProps(pointer, {
          shape: {
            angle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true)
          }
        }, seriesModel);
        group.add(pointer);
        data.setItemGraphicEl(idx, pointer);
      }).update(function(newIdx, oldIdx) {
        var pointer = oldData.getItemGraphicEl(oldIdx);
        graphic2.updateProps(pointer, {
          shape: {
            angle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true)
          }
        }, seriesModel);
        group.add(pointer);
        data.setItemGraphicEl(newIdx, pointer);
      }).remove(function(idx) {
        var pointer = oldData.getItemGraphicEl(idx);
        group.remove(pointer);
      }).execute();
      data.eachItemGraphicEl(function(pointer, idx) {
        var itemModel = data.getItemModel(idx);
        var pointerModel = itemModel.getModel("pointer");
        pointer.setShape({
          x: posInfo.cx,
          y: posInfo.cy,
          width: parsePercent2(pointerModel.get("width"), posInfo.r),
          r: parsePercent2(pointerModel.get("length"), posInfo.r)
        });
        pointer.useStyle(itemModel.getModel("itemStyle").getItemStyle());
        if (pointer.style.fill === "auto") {
          pointer.setStyle("fill", getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
        }
        graphic2.setHoverStyle(pointer, itemModel.getModel("emphasis.itemStyle").getItemStyle());
      });
      this._data = data;
    },
    _renderTitle: function(seriesModel, ecModel, api, getColor, posInfo) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var titleModel = seriesModel.getModel("title");
      if (titleModel.get("show")) {
        var offsetCenter = titleModel.get("offsetCenter");
        var x = posInfo.cx + parsePercent2(offsetCenter[0], posInfo.r);
        var y = posInfo.cy + parsePercent2(offsetCenter[1], posInfo.r);
        var minVal = +seriesModel.get("min");
        var maxVal = +seriesModel.get("max");
        var value = seriesModel.getData().get(valueDim, 0);
        var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
        this.group.add(new graphic2.Text({
          silent: true,
          style: graphic2.setTextStyle({}, titleModel, {
            x,
            y,
            // FIXME First data name ?
            text: data.getName(0),
            textAlign: "center",
            textVerticalAlign: "middle"
          }, {
            autoColor,
            forceRich: true
          })
        }));
      }
    },
    _renderDetail: function(seriesModel, ecModel, api, getColor, posInfo) {
      var detailModel = seriesModel.getModel("detail");
      var minVal = +seriesModel.get("min");
      var maxVal = +seriesModel.get("max");
      if (detailModel.get("show")) {
        var offsetCenter = detailModel.get("offsetCenter");
        var x = posInfo.cx + parsePercent2(offsetCenter[0], posInfo.r);
        var y = posInfo.cy + parsePercent2(offsetCenter[1], posInfo.r);
        var width = parsePercent2(detailModel.get("width"), posInfo.r);
        var height = parsePercent2(detailModel.get("height"), posInfo.r);
        var data = seriesModel.getData();
        var value = data.get(data.mapDimension("value"), 0);
        var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
        this.group.add(new graphic2.Text({
          silent: true,
          style: graphic2.setTextStyle({}, detailModel, {
            x,
            y,
            text: formatLabel(
              // FIXME First data name ?
              value,
              detailModel.get("formatter")
            ),
            textWidth: isNaN(width) ? null : width,
            textHeight: isNaN(height) ? null : height,
            textAlign: "center",
            textVerticalAlign: "middle"
          }, {
            autoColor,
            forceRich: true
          })
        }));
      }
    }
  });
  var _default2 = GaugeView;
  GaugeView_1 = _default2;
  return GaugeView_1;
}
var hasRequiredGauge;
function requireGauge() {
  if (hasRequiredGauge)
    return gauge;
  hasRequiredGauge = 1;
  requireGaugeSeries();
  requireGaugeView();
  return gauge;
}
var funnel = {};
var FunnelSeries_1;
var hasRequiredFunnelSeries;
function requireFunnelSeries() {
  if (hasRequiredFunnelSeries)
    return FunnelSeries_1;
  hasRequiredFunnelSeries = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var createListSimply2 = requireCreateListSimply();
  var _model2 = model;
  var defaultEmphasis2 = _model2.defaultEmphasis;
  var _sourceHelper2 = requireSourceHelper();
  var makeSeriesEncodeForNameBased = _sourceHelper2.makeSeriesEncodeForNameBased;
  var LegendVisualProvider = requireLegendVisualProvider();
  var FunnelSeries = echarts$12.extendSeriesModel({
    type: "series.funnel",
    init: function(option) {
      FunnelSeries.superApply(this, "init", arguments);
      this.legendVisualProvider = new LegendVisualProvider(zrUtil2.bind(this.getData, this), zrUtil2.bind(this.getRawData, this));
      this._defaultLabelLine(option);
    },
    getInitialData: function(option, ecModel) {
      return createListSimply2(this, {
        coordDimensions: ["value"],
        encodeDefaulter: zrUtil2.curry(makeSeriesEncodeForNameBased, this)
      });
    },
    _defaultLabelLine: function(option) {
      defaultEmphasis2(option, "labelLine", ["show"]);
      var labelLineNormalOpt = option.labelLine;
      var labelLineEmphasisOpt = option.emphasis.labelLine;
      labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
      labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
    },
    // Overwrite
    getDataParams: function(dataIndex) {
      var data = this.getData();
      var params = FunnelSeries.superCall(this, "getDataParams", dataIndex);
      var valueDim = data.mapDimension("value");
      var sum = data.getSum(valueDim);
      params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2);
      params.$vars.push("percent");
      return params;
    },
    defaultOption: {
      zlevel: 0,
      // 一级层叠
      z: 2,
      // 二级层叠
      legendHoverLink: true,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 默认取数据最小最大值
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      // 'ascending', 'descending'
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: true,
        position: "outer"
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      labelLine: {
        show: true,
        length: 20,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        // color: 各异,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }
  });
  var _default2 = FunnelSeries;
  FunnelSeries_1 = _default2;
  return FunnelSeries_1;
}
var FunnelView_1;
var hasRequiredFunnelView;
function requireFunnelView() {
  if (hasRequiredFunnelView)
    return FunnelView_1;
  hasRequiredFunnelView = 1;
  var graphic2 = graphic$4;
  var zrUtil2 = util$6;
  var ChartView = Chart_1;
  function FunnelPiece(data, idx) {
    graphic2.Group.call(this);
    var polygon2 = new graphic2.Polygon();
    var labelLine = new graphic2.Polyline();
    var text2 = new graphic2.Text();
    this.add(polygon2);
    this.add(labelLine);
    this.add(text2);
    this.highDownOnUpdate = function(fromState, toState) {
      if (toState === "emphasis") {
        labelLine.ignore = labelLine.hoverIgnore;
        text2.ignore = text2.hoverIgnore;
      } else {
        labelLine.ignore = labelLine.normalIgnore;
        text2.ignore = text2.normalIgnore;
      }
    };
    this.updateData(data, idx, true);
  }
  var funnelPieceProto = FunnelPiece.prototype;
  var opacityAccessPath = ["itemStyle", "opacity"];
  funnelPieceProto.updateData = function(data, idx, firstCreate) {
    var polygon2 = this.childAt(0);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var opacity = data.getItemModel(idx).get(opacityAccessPath);
    opacity = opacity == null ? 1 : opacity;
    polygon2.useStyle({});
    if (firstCreate) {
      polygon2.setShape({
        points: layout2.points
      });
      polygon2.setStyle({
        opacity: 0
      });
      graphic2.initProps(polygon2, {
        style: {
          opacity
        }
      }, seriesModel, idx);
    } else {
      graphic2.updateProps(polygon2, {
        style: {
          opacity
        },
        shape: {
          points: layout2.points
        }
      }, seriesModel, idx);
    }
    var itemStyleModel = itemModel.getModel("itemStyle");
    var visualColor = data.getItemVisual(idx, "color");
    polygon2.setStyle(zrUtil2.defaults({
      lineJoin: "round",
      fill: visualColor
    }, itemStyleModel.getItemStyle(["opacity"])));
    polygon2.hoverStyle = itemStyleModel.getModel("emphasis").getItemStyle();
    this._updateLabel(data, idx);
    graphic2.setHoverStyle(this);
  };
  funnelPieceProto._updateLabel = function(data, idx) {
    var labelLine = this.childAt(1);
    var labelText = this.childAt(2);
    var seriesModel = data.hostModel;
    var itemModel = data.getItemModel(idx);
    var layout2 = data.getItemLayout(idx);
    var labelLayout2 = layout2.label;
    var visualColor = data.getItemVisual(idx, "color");
    graphic2.updateProps(labelLine, {
      shape: {
        points: labelLayout2.linePoints || labelLayout2.linePoints
      }
    }, seriesModel, idx);
    graphic2.updateProps(labelText, {
      style: {
        x: labelLayout2.x,
        y: labelLayout2.y
      }
    }, seriesModel, idx);
    labelText.attr({
      rotation: labelLayout2.rotation,
      origin: [labelLayout2.x, labelLayout2.y],
      z2: 10
    });
    var labelModel = itemModel.getModel("label");
    var labelHoverModel = itemModel.getModel("emphasis.label");
    var labelLineModel = itemModel.getModel("labelLine");
    var labelLineHoverModel = itemModel.getModel("emphasis.labelLine");
    var visualColor = data.getItemVisual(idx, "color");
    graphic2.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, labelHoverModel, {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultText: data.getName(idx),
      autoColor: visualColor,
      useInsideStyle: !!labelLayout2.inside
    }, {
      textAlign: labelLayout2.textAlign,
      textVerticalAlign: labelLayout2.verticalAlign
    });
    labelText.ignore = labelText.normalIgnore = !labelModel.get("show");
    labelText.hoverIgnore = !labelHoverModel.get("show");
    labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get("show");
    labelLine.hoverIgnore = !labelLineHoverModel.get("show");
    labelLine.setStyle({
      stroke: visualColor
    });
    labelLine.setStyle(labelLineModel.getModel("lineStyle").getLineStyle());
    labelLine.hoverStyle = labelLineHoverModel.getModel("lineStyle").getLineStyle();
  };
  zrUtil2.inherits(FunnelPiece, graphic2.Group);
  var FunnelView = ChartView.extend({
    type: "funnel",
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      data.diff(oldData).add(function(idx) {
        var funnelPiece = new FunnelPiece(data, idx);
        data.setItemGraphicEl(idx, funnelPiece);
        group.add(funnelPiece);
      }).update(function(newIdx, oldIdx) {
        var piePiece = oldData.getItemGraphicEl(oldIdx);
        piePiece.updateData(data, newIdx);
        group.add(piePiece);
        data.setItemGraphicEl(newIdx, piePiece);
      }).remove(function(idx) {
        var piePiece = oldData.getItemGraphicEl(idx);
        group.remove(piePiece);
      }).execute();
      this._data = data;
    },
    remove: function() {
      this.group.removeAll();
      this._data = null;
    },
    dispose: function() {
    }
  });
  var _default2 = FunnelView;
  FunnelView_1 = _default2;
  return FunnelView_1;
}
var funnelLayout;
var hasRequiredFunnelLayout;
function requireFunnelLayout() {
  if (hasRequiredFunnelLayout)
    return funnelLayout;
  hasRequiredFunnelLayout = 1;
  var layout2 = layout$1;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var linearMap = _number2.linearMap;
  function getViewRect(seriesModel, api) {
    return layout2.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function getSortedIndices(data, sort2) {
    var valueDim = data.mapDimension("value");
    var valueArr = data.mapArray(valueDim, function(val) {
      return val;
    });
    var indices = [];
    var isAscending = sort2 === "ascending";
    for (var i = 0, len = data.count(); i < len; i++) {
      indices[i] = i;
    }
    if (typeof sort2 === "function") {
      indices.sort(sort2);
    } else if (sort2 !== "none") {
      indices.sort(function(a, b) {
        return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
      });
    }
    return indices;
  }
  function labelLayout2(data) {
    data.each(function(idx) {
      var itemModel = data.getItemModel(idx);
      var labelModel = itemModel.getModel("label");
      var labelPosition = labelModel.get("position");
      var orient = itemModel.get("orient");
      var labelLineModel = itemModel.getModel("labelLine");
      var layout3 = data.getItemLayout(idx);
      var points2 = layout3.points;
      var isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
      var textAlign;
      var textX;
      var textY;
      var linePoints;
      if (isLabelInside) {
        if (labelPosition === "insideLeft") {
          textX = (points2[0][0] + points2[3][0]) / 2 + 5;
          textY = (points2[0][1] + points2[3][1]) / 2;
          textAlign = "left";
        } else if (labelPosition === "insideRight") {
          textX = (points2[1][0] + points2[2][0]) / 2 - 5;
          textY = (points2[1][1] + points2[2][1]) / 2;
          textAlign = "right";
        } else {
          textX = (points2[0][0] + points2[1][0] + points2[2][0] + points2[3][0]) / 4;
          textY = (points2[0][1] + points2[1][1] + points2[2][1] + points2[3][1]) / 4;
          textAlign = "center";
        }
        linePoints = [[textX, textY], [textX, textY]];
      } else {
        var x1;
        var y1;
        var x2;
        var y2;
        var labelLineLen = labelLineModel.get("length");
        if (labelPosition === "left") {
          x1 = (points2[3][0] + points2[0][0]) / 2;
          y1 = (points2[3][1] + points2[0][1]) / 2;
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        } else if (labelPosition === "right") {
          x1 = (points2[1][0] + points2[2][0]) / 2;
          y1 = (points2[1][1] + points2[2][1]) / 2;
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "left";
        } else if (labelPosition === "top") {
          x1 = (points2[3][0] + points2[0][0]) / 2;
          y1 = (points2[3][1] + points2[0][1]) / 2;
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else if (labelPosition === "bottom") {
          x1 = (points2[1][0] + points2[2][0]) / 2;
          y1 = (points2[1][1] + points2[2][1]) / 2;
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else if (labelPosition === "rightTop") {
          x1 = orient === "horizontal" ? points2[3][0] : points2[1][0];
          y1 = orient === "horizontal" ? points2[3][1] : points2[1][1];
          if (orient === "horizontal") {
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = "center";
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "top";
          }
        } else if (labelPosition === "rightBottom") {
          x1 = points2[2][0];
          y1 = points2[2][1];
          if (orient === "horizontal") {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "bottom";
          }
        } else if (labelPosition === "leftTop") {
          x1 = points2[0][0];
          y1 = orient === "horizontal" ? points2[0][1] : points2[1][1];
          if (orient === "horizontal") {
            y2 = y1 - labelLineLen;
            textY = y2 - 5;
            textAlign = "center";
          } else {
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = "right";
          }
        } else if (labelPosition === "leftBottom") {
          x1 = orient === "horizontal" ? points2[1][0] : points2[3][0];
          y1 = orient === "horizontal" ? points2[1][1] : points2[2][1];
          if (orient === "horizontal") {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else {
            x2 = x1 - labelLineLen;
            textX = x2 - 5;
            textAlign = "right";
          }
        } else {
          x1 = (points2[1][0] + points2[2][0]) / 2;
          y1 = (points2[1][1] + points2[2][1]) / 2;
          if (orient === "horizontal") {
            y2 = y1 + labelLineLen;
            textY = y2 + 5;
            textAlign = "center";
          } else {
            x2 = x1 + labelLineLen;
            textX = x2 + 5;
            textAlign = "left";
          }
        }
        if (orient === "horizontal") {
          x2 = x1;
          textX = x2;
        } else {
          y2 = y1;
          textY = y2;
        }
        linePoints = [[x1, y1], [x2, y2]];
      }
      layout3.label = {
        linePoints,
        x: textX,
        y: textY,
        verticalAlign: "middle",
        textAlign,
        inside: isLabelInside
      };
    });
  }
  function _default2(ecModel, api, payload) {
    ecModel.eachSeriesByType("funnel", function(seriesModel) {
      var data = seriesModel.getData();
      var valueDim = data.mapDimension("value");
      var sort2 = seriesModel.get("sort");
      var viewRect2 = getViewRect(seriesModel, api);
      var indices = getSortedIndices(data, sort2);
      var orient = seriesModel.get("orient");
      var viewWidth = viewRect2.width;
      var viewHeight = viewRect2.height;
      var x = viewRect2.x;
      var y = viewRect2.y;
      var sizeExtent = orient === "horizontal" ? [parsePercent2(seriesModel.get("minSize"), viewHeight), parsePercent2(seriesModel.get("maxSize"), viewHeight)] : [parsePercent2(seriesModel.get("minSize"), viewWidth), parsePercent2(seriesModel.get("maxSize"), viewWidth)];
      var dataExtent = data.getDataExtent(valueDim);
      var min3 = seriesModel.get("min");
      var max3 = seriesModel.get("max");
      if (min3 == null) {
        min3 = Math.min(dataExtent[0], 0);
      }
      if (max3 == null) {
        max3 = dataExtent[1];
      }
      var funnelAlign = seriesModel.get("funnelAlign");
      var gap = seriesModel.get("gap");
      var viewSize = orient === "horizontal" ? viewWidth : viewHeight;
      var itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
      var getLinePoints = function(idx2, offset) {
        if (orient === "horizontal") {
          var val = data.get(valueDim, idx2) || 0;
          var itemHeight = linearMap(val, [min3, max3], sizeExtent, true);
          var y0;
          switch (funnelAlign) {
            case "top":
              y0 = y;
              break;
            case "center":
              y0 = y + (viewHeight - itemHeight) / 2;
              break;
            case "bottom":
              y0 = y + (viewHeight - itemHeight);
              break;
          }
          return [[offset, y0], [offset, y0 + itemHeight]];
        }
        var val = data.get(valueDim, idx2) || 0;
        var itemWidth = linearMap(val, [min3, max3], sizeExtent, true);
        var x0;
        switch (funnelAlign) {
          case "left":
            x0 = x;
            break;
          case "center":
            x0 = x + (viewWidth - itemWidth) / 2;
            break;
          case "right":
            x0 = x + viewWidth - itemWidth;
            break;
        }
        return [[x0, offset], [x0 + itemWidth, offset]];
      };
      if (sort2 === "ascending") {
        itemSize = -itemSize;
        gap = -gap;
        if (orient === "horizontal") {
          x += viewWidth;
        } else {
          y += viewHeight;
        }
        indices = indices.reverse();
      }
      for (var i = 0; i < indices.length; i++) {
        var idx = indices[i];
        var nextIdx = indices[i + 1];
        var itemModel = data.getItemModel(idx);
        if (orient === "horizontal") {
          var width = itemModel.get("itemStyle.width");
          if (width == null) {
            width = itemSize;
          } else {
            width = parsePercent2(width, viewWidth);
            if (sort2 === "ascending") {
              width = -width;
            }
          }
          var start = getLinePoints(idx, x);
          var end = getLinePoints(nextIdx, x + width);
          x += width + gap;
          data.setItemLayout(idx, {
            points: start.concat(end.slice().reverse())
          });
        } else {
          var height = itemModel.get("itemStyle.height");
          if (height == null) {
            height = itemSize;
          } else {
            height = parsePercent2(height, viewHeight);
            if (sort2 === "ascending") {
              height = -height;
            }
          }
          var start = orient === "horizontal" ? getLinePoints(idx, x) : getLinePoints(idx, y);
          var end = orient === "horizontal" ? getLinePoints(nextIdx, x + width) : getLinePoints(nextIdx, y + height);
          y += height + gap;
          data.setItemLayout(idx, {
            points: start.concat(end.slice().reverse())
          });
        }
      }
      labelLayout2(data);
    });
  }
  funnelLayout = _default2;
  return funnelLayout;
}
var hasRequiredFunnel;
function requireFunnel() {
  if (hasRequiredFunnel)
    return funnel;
  hasRequiredFunnel = 1;
  var echarts$12 = echarts;
  requireFunnelSeries();
  requireFunnelView();
  var dataColor2 = requireDataColor();
  var funnelLayout2 = requireFunnelLayout();
  var dataFilter2 = requireDataFilter();
  echarts$12.registerVisual(dataColor2("funnel"));
  echarts$12.registerLayout(funnelLayout2);
  echarts$12.registerProcessor(dataFilter2("funnel"));
  return funnel;
}
var parallel$1 = {};
var parallel = {};
var parallelPreprocessor;
var hasRequiredParallelPreprocessor;
function requireParallelPreprocessor() {
  if (hasRequiredParallelPreprocessor)
    return parallelPreprocessor;
  hasRequiredParallelPreprocessor = 1;
  var zrUtil2 = util$6;
  var modelUtil2 = model;
  function _default2(option) {
    createParallelIfNeeded(option);
    mergeAxisOptionFromParallel(option);
  }
  function createParallelIfNeeded(option) {
    if (option.parallel) {
      return;
    }
    var hasParallelSeries = false;
    zrUtil2.each(option.series, function(seriesOpt) {
      if (seriesOpt && seriesOpt.type === "parallel") {
        hasParallelSeries = true;
      }
    });
    if (hasParallelSeries) {
      option.parallel = [{}];
    }
  }
  function mergeAxisOptionFromParallel(option) {
    var axes = modelUtil2.normalizeToArray(option.parallelAxis);
    zrUtil2.each(axes, function(axisOption) {
      if (!zrUtil2.isObject(axisOption)) {
        return;
      }
      var parallelIndex = axisOption.parallelIndex || 0;
      var parallelOption = modelUtil2.normalizeToArray(option.parallel)[parallelIndex];
      if (parallelOption && parallelOption.parallelAxisDefault) {
        zrUtil2.merge(axisOption, parallelOption.parallelAxisDefault, false);
      }
    });
  }
  parallelPreprocessor = _default2;
  return parallelPreprocessor;
}
var parallelCreator = {};
var ParallelAxis_1;
var hasRequiredParallelAxis$1;
function requireParallelAxis$1() {
  if (hasRequiredParallelAxis$1)
    return ParallelAxis_1;
  hasRequiredParallelAxis$1 = 1;
  var zrUtil2 = util$6;
  var Axis = requireAxis$1();
  var ParallelAxis = function(dim, scale, coordExtent, axisType, axisIndex) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || "value";
    this.axisIndex = axisIndex;
  };
  ParallelAxis.prototype = {
    constructor: ParallelAxis,
    /**
     * Axis model
     * @param {module:echarts/coord/parallel/AxisModel}
     */
    model: null,
    /**
     * @override
     */
    isHorizontal: function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }
  };
  zrUtil2.inherits(ParallelAxis, Axis);
  var _default2 = ParallelAxis;
  ParallelAxis_1 = _default2;
  return ParallelAxis_1;
}
var sliderMove;
var hasRequiredSliderMove;
function requireSliderMove() {
  if (hasRequiredSliderMove)
    return sliderMove;
  hasRequiredSliderMove = 1;
  function _default2(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
    delta = delta || 0;
    var extentSpan = extent[1] - extent[0];
    if (minSpan != null) {
      minSpan = restrict(minSpan, [0, extentSpan]);
    }
    if (maxSpan != null) {
      maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
    }
    if (handleIndex === "all") {
      var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
      handleSpan = restrict(handleSpan, [0, extentSpan]);
      minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
      handleIndex = 0;
    }
    handleEnds[0] = restrict(handleEnds[0], extent);
    handleEnds[1] = restrict(handleEnds[1], extent);
    var originalDistSign = getSpanSign(handleEnds, handleIndex);
    handleEnds[handleIndex] += delta;
    var extentMinSpan = minSpan || 0;
    var realExtent = extent.slice();
    originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
    handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
    var currDistSign = getSpanSign(handleEnds, handleIndex);
    if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
    }
    var currDistSign = getSpanSign(handleEnds, handleIndex);
    if (maxSpan != null && currDistSign.span > maxSpan) {
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
    }
    return handleEnds;
  }
  function getSpanSign(handleEnds, handleIndex) {
    var dist2 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
    return {
      span: Math.abs(dist2),
      sign: dist2 > 0 ? -1 : dist2 < 0 ? 1 : handleIndex ? -1 : 1
    };
  }
  function restrict(value, extend2) {
    return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
  }
  sliderMove = _default2;
  return sliderMove;
}
var Parallel_1;
var hasRequiredParallel$2;
function requireParallel$2() {
  if (hasRequiredParallel$2)
    return Parallel_1;
  hasRequiredParallel$2 = 1;
  var zrUtil2 = util$6;
  var matrix2 = requireMatrix();
  var layoutUtil = layout$1;
  var axisHelper2 = requireAxisHelper();
  var ParallelAxis = requireParallelAxis$1();
  var graphic2 = graphic$4;
  var numberUtil = requireNumber();
  var sliderMove2 = requireSliderMove();
  var each2 = zrUtil2.each;
  var mathMin2 = Math.min;
  var mathMax2 = Math.max;
  var mathFloor = Math.floor;
  var mathCeil = Math.ceil;
  var round2 = numberUtil.round;
  var PI3 = Math.PI;
  function Parallel(parallelModel, ecModel, api) {
    this._axesMap = zrUtil2.createHashMap();
    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._rect;
    this._model = parallelModel;
    this._init(parallelModel, ecModel, api);
  }
  Parallel.prototype = {
    type: "parallel",
    constructor: Parallel,
    /**
     * Initialize cartesian coordinate systems
     * @private
     */
    _init: function(parallelModel, ecModel, api) {
      var dimensions = parallelModel.dimensions;
      var parallelAxisIndex = parallelModel.parallelAxisIndex;
      each2(dimensions, function(dim, idx) {
        var axisIndex = parallelAxisIndex[idx];
        var axisModel = ecModel.getComponent("parallelAxis", axisIndex);
        var axis2 = this._axesMap.set(dim, new ParallelAxis(dim, axisHelper2.createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisIndex));
        var isCategory = axis2.type === "category";
        axis2.onBand = isCategory && axisModel.get("boundaryGap");
        axis2.inverse = axisModel.get("inverse");
        axisModel.axis = axis2;
        axis2.model = axisModel;
        axis2.coordinateSystem = axisModel.coordinateSystem = this;
      }, this);
    },
    /**
     * Update axis scale after data processed
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */
    update: function(ecModel, api) {
      this._updateAxesFromSeries(this._model, ecModel);
    },
    /**
     * @override
     */
    containPoint: function(point) {
      var layoutInfo = this._makeLayoutInfo();
      var axisBase = layoutInfo.axisBase;
      var layoutBase = layoutInfo.layoutBase;
      var pixelDimIndex = layoutInfo.pixelDimIndex;
      var pAxis = point[1 - pixelDimIndex];
      var pLayout = point[pixelDimIndex];
      return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
    },
    getModel: function() {
      return this._model;
    },
    /**
     * Update properties from series
     * @private
     */
    _updateAxesFromSeries: function(parallelModel, ecModel) {
      ecModel.eachSeries(function(seriesModel) {
        if (!parallelModel.contains(seriesModel, ecModel)) {
          return;
        }
        var data = seriesModel.getData();
        each2(this.dimensions, function(dim) {
          var axis2 = this._axesMap.get(dim);
          axis2.scale.unionExtentFromData(data, data.mapDimension(dim));
          axisHelper2.niceScaleExtent(axis2.scale, axis2.model);
        }, this);
      }, this);
    },
    /**
     * Resize the parallel coordinate system.
     * @param {module:echarts/coord/parallel/ParallelModel} parallelModel
     * @param {module:echarts/ExtensionAPI} api
     */
    resize: function(parallelModel, api) {
      this._rect = layoutUtil.getLayoutRect(parallelModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._layoutAxes();
    },
    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getRect: function() {
      return this._rect;
    },
    /**
     * @private
     */
    _makeLayoutInfo: function() {
      var parallelModel = this._model;
      var rect = this._rect;
      var xy = ["x", "y"];
      var wh = ["width", "height"];
      var layout2 = parallelModel.get("layout");
      var pixelDimIndex = layout2 === "horizontal" ? 0 : 1;
      var layoutLength = rect[wh[pixelDimIndex]];
      var layoutExtent = [0, layoutLength];
      var axisCount = this.dimensions.length;
      var axisExpandWidth = restrict(parallelModel.get("axisExpandWidth"), layoutExtent);
      var axisExpandCount = restrict(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
      var axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
      var axisExpandWindow = parallelModel.get("axisExpandWindow");
      var winSize;
      if (!axisExpandWindow) {
        winSize = restrict(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
        var axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor(axisCount / 2);
        axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
        axisExpandWindow[1] = axisExpandWindow[0] + winSize;
      } else {
        winSize = restrict(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
        axisExpandWindow[1] = axisExpandWindow[0] + winSize;
      }
      var axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
      axisCollapseWidth < 3 && (axisCollapseWidth = 0);
      var winInnerIndices = [mathFloor(round2(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil(round2(axisExpandWindow[1] / axisExpandWidth, 1)) - 1];
      var axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
      return {
        layout: layout2,
        pixelDimIndex,
        layoutBase: rect[xy[pixelDimIndex]],
        layoutLength,
        axisBase: rect[xy[1 - pixelDimIndex]],
        axisLength: rect[wh[1 - pixelDimIndex]],
        axisExpandable,
        axisExpandWidth,
        axisCollapseWidth,
        axisExpandWindow,
        axisCount,
        winInnerIndices,
        axisExpandWindow0Pos
      };
    },
    /**
     * @private
     */
    _layoutAxes: function() {
      var rect = this._rect;
      var axes = this._axesMap;
      var dimensions = this.dimensions;
      var layoutInfo = this._makeLayoutInfo();
      var layout2 = layoutInfo.layout;
      axes.each(function(axis2) {
        var axisExtent = [0, layoutInfo.axisLength];
        var idx = axis2.inverse ? 1 : 0;
        axis2.setExtent(axisExtent[idx], axisExtent[1 - idx]);
      });
      each2(dimensions, function(dim, idx) {
        var posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
        var positionTable = {
          horizontal: {
            x: posInfo.position,
            y: layoutInfo.axisLength
          },
          vertical: {
            x: 0,
            y: posInfo.position
          }
        };
        var rotationTable = {
          horizontal: PI3 / 2,
          vertical: 0
        };
        var position = [positionTable[layout2].x + rect.x, positionTable[layout2].y + rect.y];
        var rotation = rotationTable[layout2];
        var transform = matrix2.create();
        matrix2.rotate(transform, transform, rotation);
        matrix2.translate(transform, transform, position);
        this._axesLayout[dim] = {
          position,
          rotation,
          transform,
          axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
          axisLabelShow: posInfo.axisLabelShow,
          nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    },
    /**
     * Get axis by dim.
     * @param {string} dim
     * @return {module:echarts/coord/parallel/ParallelAxis} [description]
     */
    getAxis: function(dim) {
      return this._axesMap.get(dim);
    },
    /**
     * Convert a dim value of a single item of series data to Point.
     * @param {*} value
     * @param {string} dim
     * @return {Array}
     */
    dataToPoint: function(value, dim) {
      return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
    },
    /**
     * Travel data for one time, get activeState of each data item.
     * @param {module:echarts/data/List} data
     * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'
     *                            {number} dataIndex
     * @param {number} [start=0] the start dataIndex that travel from.
     * @param {number} [end=data.count()] the next dataIndex of the last dataIndex will be travel.
     */
    eachActiveState: function(data, callback, start, end) {
      start == null && (start = 0);
      end == null && (end = data.count());
      var axesMap = this._axesMap;
      var dimensions = this.dimensions;
      var dataDimensions = [];
      var axisModels = [];
      zrUtil2.each(dimensions, function(axisDim) {
        dataDimensions.push(data.mapDimension(axisDim));
        axisModels.push(axesMap.get(axisDim).model);
      });
      var hasActiveSet = this.hasAxisBrushed();
      for (var dataIndex = start; dataIndex < end; dataIndex++) {
        var activeState;
        if (!hasActiveSet) {
          activeState = "normal";
        } else {
          activeState = "active";
          var values = data.getValues(dataDimensions, dataIndex);
          for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
            var state = axisModels[j].getActiveState(values[j]);
            if (state === "inactive") {
              activeState = "inactive";
              break;
            }
          }
        }
        callback(activeState, dataIndex);
      }
    },
    /**
     * Whether has any activeSet.
     * @return {boolean}
     */
    hasAxisBrushed: function() {
      var dimensions = this.dimensions;
      var axesMap = this._axesMap;
      var hasActiveSet = false;
      for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
        if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
          hasActiveSet = true;
        }
      }
      return hasActiveSet;
    },
    /**
     * Convert coords of each axis to Point.
     *  Return point. For example: [10, 20]
     * @param {Array.<number>} coords
     * @param {string} dim
     * @return {Array.<number>}
     */
    axisCoordToPoint: function(coord, dim) {
      var axisLayout = this._axesLayout[dim];
      return graphic2.applyTransform([coord, 0], axisLayout.transform);
    },
    /**
     * Get axis layout.
     */
    getAxisLayout: function(dim) {
      return zrUtil2.clone(this._axesLayout[dim]);
    },
    /**
     * @param {Array.<number>} point
     * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
     */
    getSlidedAxisExpandWindow: function(point) {
      var layoutInfo = this._makeLayoutInfo();
      var pixelDimIndex = layoutInfo.pixelDimIndex;
      var axisExpandWindow = layoutInfo.axisExpandWindow.slice();
      var winSize = axisExpandWindow[1] - axisExpandWindow[0];
      var extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
      if (!this.containPoint(point)) {
        return {
          behavior: "none",
          axisExpandWindow
        };
      }
      var pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
      var delta;
      var behavior = "slide";
      var axisCollapseWidth = layoutInfo.axisCollapseWidth;
      var triggerArea = this._model.get("axisExpandSlideTriggerArea");
      var useJump = triggerArea[0] != null;
      if (axisCollapseWidth) {
        if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
          behavior = "jump";
          delta = pointCoord - winSize * triggerArea[2];
        } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
          behavior = "jump";
          delta = pointCoord - winSize * (1 - triggerArea[2]);
        } else {
          (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
        }
        delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
        delta ? sliderMove2(delta, axisExpandWindow, extent, "all") : behavior = "none";
      } else {
        var winSize = axisExpandWindow[1] - axisExpandWindow[0];
        var pos = extent[1] * pointCoord / winSize;
        axisExpandWindow = [mathMax2(0, pos - winSize / 2)];
        axisExpandWindow[1] = mathMin2(extent[1], axisExpandWindow[0] + winSize);
        axisExpandWindow[0] = axisExpandWindow[1] - winSize;
      }
      return {
        axisExpandWindow,
        behavior
      };
    }
  };
  function restrict(len, extent) {
    return mathMin2(mathMax2(len, extent[0]), extent[1]);
  }
  function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
    var step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
    return {
      position: step * axisIndex,
      axisNameAvailableWidth: step,
      axisLabelShow: true
    };
  }
  function layoutAxisWithExpand(axisIndex, layoutInfo) {
    var layoutLength = layoutInfo.layoutLength;
    var axisExpandWidth = layoutInfo.axisExpandWidth;
    var axisCount = layoutInfo.axisCount;
    var axisCollapseWidth = layoutInfo.axisCollapseWidth;
    var winInnerIndices = layoutInfo.winInnerIndices;
    var position;
    var axisNameAvailableWidth = axisCollapseWidth;
    var axisLabelShow = false;
    var nameTruncateMaxWidth;
    if (axisIndex < winInnerIndices[0]) {
      position = axisIndex * axisCollapseWidth;
      nameTruncateMaxWidth = axisCollapseWidth;
    } else if (axisIndex <= winInnerIndices[1]) {
      position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
      axisNameAvailableWidth = axisExpandWidth;
      axisLabelShow = true;
    } else {
      position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
      nameTruncateMaxWidth = axisCollapseWidth;
    }
    return {
      position,
      axisNameAvailableWidth,
      axisLabelShow,
      nameTruncateMaxWidth
    };
  }
  var _default2 = Parallel;
  Parallel_1 = _default2;
  return Parallel_1;
}
var hasRequiredParallelCreator;
function requireParallelCreator() {
  if (hasRequiredParallelCreator)
    return parallelCreator;
  hasRequiredParallelCreator = 1;
  var Parallel = requireParallel$2();
  var CoordinateSystem$1 = CoordinateSystem;
  function create(ecModel, api) {
    var coordSysList = [];
    ecModel.eachComponent("parallel", function(parallelModel, idx) {
      var coordSys = new Parallel(parallelModel, ecModel, api);
      coordSys.name = "parallel_" + idx;
      coordSys.resize(parallelModel, api);
      parallelModel.coordinateSystem = coordSys;
      coordSys.model = parallelModel;
      coordSysList.push(coordSys);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "parallel") {
        var parallelModel = ecModel.queryComponents({
          mainType: "parallel",
          index: seriesModel.get("parallelIndex"),
          id: seriesModel.get("parallelId")
        })[0];
        seriesModel.coordinateSystem = parallelModel.coordinateSystem;
      }
    });
    return coordSysList;
  }
  CoordinateSystem$1.register("parallel", {
    create
  });
  return parallelCreator;
}
var AxisModel_1$1;
var hasRequiredAxisModel$2;
function requireAxisModel$2() {
  if (hasRequiredAxisModel$2)
    return AxisModel_1$1;
  hasRequiredAxisModel$2 = 1;
  var zrUtil2 = util$6;
  var ComponentModel2 = Component$2;
  var makeStyleMapper2 = requireMakeStyleMapper();
  var axisModelCreator2 = requireAxisModelCreator();
  var numberUtil = requireNumber();
  var axisModelCommonMixin2 = requireAxisModelCommonMixin();
  var AxisModel2 = ComponentModel2.extend({
    type: "baseParallelAxis",
    /**
     * @type {module:echarts/coord/parallel/Axis}
     */
    axis: null,
    /**
     * @type {Array.<Array.<number>}
     * @readOnly
     */
    activeIntervals: [],
    /**
     * @return {Object}
     */
    getAreaSelectStyle: function() {
      return makeStyleMapper2([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle"));
    },
    /**
     * The code of this feature is put on AxisModel but not ParallelAxis,
     * because axisModel can be alive after echarts updating but instance of
     * ParallelAxis having been disposed. this._activeInterval should be kept
     * when action dispatched (i.e. legend click).
     *
     * @param {Array.<Array<number>>} intervals interval.length === 0
     *                                          means set all active.
     * @public
     */
    setActiveIntervals: function(intervals) {
      var activeIntervals = this.activeIntervals = zrUtil2.clone(intervals);
      if (activeIntervals) {
        for (var i = activeIntervals.length - 1; i >= 0; i--) {
          numberUtil.asc(activeIntervals[i]);
        }
      }
    },
    /**
     * @param {number|string} [value] When attempting to detect 'no activeIntervals set',
     *                         value can not be input.
     * @return {string} 'normal': no activeIntervals set,
     *                  'active',
     *                  'inactive'.
     * @public
     */
    getActiveState: function(value) {
      var activeIntervals = this.activeIntervals;
      if (!activeIntervals.length) {
        return "normal";
      }
      if (value == null || isNaN(value)) {
        return "inactive";
      }
      if (activeIntervals.length === 1) {
        var interval = activeIntervals[0];
        if (interval[0] <= value && value <= interval[1]) {
          return "active";
        }
      } else {
        for (var i = 0, len = activeIntervals.length; i < len; i++) {
          if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
            return "active";
          }
        }
      }
      return "inactive";
    }
  });
  var defaultOption = {
    type: "value",
    /**
     * @type {Array.<number>}
     */
    dim: null,
    // 0, 1, 2, ...
    // parallelIndex: null,
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: "rgba(160,197,232)",
      color: "rgba(160,197,232)",
      opacity: 0.3
    },
    realtime: true,
    // Whether realtime update view when select.
    z: 10
  };
  zrUtil2.merge(AxisModel2.prototype, axisModelCommonMixin2);
  function getAxisType(axisName, option) {
    return option.type || (option.data ? "category" : "value");
  }
  axisModelCreator2("parallel", AxisModel2, getAxisType, defaultOption);
  var _default2 = AxisModel2;
  AxisModel_1$1 = _default2;
  return AxisModel_1$1;
}
var ParallelModel;
var hasRequiredParallelModel;
function requireParallelModel() {
  if (hasRequiredParallelModel)
    return ParallelModel;
  hasRequiredParallelModel = 1;
  var zrUtil2 = util$6;
  var Component2 = Component$2;
  requireAxisModel$2();
  var _default2 = Component2.extend({
    type: "parallel",
    dependencies: ["parallelAxis"],
    /**
     * @type {module:echarts/coord/parallel/Parallel}
     */
    coordinateSystem: null,
    /**
     * Each item like: 'dim0', 'dim1', 'dim2', ...
     * @type {Array.<string>}
     * @readOnly
     */
    dimensions: null,
    /**
     * Coresponding to dimensions.
     * @type {Array.<number>}
     * @readOnly
     */
    parallelAxisIndex: null,
    layoutMode: "box",
    defaultOption: {
      zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // 'horizontal' or 'vertical'
      // FIXME
      // naming?
      axisExpandable: false,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      // FIXME '10%' ?
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      // 'mousemove' or 'click'
      parallelAxisDefault: null
    },
    /**
     * @override
     */
    init: function() {
      Component2.prototype.init.apply(this, arguments);
      this.mergeOption({});
    },
    /**
     * @override
     */
    mergeOption: function(newOption) {
      var thisOption = this.option;
      newOption && zrUtil2.merge(thisOption, newOption, true);
      this._initDimensions();
    },
    /**
     * Whether series or axis is in this coordinate system.
     * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model
     * @param {module:echarts/model/Global} ecModel
     */
    contains: function(model2, ecModel) {
      var parallelIndex = model2.get("parallelIndex");
      return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
    },
    setAxisExpand: function(opt) {
      zrUtil2.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(name2) {
        if (opt.hasOwnProperty(name2)) {
          this.option[name2] = opt[name2];
        }
      }, this);
    },
    /**
     * @private
     */
    _initDimensions: function() {
      var dimensions = this.dimensions = [];
      var parallelAxisIndex = this.parallelAxisIndex = [];
      var axisModels = zrUtil2.filter(this.dependentModels.parallelAxis, function(axisModel) {
        return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      zrUtil2.each(axisModels, function(axisModel) {
        dimensions.push("dim" + axisModel.get("dim"));
        parallelAxisIndex.push(axisModel.componentIndex);
      });
    }
  });
  ParallelModel = _default2;
  return ParallelModel;
}
var parallelAxis = {};
var parallelAxisAction = {};
var hasRequiredParallelAxisAction;
function requireParallelAxisAction() {
  if (hasRequiredParallelAxisAction)
    return parallelAxisAction;
  hasRequiredParallelAxisAction = 1;
  var echarts$12 = echarts;
  var actionInfo = {
    type: "axisAreaSelect",
    event: "axisAreaSelected"
    // update: 'updateVisual'
  };
  echarts$12.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallelAxis",
      query: payload
    }, function(parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  echarts$12.registerAction("parallelAxisExpand", function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "parallel",
      query: payload
    }, function(parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
  return parallelAxisAction;
}
var BrushController_1;
var hasRequiredBrushController;
function requireBrushController() {
  if (hasRequiredBrushController)
    return BrushController_1;
  hasRequiredBrushController = 1;
  var zrUtil2 = util$6;
  var Eventful2 = Eventful_1;
  var graphic2 = graphic$4;
  var interactionMutex2 = requireInteractionMutex();
  var DataDiffer = requireDataDiffer();
  var curry2 = zrUtil2.curry;
  var each2 = zrUtil2.each;
  var map2 = zrUtil2.map;
  var mathMin2 = Math.min;
  var mathMax2 = Math.max;
  var mathPow2 = Math.pow;
  var COVER_Z = 1e4;
  var UNSELECT_THRESHOLD = 6;
  var MIN_RESIZE_LINE_WIDTH = 6;
  var MUTEX_RESOURCE_KEY = "globalPan";
  var DIRECTION_MAP = {
    w: [0, 0],
    e: [0, 1],
    n: [1, 0],
    s: [1, 1]
  };
  var CURSOR_MAP = {
    w: "ew",
    e: "ew",
    n: "ns",
    s: "ns",
    ne: "nesw",
    sw: "nesw",
    nw: "nwse",
    se: "nwse"
  };
  var DEFAULT_BRUSH_OPT = {
    brushStyle: {
      lineWidth: 2,
      stroke: "rgba(0,0,0,0.3)",
      fill: "rgba(0,0,0,0.1)"
    },
    transformable: true,
    brushMode: "single",
    removeOnClick: false
  };
  var baseUID = 0;
  function BrushController(zr) {
    Eventful2.call(this);
    this._zr = zr;
    this.group = new graphic2.Group();
    this._brushType;
    this._brushOption;
    this._panels;
    this._track = [];
    this._dragging;
    this._covers = [];
    this._creatingCover;
    this._creatingPanel;
    this._enableGlobalPan;
    this._uid = "brushController_" + baseUID++;
    this._handlers = {};
    each2(pointerHandlers, function(handler, eventName) {
      this._handlers[eventName] = zrUtil2.bind(handler, this);
    }, this);
  }
  BrushController.prototype = {
    constructor: BrushController,
    /**
     * If set to null/undefined/false, select disabled.
     * @param {Object} brushOption
     * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
     *                          If passing false/null/undefined, disable brush.
     *                          If passing 'auto', determined by panel.defaultBrushType.
     *                              ('auto' can not be used in global panel)
     * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
     * @param {boolean} [brushOption.transformable=true]
     * @param {boolean} [brushOption.removeOnClick=false]
     * @param {Object} [brushOption.brushStyle]
     * @param {number} [brushOption.brushStyle.width]
     * @param {number} [brushOption.brushStyle.lineWidth]
     * @param {string} [brushOption.brushStyle.stroke]
     * @param {string} [brushOption.brushStyle.fill]
     * @param {number} [brushOption.z]
     */
    enableBrush: function(brushOption) {
      this._brushType && doDisableBrush(this);
      brushOption.brushType && doEnableBrush(this, brushOption);
      return this;
    },
    /**
     * @param {Array.<Object>} panelOpts If not pass, it is global brush.
     *        Each items: {
     *            panelId, // mandatory.
     *            clipPath, // mandatory. function.
     *            isTargetByCursor, // mandatory. function.
     *            defaultBrushType, // optional, only used when brushType is 'auto'.
     *            getLinearBrushOtherExtent, // optional. function.
     *        }
     */
    setPanels: function(panelOpts) {
      if (panelOpts && panelOpts.length) {
        var panels = this._panels = {};
        zrUtil2.each(panelOpts, function(panelOpts2) {
          panels[panelOpts2.panelId] = zrUtil2.clone(panelOpts2);
        });
      } else {
        this._panels = null;
      }
      return this;
    },
    /**
     * @param {Object} [opt]
     * @return {boolean} [opt.enableGlobalPan=false]
     */
    mount: function(opt) {
      opt = opt || {};
      this._enableGlobalPan = opt.enableGlobalPan;
      var thisGroup = this.group;
      this._zr.add(thisGroup);
      thisGroup.attr({
        position: opt.position || [0, 0],
        rotation: opt.rotation || 0,
        scale: opt.scale || [1, 1]
      });
      this._transform = thisGroup.getLocalTransform();
      return this;
    },
    eachCover: function(cb, context) {
      each2(this._covers, cb, context);
    },
    /**
     * Update covers.
     * @param {Array.<Object>} brushOptionList Like:
     *        [
     *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
     *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
     *            ...
     *        ]
     *        `brushType` is required in each cover info. (can not be 'auto')
     *        `id` is not mandatory.
     *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
     *        If brushOptionList is null/undefined, all covers removed.
     */
    updateCovers: function(brushOptionList) {
      brushOptionList = zrUtil2.map(brushOptionList, function(brushOption) {
        return zrUtil2.merge(zrUtil2.clone(DEFAULT_BRUSH_OPT), brushOption, true);
      });
      var tmpIdPrefix = "\0-brush-index-";
      var oldCovers = this._covers;
      var newCovers = this._covers = [];
      var controller = this;
      var creatingCover = this._creatingCover;
      new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove2).execute();
      return this;
      function getKey(brushOption, index2) {
        return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index2) + "-" + brushOption.brushType;
      }
      function oldGetKey(cover, index2) {
        return getKey(cover.__brushOption, index2);
      }
      function addOrUpdate(newIndex, oldIndex) {
        var newBrushOption = brushOptionList[newIndex];
        if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
          newCovers[newIndex] = oldCovers[oldIndex];
        } else {
          var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));
          updateCoverAfterCreation(controller, cover);
        }
      }
      function remove2(oldIndex) {
        if (oldCovers[oldIndex] !== creatingCover) {
          controller.group.remove(oldCovers[oldIndex]);
        }
      }
    },
    unmount: function() {
      this.enableBrush(false);
      clearCovers(this);
      this._zr.remove(this.group);
      return this;
    },
    dispose: function() {
      this.unmount();
      this.off();
    }
  };
  zrUtil2.mixin(BrushController, Eventful2);
  function doEnableBrush(controller, brushOption) {
    var zr = controller._zr;
    if (!controller._enableGlobalPan) {
      interactionMutex2.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
    }
    mountHandlers(zr, controller._handlers);
    controller._brushType = brushOption.brushType;
    controller._brushOption = zrUtil2.merge(zrUtil2.clone(DEFAULT_BRUSH_OPT), brushOption, true);
  }
  function doDisableBrush(controller) {
    var zr = controller._zr;
    interactionMutex2.release(zr, MUTEX_RESOURCE_KEY, controller._uid);
    unmountHandlers(zr, controller._handlers);
    controller._brushType = controller._brushOption = null;
  }
  function mountHandlers(zr, handlers) {
    each2(handlers, function(handler, eventName) {
      zr.on(eventName, handler);
    });
  }
  function unmountHandlers(zr, handlers) {
    each2(handlers, function(handler, eventName) {
      zr.off(eventName, handler);
    });
  }
  function createCover(controller, brushOption) {
    var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
    cover.__brushOption = brushOption;
    updateZ(cover, brushOption);
    controller.group.add(cover);
    return cover;
  }
  function endCreating(controller, creatingCover) {
    var coverRenderer = getCoverRenderer(creatingCover);
    if (coverRenderer.endCreating) {
      coverRenderer.endCreating(controller, creatingCover);
      updateZ(creatingCover, creatingCover.__brushOption);
    }
    return creatingCover;
  }
  function updateCoverShape(controller, cover) {
    var brushOption = cover.__brushOption;
    getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
  }
  function updateZ(cover, brushOption) {
    var z = brushOption.z;
    z == null && (z = COVER_Z);
    cover.traverse(function(el) {
      el.z = z;
      el.z2 = z;
    });
  }
  function updateCoverAfterCreation(controller, cover) {
    getCoverRenderer(cover).updateCommon(controller, cover);
    updateCoverShape(controller, cover);
  }
  function getCoverRenderer(cover) {
    return coverRenderers[cover.__brushOption.brushType];
  }
  function getPanelByPoint(controller, e2, localCursorPoint) {
    var panels = controller._panels;
    if (!panels) {
      return true;
    }
    var panel;
    var transform = controller._transform;
    each2(panels, function(pn) {
      pn.isTargetByCursor(e2, localCursorPoint, transform) && (panel = pn);
    });
    return panel;
  }
  function getPanelByCover(controller, cover) {
    var panels = controller._panels;
    if (!panels) {
      return true;
    }
    var panelId = cover.__brushOption.panelId;
    return panelId != null ? panels[panelId] : true;
  }
  function clearCovers(controller) {
    var covers = controller._covers;
    var originalLength = covers.length;
    each2(covers, function(cover) {
      controller.group.remove(cover);
    }, controller);
    covers.length = 0;
    return !!originalLength;
  }
  function trigger2(controller, opt) {
    var areas = map2(controller._covers, function(cover) {
      var brushOption = cover.__brushOption;
      var range = zrUtil2.clone(brushOption.range);
      return {
        brushType: brushOption.brushType,
        panelId: brushOption.panelId,
        range
      };
    });
    controller.trigger("brush", areas, {
      isEnd: !!opt.isEnd,
      removeOnClick: !!opt.removeOnClick
    });
  }
  function shouldShowCover(controller) {
    var track2 = controller._track;
    if (!track2.length) {
      return false;
    }
    var p2 = track2[track2.length - 1];
    var p1 = track2[0];
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var dist2 = mathPow2(dx * dx + dy * dy, 0.5);
    return dist2 > UNSELECT_THRESHOLD;
  }
  function getTrackEnds(track2) {
    var tail = track2.length - 1;
    tail < 0 && (tail = 0);
    return [track2[0], track2[tail]];
  }
  function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
    var cover = new graphic2.Group();
    cover.add(new graphic2.Rect({
      name: "main",
      style: makeStyle(brushOption),
      silent: true,
      draggable: true,
      cursor: "move",
      drift: curry2(doDrift, controller, cover, "nswe"),
      ondragend: curry2(trigger2, controller, {
        isEnd: true
      })
    }));
    each2(edgeNames, function(name2) {
      cover.add(new graphic2.Rect({
        name: name2,
        style: {
          opacity: 0
        },
        draggable: true,
        silent: true,
        invisible: true,
        drift: curry2(doDrift, controller, cover, name2),
        ondragend: curry2(trigger2, controller, {
          isEnd: true
        })
      }));
    });
    return cover;
  }
  function updateBaseRect(controller, cover, localRange, brushOption) {
    var lineWidth = brushOption.brushStyle.lineWidth || 0;
    var handleSize = mathMax2(lineWidth, MIN_RESIZE_LINE_WIDTH);
    var x = localRange[0][0];
    var y = localRange[1][0];
    var xa = x - lineWidth / 2;
    var ya = y - lineWidth / 2;
    var x2 = localRange[0][1];
    var y2 = localRange[1][1];
    var x2a = x2 - handleSize + lineWidth / 2;
    var y2a = y2 - handleSize + lineWidth / 2;
    var width = x2 - x;
    var height = y2 - y;
    var widtha = width + lineWidth;
    var heighta = height + lineWidth;
    updateRectShape(controller, cover, "main", x, y, width, height);
    if (brushOption.transformable) {
      updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
      updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
      updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
      updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
      updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
      updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
      updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
      updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
    }
  }
  function updateCommon(controller, cover) {
    var brushOption = cover.__brushOption;
    var transformable = brushOption.transformable;
    var mainEl = cover.childAt(0);
    mainEl.useStyle(makeStyle(brushOption));
    mainEl.attr({
      silent: !transformable,
      cursor: transformable ? "move" : "default"
    });
    each2(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function(name2) {
      var el = cover.childOfName(name2);
      var globalDir = getGlobalDirection(controller, name2);
      el && el.attr({
        silent: !transformable,
        invisible: !transformable,
        cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
      });
    });
  }
  function updateRectShape(controller, cover, name2, x, y, w, h) {
    var el = cover.childOfName(name2);
    el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
  }
  function makeStyle(brushOption) {
    return zrUtil2.defaults({
      strokeNoScale: true
    }, brushOption.brushStyle);
  }
  function formatRectRange(x, y, x2, y2) {
    var min3 = [mathMin2(x, x2), mathMin2(y, y2)];
    var max3 = [mathMax2(x, x2), mathMax2(y, y2)];
    return [
      [min3[0], max3[0]],
      // x range
      [min3[1], max3[1]]
      // y range
    ];
  }
  function getTransform2(controller) {
    return graphic2.getTransform(controller.group);
  }
  function getGlobalDirection(controller, localDirection) {
    if (localDirection.length > 1) {
      localDirection = localDirection.split("");
      var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];
      (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
      return globalDir.join("");
    } else {
      var map3 = {
        w: "left",
        e: "right",
        n: "top",
        s: "bottom"
      };
      var inverseMap = {
        left: "w",
        right: "e",
        top: "n",
        bottom: "s"
      };
      var globalDir = graphic2.transformDirection(map3[localDirection], getTransform2(controller));
      return inverseMap[globalDir];
    }
  }
  function driftRect(toRectRange, fromRectRange, controller, cover, name2, dx, dy, e2) {
    var brushOption = cover.__brushOption;
    var rectRange = toRectRange(brushOption.range);
    var localDelta = toLocalDelta(controller, dx, dy);
    each2(name2.split(""), function(namePart) {
      var ind = DIRECTION_MAP[namePart];
      rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
    });
    brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
    updateCoverAfterCreation(controller, cover);
    trigger2(controller, {
      isEnd: false
    });
  }
  function driftPolygon(controller, cover, dx, dy, e2) {
    var range = cover.__brushOption.range;
    var localDelta = toLocalDelta(controller, dx, dy);
    each2(range, function(point) {
      point[0] += localDelta[0];
      point[1] += localDelta[1];
    });
    updateCoverAfterCreation(controller, cover);
    trigger2(controller, {
      isEnd: false
    });
  }
  function toLocalDelta(controller, dx, dy) {
    var thisGroup = controller.group;
    var localD = thisGroup.transformCoordToLocal(dx, dy);
    var localZero = thisGroup.transformCoordToLocal(0, 0);
    return [localD[0] - localZero[0], localD[1] - localZero[1]];
  }
  function clipByPanel(controller, cover, data) {
    var panel = getPanelByCover(controller, cover);
    return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil2.clone(data);
  }
  function pointsToRect(points2) {
    var xmin = mathMin2(points2[0][0], points2[1][0]);
    var ymin = mathMin2(points2[0][1], points2[1][1]);
    var xmax = mathMax2(points2[0][0], points2[1][0]);
    var ymax = mathMax2(points2[0][1], points2[1][1]);
    return {
      x: xmin,
      y: ymin,
      width: xmax - xmin,
      height: ymax - ymin
    };
  }
  function resetCursor(controller, e2, localCursorPoint) {
    if (
      // Check active
      !controller._brushType || isOutsideZrArea(controller, e2)
    ) {
      return;
    }
    var zr = controller._zr;
    var covers = controller._covers;
    var currPanel = getPanelByPoint(controller, e2, localCursorPoint);
    if (!controller._dragging) {
      for (var i = 0; i < covers.length; i++) {
        var brushOption = covers[i].__brushOption;
        if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
          return;
        }
      }
    }
    currPanel && zr.setCursorStyle("crosshair");
  }
  function preventDefault(e2) {
    var rawE = e2.event;
    rawE.preventDefault && rawE.preventDefault();
  }
  function mainShapeContain(cover, x, y) {
    return cover.childOfName("main").contain(x, y);
  }
  function updateCoverByMouse(controller, e2, localCursorPoint, isEnd) {
    var creatingCover = controller._creatingCover;
    var panel = controller._creatingPanel;
    var thisBrushOption = controller._brushOption;
    var eventParams;
    controller._track.push(localCursorPoint.slice());
    if (shouldShowCover(controller) || creatingCover) {
      if (panel && !creatingCover) {
        thisBrushOption.brushMode === "single" && clearCovers(controller);
        var brushOption = zrUtil2.clone(thisBrushOption);
        brushOption.brushType = determineBrushType(brushOption.brushType, panel);
        brushOption.panelId = panel === true ? null : panel.panelId;
        creatingCover = controller._creatingCover = createCover(controller, brushOption);
        controller._covers.push(creatingCover);
      }
      if (creatingCover) {
        var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
        var coverBrushOption = creatingCover.__brushOption;
        coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
        if (isEnd) {
          endCreating(controller, creatingCover);
          coverRenderer.updateCommon(controller, creatingCover);
        }
        updateCoverShape(controller, creatingCover);
        eventParams = {
          isEnd
        };
      }
    } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
      if (getPanelByPoint(controller, e2, localCursorPoint) && clearCovers(controller)) {
        eventParams = {
          isEnd,
          removeOnClick: true
        };
      }
    }
    return eventParams;
  }
  function determineBrushType(brushType, panel) {
    if (brushType === "auto") {
      return panel.defaultBrushType;
    }
    return brushType;
  }
  var pointerHandlers = {
    mousedown: function(e2) {
      if (this._dragging) {
        handleDragEnd(this, e2);
      } else if (!e2.target || !e2.target.draggable) {
        preventDefault(e2);
        var localCursorPoint = this.group.transformCoordToLocal(e2.offsetX, e2.offsetY);
        this._creatingCover = null;
        var panel = this._creatingPanel = getPanelByPoint(this, e2, localCursorPoint);
        if (panel) {
          this._dragging = true;
          this._track = [localCursorPoint.slice()];
        }
      }
    },
    mousemove: function(e2) {
      var x = e2.offsetX;
      var y = e2.offsetY;
      var localCursorPoint = this.group.transformCoordToLocal(x, y);
      resetCursor(this, e2, localCursorPoint);
      if (this._dragging) {
        preventDefault(e2);
        var eventParams = updateCoverByMouse(this, e2, localCursorPoint, false);
        eventParams && trigger2(this, eventParams);
      }
    },
    mouseup: function(e2) {
      handleDragEnd(this, e2);
    }
  };
  function handleDragEnd(controller, e2) {
    if (controller._dragging) {
      preventDefault(e2);
      var x = e2.offsetX;
      var y = e2.offsetY;
      var localCursorPoint = controller.group.transformCoordToLocal(x, y);
      var eventParams = updateCoverByMouse(controller, e2, localCursorPoint, true);
      controller._dragging = false;
      controller._track = [];
      controller._creatingCover = null;
      eventParams && trigger2(controller, eventParams);
    }
  }
  function isOutsideZrArea(controller, x, y) {
    var zr = controller._zr;
    return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
  }
  var coverRenderers = {
    lineX: getLineRenderer(0),
    lineY: getLineRenderer(1),
    rect: {
      createCover: function(controller, brushOption) {
        return createBaseRectCover(curry2(driftRect, function(range) {
          return range;
        }, function(range) {
          return range;
        }), controller, brushOption, ["w", "e", "n", "s", "se", "sw", "ne", "nw"]);
      },
      getCreatingRange: function(localTrack) {
        var ends = getTrackEnds(localTrack);
        return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        updateBaseRect(controller, cover, localRange, brushOption);
      },
      updateCommon,
      contain: mainShapeContain
    },
    polygon: {
      createCover: function(controller, brushOption) {
        var cover = new graphic2.Group();
        cover.add(new graphic2.Polyline({
          name: "main",
          style: makeStyle(brushOption),
          silent: true
        }));
        return cover;
      },
      getCreatingRange: function(localTrack) {
        return localTrack;
      },
      endCreating: function(controller, cover) {
        cover.remove(cover.childAt(0));
        cover.add(new graphic2.Polygon({
          name: "main",
          draggable: true,
          drift: curry2(driftPolygon, controller, cover),
          ondragend: curry2(trigger2, controller, {
            isEnd: true
          })
        }));
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        cover.childAt(0).setShape({
          points: clipByPanel(controller, cover, localRange)
        });
      },
      updateCommon,
      contain: mainShapeContain
    }
  };
  function getLineRenderer(xyIndex) {
    return {
      createCover: function(controller, brushOption) {
        return createBaseRectCover(curry2(driftRect, function(range) {
          var rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        }, function(rectRange) {
          return rectRange[xyIndex];
        }), controller, brushOption, [["w", "e"], ["n", "s"]][xyIndex]);
      },
      getCreatingRange: function(localTrack) {
        var ends = getTrackEnds(localTrack);
        var min3 = mathMin2(ends[0][xyIndex], ends[1][xyIndex]);
        var max3 = mathMax2(ends[0][xyIndex], ends[1][xyIndex]);
        return [min3, max3];
      },
      updateCoverShape: function(controller, cover, localRange, brushOption) {
        var otherExtent;
        var panel = getPanelByCover(controller, cover);
        if (panel !== true && panel.getLinearBrushOtherExtent) {
          otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);
        } else {
          var zr = controller._zr;
          otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
        }
        var rectRange = [localRange, otherExtent];
        xyIndex && rectRange.reverse();
        updateBaseRect(controller, cover, rectRange, brushOption);
      },
      updateCommon,
      contain: mainShapeContain
    };
  }
  var _default2 = BrushController;
  BrushController_1 = _default2;
  return BrushController_1;
}
var brushHelper = {};
var hasRequiredBrushHelper;
function requireBrushHelper() {
  if (hasRequiredBrushHelper)
    return brushHelper;
  hasRequiredBrushHelper = 1;
  var BoundingRect2 = BoundingRect_1;
  var _cursorHelper = requireCursorHelper();
  var onIrrelevantElement = _cursorHelper.onIrrelevantElement;
  var graphicUtil2 = graphic$4;
  function makeRectPanelClipPath(rect) {
    rect = normalizeRect(rect);
    return function(localPoints, transform) {
      return graphicUtil2.clipPointsByRect(localPoints, rect);
    };
  }
  function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
    rect = normalizeRect(rect);
    return function(xyIndex) {
      var idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
      var brushWidth = idx ? rect.width : rect.height;
      var base2 = idx ? rect.x : rect.y;
      return [base2, base2 + (brushWidth || 0)];
    };
  }
  function makeRectIsTargetByCursor(rect, api, targetModel) {
    rect = normalizeRect(rect);
    return function(e2, localCursorPoint, transform) {
      return rect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e2, api, targetModel);
    };
  }
  function normalizeRect(rect) {
    return BoundingRect2.create(rect);
  }
  brushHelper.makeRectPanelClipPath = makeRectPanelClipPath;
  brushHelper.makeLinearBrushOtherExtent = makeLinearBrushOtherExtent;
  brushHelper.makeRectIsTargetByCursor = makeRectIsTargetByCursor;
  return brushHelper;
}
var ParallelAxisView;
var hasRequiredParallelAxisView;
function requireParallelAxisView() {
  if (hasRequiredParallelAxisView)
    return ParallelAxisView;
  hasRequiredParallelAxisView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var AxisBuilder = requireAxisBuilder();
  var BrushController = requireBrushController();
  var brushHelper2 = requireBrushHelper();
  var graphic2 = graphic$4;
  var elementList = ["axisLine", "axisTickLabel", "axisName"];
  var AxisView = echarts$12.extendComponentView({
    type: "parallelAxis",
    /**
     * @override
     */
    init: function(ecModel, api) {
      AxisView.superApply(this, "init", arguments);
      (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil2.bind(this._onBrush, this));
    },
    /**
     * @override
     */
    render: function(axisModel, ecModel, api, payload) {
      if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
        return;
      }
      this.axisModel = axisModel;
      this.api = api;
      this.group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new graphic2.Group();
      this.group.add(this._axisGroup);
      if (!axisModel.get("show")) {
        return;
      }
      var coordSysModel = getCoordSysModel(axisModel, ecModel);
      var coordSys = coordSysModel.coordinateSystem;
      var areaSelectStyle = axisModel.getAreaSelectStyle();
      var areaWidth = areaSelectStyle.width;
      var dim = axisModel.axis.dim;
      var axisLayout = coordSys.getAxisLayout(dim);
      var builderOpt = zrUtil2.extend({
        strokeContainThreshold: areaWidth
      }, axisLayout);
      var axisBuilder = new AxisBuilder(axisModel, builderOpt);
      zrUtil2.each(elementList, axisBuilder.add, axisBuilder);
      this._axisGroup.add(axisBuilder.getGroup());
      this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api);
      var animationModel = payload && payload.animation === false ? null : axisModel;
      graphic2.groupTransition(oldAxisGroup, this._axisGroup, animationModel);
    },
    // /**
    //  * @override
    //  */
    // updateVisual: function (axisModel, ecModel, api, payload) {
    //     this._brushController && this._brushController
    //         .updateCovers(getCoverInfoList(axisModel));
    // },
    _refreshBrushController: function(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
      var extent = axisModel.axis.getExtent();
      var extentLen = extent[1] - extent[0];
      var extra = Math.min(30, Math.abs(extentLen) * 0.1);
      var rect = graphic2.BoundingRect.create({
        x: extent[0],
        y: -areaWidth / 2,
        width: extentLen,
        height: areaWidth
      });
      rect.x -= extra;
      rect.width += 2 * extra;
      this._brushController.mount({
        enableGlobalPan: true,
        rotation: builderOpt.rotation,
        position: builderOpt.position
      }).setPanels([{
        panelId: "pl",
        clipPath: brushHelper2.makeRectPanelClipPath(rect),
        isTargetByCursor: brushHelper2.makeRectIsTargetByCursor(rect, api, coordSysModel),
        getLinearBrushOtherExtent: brushHelper2.makeLinearBrushOtherExtent(rect, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: areaSelectStyle,
        removeOnClick: true
      }).updateCovers(getCoverInfoList(axisModel));
    },
    _onBrush: function(coverInfoList, opt) {
      var axisModel = this.axisModel;
      var axis2 = axisModel.axis;
      var intervals = zrUtil2.map(coverInfoList, function(coverInfo) {
        return [axis2.coordToData(coverInfo.range[0], true), axis2.coordToData(coverInfo.range[1], true)];
      });
      if (!axisModel.option.realtime === opt.isEnd || opt.removeOnClick) {
        this.api.dispatchAction({
          type: "axisAreaSelect",
          parallelAxisId: axisModel.id,
          intervals
        });
      }
    },
    /**
     * @override
     */
    dispose: function() {
      this._brushController.dispose();
    }
  });
  function fromAxisAreaSelect(axisModel, ecModel, payload) {
    return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({
      mainType: "parallelAxis",
      query: payload
    })[0] === axisModel;
  }
  function getCoverInfoList(axisModel) {
    var axis2 = axisModel.axis;
    return zrUtil2.map(axisModel.activeIntervals, function(interval) {
      return {
        brushType: "lineX",
        panelId: "pl",
        range: [axis2.dataToCoord(interval[0], true), axis2.dataToCoord(interval[1], true)]
      };
    });
  }
  function getCoordSysModel(axisModel, ecModel) {
    return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
  }
  var _default2 = AxisView;
  ParallelAxisView = _default2;
  return ParallelAxisView;
}
var hasRequiredParallelAxis;
function requireParallelAxis() {
  if (hasRequiredParallelAxis)
    return parallelAxis;
  hasRequiredParallelAxis = 1;
  requireParallelCreator();
  requireParallelAxisAction();
  requireParallelAxisView();
  return parallelAxis;
}
var hasRequiredParallel$1;
function requireParallel$1() {
  if (hasRequiredParallel$1)
    return parallel;
  hasRequiredParallel$1 = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var throttleUtil = throttle$1;
  var parallelPreprocessor2 = requireParallelPreprocessor();
  requireParallelCreator();
  requireParallelModel();
  requireParallelAxis();
  var CLICK_THRESHOLD = 5;
  echarts$12.extendComponentView({
    type: "parallel",
    render: function(parallelModel, ecModel, api) {
      this._model = parallelModel;
      this._api = api;
      if (!this._handlers) {
        this._handlers = {};
        zrUtil2.each(handlers, function(handler, eventName) {
          api.getZr().on(eventName, this._handlers[eventName] = zrUtil2.bind(handler, this));
        }, this);
      }
      throttleUtil.createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
    },
    dispose: function(ecModel, api) {
      zrUtil2.each(this._handlers, function(handler, eventName) {
        api.getZr().off(eventName, handler);
      });
      this._handlers = null;
    },
    /**
     * @param {Object} [opt] If null, cancle the last action triggering for debounce.
     */
    _throttledDispatchExpand: function(opt) {
      this._dispatchExpand(opt);
    },
    _dispatchExpand: function(opt) {
      opt && this._api.dispatchAction(zrUtil2.extend({
        type: "parallelAxisExpand"
      }, opt));
    }
  });
  var handlers = {
    mousedown: function(e2) {
      if (checkTrigger(this, "click")) {
        this._mouseDownPoint = [e2.offsetX, e2.offsetY];
      }
    },
    mouseup: function(e2) {
      var mouseDownPoint = this._mouseDownPoint;
      if (checkTrigger(this, "click") && mouseDownPoint) {
        var point = [e2.offsetX, e2.offsetY];
        var dist2 = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
        if (dist2 > CLICK_THRESHOLD) {
          return;
        }
        var result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
        result.behavior !== "none" && this._dispatchExpand({
          axisExpandWindow: result.axisExpandWindow
        });
      }
      this._mouseDownPoint = null;
    },
    mousemove: function(e2) {
      if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
        return;
      }
      var model2 = this._model;
      var result = model2.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
      var behavior = result.behavior;
      behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model2.get("axisExpandDebounce"));
      this._throttledDispatchExpand(behavior === "none" ? null : {
        axisExpandWindow: result.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: behavior === "jump" ? null : false
      });
    }
  };
  function checkTrigger(view, triggerOn) {
    var model2 = view._model;
    return model2.get("axisExpandable") && model2.get("axisExpandTriggerOn") === triggerOn;
  }
  echarts$12.registerPreprocessor(parallelPreprocessor2);
  return parallel;
}
var ParallelSeries;
var hasRequiredParallelSeries;
function requireParallelSeries() {
  if (hasRequiredParallelSeries)
    return ParallelSeries;
  hasRequiredParallelSeries = 1;
  var _util2 = util$6;
  var each2 = _util2.each;
  var createHashMap2 = _util2.createHashMap;
  var SeriesModel2 = Series;
  var createListFromArray = requireCreateListFromArray();
  var _default2 = SeriesModel2.extend({
    type: "series.parallel",
    dependencies: ["parallel"],
    visualColorAccessPath: "lineStyle.color",
    getInitialData: function(option, ecModel) {
      var source = this.getSource();
      setEncodeAndDimensions(source, this);
      return createListFromArray(source, this);
    },
    /**
     * User can get data raw indices on 'axisAreaSelected' event received.
     *
     * @public
     * @param {string} activeState 'active' or 'inactive' or 'normal'
     * @return {Array.<number>} Raw indices
     */
    getRawIndicesByActiveState: function(activeState) {
      var coordSys = this.coordinateSystem;
      var data = this.getData();
      var indices = [];
      coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
        if (activeState === theActiveState) {
          indices.push(data.getRawIndex(dataIndex));
        }
      });
      return indices;
    },
    defaultOption: {
      zlevel: 0,
      // 一级层叠
      z: 2,
      // 二级层叠
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: false
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: false
        }
      },
      progressive: 500,
      smooth: false,
      // true | false | number
      animationEasing: "linear"
    }
  });
  function setEncodeAndDimensions(source, seriesModel) {
    if (source.encodeDefine) {
      return;
    }
    var parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    if (!parallelModel) {
      return;
    }
    var encodeDefine = source.encodeDefine = createHashMap2();
    each2(parallelModel.dimensions, function(axisDim) {
      var dataDimIndex = convertDimNameToNumber(axisDim);
      encodeDefine.set(axisDim, dataDimIndex);
    });
  }
  function convertDimNameToNumber(dimName) {
    return +dimName.replace("dim", "");
  }
  ParallelSeries = _default2;
  return ParallelSeries;
}
var ParallelView_1;
var hasRequiredParallelView;
function requireParallelView() {
  if (hasRequiredParallelView)
    return ParallelView_1;
  hasRequiredParallelView = 1;
  var graphic2 = graphic$4;
  var ChartView = Chart_1;
  var DEFAULT_SMOOTH = 0.3;
  var ParallelView = ChartView.extend({
    type: "parallel",
    init: function() {
      this._dataGroup = new graphic2.Group();
      this.group.add(this._dataGroup);
      this._data;
      this._initialized;
    },
    /**
     * @override
     */
    render: function(seriesModel, ecModel, api, payload) {
      var dataGroup = this._dataGroup;
      var data = seriesModel.getData();
      var oldData = this._data;
      var coordSys = seriesModel.coordinateSystem;
      var dimensions = coordSys.dimensions;
      var seriesScope = makeSeriesScope(seriesModel);
      data.diff(oldData).add(add2).update(update).remove(remove2).execute();
      function add2(newDataIndex) {
        var line2 = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
        updateElCommon(line2, data, newDataIndex, seriesScope);
      }
      function update(newDataIndex, oldDataIndex) {
        var line2 = oldData.getItemGraphicEl(oldDataIndex);
        var points2 = createLinePoints(data, newDataIndex, dimensions, coordSys);
        data.setItemGraphicEl(newDataIndex, line2);
        var animationModel = payload && payload.animation === false ? null : seriesModel;
        graphic2.updateProps(line2, {
          shape: {
            points: points2
          }
        }, animationModel, newDataIndex);
        updateElCommon(line2, data, newDataIndex, seriesScope);
      }
      function remove2(oldDataIndex) {
        var line2 = oldData.getItemGraphicEl(oldDataIndex);
        dataGroup.remove(line2);
      }
      if (!this._initialized) {
        this._initialized = true;
        var clipPath = createGridClipShape(coordSys, seriesModel, function() {
          setTimeout(function() {
            dataGroup.removeClipPath();
          });
        });
        dataGroup.setClipPath(clipPath);
      }
      this._data = data;
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
      this._initialized = true;
      this._data = null;
      this._dataGroup.removeAll();
    },
    incrementalRender: function(taskParams, seriesModel, ecModel) {
      var data = seriesModel.getData();
      var coordSys = seriesModel.coordinateSystem;
      var dimensions = coordSys.dimensions;
      var seriesScope = makeSeriesScope(seriesModel);
      for (var dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
        var line2 = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
        line2.incremental = true;
        updateElCommon(line2, data, dataIndex, seriesScope);
      }
    },
    dispose: function() {
    },
    // _renderForProgressive: function (seriesModel) {
    //     var dataGroup = this._dataGroup;
    //     var data = seriesModel.getData();
    //     var oldData = this._data;
    //     var coordSys = seriesModel.coordinateSystem;
    //     var dimensions = coordSys.dimensions;
    //     var option = seriesModel.option;
    //     var progressive = option.progressive;
    //     var smooth = option.smooth ? SMOOTH : null;
    //     // In progressive animation is disabled, so use simple data diff,
    //     // which effects performance less.
    //     // (Typically performance for data with length 7000+ like:
    //     // simpleDiff: 60ms, addEl: 184ms,
    //     // in RMBP 2.4GHz intel i7, OSX 10.9 chrome 50.0.2661.102 (64-bit))
    //     if (simpleDiff(oldData, data, dimensions)) {
    //         dataGroup.removeAll();
    //         data.each(function (dataIndex) {
    //             addEl(data, dataGroup, dataIndex, dimensions, coordSys);
    //         });
    //     }
    //     updateElCommon(data, progressive, smooth);
    //     // Consider switch between progressive and not.
    //     data.__plProgressive = true;
    //     this._data = data;
    // },
    /**
     * @override
     */
    remove: function() {
      this._dataGroup && this._dataGroup.removeAll();
      this._data = null;
    }
  });
  function createGridClipShape(coordSys, seriesModel, cb) {
    var parallelModel = coordSys.model;
    var rect = coordSys.getRect();
    var rectEl = new graphic2.Rect({
      shape: {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      }
    });
    var dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
    rectEl.setShape(dim, 0);
    graphic2.initProps(rectEl, {
      shape: {
        width: rect.width,
        height: rect.height
      }
    }, seriesModel, cb);
    return rectEl;
  }
  function createLinePoints(data, dataIndex, dimensions, coordSys) {
    var points2 = [];
    for (var i = 0; i < dimensions.length; i++) {
      var dimName = dimensions[i];
      var value = data.get(data.mapDimension(dimName), dataIndex);
      if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
        points2.push(coordSys.dataToPoint(value, dimName));
      }
    }
    return points2;
  }
  function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
    var points2 = createLinePoints(data, dataIndex, dimensions, coordSys);
    var line2 = new graphic2.Polyline({
      shape: {
        points: points2
      },
      silent: true,
      z2: 10
    });
    dataGroup.add(line2);
    data.setItemGraphicEl(dataIndex, line2);
    return line2;
  }
  function makeSeriesScope(seriesModel) {
    var smooth = seriesModel.get("smooth", true);
    smooth === true && (smooth = DEFAULT_SMOOTH);
    return {
      lineStyle: seriesModel.getModel("lineStyle").getLineStyle(),
      smooth: smooth != null ? smooth : DEFAULT_SMOOTH
    };
  }
  function updateElCommon(el, data, dataIndex, seriesScope) {
    var lineStyle2 = seriesScope.lineStyle;
    if (data.hasItemOption) {
      var lineStyleModel = data.getItemModel(dataIndex).getModel("lineStyle");
      lineStyle2 = lineStyleModel.getLineStyle();
    }
    el.useStyle(lineStyle2);
    var elStyle = el.style;
    elStyle.fill = null;
    elStyle.stroke = data.getItemVisual(dataIndex, "color");
    elStyle.opacity = data.getItemVisual(dataIndex, "opacity");
    seriesScope.smooth && (el.shape.smooth = seriesScope.smooth);
  }
  function isEmptyValue(val, axisType) {
    return axisType === "category" ? val == null : val == null || isNaN(val);
  }
  var _default2 = ParallelView;
  ParallelView_1 = _default2;
  return ParallelView_1;
}
var parallelVisual;
var hasRequiredParallelVisual;
function requireParallelVisual() {
  if (hasRequiredParallelVisual)
    return parallelVisual;
  hasRequiredParallelVisual = 1;
  var opacityAccessPath = ["lineStyle", "normal", "opacity"];
  var _default2 = {
    seriesType: "parallel",
    reset: function(seriesModel, ecModel, api) {
      var itemStyleModel = seriesModel.getModel("itemStyle");
      var lineStyleModel = seriesModel.getModel("lineStyle");
      var globalColors = ecModel.get("color");
      var color2 = lineStyleModel.get("color") || itemStyleModel.get("color") || globalColors[seriesModel.seriesIndex % globalColors.length];
      var inactiveOpacity = seriesModel.get("inactiveOpacity");
      var activeOpacity = seriesModel.get("activeOpacity");
      var lineStyle2 = seriesModel.getModel("lineStyle").getLineStyle();
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var opacityMap = {
        normal: lineStyle2.opacity,
        active: activeOpacity,
        inactive: inactiveOpacity
      };
      data.setVisual("color", color2);
      function progress(params, data2) {
        coordSys.eachActiveState(data2, function(activeState, dataIndex) {
          var opacity = opacityMap[activeState];
          if (activeState === "normal" && data2.hasItemOption) {
            var itemOpacity = data2.getItemModel(dataIndex).get(opacityAccessPath, true);
            itemOpacity != null && (opacity = itemOpacity);
          }
          data2.setItemVisual(dataIndex, "opacity", opacity);
        }, params.start, params.end);
      }
      return {
        progress
      };
    }
  };
  parallelVisual = _default2;
  return parallelVisual;
}
var hasRequiredParallel;
function requireParallel() {
  if (hasRequiredParallel)
    return parallel$1;
  hasRequiredParallel = 1;
  var echarts$12 = echarts;
  requireParallel$1();
  requireParallelSeries();
  requireParallelView();
  var parallelVisual2 = requireParallelVisual();
  echarts$12.registerVisual(parallelVisual2);
  return parallel$1;
}
var sankey = {};
var SankeySeries_1;
var hasRequiredSankeySeries;
function requireSankeySeries() {
  if (hasRequiredSankeySeries)
    return SankeySeries_1;
  hasRequiredSankeySeries = 1;
  var SeriesModel2 = Series;
  var createGraphFromNodeEdge2 = requireCreateGraphFromNodeEdge();
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var Model2 = requireModel();
  var SankeySeries = SeriesModel2.extend({
    type: "series.sankey",
    layoutInfo: null,
    levelModels: null,
    /**
     * Init a graph data structure from data in option series
     *
     * @param  {Object} option  the object used to config echarts view
     * @return {module:echarts/data/List} storage initial data
     */
    getInitialData: function(option, ecModel) {
      var links = option.edges || option.links;
      var nodes = option.data || option.nodes;
      var levels = option.levels;
      var levelModels = this.levelModels = {};
      for (var i = 0; i < levels.length; i++) {
        if (levels[i].depth != null && levels[i].depth >= 0) {
          levelModels[levels[i].depth] = new Model2(levels[i], this, ecModel);
        }
      }
      if (nodes && links) {
        var graph2 = createGraphFromNodeEdge2(nodes, links, this, true, beforeLink);
        return graph2.data;
      }
      function beforeLink(nodeData, edgeData) {
        nodeData.wrapMethod("getItemModel", function(model2, idx) {
          model2.customizeGetParent(function(path2) {
            var parentModel = this.parentModel;
            var nodeDepth = parentModel.getData().getItemLayout(idx).depth;
            var levelModel = parentModel.levelModels[nodeDepth];
            return levelModel || this.parentModel;
          });
          return model2;
        });
        edgeData.wrapMethod("getItemModel", function(model2, idx) {
          model2.customizeGetParent(function(path2) {
            var parentModel = this.parentModel;
            var edge = parentModel.getGraph().getEdgeByIndex(idx);
            var depth = edge.node1.getLayout().depth;
            var levelModel = parentModel.levelModels[depth];
            return levelModel || this.parentModel;
          });
          return model2;
        });
      }
    },
    setNodePosition: function(dataIndex, localPosition) {
      var dataItem = this.option.data[dataIndex];
      dataItem.localX = localPosition[0];
      dataItem.localY = localPosition[1];
    },
    /**
     * Return the graphic data structure
     *
     * @return {module:echarts/data/Graph} graphic data structure
     */
    getGraph: function() {
      return this.getData().graph;
    },
    /**
     * Get edge data of graphic data structure
     *
     * @return {module:echarts/data/List} data structure of list
     */
    getEdgeData: function() {
      return this.getGraph().edgeData;
    },
    /**
     * @override
     */
    formatTooltip: function(dataIndex, multipleSeries, dataType) {
      if (dataType === "edge") {
        var params = this.getDataParams(dataIndex, dataType);
        var rawDataOpt = params.data;
        var html = rawDataOpt.source + " -- " + rawDataOpt.target;
        if (params.value) {
          html += " : " + params.value;
        }
        return encodeHTML2(html);
      } else if (dataType === "node") {
        var node = this.getGraph().getNodeByIndex(dataIndex);
        var value = node.getLayout().value;
        var name2 = this.getDataParams(dataIndex, dataType).data.name;
        if (value) {
          var html = name2 + " : " + value;
        }
        return encodeHTML2(html);
      }
      return SankeySeries.superCall(this, "formatTooltip", dataIndex, multipleSeries);
    },
    optionUpdated: function() {
      var option = this.option;
      if (option.focusNodeAdjacency === true) {
        option.focusNodeAdjacency = "allEdges";
      }
    },
    // Override Series.getDataParams()
    getDataParams: function(dataIndex, dataType) {
      var params = SankeySeries.superCall(this, "getDataParams", dataIndex, dataType);
      if (params.value == null && dataType === "node") {
        var node = this.getGraph().getNodeByIndex(dataIndex);
        var nodeValue = node.getLayout().value;
        params.value = nodeValue;
      }
      return params;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      layout: null,
      // The position of the whole view
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      // Value can be 'vertical'
      orient: "horizontal",
      // The dx of the node
      nodeWidth: 20,
      // The vertical distance between two nodes
      nodeGap: 8,
      // Control if the node can move or not
      draggable: true,
      // Value can be 'inEdges', 'outEdges', 'allEdges', true (the same as 'allEdges').
      focusNodeAdjacency: false,
      // The number of iterations to change the position of the node
      layoutIterations: 32,
      label: {
        show: true,
        position: "right",
        color: "#000",
        fontSize: 12
      },
      levels: [],
      // Value can be 'left' or 'right'
      nodeAlign: "justify",
      itemStyle: {
        borderWidth: 1,
        borderColor: "#333"
      },
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }
  });
  var _default2 = SankeySeries;
  SankeySeries_1 = _default2;
  return SankeySeries_1;
}
var SankeyView;
var hasRequiredSankeyView;
function requireSankeyView() {
  if (hasRequiredSankeyView)
    return SankeyView;
  hasRequiredSankeyView = 1;
  var graphic2 = graphic$4;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var nodeOpacityPath = ["itemStyle", "opacity"];
  var hoverNodeOpacityPath = ["emphasis", "itemStyle", "opacity"];
  var lineOpacityPath = ["lineStyle", "opacity"];
  var hoverLineOpacityPath = ["emphasis", "lineStyle", "opacity"];
  function getItemOpacity(item, opacityPath) {
    return item.getVisual("opacity") || item.getModel().get(opacityPath);
  }
  function fadeOutItem(item, opacityPath, opacityRatio) {
    var el = item.getGraphicEl();
    var opacity = getItemOpacity(item, opacityPath);
    if (opacityRatio != null) {
      opacity == null && (opacity = 1);
      opacity *= opacityRatio;
    }
    el.downplay && el.downplay();
    el.traverse(function(child) {
      if (child.type !== "group") {
        child.setStyle("opacity", opacity);
      }
    });
  }
  function fadeInItem(item, opacityPath) {
    var opacity = getItemOpacity(item, opacityPath);
    var el = item.getGraphicEl();
    el.traverse(function(child) {
      if (child.type !== "group") {
        child.setStyle("opacity", opacity);
      }
    });
    el.highlight && el.highlight();
  }
  var SankeyShape = graphic2.extendShape({
    shape: {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0,
      cpx1: 0,
      cpy1: 0,
      cpx2: 0,
      cpy2: 0,
      extent: 0,
      orient: ""
    },
    buildPath: function(ctx, shape) {
      var extent = shape.extent;
      ctx.moveTo(shape.x1, shape.y1);
      ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
      if (shape.orient === "vertical") {
        ctx.lineTo(shape.x2 + extent, shape.y2);
        ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);
      } else {
        ctx.lineTo(shape.x2, shape.y2 + extent);
        ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);
      }
      ctx.closePath();
    },
    highlight: function() {
      this.trigger("emphasis");
    },
    downplay: function() {
      this.trigger("normal");
    }
  });
  var _default2 = echarts$12.extendChartView({
    type: "sankey",
    /**
     * @private
     * @type {module:echarts/chart/sankey/SankeySeries}
     */
    _model: null,
    /**
     * @private
     * @type {boolean}
     */
    _focusAdjacencyDisabled: false,
    render: function(seriesModel, ecModel, api) {
      var sankeyView = this;
      var graph2 = seriesModel.getGraph();
      var group = this.group;
      var layoutInfo = seriesModel.layoutInfo;
      var width = layoutInfo.width;
      var height = layoutInfo.height;
      var nodeData = seriesModel.getData();
      var edgeData = seriesModel.getData("edge");
      var orient = seriesModel.get("orient");
      this._model = seriesModel;
      group.removeAll();
      group.attr("position", [layoutInfo.x, layoutInfo.y]);
      graph2.eachEdge(function(edge) {
        var curve2 = new SankeyShape();
        curve2.dataIndex = edge.dataIndex;
        curve2.seriesIndex = seriesModel.seriesIndex;
        curve2.dataType = "edge";
        var lineStyleModel = edge.getModel("lineStyle");
        var curvature = lineStyleModel.get("curveness");
        var n1Layout = edge.node1.getLayout();
        var node1Model = edge.node1.getModel();
        var dragX1 = node1Model.get("localX");
        var dragY1 = node1Model.get("localY");
        var n2Layout = edge.node2.getLayout();
        var node2Model = edge.node2.getModel();
        var dragX2 = node2Model.get("localX");
        var dragY2 = node2Model.get("localY");
        var edgeLayout = edge.getLayout();
        var x1;
        var y1;
        var x2;
        var y2;
        var cpx1;
        var cpy1;
        var cpx2;
        var cpy2;
        curve2.shape.extent = Math.max(1, edgeLayout.dy);
        curve2.shape.orient = orient;
        if (orient === "vertical") {
          x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
          y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
          x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
          y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
          cpx1 = x1;
          cpy1 = y1 * (1 - curvature) + y2 * curvature;
          cpx2 = x2;
          cpy2 = y1 * curvature + y2 * (1 - curvature);
        } else {
          x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
          y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
          x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
          y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
          cpx1 = x1 * (1 - curvature) + x2 * curvature;
          cpy1 = y1;
          cpx2 = x1 * curvature + x2 * (1 - curvature);
          cpy2 = y2;
        }
        curve2.setShape({
          x1,
          y1,
          x2,
          y2,
          cpx1,
          cpy1,
          cpx2,
          cpy2
        });
        curve2.setStyle(lineStyleModel.getItemStyle());
        switch (curve2.style.fill) {
          case "source":
            curve2.style.fill = edge.node1.getVisual("color");
            break;
          case "target":
            curve2.style.fill = edge.node2.getVisual("color");
            break;
        }
        graphic2.setHoverStyle(curve2, edge.getModel("emphasis.lineStyle").getItemStyle());
        group.add(curve2);
        edgeData.setItemGraphicEl(edge.dataIndex, curve2);
      });
      graph2.eachNode(function(node) {
        var layout2 = node.getLayout();
        var itemModel = node.getModel();
        var dragX = itemModel.get("localX");
        var dragY = itemModel.get("localY");
        var labelModel = itemModel.getModel("label");
        var labelHoverModel = itemModel.getModel("emphasis.label");
        var rect = new graphic2.Rect({
          shape: {
            x: dragX != null ? dragX * width : layout2.x,
            y: dragY != null ? dragY * height : layout2.y,
            width: layout2.dx,
            height: layout2.dy
          },
          style: itemModel.getModel("itemStyle").getItemStyle()
        });
        var hoverStyle = node.getModel("emphasis.itemStyle").getItemStyle();
        graphic2.setLabelStyle(rect.style, hoverStyle, labelModel, labelHoverModel, {
          labelFetcher: seriesModel,
          labelDataIndex: node.dataIndex,
          defaultText: node.id,
          isRectText: true
        });
        rect.setStyle("fill", node.getVisual("color"));
        graphic2.setHoverStyle(rect, hoverStyle);
        group.add(rect);
        nodeData.setItemGraphicEl(node.dataIndex, rect);
        rect.dataType = "node";
      });
      nodeData.eachItemGraphicEl(function(el, dataIndex) {
        var itemModel = nodeData.getItemModel(dataIndex);
        if (itemModel.get("draggable")) {
          el.drift = function(dx, dy) {
            sankeyView._focusAdjacencyDisabled = true;
            this.shape.x += dx;
            this.shape.y += dy;
            this.dirty();
            api.dispatchAction({
              type: "dragNode",
              seriesId: seriesModel.id,
              dataIndex: nodeData.getRawIndex(dataIndex),
              localX: this.shape.x / width,
              localY: this.shape.y / height
            });
          };
          el.ondragend = function() {
            sankeyView._focusAdjacencyDisabled = false;
          };
          el.draggable = true;
          el.cursor = "move";
        }
        el.highlight = function() {
          this.trigger("emphasis");
        };
        el.downplay = function() {
          this.trigger("normal");
        };
        el.focusNodeAdjHandler && el.off("mouseover", el.focusNodeAdjHandler);
        el.unfocusNodeAdjHandler && el.off("mouseout", el.unfocusNodeAdjHandler);
        if (itemModel.get("focusNodeAdjacency")) {
          el.on("mouseover", el.focusNodeAdjHandler = function() {
            if (!sankeyView._focusAdjacencyDisabled) {
              sankeyView._clearTimer();
              api.dispatchAction({
                type: "focusNodeAdjacency",
                seriesId: seriesModel.id,
                dataIndex: el.dataIndex
              });
            }
          });
          el.on("mouseout", el.unfocusNodeAdjHandler = function() {
            if (!sankeyView._focusAdjacencyDisabled) {
              sankeyView._dispatchUnfocus(api);
            }
          });
        }
      });
      edgeData.eachItemGraphicEl(function(el, dataIndex) {
        var edgeModel = edgeData.getItemModel(dataIndex);
        el.focusNodeAdjHandler && el.off("mouseover", el.focusNodeAdjHandler);
        el.unfocusNodeAdjHandler && el.off("mouseout", el.unfocusNodeAdjHandler);
        if (edgeModel.get("focusNodeAdjacency")) {
          el.on("mouseover", el.focusNodeAdjHandler = function() {
            if (!sankeyView._focusAdjacencyDisabled) {
              sankeyView._clearTimer();
              api.dispatchAction({
                type: "focusNodeAdjacency",
                seriesId: seriesModel.id,
                edgeDataIndex: el.dataIndex
              });
            }
          });
          el.on("mouseout", el.unfocusNodeAdjHandler = function() {
            if (!sankeyView._focusAdjacencyDisabled) {
              sankeyView._dispatchUnfocus(api);
            }
          });
        }
      });
      if (!this._data && seriesModel.get("animation")) {
        group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function() {
          group.removeClipPath();
        }));
      }
      this._data = seriesModel.getData();
    },
    dispose: function() {
      this._clearTimer();
    },
    _dispatchUnfocus: function(api) {
      var self2 = this;
      this._clearTimer();
      this._unfocusDelayTimer = setTimeout(function() {
        self2._unfocusDelayTimer = null;
        api.dispatchAction({
          type: "unfocusNodeAdjacency",
          seriesId: self2._model.id
        });
      }, 500);
    },
    _clearTimer: function() {
      if (this._unfocusDelayTimer) {
        clearTimeout(this._unfocusDelayTimer);
        this._unfocusDelayTimer = null;
      }
    },
    focusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
      var data = seriesModel.getData();
      var graph2 = data.graph;
      var dataIndex = payload.dataIndex;
      var itemModel = data.getItemModel(dataIndex);
      var edgeDataIndex = payload.edgeDataIndex;
      if (dataIndex == null && edgeDataIndex == null) {
        return;
      }
      var node = graph2.getNodeByIndex(dataIndex);
      var edge = graph2.getEdgeByIndex(edgeDataIndex);
      graph2.eachNode(function(node2) {
        fadeOutItem(node2, nodeOpacityPath, 0.1);
      });
      graph2.eachEdge(function(edge2) {
        fadeOutItem(edge2, lineOpacityPath, 0.1);
      });
      if (node) {
        fadeInItem(node, hoverNodeOpacityPath);
        var focusNodeAdj = itemModel.get("focusNodeAdjacency");
        if (focusNodeAdj === "outEdges") {
          zrUtil2.each(node.outEdges, function(edge2) {
            if (edge2.dataIndex < 0) {
              return;
            }
            fadeInItem(edge2, hoverLineOpacityPath);
            fadeInItem(edge2.node2, hoverNodeOpacityPath);
          });
        } else if (focusNodeAdj === "inEdges") {
          zrUtil2.each(node.inEdges, function(edge2) {
            if (edge2.dataIndex < 0) {
              return;
            }
            fadeInItem(edge2, hoverLineOpacityPath);
            fadeInItem(edge2.node1, hoverNodeOpacityPath);
          });
        } else if (focusNodeAdj === "allEdges") {
          zrUtil2.each(node.edges, function(edge2) {
            if (edge2.dataIndex < 0) {
              return;
            }
            fadeInItem(edge2, hoverLineOpacityPath);
            edge2.node1 !== node && fadeInItem(edge2.node1, hoverNodeOpacityPath);
            edge2.node2 !== node && fadeInItem(edge2.node2, hoverNodeOpacityPath);
          });
        }
      }
      if (edge) {
        fadeInItem(edge, hoverLineOpacityPath);
        fadeInItem(edge.node1, hoverNodeOpacityPath);
        fadeInItem(edge.node2, hoverNodeOpacityPath);
      }
    },
    unfocusNodeAdjacency: function(seriesModel, ecModel, api, payload) {
      var graph2 = seriesModel.getGraph();
      graph2.eachNode(function(node) {
        fadeOutItem(node, nodeOpacityPath);
      });
      graph2.eachEdge(function(edge) {
        fadeOutItem(edge, lineOpacityPath);
      });
    }
  });
  function createGridClipShape(rect, seriesModel, cb) {
    var rectEl = new graphic2.Rect({
      shape: {
        x: rect.x - 10,
        y: rect.y - 10,
        width: 0,
        height: rect.height + 20
      }
    });
    graphic2.initProps(rectEl, {
      shape: {
        width: rect.width + 20
      }
    }, seriesModel, cb);
    return rectEl;
  }
  SankeyView = _default2;
  return SankeyView;
}
var sankeyAction = {};
var hasRequiredSankeyAction;
function requireSankeyAction() {
  if (hasRequiredSankeyAction)
    return sankeyAction;
  hasRequiredSankeyAction = 1;
  var echarts$12 = echarts;
  requireFocusNodeAdjacencyAction();
  echarts$12.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: payload
    }, function(seriesModel) {
      seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
    });
  });
  return sankeyAction;
}
var sankeyLayout;
var hasRequiredSankeyLayout;
function requireSankeyLayout() {
  if (hasRequiredSankeyLayout)
    return sankeyLayout;
  hasRequiredSankeyLayout = 1;
  var layout2 = layout$1;
  var zrUtil2 = util$6;
  var _model2 = model;
  var groupData2 = _model2.groupData;
  function _default2(ecModel, api, payload) {
    ecModel.eachSeriesByType("sankey", function(seriesModel) {
      var nodeWidth = seriesModel.get("nodeWidth");
      var nodeGap = seriesModel.get("nodeGap");
      var layoutInfo = getViewRect(seriesModel, api);
      seriesModel.layoutInfo = layoutInfo;
      var width = layoutInfo.width;
      var height = layoutInfo.height;
      var graph2 = seriesModel.getGraph();
      var nodes = graph2.nodes;
      var edges = graph2.edges;
      computeNodeValues(nodes);
      var filteredNodes = zrUtil2.filter(nodes, function(node) {
        return node.getLayout().value === 0;
      });
      var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
      var orient = seriesModel.get("orient");
      var nodeAlign = seriesModel.get("nodeAlign");
      layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
    });
  }
  function getViewRect(seriesModel, api) {
    return layout2.getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    });
  }
  function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
    computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
    computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
    computeEdgeDepths(nodes, orient);
  }
  function computeNodeValues(nodes) {
    zrUtil2.each(nodes, function(node) {
      var value1 = sum(node.outEdges, getEdgeValue);
      var value2 = sum(node.inEdges, getEdgeValue);
      var nodeRawValue = node.getValue() || 0;
      var value = Math.max(value1, value2, nodeRawValue);
      node.setLayout({
        value
      }, true);
    });
  }
  function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
    var remainEdges = [];
    var indegreeArr = [];
    var zeroIndegrees = [];
    var nextTargetNode = [];
    var x = 0;
    var kx = 0;
    for (var i = 0; i < edges.length; i++) {
      remainEdges[i] = 1;
    }
    for (i = 0; i < nodes.length; i++) {
      indegreeArr[i] = nodes[i].inEdges.length;
      if (indegreeArr[i] === 0) {
        zeroIndegrees.push(nodes[i]);
      }
    }
    var maxNodeDepth = -1;
    while (zeroIndegrees.length) {
      for (var idx = 0; idx < zeroIndegrees.length; idx++) {
        var node = zeroIndegrees[idx];
        var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
        var isItemDepth = item.depth != null && item.depth >= 0;
        if (isItemDepth && item.depth > maxNodeDepth) {
          maxNodeDepth = item.depth;
        }
        node.setLayout({
          depth: isItemDepth ? item.depth : x
        }, true);
        orient === "vertical" ? node.setLayout({
          dy: nodeWidth
        }, true) : node.setLayout({
          dx: nodeWidth
        }, true);
        for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
          var edge = node.outEdges[edgeIdx];
          var indexEdge = edges.indexOf(edge);
          remainEdges[indexEdge] = 0;
          var targetNode = edge.node2;
          var nodeIndex = nodes.indexOf(targetNode);
          if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
            nextTargetNode.push(targetNode);
          }
        }
      }
      ++x;
      zeroIndegrees = nextTargetNode;
      nextTargetNode = [];
    }
    for (i = 0; i < remainEdges.length; i++) {
      if (remainEdges[i] === 1) {
        throw new Error("Sankey is a DAG, the original data has cycle!");
      }
    }
    var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
    if (nodeAlign && nodeAlign !== "left") {
      adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
    }
    var kx = orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
    scaleNodeBreadths(nodes, kx, orient);
  }
  function isNodeDepth(node) {
    var item = node.hostGraph.data.getRawDataItem(node.dataIndex);
    return item.depth != null && item.depth >= 0;
  }
  function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
    if (nodeAlign === "right") {
      var nextSourceNode = [];
      var remainNodes = nodes;
      var nodeHeight = 0;
      while (remainNodes.length) {
        for (var i = 0; i < remainNodes.length; i++) {
          var node = remainNodes[i];
          node.setLayout({
            skNodeHeight: nodeHeight
          }, true);
          for (var j = 0; j < node.inEdges.length; j++) {
            var edge = node.inEdges[j];
            if (nextSourceNode.indexOf(edge.node1) < 0) {
              nextSourceNode.push(edge.node1);
            }
          }
        }
        remainNodes = nextSourceNode;
        nextSourceNode = [];
        ++nodeHeight;
      }
      zrUtil2.each(nodes, function(node2) {
        if (!isNodeDepth(node2)) {
          node2.setLayout({
            depth: Math.max(0, maxDepth - node2.getLayout().skNodeHeight)
          }, true);
        }
      });
    } else if (nodeAlign === "justify") {
      moveSinksRight(nodes, maxDepth);
    }
  }
  function moveSinksRight(nodes, maxDepth) {
    zrUtil2.each(nodes, function(node) {
      if (!isNodeDepth(node) && !node.outEdges.length) {
        node.setLayout({
          depth: maxDepth
        }, true);
      }
    });
  }
  function scaleNodeBreadths(nodes, kx, orient) {
    zrUtil2.each(nodes, function(node) {
      var nodeDepth = node.getLayout().depth * kx;
      orient === "vertical" ? node.setLayout({
        y: nodeDepth
      }, true) : node.setLayout({
        x: nodeDepth
      }, true);
    });
  }
  function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
    var nodesByBreadth = prepareNodesByBreadth(nodes, orient);
    initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    for (var alpha = 1; iterations > 0; iterations--) {
      alpha *= 0.99;
      relaxRightToLeft(nodesByBreadth, alpha, orient);
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
      relaxLeftToRight(nodesByBreadth, alpha, orient);
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    }
  }
  function prepareNodesByBreadth(nodes, orient) {
    var nodesByBreadth = [];
    var keyAttr = orient === "vertical" ? "y" : "x";
    var groupResult = groupData2(nodes, function(node) {
      return node.getLayout()[keyAttr];
    });
    groupResult.keys.sort(function(a, b) {
      return a - b;
    });
    zrUtil2.each(groupResult.keys, function(key) {
      nodesByBreadth.push(groupResult.buckets.get(key));
    });
    return nodesByBreadth;
  }
  function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
    var minKy = Infinity;
    zrUtil2.each(nodesByBreadth, function(nodes) {
      var n = nodes.length;
      var sum2 = 0;
      zrUtil2.each(nodes, function(node) {
        sum2 += node.getLayout().value;
      });
      var ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
      if (ky < minKy) {
        minKy = ky;
      }
    });
    zrUtil2.each(nodesByBreadth, function(nodes) {
      zrUtil2.each(nodes, function(node, i) {
        var nodeDy = node.getLayout().value * minKy;
        if (orient === "vertical") {
          node.setLayout({
            x: i
          }, true);
          node.setLayout({
            dx: nodeDy
          }, true);
        } else {
          node.setLayout({
            y: i
          }, true);
          node.setLayout({
            dy: nodeDy
          }, true);
        }
      });
    });
    zrUtil2.each(edges, function(edge) {
      var edgeDy = +edge.getValue() * minKy;
      edge.setLayout({
        dy: edgeDy
      }, true);
    });
  }
  function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
    var keyAttr = orient === "vertical" ? "x" : "y";
    zrUtil2.each(nodesByBreadth, function(nodes) {
      nodes.sort(function(a, b) {
        return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
      });
      var nodeX;
      var node;
      var dy;
      var y0 = 0;
      var n = nodes.length;
      var nodeDyAttr = orient === "vertical" ? "dx" : "dy";
      for (var i = 0; i < n; i++) {
        node = nodes[i];
        dy = y0 - node.getLayout()[keyAttr];
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] + dy;
          orient === "vertical" ? node.setLayout({
            x: nodeX
          }, true) : node.setLayout({
            y: nodeX
          }, true);
        }
        y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
      }
      var viewWidth = orient === "vertical" ? width : height;
      dy = y0 - nodeGap - viewWidth;
      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] - dy;
        orient === "vertical" ? node.setLayout({
          x: nodeX
        }, true) : node.setLayout({
          y: nodeX
        }, true);
        y0 = nodeX;
        for (i = n - 2; i >= 0; --i) {
          node = nodes[i];
          dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
          if (dy > 0) {
            nodeX = node.getLayout()[keyAttr] - dy;
            orient === "vertical" ? node.setLayout({
              x: nodeX
            }, true) : node.setLayout({
              y: nodeX
            }, true);
          }
          y0 = node.getLayout()[keyAttr];
        }
      }
    });
  }
  function relaxRightToLeft(nodesByBreadth, alpha, orient) {
    zrUtil2.each(nodesByBreadth.slice().reverse(), function(nodes) {
      zrUtil2.each(nodes, function(node) {
        if (node.outEdges.length) {
          var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue, orient);
          if (isNaN(y)) {
            var len = node.outEdges.length;
            y = len ? sum(node.outEdges, centerTarget, orient) / len : 0;
          }
          if (orient === "vertical") {
            var nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
            node.setLayout({
              x: nodeX
            }, true);
          } else {
            var nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
            node.setLayout({
              y: nodeY
            }, true);
          }
        }
      });
    });
  }
  function weightedTarget(edge, orient) {
    return center2(edge.node2, orient) * edge.getValue();
  }
  function centerTarget(edge, orient) {
    return center2(edge.node2, orient);
  }
  function weightedSource(edge, orient) {
    return center2(edge.node1, orient) * edge.getValue();
  }
  function centerSource(edge, orient) {
    return center2(edge.node1, orient);
  }
  function center2(node, orient) {
    return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
  }
  function getEdgeValue(edge) {
    return edge.getValue();
  }
  function sum(array, cb, orient) {
    var sum2 = 0;
    var len = array.length;
    var i = -1;
    while (++i < len) {
      var value = +cb.call(array, array[i], orient);
      if (!isNaN(value)) {
        sum2 += value;
      }
    }
    return sum2;
  }
  function relaxLeftToRight(nodesByBreadth, alpha, orient) {
    zrUtil2.each(nodesByBreadth, function(nodes) {
      zrUtil2.each(nodes, function(node) {
        if (node.inEdges.length) {
          var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue, orient);
          if (isNaN(y)) {
            var len = node.inEdges.length;
            y = len ? sum(node.inEdges, centerSource, orient) / len : 0;
          }
          if (orient === "vertical") {
            var nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
            node.setLayout({
              x: nodeX
            }, true);
          } else {
            var nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
            node.setLayout({
              y: nodeY
            }, true);
          }
        }
      });
    });
  }
  function computeEdgeDepths(nodes, orient) {
    var keyAttr = orient === "vertical" ? "x" : "y";
    zrUtil2.each(nodes, function(node) {
      node.outEdges.sort(function(a, b) {
        return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
      });
      node.inEdges.sort(function(a, b) {
        return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
      });
    });
    zrUtil2.each(nodes, function(node) {
      var sy = 0;
      var ty = 0;
      zrUtil2.each(node.outEdges, function(edge) {
        edge.setLayout({
          sy
        }, true);
        sy += edge.getLayout().dy;
      });
      zrUtil2.each(node.inEdges, function(edge) {
        edge.setLayout({
          ty
        }, true);
        ty += edge.getLayout().dy;
      });
    });
  }
  sankeyLayout = _default2;
  return sankeyLayout;
}
var sankeyVisual;
var hasRequiredSankeyVisual;
function requireSankeyVisual() {
  if (hasRequiredSankeyVisual)
    return sankeyVisual;
  hasRequiredSankeyVisual = 1;
  var VisualMapping = requireVisualMapping();
  var zrUtil2 = util$6;
  function _default2(ecModel, payload) {
    ecModel.eachSeriesByType("sankey", function(seriesModel) {
      var graph2 = seriesModel.getGraph();
      var nodes = graph2.nodes;
      if (nodes.length) {
        var minValue = Infinity;
        var maxValue = -Infinity;
        zrUtil2.each(nodes, function(node) {
          var nodeValue = node.getLayout().value;
          if (nodeValue < minValue) {
            minValue = nodeValue;
          }
          if (nodeValue > maxValue) {
            maxValue = nodeValue;
          }
        });
        zrUtil2.each(nodes, function(node) {
          var mapping = new VisualMapping({
            type: "color",
            mappingMethod: "linear",
            dataExtent: [minValue, maxValue],
            visual: seriesModel.get("color")
          });
          var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
          var customColor = node.getModel().get("itemStyle.color");
          customColor != null ? node.setVisual("color", customColor) : node.setVisual("color", mapValueToColor);
        });
      }
    });
  }
  sankeyVisual = _default2;
  return sankeyVisual;
}
var hasRequiredSankey;
function requireSankey() {
  if (hasRequiredSankey)
    return sankey;
  hasRequiredSankey = 1;
  var echarts$12 = echarts;
  requireSankeySeries();
  requireSankeyView();
  requireSankeyAction();
  var sankeyLayout2 = requireSankeyLayout();
  var sankeyVisual2 = requireSankeyVisual();
  echarts$12.registerLayout(sankeyLayout2);
  echarts$12.registerVisual(sankeyVisual2);
  return sankey;
}
var boxplot = {};
var whiskerBoxCommon = {};
var hasRequiredWhiskerBoxCommon;
function requireWhiskerBoxCommon() {
  if (hasRequiredWhiskerBoxCommon)
    return whiskerBoxCommon;
  hasRequiredWhiskerBoxCommon = 1;
  var createListSimply2 = requireCreateListSimply();
  var zrUtil2 = util$6;
  var _dimensionHelper = requireDimensionHelper();
  var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
  var _sourceHelper2 = requireSourceHelper();
  var makeSeriesEncodeForAxisCoordSys = _sourceHelper2.makeSeriesEncodeForAxisCoordSys;
  var seriesModelMixin = {
    /**
     * @private
     * @type {string}
     */
    _baseAxisDim: null,
    /**
     * @override
     */
    getInitialData: function(option, ecModel) {
      var ordinalMeta;
      var xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
      var yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
      var xAxisType = xAxisModel.get("type");
      var yAxisType = yAxisModel.get("type");
      var addOrdinal;
      if (xAxisType === "category") {
        option.layout = "horizontal";
        ordinalMeta = xAxisModel.getOrdinalMeta();
        addOrdinal = true;
      } else if (yAxisType === "category") {
        option.layout = "vertical";
        ordinalMeta = yAxisModel.getOrdinalMeta();
        addOrdinal = true;
      } else {
        option.layout = option.layout || "horizontal";
      }
      var coordDims = ["x", "y"];
      var baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
      var baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
      var otherAxisDim = coordDims[1 - baseAxisDimIndex];
      var axisModels = [xAxisModel, yAxisModel];
      var baseAxisType = axisModels[baseAxisDimIndex].get("type");
      var otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
      var data = option.data;
      if (data && addOrdinal) {
        var newOptionData = [];
        zrUtil2.each(data, function(item, index2) {
          var newItem;
          if (item.value && zrUtil2.isArray(item.value)) {
            newItem = item.value.slice();
            item.value.unshift(index2);
          } else if (zrUtil2.isArray(item)) {
            newItem = item.slice();
            item.unshift(index2);
          } else {
            newItem = item;
          }
          newOptionData.push(newItem);
        });
        option.data = newOptionData;
      }
      var defaultValueDimensions = this.defaultValueDimensions;
      var coordDimensions = [{
        name: baseAxisDim,
        type: getDimensionTypeByAxis(baseAxisType),
        ordinalMeta,
        otherDims: {
          tooltip: false,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: otherAxisDim,
        type: getDimensionTypeByAxis(otherAxisType),
        dimsDef: defaultValueDimensions.slice()
      }];
      return createListSimply2(this, {
        coordDimensions,
        dimensionsCount: defaultValueDimensions.length + 1,
        encodeDefaulter: zrUtil2.curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
      });
    },
    /**
     * If horizontal, base axis is x, otherwise y.
     * @override
     */
    getBaseAxis: function() {
      var dim = this._baseAxisDim;
      return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
    }
  };
  whiskerBoxCommon.seriesModelMixin = seriesModelMixin;
  return whiskerBoxCommon;
}
var BoxplotSeries_1;
var hasRequiredBoxplotSeries;
function requireBoxplotSeries() {
  if (hasRequiredBoxplotSeries)
    return BoxplotSeries_1;
  hasRequiredBoxplotSeries = 1;
  var zrUtil2 = util$6;
  var SeriesModel2 = Series;
  var _whiskerBoxCommon = requireWhiskerBoxCommon();
  var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
  var BoxplotSeries = SeriesModel2.extend({
    type: "series.boxplot",
    dependencies: ["xAxis", "yAxis", "grid"],
    // TODO
    // box width represents group size, so dimension should have 'size'.
    /**
     * @see <https://en.wikipedia.org/wiki/Box_plot>
     * The meanings of 'min' and 'max' depend on user,
     * and echarts do not need to know it.
     * @readOnly
     */
    defaultValueDimensions: [{
      name: "min",
      defaultTooltip: true
    }, {
      name: "Q1",
      defaultTooltip: true
    }, {
      name: "median",
      defaultTooltip: true
    }, {
      name: "Q3",
      defaultTooltip: true
    }, {
      name: "max",
      defaultTooltip: true
    }],
    /**
     * @type {Array.<string>}
     * @readOnly
     */
    dimensions: null,
    /**
     * @override
     */
    defaultOption: {
      zlevel: 0,
      // 一级层叠
      z: 2,
      // 二级层叠
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      hoverAnimation: true,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      // 'horizontal' or 'vertical'
      boxWidth: [7, 50],
      // [min, max] can be percent of band width.
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 2,
          shadowOffsetY: 2,
          shadowColor: "rgba(0,0,0,0.4)"
        }
      },
      animationEasing: "elasticOut",
      animationDuration: 800
    }
  });
  zrUtil2.mixin(BoxplotSeries, seriesModelMixin, true);
  var _default2 = BoxplotSeries;
  BoxplotSeries_1 = _default2;
  return BoxplotSeries_1;
}
var BoxplotView_1;
var hasRequiredBoxplotView;
function requireBoxplotView() {
  if (hasRequiredBoxplotView)
    return BoxplotView_1;
  hasRequiredBoxplotView = 1;
  var zrUtil2 = util$6;
  var ChartView = Chart_1;
  var graphic2 = graphic$4;
  var Path2 = Path_1;
  var NORMAL_ITEM_STYLE_PATH = ["itemStyle"];
  var EMPHASIS_ITEM_STYLE_PATH = ["emphasis", "itemStyle"];
  var BoxplotView = ChartView.extend({
    type: "boxplot",
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var group = this.group;
      var oldData = this._data;
      if (!this._data) {
        group.removeAll();
      }
      var constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
      data.diff(oldData).add(function(newIdx) {
        if (data.hasValue(newIdx)) {
          var itemLayout = data.getItemLayout(newIdx);
          var symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
          data.setItemGraphicEl(newIdx, symbolEl);
          group.add(symbolEl);
        }
      }).update(function(newIdx, oldIdx) {
        var symbolEl = oldData.getItemGraphicEl(oldIdx);
        if (!data.hasValue(newIdx)) {
          group.remove(symbolEl);
          return;
        }
        var itemLayout = data.getItemLayout(newIdx);
        if (!symbolEl) {
          symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
        } else {
          updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
        }
        group.add(symbolEl);
        data.setItemGraphicEl(newIdx, symbolEl);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && group.remove(el);
      }).execute();
      this._data = data;
    },
    remove: function(ecModel) {
      var group = this.group;
      var data = this._data;
      this._data = null;
      data && data.eachItemGraphicEl(function(el) {
        el && group.remove(el);
      });
    },
    dispose: zrUtil2.noop
  });
  var BoxPath = Path2.extend({
    type: "boxplotBoxPath",
    shape: {},
    buildPath: function(ctx, shape) {
      var ends = shape.points;
      var i = 0;
      ctx.moveTo(ends[i][0], ends[i][1]);
      i++;
      for (; i < 4; i++) {
        ctx.lineTo(ends[i][0], ends[i][1]);
      }
      ctx.closePath();
      for (; i < ends.length; i++) {
        ctx.moveTo(ends[i][0], ends[i][1]);
        i++;
        ctx.lineTo(ends[i][0], ends[i][1]);
      }
    }
  });
  function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
    var ends = itemLayout.ends;
    var el = new BoxPath({
      shape: {
        points: isInit ? transInit(ends, constDim, itemLayout) : ends
      }
    });
    updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
    return el;
  }
  function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
    var seriesModel = data.hostModel;
    var updateMethod = graphic2[isInit ? "initProps" : "updateProps"];
    updateMethod(el, {
      shape: {
        points: itemLayout.ends
      }
    }, seriesModel, dataIndex);
    var itemModel = data.getItemModel(dataIndex);
    var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
    var borderColor = data.getItemVisual(dataIndex, "color");
    var itemStyle2 = normalItemStyleModel.getItemStyle(["borderColor"]);
    itemStyle2.stroke = borderColor;
    itemStyle2.strokeNoScale = true;
    el.useStyle(itemStyle2);
    el.z2 = 100;
    var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
    graphic2.setHoverStyle(el, hoverStyle);
  }
  function transInit(points2, dim, itemLayout) {
    return zrUtil2.map(points2, function(point) {
      point = point.slice();
      point[dim] = itemLayout.initBaseline;
      return point;
    });
  }
  var _default2 = BoxplotView;
  BoxplotView_1 = _default2;
  return BoxplotView_1;
}
var boxplotVisual;
var hasRequiredBoxplotVisual;
function requireBoxplotVisual() {
  if (hasRequiredBoxplotVisual)
    return boxplotVisual;
  hasRequiredBoxplotVisual = 1;
  var borderColorQuery = ["itemStyle", "borderColor"];
  function _default2(ecModel, api) {
    var globalColors = ecModel.get("color");
    ecModel.eachRawSeriesByType("boxplot", function(seriesModel) {
      var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];
      var data = seriesModel.getData();
      data.setVisual({
        legendSymbol: "roundRect",
        // Use name 'color' but not 'borderColor' for legend usage and
        // visual coding from other component like dataRange.
        color: seriesModel.get(borderColorQuery) || defaulColor
      });
      if (!ecModel.isSeriesFiltered(seriesModel)) {
        data.each(function(idx) {
          var itemModel = data.getItemModel(idx);
          data.setItemVisual(idx, {
            color: itemModel.get(borderColorQuery, true)
          });
        });
      }
    });
  }
  boxplotVisual = _default2;
  return boxplotVisual;
}
var boxplotLayout;
var hasRequiredBoxplotLayout;
function requireBoxplotLayout() {
  if (hasRequiredBoxplotLayout)
    return boxplotLayout;
  hasRequiredBoxplotLayout = 1;
  var zrUtil2 = util$6;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var each2 = zrUtil2.each;
  function _default2(ecModel) {
    var groupResult = groupSeriesByAxis(ecModel);
    each2(groupResult, function(groupItem) {
      var seriesModels = groupItem.seriesModels;
      if (!seriesModels.length) {
        return;
      }
      calculateBase(groupItem);
      each2(seriesModels, function(seriesModel, idx) {
        layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
      });
    });
  }
  function groupSeriesByAxis(ecModel) {
    var result = [];
    var axisList = [];
    ecModel.eachSeriesByType("boxplot", function(seriesModel) {
      var baseAxis = seriesModel.getBaseAxis();
      var idx = zrUtil2.indexOf(axisList, baseAxis);
      if (idx < 0) {
        idx = axisList.length;
        axisList[idx] = baseAxis;
        result[idx] = {
          axis: baseAxis,
          seriesModels: []
        };
      }
      result[idx].seriesModels.push(seriesModel);
    });
    return result;
  }
  function calculateBase(groupItem) {
    var extent;
    var baseAxis = groupItem.axis;
    var seriesModels = groupItem.seriesModels;
    var seriesCount = seriesModels.length;
    var boxWidthList = groupItem.boxWidthList = [];
    var boxOffsetList = groupItem.boxOffsetList = [];
    var boundList = [];
    var bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else {
      var maxDataCount = 0;
      each2(seriesModels, function(seriesModel) {
        maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
      });
      extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;
    }
    each2(seriesModels, function(seriesModel) {
      var boxWidthBound = seriesModel.get("boxWidth");
      if (!zrUtil2.isArray(boxWidthBound)) {
        boxWidthBound = [boxWidthBound, boxWidthBound];
      }
      boundList.push([parsePercent2(boxWidthBound[0], bandWidth) || 0, parsePercent2(boxWidthBound[1], bandWidth) || 0]);
    });
    var availableWidth = bandWidth * 0.8 - 2;
    var boxGap = availableWidth / seriesCount * 0.3;
    var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
    var base2 = boxWidth / 2 - availableWidth / 2;
    each2(seriesModels, function(seriesModel, idx) {
      boxOffsetList.push(base2);
      base2 += boxGap + boxWidth;
      boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
    });
  }
  function layoutSingleSeries(seriesModel, offset, boxWidth) {
    var coordSys = seriesModel.coordinateSystem;
    var data = seriesModel.getData();
    var halfWidth = boxWidth / 2;
    var cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
    var vDimIdx = 1 - cDimIdx;
    var coordDims = ["x", "y"];
    var cDim = data.mapDimension(coordDims[cDimIdx]);
    var vDims = data.mapDimension(coordDims[vDimIdx], true);
    if (cDim == null || vDims.length < 5) {
      return;
    }
    for (var dataIndex = 0; dataIndex < data.count(); dataIndex++) {
      var axisDimVal = data.get(cDim, dataIndex);
      var median = getPoint(axisDimVal, vDims[2], dataIndex);
      var end1 = getPoint(axisDimVal, vDims[0], dataIndex);
      var end2 = getPoint(axisDimVal, vDims[1], dataIndex);
      var end4 = getPoint(axisDimVal, vDims[3], dataIndex);
      var end5 = getPoint(axisDimVal, vDims[4], dataIndex);
      var ends = [];
      addBodyEnd(ends, end2, 0);
      addBodyEnd(ends, end4, 1);
      ends.push(end1, end2, end5, end4);
      layEndLine(ends, end1);
      layEndLine(ends, end5);
      layEndLine(ends, median);
      data.setItemLayout(dataIndex, {
        initBaseline: median[vDimIdx],
        ends
      });
    }
    function getPoint(axisDimVal2, dimIdx, dataIndex2) {
      var val = data.get(dimIdx, dataIndex2);
      var p2 = [];
      p2[cDimIdx] = axisDimVal2;
      p2[vDimIdx] = val;
      var point;
      if (isNaN(axisDimVal2) || isNaN(val)) {
        point = [NaN, NaN];
      } else {
        point = coordSys.dataToPoint(p2);
        point[cDimIdx] += offset;
      }
      return point;
    }
    function addBodyEnd(ends2, point, start) {
      var point1 = point.slice();
      var point2 = point.slice();
      point1[cDimIdx] += halfWidth;
      point2[cDimIdx] -= halfWidth;
      start ? ends2.push(point1, point2) : ends2.push(point2, point1);
    }
    function layEndLine(ends2, endCenter) {
      var from = endCenter.slice();
      var to = endCenter.slice();
      from[cDimIdx] -= halfWidth;
      to[cDimIdx] += halfWidth;
      ends2.push(from, to);
    }
  }
  boxplotLayout = _default2;
  return boxplotLayout;
}
var hasRequiredBoxplot;
function requireBoxplot() {
  if (hasRequiredBoxplot)
    return boxplot;
  hasRequiredBoxplot = 1;
  var echarts$12 = echarts;
  requireBoxplotSeries();
  requireBoxplotView();
  var boxplotVisual2 = requireBoxplotVisual();
  var boxplotLayout2 = requireBoxplotLayout();
  echarts$12.registerVisual(boxplotVisual2);
  echarts$12.registerLayout(boxplotLayout2);
  return boxplot;
}
var candlestick = {};
var CandlestickSeries_1;
var hasRequiredCandlestickSeries;
function requireCandlestickSeries() {
  if (hasRequiredCandlestickSeries)
    return CandlestickSeries_1;
  hasRequiredCandlestickSeries = 1;
  var zrUtil2 = util$6;
  var SeriesModel2 = Series;
  var _whiskerBoxCommon = requireWhiskerBoxCommon();
  var seriesModelMixin = _whiskerBoxCommon.seriesModelMixin;
  var CandlestickSeries = SeriesModel2.extend({
    type: "series.candlestick",
    dependencies: ["xAxis", "yAxis", "grid"],
    /**
     * @readOnly
     */
    defaultValueDimensions: [{
      name: "open",
      defaultTooltip: true
    }, {
      name: "close",
      defaultTooltip: true
    }, {
      name: "lowest",
      defaultTooltip: true
    }, {
      name: "highest",
      defaultTooltip: true
    }],
    /**
     * @type {Array.<string>}
     * @readOnly
     */
    dimensions: null,
    /**
     * @override
     */
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: true,
      hoverAnimation: true,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      // 'horizontal' or 'vertical'
      clip: true,
      itemStyle: {
        color: "#c23531",
        // 阳线 positive
        color0: "#314656",
        // 阴线 negative     '#c23531', '#314656'
        borderWidth: 1,
        // FIXME
        // ec2中使用的是lineStyle.color 和 lineStyle.color0
        borderColor: "#c23531",
        borderColor0: "#314656"
      },
      emphasis: {
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: true,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationUpdate: false,
      animationEasing: "linear",
      animationDuration: 300
    },
    /**
     * Get dimension for shadow in dataZoom
     * @return {string} dimension name
     */
    getShadowDim: function() {
      return "open";
    },
    brushSelector: function(dataIndex, data, selectors) {
      var itemLayout = data.getItemLayout(dataIndex);
      return itemLayout && selectors.rect(itemLayout.brushRect);
    }
  });
  zrUtil2.mixin(CandlestickSeries, seriesModelMixin, true);
  var _default2 = CandlestickSeries;
  CandlestickSeries_1 = _default2;
  return CandlestickSeries_1;
}
var CandlestickView_1;
var hasRequiredCandlestickView;
function requireCandlestickView() {
  if (hasRequiredCandlestickView)
    return CandlestickView_1;
  hasRequiredCandlestickView = 1;
  var zrUtil2 = util$6;
  var ChartView = Chart_1;
  var graphic2 = graphic$4;
  var Path2 = Path_1;
  var _createClipPathFromCoordSys = requireCreateClipPathFromCoordSys();
  var createClipPath = _createClipPathFromCoordSys.createClipPath;
  var NORMAL_ITEM_STYLE_PATH = ["itemStyle"];
  var EMPHASIS_ITEM_STYLE_PATH = ["emphasis", "itemStyle"];
  var SKIP_PROPS = ["color", "color0", "borderColor", "borderColor0"];
  var CandlestickView = ChartView.extend({
    type: "candlestick",
    render: function(seriesModel, ecModel, api) {
      this.group.removeClipPath();
      this._updateDrawMode(seriesModel);
      this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
      this._clear();
      this._updateDrawMode(seriesModel);
    },
    incrementalRender: function(params, seriesModel, ecModel, api) {
      this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
    },
    _updateDrawMode: function(seriesModel) {
      var isLargeDraw = seriesModel.pipelineContext.large;
      if (this._isLargeDraw == null || isLargeDraw ^ this._isLargeDraw) {
        this._isLargeDraw = isLargeDraw;
        this._clear();
      }
    },
    _renderNormal: function(seriesModel) {
      var data = seriesModel.getData();
      var oldData = this._data;
      var group = this.group;
      var isSimpleBox = data.getLayout("isSimpleBox");
      var needsClip = seriesModel.get("clip", true);
      var coord = seriesModel.coordinateSystem;
      var clipArea = coord.getArea && coord.getArea();
      if (!this._data) {
        group.removeAll();
      }
      data.diff(oldData).add(function(newIdx) {
        if (data.hasValue(newIdx)) {
          var el;
          var itemLayout = data.getItemLayout(newIdx);
          if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
            return;
          }
          el = createNormalBox(itemLayout, newIdx, true);
          graphic2.initProps(el, {
            shape: {
              points: itemLayout.ends
            }
          }, seriesModel, newIdx);
          setBoxCommon(el, data, newIdx, isSimpleBox);
          group.add(el);
          data.setItemGraphicEl(newIdx, el);
        }
      }).update(function(newIdx, oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        if (!data.hasValue(newIdx)) {
          group.remove(el);
          return;
        }
        var itemLayout = data.getItemLayout(newIdx);
        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
          group.remove(el);
          return;
        }
        if (!el) {
          el = createNormalBox(itemLayout);
        } else {
          graphic2.updateProps(el, {
            shape: {
              points: itemLayout.ends
            }
          }, seriesModel, newIdx);
        }
        setBoxCommon(el, data, newIdx, isSimpleBox);
        group.add(el);
        data.setItemGraphicEl(newIdx, el);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && group.remove(el);
      }).execute();
      this._data = data;
    },
    _renderLarge: function(seriesModel) {
      this._clear();
      createLarge(seriesModel, this.group);
      var clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
      if (clipPath) {
        this.group.setClipPath(clipPath);
      } else {
        this.group.removeClipPath();
      }
    },
    _incrementalRenderNormal: function(params, seriesModel) {
      var data = seriesModel.getData();
      var isSimpleBox = data.getLayout("isSimpleBox");
      var dataIndex;
      while ((dataIndex = params.next()) != null) {
        var el;
        var itemLayout = data.getItemLayout(dataIndex);
        el = createNormalBox(itemLayout);
        setBoxCommon(el, data, dataIndex, isSimpleBox);
        el.incremental = true;
        this.group.add(el);
      }
    },
    _incrementalRenderLarge: function(params, seriesModel) {
      createLarge(seriesModel, this.group, true);
    },
    remove: function(ecModel) {
      this._clear();
    },
    _clear: function() {
      this.group.removeAll();
      this._data = null;
    },
    dispose: zrUtil2.noop
  });
  var NormalBoxPath = Path2.extend({
    type: "normalCandlestickBox",
    shape: {},
    buildPath: function(ctx, shape) {
      var ends = shape.points;
      if (this.__simpleBox) {
        ctx.moveTo(ends[4][0], ends[4][1]);
        ctx.lineTo(ends[6][0], ends[6][1]);
      } else {
        ctx.moveTo(ends[0][0], ends[0][1]);
        ctx.lineTo(ends[1][0], ends[1][1]);
        ctx.lineTo(ends[2][0], ends[2][1]);
        ctx.lineTo(ends[3][0], ends[3][1]);
        ctx.closePath();
        ctx.moveTo(ends[4][0], ends[4][1]);
        ctx.lineTo(ends[5][0], ends[5][1]);
        ctx.moveTo(ends[6][0], ends[6][1]);
        ctx.lineTo(ends[7][0], ends[7][1]);
      }
    }
  });
  function createNormalBox(itemLayout, dataIndex, isInit) {
    var ends = itemLayout.ends;
    return new NormalBoxPath({
      shape: {
        points: isInit ? transInit(ends, itemLayout) : ends
      },
      z2: 100
    });
  }
  function isNormalBoxClipped(clipArea, itemLayout) {
    var clipped = true;
    for (var i = 0; i < itemLayout.ends.length; i++) {
      if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
        clipped = false;
        break;
      }
    }
    return clipped;
  }
  function setBoxCommon(el, data, dataIndex, isSimpleBox) {
    var itemModel = data.getItemModel(dataIndex);
    var normalItemStyleModel = itemModel.getModel(NORMAL_ITEM_STYLE_PATH);
    var color2 = data.getItemVisual(dataIndex, "color");
    var borderColor = data.getItemVisual(dataIndex, "borderColor") || color2;
    var itemStyle2 = normalItemStyleModel.getItemStyle(SKIP_PROPS);
    el.useStyle(itemStyle2);
    el.style.strokeNoScale = true;
    el.style.fill = color2;
    el.style.stroke = borderColor;
    el.__simpleBox = isSimpleBox;
    var hoverStyle = itemModel.getModel(EMPHASIS_ITEM_STYLE_PATH).getItemStyle();
    graphic2.setHoverStyle(el, hoverStyle);
  }
  function transInit(points2, itemLayout) {
    return zrUtil2.map(points2, function(point) {
      point = point.slice();
      point[1] = itemLayout.initBaseline;
      return point;
    });
  }
  var LargeBoxPath = Path2.extend({
    type: "largeCandlestickBox",
    shape: {},
    buildPath: function(ctx, shape) {
      var points2 = shape.points;
      for (var i = 0; i < points2.length; ) {
        if (this.__sign === points2[i++]) {
          var x = points2[i++];
          ctx.moveTo(x, points2[i++]);
          ctx.lineTo(x, points2[i++]);
        } else {
          i += 3;
        }
      }
    }
  });
  function createLarge(seriesModel, group, incremental) {
    var data = seriesModel.getData();
    var largePoints = data.getLayout("largePoints");
    var elP = new LargeBoxPath({
      shape: {
        points: largePoints
      },
      __sign: 1
    });
    group.add(elP);
    var elN = new LargeBoxPath({
      shape: {
        points: largePoints
      },
      __sign: -1
    });
    group.add(elN);
    setLargeStyle(1, elP, seriesModel, data);
    setLargeStyle(-1, elN, seriesModel, data);
    if (incremental) {
      elP.incremental = true;
      elN.incremental = true;
    }
  }
  function setLargeStyle(sign, el, seriesModel, data) {
    var suffix = sign > 0 ? "P" : "N";
    var borderColor = data.getVisual("borderColor" + suffix) || data.getVisual("color" + suffix);
    var itemStyle2 = seriesModel.getModel(NORMAL_ITEM_STYLE_PATH).getItemStyle(SKIP_PROPS);
    el.useStyle(itemStyle2);
    el.style.fill = null;
    el.style.stroke = borderColor;
  }
  var _default2 = CandlestickView;
  CandlestickView_1 = _default2;
  return CandlestickView_1;
}
var preprocessor$3;
var hasRequiredPreprocessor$3;
function requirePreprocessor$3() {
  if (hasRequiredPreprocessor$3)
    return preprocessor$3;
  hasRequiredPreprocessor$3 = 1;
  var zrUtil2 = util$6;
  function _default2(option) {
    if (!option || !zrUtil2.isArray(option.series)) {
      return;
    }
    zrUtil2.each(option.series, function(seriesItem) {
      if (zrUtil2.isObject(seriesItem) && seriesItem.type === "k") {
        seriesItem.type = "candlestick";
      }
    });
  }
  preprocessor$3 = _default2;
  return preprocessor$3;
}
var candlestickVisual;
var hasRequiredCandlestickVisual;
function requireCandlestickVisual() {
  if (hasRequiredCandlestickVisual)
    return candlestickVisual;
  hasRequiredCandlestickVisual = 1;
  var createRenderPlanner2 = createRenderPlanner$1;
  var positiveBorderColorQuery = ["itemStyle", "borderColor"];
  var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
  var positiveColorQuery = ["itemStyle", "color"];
  var negativeColorQuery = ["itemStyle", "color0"];
  var _default2 = {
    seriesType: "candlestick",
    plan: createRenderPlanner2(),
    // For legend.
    performRawSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      data.setVisual({
        legendSymbol: "roundRect",
        colorP: getColor(1, seriesModel),
        colorN: getColor(-1, seriesModel),
        borderColorP: getBorderColor(1, seriesModel),
        borderColorN: getBorderColor(-1, seriesModel)
      });
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      var isLargeRender = seriesModel.pipelineContext.large;
      return !isLargeRender && {
        progress
      };
      function progress(params, data2) {
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var itemModel = data2.getItemModel(dataIndex);
          var sign = data2.getItemLayout(dataIndex).sign;
          data2.setItemVisual(dataIndex, {
            color: getColor(sign, itemModel),
            borderColor: getBorderColor(sign, itemModel)
          });
        }
      }
      function getColor(sign, model2) {
        return model2.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
      }
      function getBorderColor(sign, model2) {
        return model2.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
      }
    }
  };
  candlestickVisual = _default2;
  return candlestickVisual;
}
var candlestickLayout;
var hasRequiredCandlestickLayout;
function requireCandlestickLayout() {
  if (hasRequiredCandlestickLayout)
    return candlestickLayout;
  hasRequiredCandlestickLayout = 1;
  var _graphic = graphic$4;
  var subPixelOptimize2 = _graphic.subPixelOptimize;
  var createRenderPlanner2 = createRenderPlanner$1;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var _util2 = util$6;
  var retrieve22 = _util2.retrieve2;
  var LargeArr = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var _default2 = {
    seriesType: "candlestick",
    plan: createRenderPlanner2(),
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var data = seriesModel.getData();
      var candleWidth = calculateCandleWidth(seriesModel, data);
      var cDimIdx = 0;
      var vDimIdx = 1;
      var coordDims = ["x", "y"];
      var cDim = data.mapDimension(coordDims[cDimIdx]);
      var vDims = data.mapDimension(coordDims[vDimIdx], true);
      var openDim = vDims[0];
      var closeDim = vDims[1];
      var lowestDim = vDims[2];
      var highestDim = vDims[3];
      data.setLayout({
        candleWidth,
        // The value is experimented visually.
        isSimpleBox: candleWidth <= 1.3
      });
      if (cDim == null || vDims.length < 4) {
        return;
      }
      return {
        progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
      };
      function normalProgress(params, data2) {
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var axisDimVal = data2.get(cDim, dataIndex);
          var openVal = data2.get(openDim, dataIndex);
          var closeVal = data2.get(closeDim, dataIndex);
          var lowestVal = data2.get(lowestDim, dataIndex);
          var highestVal = data2.get(highestDim, dataIndex);
          var ocLow = Math.min(openVal, closeVal);
          var ocHigh = Math.max(openVal, closeVal);
          var ocLowPoint = getPoint(ocLow, axisDimVal);
          var ocHighPoint = getPoint(ocHigh, axisDimVal);
          var lowestPoint = getPoint(lowestVal, axisDimVal);
          var highestPoint = getPoint(highestVal, axisDimVal);
          var ends = [];
          addBodyEnd(ends, ocHighPoint, 0);
          addBodyEnd(ends, ocLowPoint, 1);
          ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
          data2.setItemLayout(dataIndex, {
            sign: getSign(data2, dataIndex, openVal, closeVal, closeDim),
            initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
            // open point.
            ends,
            brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
          });
        }
        function getPoint(val, axisDimVal2) {
          var p2 = [];
          p2[cDimIdx] = axisDimVal2;
          p2[vDimIdx] = val;
          return isNaN(axisDimVal2) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p2);
        }
        function addBodyEnd(ends2, point, start) {
          var point1 = point.slice();
          var point2 = point.slice();
          point1[cDimIdx] = subPixelOptimize2(point1[cDimIdx] + candleWidth / 2, 1, false);
          point2[cDimIdx] = subPixelOptimize2(point2[cDimIdx] - candleWidth / 2, 1, true);
          start ? ends2.push(point1, point2) : ends2.push(point2, point1);
        }
        function makeBrushRect(lowestVal2, highestVal2, axisDimVal2) {
          var pmin = getPoint(lowestVal2, axisDimVal2);
          var pmax = getPoint(highestVal2, axisDimVal2);
          pmin[cDimIdx] -= candleWidth / 2;
          pmax[cDimIdx] -= candleWidth / 2;
          return {
            x: pmin[0],
            y: pmin[1],
            width: candleWidth,
            height: pmax[1] - pmin[1]
          };
        }
        function subPixelOptimizePoint(point) {
          point[cDimIdx] = subPixelOptimize2(point[cDimIdx], 1);
          return point;
        }
      }
      function largeProgress(params, data2) {
        var points2 = new LargeArr(params.count * 4);
        var offset = 0;
        var point;
        var tmpIn = [];
        var tmpOut = [];
        var dataIndex;
        while ((dataIndex = params.next()) != null) {
          var axisDimVal = data2.get(cDim, dataIndex);
          var openVal = data2.get(openDim, dataIndex);
          var closeVal = data2.get(closeDim, dataIndex);
          var lowestVal = data2.get(lowestDim, dataIndex);
          var highestVal = data2.get(highestDim, dataIndex);
          if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
            points2[offset++] = NaN;
            offset += 3;
            continue;
          }
          points2[offset++] = getSign(data2, dataIndex, openVal, closeVal, closeDim);
          tmpIn[cDimIdx] = axisDimVal;
          tmpIn[vDimIdx] = lowestVal;
          point = coordSys.dataToPoint(tmpIn, null, tmpOut);
          points2[offset++] = point ? point[0] : NaN;
          points2[offset++] = point ? point[1] : NaN;
          tmpIn[vDimIdx] = highestVal;
          point = coordSys.dataToPoint(tmpIn, null, tmpOut);
          points2[offset++] = point ? point[1] : NaN;
        }
        data2.setLayout("largePoints", points2);
      }
    }
  };
  function getSign(data, dataIndex, openVal, closeVal, closeDim) {
    var sign;
    if (openVal > closeVal) {
      sign = -1;
    } else if (openVal < closeVal) {
      sign = 1;
    } else {
      sign = dataIndex > 0 ? data.get(closeDim, dataIndex - 1) <= closeVal ? 1 : -1 : (
        // No record of previous, set to be positive
        1
      );
    }
    return sign;
  }
  function calculateCandleWidth(seriesModel, data) {
    var baseAxis = seriesModel.getBaseAxis();
    var extent;
    var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
    var barMaxWidth = parsePercent2(retrieve22(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
    var barMinWidth = parsePercent2(retrieve22(seriesModel.get("barMinWidth"), 1), bandWidth);
    var barWidth = seriesModel.get("barWidth");
    return barWidth != null ? parsePercent2(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
  }
  candlestickLayout = _default2;
  return candlestickLayout;
}
var hasRequiredCandlestick;
function requireCandlestick() {
  if (hasRequiredCandlestick)
    return candlestick;
  hasRequiredCandlestick = 1;
  var echarts$12 = echarts;
  requireCandlestickSeries();
  requireCandlestickView();
  var preprocessor2 = requirePreprocessor$3();
  var candlestickVisual2 = requireCandlestickVisual();
  var candlestickLayout2 = requireCandlestickLayout();
  echarts$12.registerPreprocessor(preprocessor2);
  echarts$12.registerVisual(candlestickVisual2);
  echarts$12.registerLayout(candlestickLayout2);
  return candlestick;
}
var effectScatter = {};
var EffectScatterSeries;
var hasRequiredEffectScatterSeries;
function requireEffectScatterSeries() {
  if (hasRequiredEffectScatterSeries)
    return EffectScatterSeries;
  hasRequiredEffectScatterSeries = 1;
  var createListFromArray = requireCreateListFromArray();
  var SeriesModel2 = Series;
  var _default2 = SeriesModel2.extend({
    type: "series.effectScatter",
    dependencies: ["grid", "polar"],
    getInitialData: function(option, ecModel) {
      return createListFromArray(this.getSource(), this, {
        useEncodeDefaulter: true
      });
    },
    brushSelector: "point",
    defaultOption: {
      coordinateSystem: "cartesian2d",
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      // large: false,
      // Available when large is true
      // largeThreshold: 2000,
      // itemStyle: {
      //     opacity: 1
      // }
    }
  });
  EffectScatterSeries = _default2;
  return EffectScatterSeries;
}
var EffectSymbol_1;
var hasRequiredEffectSymbol;
function requireEffectSymbol() {
  if (hasRequiredEffectSymbol)
    return EffectSymbol_1;
  hasRequiredEffectSymbol = 1;
  var zrUtil2 = util$6;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var _graphic = graphic$4;
  var Group2 = _graphic.Group;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var SymbolClz = require_Symbol();
  var EFFECT_RIPPLE_NUMBER = 3;
  function normalizeSymbolSize(symbolSize) {
    if (!zrUtil2.isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize];
    }
    return symbolSize;
  }
  function updateRipplePath(rippleGroup, effectCfg) {
    var color2 = effectCfg.rippleEffectColor || effectCfg.color;
    rippleGroup.eachChild(function(ripplePath) {
      ripplePath.attr({
        z: effectCfg.z,
        zlevel: effectCfg.zlevel,
        style: {
          stroke: effectCfg.brushType === "stroke" ? color2 : null,
          fill: effectCfg.brushType === "fill" ? color2 : null
        }
      });
    });
  }
  function EffectSymbol(data, idx) {
    Group2.call(this);
    var symbol2 = new SymbolClz(data, idx);
    var rippleGroup = new Group2();
    this.add(symbol2);
    this.add(rippleGroup);
    rippleGroup.beforeUpdate = function() {
      this.attr(symbol2.getScale());
    };
    this.updateData(data, idx);
  }
  var effectSymbolProto = EffectSymbol.prototype;
  effectSymbolProto.stopEffectAnimation = function() {
    this.childAt(1).removeAll();
  };
  effectSymbolProto.startEffectAnimation = function(effectCfg) {
    var symbolType = effectCfg.symbolType;
    var color2 = effectCfg.color;
    var rippleGroup = this.childAt(1);
    for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {
      var ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color2);
      ripplePath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 99,
        silent: true,
        scale: [0.5, 0.5]
      });
      var delay = -i / EFFECT_RIPPLE_NUMBER * effectCfg.period + effectCfg.effectOffset;
      ripplePath.animate("", true).when(effectCfg.period, {
        scale: [effectCfg.rippleScale / 2, effectCfg.rippleScale / 2]
      }).delay(delay).start();
      ripplePath.animateStyle(true).when(effectCfg.period, {
        opacity: 0
      }).delay(delay).start();
      rippleGroup.add(ripplePath);
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  effectSymbolProto.updateEffectAnimation = function(effectCfg) {
    var oldEffectCfg = this._effectCfg;
    var rippleGroup = this.childAt(1);
    var DIFFICULT_PROPS = ["symbolType", "period", "rippleScale"];
    for (var i = 0; i < DIFFICULT_PROPS.length; i++) {
      var propName = DIFFICULT_PROPS[i];
      if (oldEffectCfg[propName] !== effectCfg[propName]) {
        this.stopEffectAnimation();
        this.startEffectAnimation(effectCfg);
        return;
      }
    }
    updateRipplePath(rippleGroup, effectCfg);
  };
  effectSymbolProto.highlight = function() {
    this.trigger("emphasis");
  };
  effectSymbolProto.downplay = function() {
    this.trigger("normal");
  };
  effectSymbolProto.updateData = function(data, idx) {
    var seriesModel = data.hostModel;
    this.childAt(0).updateData(data, idx);
    var rippleGroup = this.childAt(1);
    var itemModel = data.getItemModel(idx);
    var symbolType = data.getItemVisual(idx, "symbol");
    var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
    var color2 = data.getItemVisual(idx, "color");
    rippleGroup.attr("scale", symbolSize);
    rippleGroup.traverse(function(ripplePath) {
      ripplePath.attr({
        fill: color2
      });
    });
    var symbolOffset = itemModel.getShallow("symbolOffset");
    if (symbolOffset) {
      var pos = rippleGroup.position;
      pos[0] = parsePercent2(symbolOffset[0], symbolSize[0]);
      pos[1] = parsePercent2(symbolOffset[1], symbolSize[1]);
    }
    var symbolRotate = data.getItemVisual(idx, "symbolRotate");
    rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    var effectCfg = {};
    effectCfg.showEffectOn = seriesModel.get("showEffectOn");
    effectCfg.rippleScale = itemModel.get("rippleEffect.scale");
    effectCfg.brushType = itemModel.get("rippleEffect.brushType");
    effectCfg.period = itemModel.get("rippleEffect.period") * 1e3;
    effectCfg.effectOffset = idx / data.count();
    effectCfg.z = itemModel.getShallow("z") || 0;
    effectCfg.zlevel = itemModel.getShallow("zlevel") || 0;
    effectCfg.symbolType = symbolType;
    effectCfg.color = color2;
    effectCfg.rippleEffectColor = itemModel.get("rippleEffect.color");
    this.off("mouseover").off("mouseout").off("emphasis").off("normal");
    if (effectCfg.showEffectOn === "render") {
      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
      this._effectCfg = effectCfg;
    } else {
      this._effectCfg = null;
      this.stopEffectAnimation();
      var symbol2 = this.childAt(0);
      var onEmphasis = function() {
        symbol2.highlight();
        if (effectCfg.showEffectOn !== "render") {
          this.startEffectAnimation(effectCfg);
        }
      };
      var onNormal = function() {
        symbol2.downplay();
        if (effectCfg.showEffectOn !== "render") {
          this.stopEffectAnimation();
        }
      };
      this.on("mouseover", onEmphasis, this).on("mouseout", onNormal, this).on("emphasis", onEmphasis, this).on("normal", onNormal, this);
    }
    this._effectCfg = effectCfg;
  };
  effectSymbolProto.fadeOut = function(cb) {
    this.off("mouseover").off("mouseout").off("emphasis").off("normal");
    cb && cb();
  };
  zrUtil2.inherits(EffectSymbol, Group2);
  var _default2 = EffectSymbol;
  EffectSymbol_1 = _default2;
  return EffectSymbol_1;
}
var EffectScatterView;
var hasRequiredEffectScatterView;
function requireEffectScatterView() {
  if (hasRequiredEffectScatterView)
    return EffectScatterView;
  hasRequiredEffectScatterView = 1;
  var echarts$12 = echarts;
  var SymbolDraw = requireSymbolDraw();
  var EffectSymbol = requireEffectSymbol();
  var matrix2 = requireMatrix();
  var pointsLayout = requirePoints();
  var _default2 = echarts$12.extendChartView({
    type: "effectScatter",
    init: function() {
      this._symbolDraw = new SymbolDraw(EffectSymbol);
    },
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var effectSymbolDraw = this._symbolDraw;
      effectSymbolDraw.updateData(data);
      this.group.add(effectSymbolDraw.group);
    },
    updateTransform: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      this.group.dirty();
      var res = pointsLayout().reset(seriesModel);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count()
        }, data);
      }
      this._symbolDraw.updateLayout(data);
    },
    _updateGroupTransform: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.getRoamTransform) {
        this.group.transform = matrix2.clone(coordSys.getRoamTransform());
        this.group.decomposeTransform();
      }
    },
    remove: function(ecModel, api) {
      this._symbolDraw && this._symbolDraw.remove(api);
    },
    dispose: function() {
    }
  });
  EffectScatterView = _default2;
  return EffectScatterView;
}
var hasRequiredEffectScatter;
function requireEffectScatter() {
  if (hasRequiredEffectScatter)
    return effectScatter;
  hasRequiredEffectScatter = 1;
  var echarts$12 = echarts;
  requireEffectScatterSeries();
  requireEffectScatterView();
  var visualSymbol = requireSymbol();
  var layoutPoints = requirePoints();
  echarts$12.registerVisual(visualSymbol("effectScatter", "circle"));
  echarts$12.registerLayout(layoutPoints("effectScatter"));
  return effectScatter;
}
var lines = {};
var LinesSeries_1;
var hasRequiredLinesSeries;
function requireLinesSeries() {
  if (hasRequiredLinesSeries)
    return LinesSeries_1;
  hasRequiredLinesSeries = 1;
  var SeriesModel2 = Series;
  var List = requireList();
  var _util2 = util$6;
  var concatArray2 = _util2.concatArray;
  var mergeAll2 = _util2.mergeAll;
  var map2 = _util2.map;
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
  var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
  function compatEc2(seriesOpt) {
    var data = seriesOpt.data;
    if (data && data[0] && data[0][0] && data[0][0].coord) {
      seriesOpt.data = map2(data, function(itemOpt) {
        var coords = [itemOpt[0].coord, itemOpt[1].coord];
        var target = {
          coords
        };
        if (itemOpt[0].name) {
          target.fromName = itemOpt[0].name;
        }
        if (itemOpt[1].name) {
          target.toName = itemOpt[1].name;
        }
        return mergeAll2([target, itemOpt[0], itemOpt[1]]);
      });
    }
  }
  var LinesSeries = SeriesModel2.extend({
    type: "series.lines",
    dependencies: ["grid", "polar"],
    visualColorAccessPath: "lineStyle.color",
    init: function(option) {
      option.data = option.data || [];
      compatEc2(option);
      var result = this._processFlatCoordsArray(option.data);
      this._flatCoords = result.flatCoords;
      this._flatCoordsOffset = result.flatCoordsOffset;
      if (result.flatCoords) {
        option.data = new Float32Array(result.count);
      }
      LinesSeries.superApply(this, "init", arguments);
    },
    mergeOption: function(option) {
      compatEc2(option);
      if (option.data) {
        var result = this._processFlatCoordsArray(option.data);
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
        if (result.flatCoords) {
          option.data = new Float32Array(result.count);
        }
      }
      LinesSeries.superApply(this, "mergeOption", arguments);
    },
    appendData: function(params) {
      var result = this._processFlatCoordsArray(params.data);
      if (result.flatCoords) {
        if (!this._flatCoords) {
          this._flatCoords = result.flatCoords;
          this._flatCoordsOffset = result.flatCoordsOffset;
        } else {
          this._flatCoords = concatArray2(this._flatCoords, result.flatCoords);
          this._flatCoordsOffset = concatArray2(this._flatCoordsOffset, result.flatCoordsOffset);
        }
        params.data = new Float32Array(result.count);
      }
      this.getRawData().appendData(params.data);
    },
    _getCoordsFromItemModel: function(idx) {
      var itemModel = this.getData().getItemModel(idx);
      var coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
      return coords;
    },
    getLineCoordsCount: function(idx) {
      if (this._flatCoordsOffset) {
        return this._flatCoordsOffset[idx * 2 + 1];
      } else {
        return this._getCoordsFromItemModel(idx).length;
      }
    },
    getLineCoords: function(idx, out2) {
      if (this._flatCoordsOffset) {
        var offset = this._flatCoordsOffset[idx * 2];
        var len = this._flatCoordsOffset[idx * 2 + 1];
        for (var i = 0; i < len; i++) {
          out2[i] = out2[i] || [];
          out2[i][0] = this._flatCoords[offset + i * 2];
          out2[i][1] = this._flatCoords[offset + i * 2 + 1];
        }
        return len;
      } else {
        var coords = this._getCoordsFromItemModel(idx);
        for (var i = 0; i < coords.length; i++) {
          out2[i] = out2[i] || [];
          out2[i][0] = coords[i][0];
          out2[i][1] = coords[i][1];
        }
        return coords.length;
      }
    },
    _processFlatCoordsArray: function(data) {
      var startOffset = 0;
      if (this._flatCoords) {
        startOffset = this._flatCoords.length;
      }
      if (typeof data[0] === "number") {
        var len = data.length;
        var coordsOffsetAndLenStorage = new Uint32Arr(len);
        var coordsStorage = new Float64Arr(len);
        var coordsCursor = 0;
        var offsetCursor = 0;
        var dataCount = 0;
        for (var i = 0; i < len; ) {
          dataCount++;
          var count = data[i++];
          coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
          coordsOffsetAndLenStorage[offsetCursor++] = count;
          for (var k = 0; k < count; k++) {
            var x = data[i++];
            var y = data[i++];
            coordsStorage[coordsCursor++] = x;
            coordsStorage[coordsCursor++] = y;
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
          flatCoords: coordsStorage,
          count: dataCount
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: data.length
      };
    },
    getInitialData: function(option, ecModel) {
      var lineData = new List(["value"], this);
      lineData.hasItemOption = false;
      lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
        if (dataItem instanceof Array) {
          return NaN;
        } else {
          lineData.hasItemOption = true;
          var value = dataItem.value;
          if (value != null) {
            return value instanceof Array ? value[dimIndex] : value;
          }
        }
      });
      return lineData;
    },
    formatTooltip: function(dataIndex) {
      var data = this.getData();
      var itemModel = data.getItemModel(dataIndex);
      var name2 = itemModel.get("name");
      if (name2) {
        return name2;
      }
      var fromName = itemModel.get("fromName");
      var toName = itemModel.get("toName");
      var html = [];
      fromName != null && html.push(fromName);
      toName != null && html.push(toName);
      return encodeHTML2(html.join(" > "));
    },
    preventIncremental: function() {
      return !!this.get("effect.show");
    },
    getProgressive: function() {
      var progressive = this.option.progressive;
      if (progressive == null) {
        return this.option.large ? 1e4 : this.get("progressive");
      }
      return progressive;
    },
    getProgressiveThreshold: function() {
      var progressiveThreshold = this.option.progressiveThreshold;
      if (progressiveThreshold == null) {
        return this.option.large ? 2e4 : this.get("progressiveThreshold");
      }
      return progressiveThreshold;
    },
    defaultOption: {
      coordinateSystem: "geo",
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      hoverAnimation: true,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: false,
        period: 4,
        // Animation delay. support callback
        // delay: 0,
        // If move with constant speed px/sec
        // period will be ignored if this property is > 0,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: true,
        // Length of trail, 0 - 1
        trailLength: 0.2
        // Same with lineStyle.color
        // color
      },
      large: false,
      // Available when large is true
      largeThreshold: 2e3,
      // If lines are polyline
      // polyline not support curveness, label, animation
      polyline: false,
      // If clip the overflow.
      // Available when coordinateSystem is cartesian or polar.
      clip: true,
      label: {
        show: false,
        position: "end"
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      lineStyle: {
        opacity: 0.5
      }
    }
  });
  var _default2 = LinesSeries;
  LinesSeries_1 = _default2;
  return LinesSeries_1;
}
var EffectLine_1;
var hasRequiredEffectLine;
function requireEffectLine() {
  if (hasRequiredEffectLine)
    return EffectLine_1;
  hasRequiredEffectLine = 1;
  var graphic2 = graphic$4;
  var Line2 = requireLine();
  var zrUtil2 = util$6;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var vec22 = requireVector();
  var curveUtil = curve$3;
  function EffectLine(lineData, idx, seriesScope) {
    graphic2.Group.call(this);
    this.add(this.createLine(lineData, idx, seriesScope));
    this._updateEffectSymbol(lineData, idx);
  }
  var effectLineProto = EffectLine.prototype;
  effectLineProto.createLine = function(lineData, idx, seriesScope) {
    return new Line2(lineData, idx, seriesScope);
  };
  effectLineProto._updateEffectSymbol = function(lineData, idx) {
    var itemModel = lineData.getItemModel(idx);
    var effectModel = itemModel.getModel("effect");
    var size2 = effectModel.get("symbolSize");
    var symbolType = effectModel.get("symbol");
    if (!zrUtil2.isArray(size2)) {
      size2 = [size2, size2];
    }
    var color2 = effectModel.get("color") || lineData.getItemVisual(idx, "color");
    var symbol2 = this.childAt(1);
    if (this._symbolType !== symbolType) {
      this.remove(symbol2);
      symbol2 = createSymbol(symbolType, -0.5, -0.5, 1, 1, color2);
      symbol2.z2 = 100;
      symbol2.culling = true;
      this.add(symbol2);
    }
    if (!symbol2) {
      return;
    }
    symbol2.setStyle("shadowColor", color2);
    symbol2.setStyle(effectModel.getItemStyle(["color"]));
    symbol2.attr("scale", size2);
    symbol2.setColor(color2);
    symbol2.attr("scale", size2);
    this._symbolType = symbolType;
    this._symbolScale = size2;
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  effectLineProto._updateEffectAnimation = function(lineData, effectModel, idx) {
    var symbol2 = this.childAt(1);
    if (!symbol2) {
      return;
    }
    var self2 = this;
    var points2 = lineData.getItemLayout(idx);
    var period = effectModel.get("period") * 1e3;
    var loop = effectModel.get("loop");
    var constantSpeed = effectModel.get("constantSpeed");
    var delayExpr = zrUtil2.retrieve(effectModel.get("delay"), function(idx2) {
      return idx2 / lineData.count() * period / 3;
    });
    var isDelayFunc = typeof delayExpr === "function";
    symbol2.ignore = true;
    this.updateAnimationPoints(symbol2, points2);
    if (constantSpeed > 0) {
      period = this.getLineLength(symbol2) / constantSpeed * 1e3;
    }
    if (period !== this._period || loop !== this._loop) {
      symbol2.stopAnimation();
      var delay = delayExpr;
      if (isDelayFunc) {
        delay = delayExpr(idx);
      }
      if (symbol2.__t > 0) {
        delay = -period * symbol2.__t;
      }
      symbol2.__t = 0;
      var animator = symbol2.animate("", loop).when(period, {
        __t: 1
      }).delay(delay).during(function() {
        self2.updateSymbolPosition(symbol2);
      });
      if (!loop) {
        animator.done(function() {
          self2.remove(symbol2);
        });
      }
      animator.start();
    }
    this._period = period;
    this._loop = loop;
  };
  effectLineProto.getLineLength = function(symbol2) {
    return vec22.dist(symbol2.__p1, symbol2.__cp1) + vec22.dist(symbol2.__cp1, symbol2.__p2);
  };
  effectLineProto.updateAnimationPoints = function(symbol2, points2) {
    symbol2.__p1 = points2[0];
    symbol2.__p2 = points2[1];
    symbol2.__cp1 = points2[2] || [(points2[0][0] + points2[1][0]) / 2, (points2[0][1] + points2[1][1]) / 2];
  };
  effectLineProto.updateData = function(lineData, idx, seriesScope) {
    this.childAt(0).updateData(lineData, idx, seriesScope);
    this._updateEffectSymbol(lineData, idx);
  };
  effectLineProto.updateSymbolPosition = function(symbol2) {
    var p1 = symbol2.__p1;
    var p2 = symbol2.__p2;
    var cp1 = symbol2.__cp1;
    var t2 = symbol2.__t;
    var pos = symbol2.position;
    var lastPos = [pos[0], pos[1]];
    var quadraticAt2 = curveUtil.quadraticAt;
    var quadraticDerivativeAt2 = curveUtil.quadraticDerivativeAt;
    pos[0] = quadraticAt2(p1[0], cp1[0], p2[0], t2);
    pos[1] = quadraticAt2(p1[1], cp1[1], p2[1], t2);
    var tx = quadraticDerivativeAt2(p1[0], cp1[0], p2[0], t2);
    var ty = quadraticDerivativeAt2(p1[1], cp1[1], p2[1], t2);
    symbol2.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
      if (symbol2.__lastT !== void 0 && symbol2.__lastT < symbol2.__t) {
        var scaleY = vec22.dist(lastPos, pos) * 1.05;
        symbol2.attr("scale", [symbol2.scale[0], scaleY]);
        if (t2 === 1) {
          pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
          pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
        }
      } else if (symbol2.__lastT === 1) {
        var scaleY = 2 * vec22.dist(p1, pos);
        symbol2.attr("scale", [symbol2.scale[0], scaleY]);
      } else {
        symbol2.attr("scale", this._symbolScale);
      }
    }
    symbol2.__lastT = symbol2.__t;
    symbol2.ignore = false;
  };
  effectLineProto.updateLayout = function(lineData, idx) {
    this.childAt(0).updateLayout(lineData, idx);
    var effectModel = lineData.getItemModel(idx).getModel("effect");
    this._updateEffectAnimation(lineData, effectModel, idx);
  };
  zrUtil2.inherits(EffectLine, graphic2.Group);
  var _default2 = EffectLine;
  EffectLine_1 = _default2;
  return EffectLine_1;
}
var Polyline_1;
var hasRequiredPolyline;
function requirePolyline() {
  if (hasRequiredPolyline)
    return Polyline_1;
  hasRequiredPolyline = 1;
  var graphic2 = graphic$4;
  var zrUtil2 = util$6;
  function Polyline2(lineData, idx, seriesScope) {
    graphic2.Group.call(this);
    this._createPolyline(lineData, idx, seriesScope);
  }
  var polylineProto = Polyline2.prototype;
  polylineProto._createPolyline = function(lineData, idx, seriesScope) {
    var points2 = lineData.getItemLayout(idx);
    var line2 = new graphic2.Polyline({
      shape: {
        points: points2
      }
    });
    this.add(line2);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  polylineProto.updateData = function(lineData, idx, seriesScope) {
    var seriesModel = lineData.hostModel;
    var line2 = this.childAt(0);
    var target = {
      shape: {
        points: lineData.getItemLayout(idx)
      }
    };
    graphic2.updateProps(line2, target, seriesModel, idx);
    this._updateCommonStl(lineData, idx, seriesScope);
  };
  polylineProto._updateCommonStl = function(lineData, idx, seriesScope) {
    var line2 = this.childAt(0);
    var itemModel = lineData.getItemModel(idx);
    var visualColor = lineData.getItemVisual(idx, "color");
    var lineStyle2 = seriesScope && seriesScope.lineStyle;
    var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
    if (!seriesScope || lineData.hasItemOption) {
      lineStyle2 = itemModel.getModel("lineStyle").getLineStyle();
      hoverLineStyle = itemModel.getModel("emphasis.lineStyle").getLineStyle();
    }
    line2.useStyle(zrUtil2.defaults({
      strokeNoScale: true,
      fill: "none",
      stroke: visualColor
    }, lineStyle2));
    line2.hoverStyle = hoverLineStyle;
    graphic2.setHoverStyle(this);
  };
  polylineProto.updateLayout = function(lineData, idx) {
    var polyline = this.childAt(0);
    polyline.setShape("points", lineData.getItemLayout(idx));
  };
  zrUtil2.inherits(Polyline2, graphic2.Group);
  var _default2 = Polyline2;
  Polyline_1 = _default2;
  return Polyline_1;
}
var EffectPolyline_1;
var hasRequiredEffectPolyline;
function requireEffectPolyline() {
  if (hasRequiredEffectPolyline)
    return EffectPolyline_1;
  hasRequiredEffectPolyline = 1;
  var Polyline2 = requirePolyline();
  var zrUtil2 = util$6;
  var EffectLine = requireEffectLine();
  var vec22 = requireVector();
  function EffectPolyline(lineData, idx, seriesScope) {
    EffectLine.call(this, lineData, idx, seriesScope);
    this._lastFrame = 0;
    this._lastFramePercent = 0;
  }
  var effectPolylineProto = EffectPolyline.prototype;
  effectPolylineProto.createLine = function(lineData, idx, seriesScope) {
    return new Polyline2(lineData, idx, seriesScope);
  };
  effectPolylineProto.updateAnimationPoints = function(symbol2, points2) {
    this._points = points2;
    var accLenArr = [0];
    var len = 0;
    for (var i = 1; i < points2.length; i++) {
      var p1 = points2[i - 1];
      var p2 = points2[i];
      len += vec22.dist(p1, p2);
      accLenArr.push(len);
    }
    if (len === 0) {
      return;
    }
    for (var i = 0; i < accLenArr.length; i++) {
      accLenArr[i] /= len;
    }
    this._offsets = accLenArr;
    this._length = len;
  };
  effectPolylineProto.getLineLength = function(symbol2) {
    return this._length;
  };
  effectPolylineProto.updateSymbolPosition = function(symbol2) {
    var t2 = symbol2.__t;
    var points2 = this._points;
    var offsets = this._offsets;
    var len = points2.length;
    if (!offsets) {
      return;
    }
    var lastFrame = this._lastFrame;
    var frame;
    if (t2 < this._lastFramePercent) {
      var start = Math.min(lastFrame + 1, len - 1);
      for (frame = start; frame >= 0; frame--) {
        if (offsets[frame] <= t2) {
          break;
        }
      }
      frame = Math.min(frame, len - 2);
    } else {
      for (var frame = lastFrame; frame < len; frame++) {
        if (offsets[frame] > t2) {
          break;
        }
      }
      frame = Math.min(frame - 1, len - 2);
    }
    vec22.lerp(symbol2.position, points2[frame], points2[frame + 1], (t2 - offsets[frame]) / (offsets[frame + 1] - offsets[frame]));
    var tx = points2[frame + 1][0] - points2[frame][0];
    var ty = points2[frame + 1][1] - points2[frame][1];
    symbol2.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    this._lastFrame = frame;
    this._lastFramePercent = t2;
    symbol2.ignore = false;
  };
  zrUtil2.inherits(EffectPolyline, EffectLine);
  var _default2 = EffectPolyline;
  EffectPolyline_1 = _default2;
  return EffectPolyline_1;
}
var LargeLineDraw_1;
var hasRequiredLargeLineDraw;
function requireLargeLineDraw() {
  if (hasRequiredLargeLineDraw)
    return LargeLineDraw_1;
  hasRequiredLargeLineDraw = 1;
  var graphic2 = graphic$4;
  var IncrementalDisplayable2 = IncrementalDisplayable$1;
  var lineContain = line$2;
  var quadraticContain = quadratic$1;
  var LargeLineShape = graphic2.extendShape({
    shape: {
      polyline: false,
      curveness: 0,
      segs: []
    },
    buildPath: function(path2, shape) {
      var segs = shape.segs;
      var curveness = shape.curveness;
      if (shape.polyline) {
        for (var i = 0; i < segs.length; ) {
          var count = segs[i++];
          if (count > 0) {
            path2.moveTo(segs[i++], segs[i++]);
            for (var k = 1; k < count; k++) {
              path2.lineTo(segs[i++], segs[i++]);
            }
          }
        }
      } else {
        for (var i = 0; i < segs.length; ) {
          var x0 = segs[i++];
          var y0 = segs[i++];
          var x1 = segs[i++];
          var y1 = segs[i++];
          path2.moveTo(x0, y0);
          if (curveness > 0) {
            var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
            var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
            path2.quadraticCurveTo(x2, y2, x1, y1);
          } else {
            path2.lineTo(x1, y1);
          }
        }
      }
    },
    findDataIndex: function(x, y) {
      var shape = this.shape;
      var segs = shape.segs;
      var curveness = shape.curveness;
      if (shape.polyline) {
        var dataIndex = 0;
        for (var i = 0; i < segs.length; ) {
          var count = segs[i++];
          if (count > 0) {
            var x0 = segs[i++];
            var y0 = segs[i++];
            for (var k = 1; k < count; k++) {
              var x1 = segs[i++];
              var y1 = segs[i++];
              if (lineContain.containStroke(x0, y0, x1, y1)) {
                return dataIndex;
              }
            }
          }
          dataIndex++;
        }
      } else {
        var dataIndex = 0;
        for (var i = 0; i < segs.length; ) {
          var x0 = segs[i++];
          var y0 = segs[i++];
          var x1 = segs[i++];
          var y1 = segs[i++];
          if (curveness > 0) {
            var x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
            var y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
            if (quadraticContain.containStroke(x0, y0, x2, y2, x1, y1)) {
              return dataIndex;
            }
          } else {
            if (lineContain.containStroke(x0, y0, x1, y1)) {
              return dataIndex;
            }
          }
          dataIndex++;
        }
      }
      return -1;
    }
  });
  function LargeLineDraw() {
    this.group = new graphic2.Group();
  }
  var largeLineProto = LargeLineDraw.prototype;
  largeLineProto.isPersistent = function() {
    return !this._incremental;
  };
  largeLineProto.updateData = function(data) {
    this.group.removeAll();
    var lineEl = new LargeLineShape({
      rectHover: true,
      cursor: "default"
    });
    lineEl.setShape({
      segs: data.getLayout("linesPoints")
    });
    this._setCommon(lineEl, data);
    this.group.add(lineEl);
    this._incremental = null;
  };
  largeLineProto.incrementalPrepareUpdate = function(data) {
    this.group.removeAll();
    this._clearIncremental();
    if (data.count() > 5e5) {
      if (!this._incremental) {
        this._incremental = new IncrementalDisplayable2({
          silent: true
        });
      }
      this.group.add(this._incremental);
    } else {
      this._incremental = null;
    }
  };
  largeLineProto.incrementalUpdate = function(taskParams, data) {
    var lineEl = new LargeLineShape();
    lineEl.setShape({
      segs: data.getLayout("linesPoints")
    });
    this._setCommon(lineEl, data, !!this._incremental);
    if (!this._incremental) {
      lineEl.rectHover = true;
      lineEl.cursor = "default";
      lineEl.__startIndex = taskParams.start;
      this.group.add(lineEl);
    } else {
      this._incremental.addDisplayable(lineEl, true);
    }
  };
  largeLineProto.remove = function() {
    this._clearIncremental();
    this._incremental = null;
    this.group.removeAll();
  };
  largeLineProto._setCommon = function(lineEl, data, isIncremental) {
    var hostModel = data.hostModel;
    lineEl.setShape({
      polyline: hostModel.get("polyline"),
      curveness: hostModel.get("lineStyle.curveness")
    });
    lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
    lineEl.style.strokeNoScale = true;
    var visualColor = data.getVisual("color");
    if (visualColor) {
      lineEl.setStyle("stroke", visualColor);
    }
    lineEl.setStyle("fill");
    if (!isIncremental) {
      lineEl.seriesIndex = hostModel.seriesIndex;
      lineEl.on("mousemove", function(e2) {
        lineEl.dataIndex = null;
        var dataIndex = lineEl.findDataIndex(e2.offsetX, e2.offsetY);
        if (dataIndex > 0) {
          lineEl.dataIndex = dataIndex + lineEl.__startIndex;
        }
      });
    }
  };
  largeLineProto._clearIncremental = function() {
    var incremental = this._incremental;
    if (incremental) {
      incremental.clearDisplaybles();
    }
  };
  var _default2 = LargeLineDraw;
  LargeLineDraw_1 = _default2;
  return LargeLineDraw_1;
}
var linesLayout;
var hasRequiredLinesLayout;
function requireLinesLayout() {
  if (hasRequiredLinesLayout)
    return linesLayout;
  hasRequiredLinesLayout = 1;
  var createRenderPlanner2 = createRenderPlanner$1;
  var _default2 = {
    seriesType: "lines",
    plan: createRenderPlanner2(),
    reset: function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      var isPolyline = seriesModel.get("polyline");
      var isLarge = seriesModel.pipelineContext.large;
      function progress(params, lineData) {
        var lineCoords = [];
        if (isLarge) {
          var points2;
          var segCount = params.end - params.start;
          if (isPolyline) {
            var totalCoordsCount = 0;
            for (var i = params.start; i < params.end; i++) {
              totalCoordsCount += seriesModel.getLineCoordsCount(i);
            }
            points2 = new Float32Array(segCount + totalCoordsCount * 2);
          } else {
            points2 = new Float32Array(segCount * 4);
          }
          var offset = 0;
          var pt = [];
          for (var i = params.start; i < params.end; i++) {
            var len = seriesModel.getLineCoords(i, lineCoords);
            if (isPolyline) {
              points2[offset++] = len;
            }
            for (var k = 0; k < len; k++) {
              pt = coordSys.dataToPoint(lineCoords[k], false, pt);
              points2[offset++] = pt[0];
              points2[offset++] = pt[1];
            }
          }
          lineData.setLayout("linesPoints", points2);
        } else {
          for (var i = params.start; i < params.end; i++) {
            var itemModel = lineData.getItemModel(i);
            var len = seriesModel.getLineCoords(i, lineCoords);
            var pts = [];
            if (isPolyline) {
              for (var j = 0; j < len; j++) {
                pts.push(coordSys.dataToPoint(lineCoords[j]));
              }
            } else {
              pts[0] = coordSys.dataToPoint(lineCoords[0]);
              pts[1] = coordSys.dataToPoint(lineCoords[1]);
              var curveness = itemModel.get("lineStyle.curveness");
              if (+curveness) {
                pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness];
              }
            }
            lineData.setItemLayout(i, pts);
          }
        }
      }
      return {
        progress
      };
    }
  };
  linesLayout = _default2;
  return linesLayout;
}
var LinesView;
var hasRequiredLinesView;
function requireLinesView() {
  if (hasRequiredLinesView)
    return LinesView;
  hasRequiredLinesView = 1;
  var echarts$12 = echarts;
  var LineDraw = requireLineDraw();
  var EffectLine = requireEffectLine();
  var Line2 = requireLine();
  var Polyline2 = requirePolyline();
  var EffectPolyline = requireEffectPolyline();
  var LargeLineDraw = requireLargeLineDraw();
  var linesLayout2 = requireLinesLayout();
  var _createClipPathFromCoordSys = requireCreateClipPathFromCoordSys();
  var createClipPath = _createClipPathFromCoordSys.createClipPath;
  var _default2 = echarts$12.extendChartView({
    type: "lines",
    init: function() {
    },
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var lineDraw = this._updateLineDraw(data, seriesModel);
      var zlevel = seriesModel.get("zlevel");
      var trailLength = seriesModel.get("effect.trailLength");
      var zr = api.getZr();
      var isSvg = zr.painter.getType() === "svg";
      if (!isSvg) {
        zr.painter.getLayer(zlevel).clear(true);
      }
      if (this._lastZlevel != null && !isSvg) {
        zr.configLayer(this._lastZlevel, {
          motionBlur: false
        });
      }
      if (this._showEffect(seriesModel) && trailLength) {
        if (!isSvg) {
          zr.configLayer(zlevel, {
            motionBlur: true,
            lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
          });
        }
      }
      lineDraw.updateData(data);
      var clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
      if (clipPath) {
        this.group.setClipPath(clipPath);
      } else {
        this.group.removeClipPath();
      }
      this._lastZlevel = zlevel;
      this._finished = true;
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var lineDraw = this._updateLineDraw(data, seriesModel);
      lineDraw.incrementalPrepareUpdate(data);
      this._clearLayer(api);
      this._finished = false;
    },
    incrementalRender: function(taskParams, seriesModel, ecModel) {
      this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
      this._finished = taskParams.end === seriesModel.getData().count();
    },
    updateTransform: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var pipelineContext = seriesModel.pipelineContext;
      if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
        return {
          update: true
        };
      } else {
        var res = linesLayout2.reset(seriesModel);
        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count()
          }, data);
        }
        this._lineDraw.updateLayout();
        this._clearLayer(api);
      }
    },
    _updateLineDraw: function(data, seriesModel) {
      var lineDraw = this._lineDraw;
      var hasEffect = this._showEffect(seriesModel);
      var isPolyline = !!seriesModel.get("polyline");
      var pipelineContext = seriesModel.pipelineContext;
      var isLargeDraw = pipelineContext.large;
      if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
        if (lineDraw) {
          lineDraw.remove();
        }
        lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw() : new LineDraw(isPolyline ? hasEffect ? EffectPolyline : Polyline2 : hasEffect ? EffectLine : Line2);
        this._hasEffet = hasEffect;
        this._isPolyline = isPolyline;
        this._isLargeDraw = isLargeDraw;
        this.group.removeAll();
      }
      this.group.add(lineDraw.group);
      return lineDraw;
    },
    _showEffect: function(seriesModel) {
      return !!seriesModel.get("effect.show");
    },
    _clearLayer: function(api) {
      var zr = api.getZr();
      var isSvg = zr.painter.getType() === "svg";
      if (!isSvg && this._lastZlevel != null) {
        zr.painter.getLayer(this._lastZlevel).clear(true);
      }
    },
    remove: function(ecModel, api) {
      this._lineDraw && this._lineDraw.remove();
      this._lineDraw = null;
      this._clearLayer(api);
    },
    dispose: function() {
    }
  });
  LinesView = _default2;
  return LinesView;
}
var linesVisual;
var hasRequiredLinesVisual;
function requireLinesVisual() {
  if (hasRequiredLinesVisual)
    return linesVisual;
  hasRequiredLinesVisual = 1;
  function normalize(a) {
    if (!(a instanceof Array)) {
      a = [a, a];
    }
    return a;
  }
  var opacityQuery = "lineStyle.opacity".split(".");
  var _default2 = {
    seriesType: "lines",
    reset: function(seriesModel, ecModel, api) {
      var symbolType = normalize(seriesModel.get("symbol"));
      var symbolSize = normalize(seriesModel.get("symbolSize"));
      var data = seriesModel.getData();
      data.setVisual("fromSymbol", symbolType && symbolType[0]);
      data.setVisual("toSymbol", symbolType && symbolType[1]);
      data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
      data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
      data.setVisual("opacity", seriesModel.get(opacityQuery));
      function dataEach(data2, idx) {
        var itemModel = data2.getItemModel(idx);
        var symbolType2 = normalize(itemModel.getShallow("symbol", true));
        var symbolSize2 = normalize(itemModel.getShallow("symbolSize", true));
        var opacity = itemModel.get(opacityQuery);
        symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
        symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
        symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
        symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
        data2.setItemVisual(idx, "opacity", opacity);
      }
      return {
        dataEach: data.hasItemOption ? dataEach : null
      };
    }
  };
  linesVisual = _default2;
  return linesVisual;
}
var hasRequiredLines;
function requireLines() {
  if (hasRequiredLines)
    return lines;
  hasRequiredLines = 1;
  var echarts$12 = echarts;
  requireLinesSeries();
  requireLinesView();
  var linesLayout2 = requireLinesLayout();
  var linesVisual2 = requireLinesVisual();
  echarts$12.registerLayout(linesLayout2);
  echarts$12.registerVisual(linesVisual2);
  return lines;
}
var heatmap = {};
var HeatmapSeries;
var hasRequiredHeatmapSeries;
function requireHeatmapSeries() {
  if (hasRequiredHeatmapSeries)
    return HeatmapSeries;
  hasRequiredHeatmapSeries = 1;
  var SeriesModel2 = Series;
  var createListFromArray = requireCreateListFromArray();
  var CoordinateSystem$1 = CoordinateSystem;
  var _default2 = SeriesModel2.extend({
    type: "series.heatmap",
    getInitialData: function(option, ecModel) {
      return createListFromArray(this.getSource(), this, {
        generateCoord: "value"
      });
    },
    preventIncremental: function() {
      var coordSysCreator = CoordinateSystem$1.get(this.get("coordinateSystem"));
      if (coordSysCreator && coordSysCreator.dimensions) {
        return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
      }
    },
    defaultOption: {
      // Cartesian2D or geo
      coordinateSystem: "cartesian2d",
      zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0
    }
  });
  HeatmapSeries = _default2;
  return HeatmapSeries;
}
var HeatmapLayer;
var hasRequiredHeatmapLayer;
function requireHeatmapLayer() {
  if (hasRequiredHeatmapLayer)
    return HeatmapLayer;
  hasRequiredHeatmapLayer = 1;
  var zrUtil2 = util$6;
  var GRADIENT_LEVELS = 256;
  function Heatmap() {
    var canvas = zrUtil2.createCanvas();
    this.canvas = canvas;
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {};
  }
  Heatmap.prototype = {
    /**
     * Renders Heatmap and returns the rendered canvas
     * @param {Array} data array of data, each has x, y, value
     * @param {number} width canvas width
     * @param {number} height canvas height
     */
    update: function(data, width, height, normalize, colorFunc, isInRange) {
      var brush2 = this._getBrush();
      var gradientInRange = this._getGradient(data, colorFunc, "inRange");
      var gradientOutOfRange = this._getGradient(data, colorFunc, "outOfRange");
      var r = this.pointSize + this.blurSize;
      var canvas = this.canvas;
      var ctx = canvas.getContext("2d");
      var len = data.length;
      canvas.width = width;
      canvas.height = height;
      for (var i = 0; i < len; ++i) {
        var p2 = data[i];
        var x = p2[0];
        var y = p2[1];
        var value = p2[2];
        var alpha = normalize(value);
        ctx.globalAlpha = alpha;
        ctx.drawImage(brush2, x - r, y - r);
      }
      if (!canvas.width || !canvas.height) {
        return canvas;
      }
      var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      var pixels = imageData.data;
      var offset = 0;
      var pixelLen = pixels.length;
      var minOpacity = this.minOpacity;
      var maxOpacity = this.maxOpacity;
      var diffOpacity = maxOpacity - minOpacity;
      while (offset < pixelLen) {
        var alpha = pixels[offset + 3] / 256;
        var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
        if (alpha > 0) {
          var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
          alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
          pixels[offset++] = gradient[gradientOffset];
          pixels[offset++] = gradient[gradientOffset + 1];
          pixels[offset++] = gradient[gradientOffset + 2];
          pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
        } else {
          offset += 4;
        }
      }
      ctx.putImageData(imageData, 0, 0);
      return canvas;
    },
    /**
     * get canvas of a black circle brush used for canvas to draw later
     * @private
     * @returns {Object} circle brush canvas
     */
    _getBrush: function() {
      var brushCanvas = this._brushCanvas || (this._brushCanvas = zrUtil2.createCanvas());
      var r = this.pointSize + this.blurSize;
      var d = r * 2;
      brushCanvas.width = d;
      brushCanvas.height = d;
      var ctx = brushCanvas.getContext("2d");
      ctx.clearRect(0, 0, d, d);
      ctx.shadowOffsetX = d;
      ctx.shadowBlur = this.blurSize;
      ctx.shadowColor = "#000";
      ctx.beginPath();
      ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
      ctx.closePath();
      ctx.fill();
      return brushCanvas;
    },
    /**
     * get gradient color map
     * @private
     */
    _getGradient: function(data, colorFunc, state) {
      var gradientPixels = this._gradientPixels;
      var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
      var color2 = [0, 0, 0, 0];
      var off = 0;
      for (var i = 0; i < 256; i++) {
        colorFunc[state](i / 255, true, color2);
        pixelsSingleState[off++] = color2[0];
        pixelsSingleState[off++] = color2[1];
        pixelsSingleState[off++] = color2[2];
        pixelsSingleState[off++] = color2[3];
      }
      return pixelsSingleState;
    }
  };
  var _default2 = Heatmap;
  HeatmapLayer = _default2;
  return HeatmapLayer;
}
var HeatmapView;
var hasRequiredHeatmapView;
function requireHeatmapView() {
  if (hasRequiredHeatmapView)
    return HeatmapView;
  hasRequiredHeatmapView = 1;
  var echarts$12 = echarts;
  var graphic2 = graphic$4;
  var HeatmapLayer2 = requireHeatmapLayer();
  var zrUtil2 = util$6;
  function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
    var dataSpan = dataExtent[1] - dataExtent[0];
    pieceList = zrUtil2.map(pieceList, function(piece) {
      return {
        interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
      };
    });
    var len = pieceList.length;
    var lastIndex = 0;
    return function(val) {
      for (var i = lastIndex; i < len; i++) {
        var interval = pieceList[i].interval;
        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
      if (i === len) {
        for (var i = lastIndex - 1; i >= 0; i--) {
          var interval = pieceList[i].interval;
          if (interval[0] <= val && val <= interval[1]) {
            lastIndex = i;
            break;
          }
        }
      }
      return i >= 0 && i < len && selected[i];
    };
  }
  function getIsInContinuousRange(dataExtent, range) {
    var dataSpan = dataExtent[1] - dataExtent[0];
    range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan];
    return function(val) {
      return val >= range[0] && val <= range[1];
    };
  }
  function isGeoCoordSys(coordSys) {
    var dimensions = coordSys.dimensions;
    return dimensions[0] === "lng" && dimensions[1] === "lat";
  }
  var _default2 = echarts$12.extendChartView({
    type: "heatmap",
    render: function(seriesModel, ecModel, api) {
      var visualMapOfThisSeries;
      ecModel.eachComponent("visualMap", function(visualMap2) {
        visualMap2.eachTargetSeries(function(targetSeries) {
          if (targetSeries === seriesModel) {
            visualMapOfThisSeries = visualMap2;
          }
        });
      });
      this.group.removeAll();
      this._incrementalDisplayable = null;
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys.type === "cartesian2d" || coordSys.type === "calendar") {
        this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count());
      } else if (isGeoCoordSys(coordSys)) {
        this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
      }
    },
    incrementalPrepareRender: function(seriesModel, ecModel, api) {
      this.group.removeAll();
    },
    incrementalRender: function(params, seriesModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys) {
        this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true);
      }
    },
    _renderOnCartesianAndCalendar: function(seriesModel, api, start, end, incremental) {
      var coordSys = seriesModel.coordinateSystem;
      var width;
      var height;
      if (coordSys.type === "cartesian2d") {
        var xAxis = coordSys.getAxis("x");
        var yAxis = coordSys.getAxis("y");
        width = xAxis.getBandWidth();
        height = yAxis.getBandWidth();
      }
      var group = this.group;
      var data = seriesModel.getData();
      var itemStyleQuery = "itemStyle";
      var hoverItemStyleQuery = "emphasis.itemStyle";
      var labelQuery = "label";
      var hoverLabelQuery = "emphasis.label";
      var style = seriesModel.getModel(itemStyleQuery).getItemStyle(["color"]);
      var hoverStl = seriesModel.getModel(hoverItemStyleQuery).getItemStyle();
      var labelModel = seriesModel.getModel(labelQuery);
      var hoverLabelModel = seriesModel.getModel(hoverLabelQuery);
      var coordSysType = coordSys.type;
      var dataDims = coordSysType === "cartesian2d" ? [data.mapDimension("x"), data.mapDimension("y"), data.mapDimension("value")] : [data.mapDimension("time"), data.mapDimension("value")];
      for (var idx = start; idx < end; idx++) {
        var rect;
        if (coordSysType === "cartesian2d") {
          if (isNaN(data.get(dataDims[2], idx))) {
            continue;
          }
          var point = coordSys.dataToPoint([data.get(dataDims[0], idx), data.get(dataDims[1], idx)]);
          rect = new graphic2.Rect({
            shape: {
              x: Math.floor(Math.round(point[0]) - width / 2),
              y: Math.floor(Math.round(point[1]) - height / 2),
              width: Math.ceil(width),
              height: Math.ceil(height)
            },
            style: {
              fill: data.getItemVisual(idx, "color"),
              opacity: data.getItemVisual(idx, "opacity")
            }
          });
        } else {
          if (isNaN(data.get(dataDims[1], idx))) {
            continue;
          }
          rect = new graphic2.Rect({
            z2: 1,
            shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
            style: {
              fill: data.getItemVisual(idx, "color"),
              opacity: data.getItemVisual(idx, "opacity")
            }
          });
        }
        var itemModel = data.getItemModel(idx);
        if (data.hasItemOption) {
          style = itemModel.getModel(itemStyleQuery).getItemStyle(["color"]);
          hoverStl = itemModel.getModel(hoverItemStyleQuery).getItemStyle();
          labelModel = itemModel.getModel(labelQuery);
          hoverLabelModel = itemModel.getModel(hoverLabelQuery);
        }
        var rawValue = seriesModel.getRawValue(idx);
        var defaultText = "-";
        if (rawValue && rawValue[2] != null) {
          defaultText = rawValue[2];
        }
        graphic2.setLabelStyle(style, hoverStl, labelModel, hoverLabelModel, {
          labelFetcher: seriesModel,
          labelDataIndex: idx,
          defaultText,
          isRectText: true
        });
        rect.setStyle(style);
        graphic2.setHoverStyle(rect, data.hasItemOption ? hoverStl : zrUtil2.extend({}, hoverStl));
        rect.incremental = incremental;
        if (incremental) {
          rect.useHoverLayer = true;
        }
        group.add(rect);
        data.setItemGraphicEl(idx, rect);
      }
    },
    _renderOnGeo: function(geo2, seriesModel, visualMapModel, api) {
      var inRangeVisuals = visualMapModel.targetVisuals.inRange;
      var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
      var data = seriesModel.getData();
      var hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer2();
      hmLayer.blurSize = seriesModel.get("blurSize");
      hmLayer.pointSize = seriesModel.get("pointSize");
      hmLayer.minOpacity = seriesModel.get("minOpacity");
      hmLayer.maxOpacity = seriesModel.get("maxOpacity");
      var rect = geo2.getViewRect().clone();
      var roamTransform = geo2.getRoamTransform();
      rect.applyTransform(roamTransform);
      var x = Math.max(rect.x, 0);
      var y = Math.max(rect.y, 0);
      var x2 = Math.min(rect.width + rect.x, api.getWidth());
      var y2 = Math.min(rect.height + rect.y, api.getHeight());
      var width = x2 - x;
      var height = y2 - y;
      var dims = [data.mapDimension("lng"), data.mapDimension("lat"), data.mapDimension("value")];
      var points2 = data.mapArray(dims, function(lng, lat, value) {
        var pt = geo2.dataToPoint([lng, lat]);
        pt[0] -= x;
        pt[1] -= y;
        pt.push(value);
        return pt;
      });
      var dataExtent = visualMapModel.getExtent();
      var isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
      hmLayer.update(points2, width, height, inRangeVisuals.color.getNormalizer(), {
        inRange: inRangeVisuals.color.getColorMapper(),
        outOfRange: outOfRangeVisuals.color.getColorMapper()
      }, isInRange);
      var img = new graphic2.Image({
        style: {
          width,
          height,
          x,
          y,
          image: hmLayer.canvas
        },
        silent: true
      });
      this.group.add(img);
    },
    dispose: function() {
    }
  });
  HeatmapView = _default2;
  return HeatmapView;
}
var hasRequiredHeatmap;
function requireHeatmap() {
  if (hasRequiredHeatmap)
    return heatmap;
  hasRequiredHeatmap = 1;
  requireHeatmapSeries();
  requireHeatmapView();
  return heatmap;
}
var pictorialBar = {};
var PictorialBarSeries_1;
var hasRequiredPictorialBarSeries;
function requirePictorialBarSeries() {
  if (hasRequiredPictorialBarSeries)
    return PictorialBarSeries_1;
  hasRequiredPictorialBarSeries = 1;
  var BaseBarSeries2 = requireBaseBarSeries();
  var PictorialBarSeries = BaseBarSeries2.extend({
    type: "series.pictorialBar",
    dependencies: ["grid"],
    defaultOption: {
      symbol: "circle",
      // Customized bar shape
      symbolSize: null,
      // Can be ['100%', '100%'], null means auto.
      symbolRotate: null,
      symbolPosition: null,
      // 'start' or 'end' or 'center', null means auto.
      symbolOffset: null,
      symbolMargin: null,
      // start margin and end margin. Can be a number or a percent string.
      // Auto margin by default.
      symbolRepeat: false,
      // false/null/undefined, means no repeat.
      // Can be true, means auto calculate repeat times and cut by data.
      // Can be a number, specifies repeat times, and do not cut by data.
      // Can be 'fixed', means auto calculate repeat times but do not cut by data.
      symbolRepeatDirection: "end",
      // 'end' means from 'start' to 'end'.
      symbolClip: false,
      symbolBoundingData: null,
      // Can be 60 or -40 or [-40, 60]
      symbolPatternSize: 400,
      // 400 * 400 px
      barGap: "-100%",
      // In most case, overlap is needed.
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      hoverAnimation: false
      // Open only when needed.
    },
    getInitialData: function(option) {
      option.stack = null;
      return PictorialBarSeries.superApply(this, "getInitialData", arguments);
    }
  });
  var _default2 = PictorialBarSeries;
  PictorialBarSeries_1 = _default2;
  return PictorialBarSeries_1;
}
var PictorialBarView;
var hasRequiredPictorialBarView;
function requirePictorialBarView() {
  if (hasRequiredPictorialBarView)
    return PictorialBarView;
  hasRequiredPictorialBarView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var isNumeric = _number2.isNumeric;
  var _helper = requireHelper$2();
  var setLabel = _helper.setLabel;
  var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
  var LAYOUT_ATTRS = [{
    xy: "x",
    wh: "width",
    index: 0,
    posDesc: ["left", "right"]
  }, {
    xy: "y",
    wh: "height",
    index: 1,
    posDesc: ["top", "bottom"]
  }];
  var pathForLineWidth = new graphic2.Circle();
  var BarView2 = echarts$12.extendChartView({
    type: "pictorialBar",
    render: function(seriesModel, ecModel, api) {
      var group = this.group;
      var data = seriesModel.getData();
      var oldData = this._data;
      var cartesian = seriesModel.coordinateSystem;
      var baseAxis = cartesian.getBaseAxis();
      var isHorizontal = !!baseAxis.isHorizontal();
      var coordSysRect = cartesian.grid.getRect();
      var opt = {
        ecSize: {
          width: api.getWidth(),
          height: api.getHeight()
        },
        seriesModel,
        coordSys: cartesian,
        coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
        isHorizontal,
        valueDim: LAYOUT_ATTRS[+isHorizontal],
        categoryDim: LAYOUT_ATTRS[1 - isHorizontal]
      };
      data.diff(oldData).add(function(dataIndex) {
        if (!data.hasValue(dataIndex)) {
          return;
        }
        var itemModel = getItemModel(data, dataIndex);
        var symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
        var bar2 = createBar(data, opt, symbolMeta);
        data.setItemGraphicEl(dataIndex, bar2);
        group.add(bar2);
        updateCommon(bar2, opt, symbolMeta);
      }).update(function(newIndex, oldIndex) {
        var bar2 = oldData.getItemGraphicEl(oldIndex);
        if (!data.hasValue(newIndex)) {
          group.remove(bar2);
          return;
        }
        var itemModel = getItemModel(data, newIndex);
        var symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
        var pictorialShapeStr = getShapeStr(data, symbolMeta);
        if (bar2 && pictorialShapeStr !== bar2.__pictorialShapeStr) {
          group.remove(bar2);
          data.setItemGraphicEl(newIndex, null);
          bar2 = null;
        }
        if (bar2) {
          updateBar(bar2, opt, symbolMeta);
        } else {
          bar2 = createBar(data, opt, symbolMeta, true);
        }
        data.setItemGraphicEl(newIndex, bar2);
        bar2.__pictorialSymbolMeta = symbolMeta;
        group.add(bar2);
        updateCommon(bar2, opt, symbolMeta);
      }).remove(function(dataIndex) {
        var bar2 = oldData.getItemGraphicEl(dataIndex);
        bar2 && removeBar(oldData, dataIndex, bar2.__pictorialSymbolMeta.animationModel, bar2);
      }).execute();
      this._data = data;
      return this.group;
    },
    dispose: zrUtil2.noop,
    remove: function(ecModel, api) {
      var group = this.group;
      var data = this._data;
      if (ecModel.get("animation")) {
        if (data) {
          data.eachItemGraphicEl(function(bar2) {
            removeBar(data, bar2.dataIndex, ecModel, bar2);
          });
        }
      } else {
        group.removeAll();
      }
    }
  });
  function getSymbolMeta(data, dataIndex, itemModel, opt) {
    var layout2 = data.getItemLayout(dataIndex);
    var symbolRepeat = itemModel.get("symbolRepeat");
    var symbolClip = itemModel.get("symbolClip");
    var symbolPosition = itemModel.get("symbolPosition") || "start";
    var symbolRotate = itemModel.get("symbolRotate");
    var rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    var symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
    var isAnimationEnabled2 = itemModel.isAnimationEnabled();
    var symbolMeta = {
      dataIndex,
      layout: layout2,
      itemModel,
      symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
      color: data.getItemVisual(dataIndex, "color"),
      symbolClip,
      symbolRepeat,
      symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
      symbolPatternSize,
      rotation,
      animationModel: isAnimationEnabled2 ? itemModel : null,
      hoverAnimation: isAnimationEnabled2 && itemModel.get("hoverAnimation"),
      z2: itemModel.getShallow("z", true) || 0
    };
    prepareBarLength(itemModel, symbolRepeat, layout2, opt, symbolMeta);
    prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
    prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
    var symbolSize = symbolMeta.symbolSize;
    var symbolOffset = itemModel.get("symbolOffset");
    if (zrUtil2.isArray(symbolOffset)) {
      symbolOffset = [parsePercent2(symbolOffset[0], symbolSize[0]), parsePercent2(symbolOffset[1], symbolSize[1])];
    }
    prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
    return symbolMeta;
  }
  function prepareBarLength(itemModel, symbolRepeat, layout2, opt, output) {
    var valueDim = opt.valueDim;
    var symbolBoundingData = itemModel.get("symbolBoundingData");
    var valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
    var zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0));
    var pxSignIdx = 1 - +(layout2[valueDim.wh] <= 0);
    var boundingLength;
    if (zrUtil2.isArray(symbolBoundingData)) {
      var symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx];
      symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
      boundingLength = symbolBoundingExtent[pxSignIdx];
    } else if (symbolBoundingData != null) {
      boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx;
    } else if (symbolRepeat) {
      boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
    } else {
      boundingLength = layout2[valueDim.wh];
    }
    output.boundingLength = boundingLength;
    if (symbolRepeat) {
      output.repeatCutLength = layout2[valueDim.wh];
    }
    output.pxSign = boundingLength > 0 ? 1 : boundingLength < 0 ? -1 : 0;
  }
  function convertToCoordOnAxis(axis2, value) {
    return axis2.toGlobalCoord(axis2.dataToCoord(axis2.scale.parse(value)));
  }
  function prepareSymbolSize(data, dataIndex, layout2, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, output) {
    var valueDim = opt.valueDim;
    var categoryDim = opt.categoryDim;
    var categorySize = Math.abs(layout2[categoryDim.wh]);
    var symbolSize = data.getItemVisual(dataIndex, "symbolSize");
    if (zrUtil2.isArray(symbolSize)) {
      symbolSize = symbolSize.slice();
    } else {
      if (symbolSize == null) {
        symbolSize = "100%";
      }
      symbolSize = [symbolSize, symbolSize];
    }
    symbolSize[categoryDim.index] = parsePercent2(symbolSize[categoryDim.index], categorySize);
    symbolSize[valueDim.index] = parsePercent2(symbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
    output.symbolSize = symbolSize;
    var symbolScale = output.symbolScale = [symbolSize[0] / symbolPatternSize, symbolSize[1] / symbolPatternSize];
    symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
  }
  function prepareLineWidth(itemModel, symbolScale, rotation, opt, output) {
    var valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
    if (valueLineWidth) {
      pathForLineWidth.attr({
        scale: symbolScale.slice(),
        rotation
      });
      pathForLineWidth.updateTransform();
      valueLineWidth /= pathForLineWidth.getLineScale();
      valueLineWidth *= symbolScale[opt.valueDim.index];
    }
    output.valueLineWidth = valueLineWidth;
  }
  function prepareLayoutInfo(itemModel, symbolSize, layout2, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, output) {
    var categoryDim = opt.categoryDim;
    var valueDim = opt.valueDim;
    var pxSign = output.pxSign;
    var unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
    var pathLen = unitLength;
    if (symbolRepeat) {
      var absBoundingLength = Math.abs(boundingLength);
      var symbolMargin = zrUtil2.retrieve(itemModel.get("symbolMargin"), "15%") + "";
      var hasEndGap = false;
      if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
        hasEndGap = true;
        symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
      }
      symbolMargin = parsePercent2(symbolMargin, symbolSize[valueDim.index]);
      var uLenWithMargin = Math.max(unitLength + symbolMargin * 2, 0);
      var endFix = hasEndGap ? 0 : symbolMargin * 2;
      var repeatSpecified = isNumeric(symbolRepeat);
      var repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
      var mDiff = absBoundingLength - repeatTimes * unitLength;
      symbolMargin = mDiff / 2 / (hasEndGap ? repeatTimes : repeatTimes - 1);
      uLenWithMargin = unitLength + symbolMargin * 2;
      endFix = hasEndGap ? 0 : symbolMargin * 2;
      if (!repeatSpecified && symbolRepeat !== "fixed") {
        repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
      }
      pathLen = repeatTimes * uLenWithMargin - endFix;
      output.repeatTimes = repeatTimes;
      output.symbolMargin = symbolMargin;
    }
    var sizeFix = pxSign * (pathLen / 2);
    var pathPosition = output.pathPosition = [];
    pathPosition[categoryDim.index] = layout2[categoryDim.wh] / 2;
    pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
    if (symbolOffset) {
      pathPosition[0] += symbolOffset[0];
      pathPosition[1] += symbolOffset[1];
    }
    var bundlePosition = output.bundlePosition = [];
    bundlePosition[categoryDim.index] = layout2[categoryDim.xy];
    bundlePosition[valueDim.index] = layout2[valueDim.xy];
    var barRectShape = output.barRectShape = zrUtil2.extend({}, layout2);
    barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout2[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
    barRectShape[categoryDim.wh] = layout2[categoryDim.wh];
    var clipShape = output.clipShape = {};
    clipShape[categoryDim.xy] = -layout2[categoryDim.xy];
    clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
    clipShape[valueDim.xy] = 0;
    clipShape[valueDim.wh] = layout2[valueDim.wh];
  }
  function createPath(symbolMeta) {
    var symbolPatternSize = symbolMeta.symbolPatternSize;
    var path2 = createSymbol(
      // Consider texture img, make a big size.
      symbolMeta.symbolType,
      -symbolPatternSize / 2,
      -symbolPatternSize / 2,
      symbolPatternSize,
      symbolPatternSize,
      symbolMeta.color
    );
    path2.attr({
      culling: true
    });
    path2.type !== "image" && path2.setStyle({
      strokeNoScale: true
    });
    return path2;
  }
  function createOrUpdateRepeatSymbols(bar2, opt, symbolMeta, isUpdate) {
    var bundle = bar2.__pictorialBundle;
    var symbolSize = symbolMeta.symbolSize;
    var valueLineWidth = symbolMeta.valueLineWidth;
    var pathPosition = symbolMeta.pathPosition;
    var valueDim = opt.valueDim;
    var repeatTimes = symbolMeta.repeatTimes || 0;
    var index2 = 0;
    var unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
    eachPath(bar2, function(path3) {
      path3.__pictorialAnimationIndex = index2;
      path3.__pictorialRepeatTimes = repeatTimes;
      if (index2 < repeatTimes) {
        updateAttr(path3, null, makeTarget(index2), symbolMeta, isUpdate);
      } else {
        updateAttr(path3, null, {
          scale: [0, 0]
        }, symbolMeta, isUpdate, function() {
          bundle.remove(path3);
        });
      }
      updateHoverAnimation(path3, symbolMeta);
      index2++;
    });
    for (; index2 < repeatTimes; index2++) {
      var path2 = createPath(symbolMeta);
      path2.__pictorialAnimationIndex = index2;
      path2.__pictorialRepeatTimes = repeatTimes;
      bundle.add(path2);
      var target = makeTarget(index2);
      updateAttr(path2, {
        position: target.position,
        scale: [0, 0]
      }, {
        scale: target.scale,
        rotation: target.rotation
      }, symbolMeta, isUpdate);
      path2.on("mouseover", onMouseOver).on("mouseout", onMouseOut);
      updateHoverAnimation(path2, symbolMeta);
    }
    function makeTarget(index3) {
      var position = pathPosition.slice();
      var pxSign = symbolMeta.pxSign;
      var i = index3;
      if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
        i = repeatTimes - 1 - index3;
      }
      position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
      return {
        position,
        scale: symbolMeta.symbolScale.slice(),
        rotation: symbolMeta.rotation
      };
    }
    function onMouseOver() {
      eachPath(bar2, function(path3) {
        path3.trigger("emphasis");
      });
    }
    function onMouseOut() {
      eachPath(bar2, function(path3) {
        path3.trigger("normal");
      });
    }
  }
  function createOrUpdateSingleSymbol(bar2, opt, symbolMeta, isUpdate) {
    var bundle = bar2.__pictorialBundle;
    var mainPath = bar2.__pictorialMainPath;
    if (!mainPath) {
      mainPath = bar2.__pictorialMainPath = createPath(symbolMeta);
      bundle.add(mainPath);
      updateAttr(mainPath, {
        position: symbolMeta.pathPosition.slice(),
        scale: [0, 0],
        rotation: symbolMeta.rotation
      }, {
        scale: symbolMeta.symbolScale.slice()
      }, symbolMeta, isUpdate);
      mainPath.on("mouseover", onMouseOver).on("mouseout", onMouseOut);
    } else {
      updateAttr(mainPath, null, {
        position: symbolMeta.pathPosition.slice(),
        scale: symbolMeta.symbolScale.slice(),
        rotation: symbolMeta.rotation
      }, symbolMeta, isUpdate);
    }
    updateHoverAnimation(mainPath, symbolMeta);
    function onMouseOver() {
      this.trigger("emphasis");
    }
    function onMouseOut() {
      this.trigger("normal");
    }
  }
  function createOrUpdateBarRect(bar2, symbolMeta, isUpdate) {
    var rectShape = zrUtil2.extend({}, symbolMeta.barRectShape);
    var barRect = bar2.__pictorialBarRect;
    if (!barRect) {
      barRect = bar2.__pictorialBarRect = new graphic2.Rect({
        z2: 2,
        shape: rectShape,
        silent: true,
        style: {
          stroke: "transparent",
          fill: "transparent",
          lineWidth: 0
        }
      });
      bar2.add(barRect);
    } else {
      updateAttr(barRect, null, {
        shape: rectShape
      }, symbolMeta, isUpdate);
    }
  }
  function createOrUpdateClip(bar2, opt, symbolMeta, isUpdate) {
    if (symbolMeta.symbolClip) {
      var clipPath = bar2.__pictorialClipPath;
      var clipShape = zrUtil2.extend({}, symbolMeta.clipShape);
      var valueDim = opt.valueDim;
      var animationModel = symbolMeta.animationModel;
      var dataIndex = symbolMeta.dataIndex;
      if (clipPath) {
        graphic2.updateProps(clipPath, {
          shape: clipShape
        }, animationModel, dataIndex);
      } else {
        clipShape[valueDim.wh] = 0;
        clipPath = new graphic2.Rect({
          shape: clipShape
        });
        bar2.__pictorialBundle.setClipPath(clipPath);
        bar2.__pictorialClipPath = clipPath;
        var target = {};
        target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
        graphic2[isUpdate ? "updateProps" : "initProps"](clipPath, {
          shape: target
        }, animationModel, dataIndex);
      }
    }
  }
  function getItemModel(data, dataIndex) {
    var itemModel = data.getItemModel(dataIndex);
    itemModel.getAnimationDelayParams = getAnimationDelayParams;
    itemModel.isAnimationEnabled = isAnimationEnabled;
    return itemModel;
  }
  function getAnimationDelayParams(path2) {
    return {
      index: path2.__pictorialAnimationIndex,
      count: path2.__pictorialRepeatTimes
    };
  }
  function isAnimationEnabled() {
    return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
  }
  function updateHoverAnimation(path2, symbolMeta) {
    path2.off("emphasis").off("normal");
    var scale = symbolMeta.symbolScale.slice();
    symbolMeta.hoverAnimation && path2.on("emphasis", function() {
      this.animateTo({
        scale: [scale[0] * 1.1, scale[1] * 1.1]
      }, 400, "elasticOut");
    }).on("normal", function() {
      this.animateTo({
        scale: scale.slice()
      }, 400, "elasticOut");
    });
  }
  function createBar(data, opt, symbolMeta, isUpdate) {
    var bar2 = new graphic2.Group();
    var bundle = new graphic2.Group();
    bar2.add(bundle);
    bar2.__pictorialBundle = bundle;
    bundle.attr("position", symbolMeta.bundlePosition.slice());
    if (symbolMeta.symbolRepeat) {
      createOrUpdateRepeatSymbols(bar2, opt, symbolMeta);
    } else {
      createOrUpdateSingleSymbol(bar2, opt, symbolMeta);
    }
    createOrUpdateBarRect(bar2, symbolMeta, isUpdate);
    createOrUpdateClip(bar2, opt, symbolMeta, isUpdate);
    bar2.__pictorialShapeStr = getShapeStr(data, symbolMeta);
    bar2.__pictorialSymbolMeta = symbolMeta;
    return bar2;
  }
  function updateBar(bar2, opt, symbolMeta) {
    var animationModel = symbolMeta.animationModel;
    var dataIndex = symbolMeta.dataIndex;
    var bundle = bar2.__pictorialBundle;
    graphic2.updateProps(bundle, {
      position: symbolMeta.bundlePosition.slice()
    }, animationModel, dataIndex);
    if (symbolMeta.symbolRepeat) {
      createOrUpdateRepeatSymbols(bar2, opt, symbolMeta, true);
    } else {
      createOrUpdateSingleSymbol(bar2, opt, symbolMeta, true);
    }
    createOrUpdateBarRect(bar2, symbolMeta, true);
    createOrUpdateClip(bar2, opt, symbolMeta, true);
  }
  function removeBar(data, dataIndex, animationModel, bar2) {
    var labelRect = bar2.__pictorialBarRect;
    labelRect && (labelRect.style.text = null);
    var pathes = [];
    eachPath(bar2, function(path2) {
      pathes.push(path2);
    });
    bar2.__pictorialMainPath && pathes.push(bar2.__pictorialMainPath);
    bar2.__pictorialClipPath && (animationModel = null);
    zrUtil2.each(pathes, function(path2) {
      graphic2.updateProps(path2, {
        scale: [0, 0]
      }, animationModel, dataIndex, function() {
        bar2.parent && bar2.parent.remove(bar2);
      });
    });
    data.setItemGraphicEl(dataIndex, null);
  }
  function getShapeStr(data, symbolMeta) {
    return [data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none", !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(":");
  }
  function eachPath(bar2, cb, context) {
    zrUtil2.each(bar2.__pictorialBundle.children(), function(el) {
      el !== bar2.__pictorialBarRect && cb.call(context, el);
    });
  }
  function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
    immediateAttrs && el.attr(immediateAttrs);
    if (symbolMeta.symbolClip && !isUpdate) {
      animationAttrs && el.attr(animationAttrs);
    } else {
      animationAttrs && graphic2[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
    }
  }
  function updateCommon(bar2, opt, symbolMeta) {
    var color2 = symbolMeta.color;
    var dataIndex = symbolMeta.dataIndex;
    var itemModel = symbolMeta.itemModel;
    var normalStyle = itemModel.getModel("itemStyle").getItemStyle(["color"]);
    var hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
    var cursorStyle = itemModel.getShallow("cursor");
    eachPath(bar2, function(path2) {
      path2.setColor(color2);
      path2.setStyle(zrUtil2.defaults({
        fill: color2,
        opacity: symbolMeta.opacity
      }, normalStyle));
      graphic2.setHoverStyle(path2, hoverStyle);
      cursorStyle && (path2.cursor = cursorStyle);
      path2.z2 = symbolMeta.z2;
    });
    var barRectHoverStyle = {};
    var barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
    var barRect = bar2.__pictorialBarRect;
    setLabel(barRect.style, barRectHoverStyle, itemModel, color2, opt.seriesModel, dataIndex, barPositionOutside);
    graphic2.setHoverStyle(barRect, barRectHoverStyle);
  }
  function toIntTimes(times) {
    var roundedTimes = Math.round(times);
    return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
  }
  var _default2 = BarView2;
  PictorialBarView = _default2;
  return PictorialBarView;
}
var hasRequiredPictorialBar;
function requirePictorialBar() {
  if (hasRequiredPictorialBar)
    return pictorialBar;
  hasRequiredPictorialBar = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  requireGrid$1();
  requirePictorialBarSeries();
  requirePictorialBarView();
  var _barGrid = requireBarGrid();
  var layout2 = _barGrid.layout;
  var visualSymbol = requireSymbol();
  requireGridSimple();
  echarts$12.registerLayout(zrUtil2.curry(layout2, "pictorialBar"));
  echarts$12.registerVisual(visualSymbol("pictorialBar", "roundRect"));
  return pictorialBar;
}
var themeRiver = {};
var singleAxis = {};
var singleCreator = {};
var SingleAxis_1;
var hasRequiredSingleAxis$1;
function requireSingleAxis$1() {
  if (hasRequiredSingleAxis$1)
    return SingleAxis_1;
  hasRequiredSingleAxis$1 = 1;
  var zrUtil2 = util$6;
  var Axis = requireAxis$1();
  var SingleAxis = function(dim, scale, coordExtent, axisType, position) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || "value";
    this.position = position || "bottom";
    this.orient = null;
  };
  SingleAxis.prototype = {
    constructor: SingleAxis,
    /**
     * Axis model
     * @type {module:echarts/coord/single/AxisModel}
     */
    model: null,
    /**
     * Judge the orient of the axis.
     * @return {boolean}
     */
    isHorizontal: function() {
      var position = this.position;
      return position === "top" || position === "bottom";
    },
    /**
     * @override
     */
    pointToData: function(point, clamp) {
      return this.coordinateSystem.pointToData(point, clamp)[0];
    },
    /**
     * Convert the local coord(processed by dataToCoord())
     * to global coord(concrete pixel coord).
     * designated by module:echarts/coord/single/Single.
     * @type {Function}
     */
    toGlobalCoord: null,
    /**
     * Convert the global coord to local coord.
     * designated by module:echarts/coord/single/Single.
     * @type {Function}
     */
    toLocalCoord: null
  };
  zrUtil2.inherits(SingleAxis, Axis);
  var _default2 = SingleAxis;
  SingleAxis_1 = _default2;
  return SingleAxis_1;
}
var Single_1;
var hasRequiredSingle;
function requireSingle() {
  if (hasRequiredSingle)
    return Single_1;
  hasRequiredSingle = 1;
  var SingleAxis = requireSingleAxis$1();
  var axisHelper2 = requireAxisHelper();
  var _layout2 = layout$1;
  var getLayoutRect2 = _layout2.getLayoutRect;
  var _util2 = util$6;
  var each2 = _util2.each;
  function Single(axisModel, ecModel, api) {
    this.dimension = "single";
    this.dimensions = ["single"];
    this._axis = null;
    this._rect;
    this._init(axisModel, ecModel, api);
    this.model = axisModel;
  }
  Single.prototype = {
    type: "singleAxis",
    axisPointerEnabled: true,
    constructor: Single,
    /**
     * Initialize single coordinate system.
     *
     * @param  {module:echarts/coord/single/AxisModel} axisModel
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     * @private
     */
    _init: function(axisModel, ecModel, api) {
      var dim = this.dimension;
      var axis2 = new SingleAxis(dim, axisHelper2.createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
      var isCategory = axis2.type === "category";
      axis2.onBand = isCategory && axisModel.get("boundaryGap");
      axis2.inverse = axisModel.get("inverse");
      axis2.orient = axisModel.get("orient");
      axisModel.axis = axis2;
      axis2.model = axisModel;
      axis2.coordinateSystem = this;
      this._axis = axis2;
    },
    /**
     * Update axis scale after data processed
     * @param  {module:echarts/model/Global} ecModel
     * @param  {module:echarts/ExtensionAPI} api
     */
    update: function(ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.coordinateSystem === this) {
          var data = seriesModel.getData();
          each2(data.mapDimension(this.dimension, true), function(dim) {
            this._axis.scale.unionExtentFromData(data, dim);
          }, this);
          axisHelper2.niceScaleExtent(this._axis.scale, this._axis.model);
        }
      }, this);
    },
    /**
     * Resize the single coordinate system.
     *
     * @param  {module:echarts/coord/single/AxisModel} axisModel
     * @param  {module:echarts/ExtensionAPI} api
     */
    resize: function(axisModel, api) {
      this._rect = getLayoutRect2({
        left: axisModel.get("left"),
        top: axisModel.get("top"),
        right: axisModel.get("right"),
        bottom: axisModel.get("bottom"),
        width: axisModel.get("width"),
        height: axisModel.get("height")
      }, {
        width: api.getWidth(),
        height: api.getHeight()
      });
      this._adjustAxis();
    },
    /**
     * @return {module:zrender/core/BoundingRect}
     */
    getRect: function() {
      return this._rect;
    },
    /**
     * @private
     */
    _adjustAxis: function() {
      var rect = this._rect;
      var axis2 = this._axis;
      var isHorizontal = axis2.isHorizontal();
      var extent = isHorizontal ? [0, rect.width] : [0, rect.height];
      var idx = axis2.reverse ? 1 : 0;
      axis2.setExtent(extent[idx], extent[1 - idx]);
      this._updateAxisTransform(axis2, isHorizontal ? rect.x : rect.y);
    },
    /**
     * @param  {module:echarts/coord/single/SingleAxis} axis
     * @param  {number} coordBase
     */
    _updateAxisTransform: function(axis2, coordBase) {
      var axisExtent = axis2.getExtent();
      var extentSum = axisExtent[0] + axisExtent[1];
      var isHorizontal = axis2.isHorizontal();
      axis2.toGlobalCoord = isHorizontal ? function(coord) {
        return coord + coordBase;
      } : function(coord) {
        return extentSum - coord + coordBase;
      };
      axis2.toLocalCoord = isHorizontal ? function(coord) {
        return coord - coordBase;
      } : function(coord) {
        return extentSum - coord + coordBase;
      };
    },
    /**
     * Get axis.
     *
     * @return {module:echarts/coord/single/SingleAxis}
     */
    getAxis: function() {
      return this._axis;
    },
    /**
     * Get axis, add it just for draw tooltip.
     *
     * @return {[type]} [description]
     */
    getBaseAxis: function() {
      return this._axis;
    },
    /**
     * @return {Array.<module:echarts/coord/Axis>}
     */
    getAxes: function() {
      return [this._axis];
    },
    /**
     * @return {Object} {baseAxes: [], otherAxes: []}
     */
    getTooltipAxes: function() {
      return {
        baseAxes: [this.getAxis()]
      };
    },
    /**
     * If contain point.
     *
     * @param  {Array.<number>} point
     * @return {boolean}
     */
    containPoint: function(point) {
      var rect = this.getRect();
      var axis2 = this.getAxis();
      var orient = axis2.orient;
      if (orient === "horizontal") {
        return axis2.contain(axis2.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height;
      } else {
        return axis2.contain(axis2.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height;
      }
    },
    /**
     * @param {Array.<number>} point
     * @return {Array.<number>}
     */
    pointToData: function(point) {
      var axis2 = this.getAxis();
      return [axis2.coordToData(axis2.toLocalCoord(point[axis2.orient === "horizontal" ? 0 : 1]))];
    },
    /**
     * Convert the series data to concrete point.
     *
     * @param  {number|Array.<number>} val
     * @return {Array.<number>}
     */
    dataToPoint: function(val) {
      var axis2 = this.getAxis();
      var rect = this.getRect();
      var pt = [];
      var idx = axis2.orient === "horizontal" ? 0 : 1;
      if (val instanceof Array) {
        val = val[0];
      }
      pt[idx] = axis2.toGlobalCoord(axis2.dataToCoord(+val));
      pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
      return pt;
    }
  };
  var _default2 = Single;
  Single_1 = _default2;
  return Single_1;
}
var hasRequiredSingleCreator;
function requireSingleCreator() {
  if (hasRequiredSingleCreator)
    return singleCreator;
  hasRequiredSingleCreator = 1;
  var Single = requireSingle();
  var CoordinateSystem$1 = CoordinateSystem;
  function create(ecModel, api) {
    var singles = [];
    ecModel.eachComponent("singleAxis", function(axisModel, idx) {
      var single = new Single(axisModel, ecModel, api);
      single.name = "single_" + idx;
      single.resize(axisModel, api);
      axisModel.coordinateSystem = single;
      singles.push(single);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "singleAxis") {
        var singleAxisModel = ecModel.queryComponents({
          mainType: "singleAxis",
          index: seriesModel.get("singleAxisIndex"),
          id: seriesModel.get("singleAxisId")
        })[0];
        seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
      }
    });
    return singles;
  }
  CoordinateSystem$1.register("single", {
    create,
    dimensions: Single.prototype.dimensions
  });
  return singleCreator;
}
var singleAxisHelper = {};
var hasRequiredSingleAxisHelper;
function requireSingleAxisHelper() {
  if (hasRequiredSingleAxisHelper)
    return singleAxisHelper;
  hasRequiredSingleAxisHelper = 1;
  var zrUtil2 = util$6;
  function layout2(axisModel, opt) {
    opt = opt || {};
    var single = axisModel.coordinateSystem;
    var axis2 = axisModel.axis;
    var layout3 = {};
    var axisPosition = axis2.position;
    var orient = axis2.orient;
    var rect = single.getRect();
    var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
    var positionMap = {
      horizontal: {
        top: rectBound[2],
        bottom: rectBound[3]
      },
      vertical: {
        left: rectBound[0],
        right: rectBound[1]
      }
    };
    layout3.position = [orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0], orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]];
    var r = {
      horizontal: 0,
      vertical: 1
    };
    layout3.rotation = Math.PI / 2 * r[orient];
    var directionMap = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    };
    layout3.labelDirection = layout3.tickDirection = layout3.nameDirection = directionMap[axisPosition];
    if (axisModel.get("axisTick.inside")) {
      layout3.tickDirection = -layout3.tickDirection;
    }
    if (zrUtil2.retrieve(opt.labelInside, axisModel.get("axisLabel.inside"))) {
      layout3.labelDirection = -layout3.labelDirection;
    }
    var labelRotation = opt.rotate;
    labelRotation == null && (labelRotation = axisModel.get("axisLabel.rotate"));
    layout3.labelRotation = axisPosition === "top" ? -labelRotation : labelRotation;
    layout3.z2 = 1;
    return layout3;
  }
  singleAxisHelper.layout = layout2;
  return singleAxisHelper;
}
var SingleAxisView_1;
var hasRequiredSingleAxisView;
function requireSingleAxisView() {
  if (hasRequiredSingleAxisView)
    return SingleAxisView_1;
  hasRequiredSingleAxisView = 1;
  var zrUtil2 = util$6;
  var AxisBuilder = requireAxisBuilder();
  var graphic2 = graphic$4;
  var singleAxisHelper2 = requireSingleAxisHelper();
  var AxisView = requireAxisView();
  var _axisSplitHelper = requireAxisSplitHelper();
  var rectCoordAxisBuildSplitArea = _axisSplitHelper.rectCoordAxisBuildSplitArea;
  var rectCoordAxisHandleRemove = _axisSplitHelper.rectCoordAxisHandleRemove;
  var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
  var selfBuilderAttrs = ["splitArea", "splitLine"];
  var SingleAxisView = AxisView.extend({
    type: "singleAxis",
    axisPointerClass: "SingleAxisPointer",
    render: function(axisModel, ecModel, api, payload) {
      var group = this.group;
      group.removeAll();
      var oldAxisGroup = this._axisGroup;
      this._axisGroup = new graphic2.Group();
      var layout2 = singleAxisHelper2.layout(axisModel);
      var axisBuilder = new AxisBuilder(axisModel, layout2);
      zrUtil2.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      group.add(this._axisGroup);
      group.add(axisBuilder.getGroup());
      zrUtil2.each(selfBuilderAttrs, function(name2) {
        if (axisModel.get(name2 + ".show")) {
          this["_" + name2](axisModel);
        }
      }, this);
      graphic2.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
      SingleAxisView.superCall(this, "render", axisModel, ecModel, api, payload);
    },
    remove: function() {
      rectCoordAxisHandleRemove(this);
    },
    _splitLine: function(axisModel) {
      var axis2 = axisModel.axis;
      if (axis2.scale.isBlank()) {
        return;
      }
      var splitLineModel = axisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineWidth = lineStyleModel.get("width");
      var lineColors = lineStyleModel.get("color");
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var gridRect = axisModel.coordinateSystem.getRect();
      var isHorizontal = axis2.isHorizontal();
      var splitLines = [];
      var lineCount = 0;
      var ticksCoords = axis2.getTicksCoords({
        tickModel: splitLineModel
      });
      var p1 = [];
      var p2 = [];
      for (var i = 0; i < ticksCoords.length; ++i) {
        var tickCoord = axis2.toGlobalCoord(ticksCoords[i].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        var colorIndex = lineCount++ % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new graphic2.Line({
          subPixelOptimize: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: {
            lineWidth
          },
          silent: true
        }));
      }
      for (var i = 0; i < splitLines.length; ++i) {
        this.group.add(graphic2.mergePath(splitLines[i], {
          style: {
            stroke: lineColors[i % lineColors.length],
            lineDash: lineStyleModel.getLineDash(lineWidth),
            lineWidth
          },
          silent: true
        }));
      }
    },
    _splitArea: function(axisModel) {
      rectCoordAxisBuildSplitArea(this, this._axisGroup, axisModel, axisModel);
    }
  });
  var _default2 = SingleAxisView;
  SingleAxisView_1 = _default2;
  return SingleAxisView_1;
}
var AxisModel_1;
var hasRequiredAxisModel$1;
function requireAxisModel$1() {
  if (hasRequiredAxisModel$1)
    return AxisModel_1;
  hasRequiredAxisModel$1 = 1;
  var zrUtil2 = util$6;
  var ComponentModel2 = Component$2;
  var axisModelCreator2 = requireAxisModelCreator();
  var axisModelCommonMixin2 = requireAxisModelCommonMixin();
  var AxisModel2 = ComponentModel2.extend({
    type: "singleAxis",
    layoutMode: "box",
    /**
     * @type {module:echarts/coord/single/SingleAxis}
     */
    axis: null,
    /**
     * @type {module:echarts/coord/single/Single}
     */
    coordinateSystem: null,
    /**
     * @override
     */
    getCoordSysModel: function() {
      return this;
    }
  });
  var defaultOption = {
    left: "5%",
    top: "5%",
    right: "5%",
    bottom: "5%",
    type: "value",
    position: "bottom",
    orient: "horizontal",
    axisLine: {
      show: true,
      lineStyle: {
        width: 1,
        type: "solid"
      }
    },
    // Single coordinate system and single axis is the,
    // which is used as the parent tooltip model.
    // same model, so we set default tooltip show as true.
    tooltip: {
      show: true
    },
    axisTick: {
      show: true,
      length: 6,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      interval: "auto"
    },
    splitLine: {
      show: true,
      lineStyle: {
        type: "dashed",
        opacity: 0.2
      }
    }
  };
  function getAxisType(axisName, option) {
    return option.type || (option.data ? "category" : "value");
  }
  zrUtil2.merge(AxisModel2.prototype, axisModelCommonMixin2);
  axisModelCreator2("single", AxisModel2, getAxisType, defaultOption);
  var _default2 = AxisModel2;
  AxisModel_1 = _default2;
  return AxisModel_1;
}
var axisPointer = {};
var findPointFromSeries;
var hasRequiredFindPointFromSeries;
function requireFindPointFromSeries() {
  if (hasRequiredFindPointFromSeries)
    return findPointFromSeries;
  hasRequiredFindPointFromSeries = 1;
  var zrUtil2 = util$6;
  var modelUtil2 = model;
  function _default2(finder, ecModel) {
    var point = [];
    var seriesIndex = finder.seriesIndex;
    var seriesModel;
    if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
      return {
        point: []
      };
    }
    var data = seriesModel.getData();
    var dataIndex = modelUtil2.queryDataIndex(data, finder);
    if (dataIndex == null || dataIndex < 0 || zrUtil2.isArray(dataIndex)) {
      return {
        point: []
      };
    }
    var el = data.getItemGraphicEl(dataIndex);
    var coordSys = seriesModel.coordinateSystem;
    if (seriesModel.getTooltipPosition) {
      point = seriesModel.getTooltipPosition(dataIndex) || [];
    } else if (coordSys && coordSys.dataToPoint) {
      point = coordSys.dataToPoint(data.getValues(zrUtil2.map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex, true)) || [];
    } else if (el) {
      var rect = el.getBoundingRect().clone();
      rect.applyTransform(el.transform);
      point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
    }
    return {
      point,
      el
    };
  }
  findPointFromSeries = _default2;
  return findPointFromSeries;
}
var axisTrigger;
var hasRequiredAxisTrigger;
function requireAxisTrigger() {
  if (hasRequiredAxisTrigger)
    return axisTrigger;
  hasRequiredAxisTrigger = 1;
  var zrUtil2 = util$6;
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var modelHelper2 = requireModelHelper();
  var findPointFromSeries2 = requireFindPointFromSeries();
  var each2 = zrUtil2.each;
  var curry2 = zrUtil2.curry;
  var inner2 = makeInner2();
  function _default2(payload, ecModel, api) {
    var currTrigger = payload.currTrigger;
    var point = [payload.x, payload.y];
    var finder = payload;
    var dispatchAction = payload.dispatchAction || zrUtil2.bind(api.dispatchAction, api);
    var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (!coordSysAxesInfo) {
      return;
    }
    if (illegalPoint(point)) {
      point = findPointFromSeries2({
        seriesIndex: finder.seriesIndex,
        // Do not use dataIndexInside from other ec instance.
        // FIXME: auto detect it?
        dataIndex: finder.dataIndex
      }, ecModel).point;
    }
    var isIllegalPoint = illegalPoint(point);
    var inputAxesInfo = finder.axesInfo;
    var axesInfo = coordSysAxesInfo.axesInfo;
    var shouldHide = currTrigger === "leave" || illegalPoint(point);
    var outputFinder = {};
    var showValueMap = {};
    var dataByCoordSys = {
      list: [],
      map: {}
    };
    var updaters = {
      showPointer: curry2(showPointer, showValueMap),
      showTooltip: curry2(showTooltip, dataByCoordSys)
    };
    each2(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
      var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
      each2(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
        var axis2 = axisInfo.axis;
        var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
        if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
          var val = inputAxisInfo && inputAxisInfo.value;
          if (val == null && !isIllegalPoint) {
            val = axis2.pointToData(point);
          }
          val != null && processOnAxis(axisInfo, val, updaters, false, outputFinder);
        }
      });
    });
    var linkTriggers = {};
    each2(axesInfo, function(tarAxisInfo, tarKey) {
      var linkGroup = tarAxisInfo.linkGroup;
      if (linkGroup && !showValueMap[tarKey]) {
        each2(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
          var srcValItem = showValueMap[srcKey];
          if (srcAxisInfo !== tarAxisInfo && srcValItem) {
            var val = srcValItem.value;
            linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
            linkTriggers[tarAxisInfo.key] = val;
          }
        });
      }
    });
    each2(linkTriggers, function(val, tarKey) {
      processOnAxis(axesInfo[tarKey], val, updaters, true, outputFinder);
    });
    updateModelActually(showValueMap, axesInfo, outputFinder);
    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
    dispatchHighDownActually(axesInfo, dispatchAction, api);
    return outputFinder;
  }
  function processOnAxis(axisInfo, newValue, updaters, dontSnap, outputFinder) {
    var axis2 = axisInfo.axis;
    if (axis2.scale.isBlank() || !axis2.containData(newValue)) {
      return;
    }
    if (!axisInfo.involveSeries) {
      updaters.showPointer(axisInfo, newValue);
      return;
    }
    var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
    var payloadBatch = payloadInfo.payloadBatch;
    var snapToValue = payloadInfo.snapToValue;
    if (payloadBatch[0] && outputFinder.seriesIndex == null) {
      zrUtil2.extend(outputFinder, payloadBatch[0]);
    }
    if (!dontSnap && axisInfo.snap) {
      if (axis2.containData(snapToValue) && snapToValue != null) {
        newValue = snapToValue;
      }
    }
    updaters.showPointer(axisInfo, newValue, payloadBatch, outputFinder);
    updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
  }
  function buildPayloadsBySeries(value, axisInfo) {
    var axis2 = axisInfo.axis;
    var dim = axis2.dim;
    var snapToValue = value;
    var payloadBatch = [];
    var minDist = Number.MAX_VALUE;
    var minDiff = -1;
    each2(axisInfo.seriesModels, function(series, idx) {
      var dataDim = series.getData().mapDimension(dim, true);
      var seriesNestestValue;
      var dataIndices;
      if (series.getAxisTooltipData) {
        var result = series.getAxisTooltipData(dataDim, value, axis2);
        dataIndices = result.dataIndices;
        seriesNestestValue = result.nestestValue;
      } else {
        dataIndices = series.getData().indicesOfNearest(
          dataDim[0],
          value,
          // Add a threshold to avoid find the wrong dataIndex
          // when data length is not same.
          // false,
          axis2.type === "category" ? 0.5 : null
        );
        if (!dataIndices.length) {
          return;
        }
        seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
      }
      if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
        return;
      }
      var diff2 = value - seriesNestestValue;
      var dist2 = Math.abs(diff2);
      if (dist2 <= minDist) {
        if (dist2 < minDist || diff2 >= 0 && minDiff < 0) {
          minDist = dist2;
          minDiff = diff2;
          snapToValue = seriesNestestValue;
          payloadBatch.length = 0;
        }
        each2(dataIndices, function(dataIndex) {
          payloadBatch.push({
            seriesIndex: series.seriesIndex,
            dataIndexInside: dataIndex,
            dataIndex: series.getData().getRawIndex(dataIndex)
          });
        });
      }
    });
    return {
      payloadBatch,
      snapToValue
    };
  }
  function showPointer(showValueMap, axisInfo, value, payloadBatch) {
    showValueMap[axisInfo.key] = {
      value,
      payloadBatch
    };
  }
  function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
    var payloadBatch = payloadInfo.payloadBatch;
    var axis2 = axisInfo.axis;
    var axisModel = axis2.model;
    var axisPointerModel = axisInfo.axisPointerModel;
    if (!axisInfo.triggerTooltip || !payloadBatch.length) {
      return;
    }
    var coordSysModel = axisInfo.coordSys.model;
    var coordSysKey = modelHelper2.makeKey(coordSysModel);
    var coordSysItem = dataByCoordSys.map[coordSysKey];
    if (!coordSysItem) {
      coordSysItem = dataByCoordSys.map[coordSysKey] = {
        coordSysId: coordSysModel.id,
        coordSysIndex: coordSysModel.componentIndex,
        coordSysType: coordSysModel.type,
        coordSysMainType: coordSysModel.mainType,
        dataByAxis: []
      };
      dataByCoordSys.list.push(coordSysItem);
    }
    coordSysItem.dataByAxis.push({
      axisDim: axis2.dim,
      axisIndex: axisModel.componentIndex,
      axisType: axisModel.type,
      axisId: axisModel.id,
      value,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: axisPointerModel.get("label.precision"),
        formatter: axisPointerModel.get("label.formatter")
      },
      seriesDataIndices: payloadBatch.slice()
    });
  }
  function updateModelActually(showValueMap, axesInfo, outputFinder) {
    var outputAxesInfo = outputFinder.axesInfo = [];
    each2(axesInfo, function(axisInfo, key) {
      var option = axisInfo.axisPointerModel.option;
      var valItem = showValueMap[key];
      if (valItem) {
        !axisInfo.useHandle && (option.status = "show");
        option.value = valItem.value;
        option.seriesDataIndices = (valItem.payloadBatch || []).slice();
      } else {
        !axisInfo.useHandle && (option.status = "hide");
      }
      option.status === "show" && outputAxesInfo.push({
        axisDim: axisInfo.axis.dim,
        axisIndex: axisInfo.axis.model.componentIndex,
        value: option.value
      });
    });
  }
  function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
    if (illegalPoint(point) || !dataByCoordSys.list.length) {
      dispatchAction({
        type: "hideTip"
      });
      return;
    }
    var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
    dispatchAction({
      type: "showTip",
      escapeConnect: true,
      x: point[0],
      y: point[1],
      tooltipOption: payload.tooltipOption,
      position: payload.position,
      dataIndexInside: sampleItem.dataIndexInside,
      dataIndex: sampleItem.dataIndex,
      seriesIndex: sampleItem.seriesIndex,
      dataByCoordSys: dataByCoordSys.list
    });
  }
  function dispatchHighDownActually(axesInfo, dispatchAction, api) {
    var zr = api.getZr();
    var highDownKey = "axisPointerLastHighlights";
    var lastHighlights = inner2(zr)[highDownKey] || {};
    var newHighlights = inner2(zr)[highDownKey] = {};
    each2(axesInfo, function(axisInfo, key) {
      var option = axisInfo.axisPointerModel.option;
      option.status === "show" && each2(option.seriesDataIndices, function(batchItem) {
        var key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
        newHighlights[key2] = batchItem;
      });
    });
    var toHighlight = [];
    var toDownplay = [];
    zrUtil2.each(lastHighlights, function(batchItem, key) {
      !newHighlights[key] && toDownplay.push(batchItem);
    });
    zrUtil2.each(newHighlights, function(batchItem, key) {
      !lastHighlights[key] && toHighlight.push(batchItem);
    });
    toDownplay.length && api.dispatchAction({
      type: "downplay",
      escapeConnect: true,
      batch: toDownplay
    });
    toHighlight.length && api.dispatchAction({
      type: "highlight",
      escapeConnect: true,
      batch: toHighlight
    });
  }
  function findInputAxisInfo(inputAxesInfo, axisInfo) {
    for (var i = 0; i < (inputAxesInfo || []).length; i++) {
      var inputAxisInfo = inputAxesInfo[i];
      if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
        return inputAxisInfo;
      }
    }
  }
  function makeMapperParam(axisInfo) {
    var axisModel = axisInfo.axis.model;
    var item = {};
    var dim = item.axisDim = axisInfo.axis.dim;
    item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
    item.axisName = item[dim + "AxisName"] = axisModel.name;
    item.axisId = item[dim + "AxisId"] = axisModel.id;
    return item;
  }
  function illegalPoint(point) {
    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
  }
  axisTrigger = _default2;
  return axisTrigger;
}
var AxisPointerModel_1;
var hasRequiredAxisPointerModel;
function requireAxisPointerModel() {
  if (hasRequiredAxisPointerModel)
    return AxisPointerModel_1;
  hasRequiredAxisPointerModel = 1;
  var echarts$12 = echarts;
  var AxisPointerModel = echarts$12.extendComponentModel({
    type: "axisPointer",
    coordSysAxesInfo: null,
    defaultOption: {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // 'click' | 'mousemove' | 'none'
      triggerOn: null,
      // set default in AxisPonterView.js
      zlevel: 0,
      z: 50,
      type: "line",
      // 'line' 'shadow' 'cross' 'none'.
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: false,
      triggerTooltip: true,
      value: null,
      status: null,
      // Init value depends on whether handle is used.
      // [group0, group1, ...]
      // Each group can be: {
      //      mapper: function () {},
      //      singleTooltip: 'multiple',  // 'multiple' or 'single'
      //      xAxisId: ...,
      //      yAxisName: ...,
      //      angleAxisIndex: ...
      // }
      // mapper: can be ignored.
      //      input: {axisInfo, value}
      //      output: {axisInfo, value}
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#aaa",
        width: 1,
        type: "solid"
      },
      shadowStyle: {
        color: "rgba(150,150,150,0.3)"
      },
      label: {
        show: true,
        formatter: null,
        // string | Function
        precision: "auto",
        // Or a number like 0, 1, 2 ...
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        // default: axis line color
        borderColor: null,
        borderWidth: 0,
        shadowBlur: 3,
        shadowColor: "#aaa"
        // Considering applicability, common style should
        // better not have shadowOffset.
        // shadowOffsetX: 0,
        // shadowOffsetY: 2
      },
      handle: {
        show: false,
        /* eslint-disable */
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        // jshint ignore:line
        /* eslint-enable */
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }
  });
  var _default2 = AxisPointerModel;
  AxisPointerModel_1 = _default2;
  return AxisPointerModel_1;
}
var globalListener = {};
var hasRequiredGlobalListener;
function requireGlobalListener() {
  if (hasRequiredGlobalListener)
    return globalListener;
  hasRequiredGlobalListener = 1;
  var zrUtil2 = util$6;
  var env2 = env_1;
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var inner2 = makeInner2();
  var each2 = zrUtil2.each;
  function register(key, api, handler) {
    if (env2.node) {
      return;
    }
    var zr = api.getZr();
    inner2(zr).records || (inner2(zr).records = {});
    initGlobalListeners(zr, api);
    var record = inner2(zr).records[key] || (inner2(zr).records[key] = {});
    record.handler = handler;
  }
  function initGlobalListeners(zr, api) {
    if (inner2(zr).initialized) {
      return;
    }
    inner2(zr).initialized = true;
    useHandler("click", zrUtil2.curry(doEnter, "click"));
    useHandler("mousemove", zrUtil2.curry(doEnter, "mousemove"));
    useHandler("globalout", onLeave);
    function useHandler(eventType, cb) {
      zr.on(eventType, function(e2) {
        var dis = makeDispatchAction(api);
        each2(inner2(zr).records, function(record) {
          record && cb(record, e2, dis.dispatchAction);
        });
        dispatchTooltipFinally(dis.pendings, api);
      });
    }
  }
  function dispatchTooltipFinally(pendings, api) {
    var showLen = pendings.showTip.length;
    var hideLen = pendings.hideTip.length;
    var actuallyPayload;
    if (showLen) {
      actuallyPayload = pendings.showTip[showLen - 1];
    } else if (hideLen) {
      actuallyPayload = pendings.hideTip[hideLen - 1];
    }
    if (actuallyPayload) {
      actuallyPayload.dispatchAction = null;
      api.dispatchAction(actuallyPayload);
    }
  }
  function onLeave(record, e2, dispatchAction) {
    record.handler("leave", null, dispatchAction);
  }
  function doEnter(currTrigger, record, e2, dispatchAction) {
    record.handler(currTrigger, e2, dispatchAction);
  }
  function makeDispatchAction(api) {
    var pendings = {
      showTip: [],
      hideTip: []
    };
    var dispatchAction = function(payload) {
      var pendingList = pendings[payload.type];
      if (pendingList) {
        pendingList.push(payload);
      } else {
        payload.dispatchAction = dispatchAction;
        api.dispatchAction(payload);
      }
    };
    return {
      dispatchAction,
      pendings
    };
  }
  function unregister(key, api) {
    if (env2.node) {
      return;
    }
    var zr = api.getZr();
    var record = (inner2(zr).records || {})[key];
    if (record) {
      inner2(zr).records[key] = null;
    }
  }
  globalListener.register = register;
  globalListener.unregister = unregister;
  return globalListener;
}
var AxisPointerView_1;
var hasRequiredAxisPointerView;
function requireAxisPointerView() {
  if (hasRequiredAxisPointerView)
    return AxisPointerView_1;
  hasRequiredAxisPointerView = 1;
  var echarts$12 = echarts;
  var globalListener2 = requireGlobalListener();
  var AxisPointerView = echarts$12.extendComponentView({
    type: "axisPointer",
    render: function(globalAxisPointerModel, ecModel, api) {
      var globalTooltipModel = ecModel.getComponent("tooltip");
      var triggerOn = globalAxisPointerModel.get("triggerOn") || globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click";
      globalListener2.register("axisPointer", api, function(currTrigger, e2, dispatchAction) {
        if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
          dispatchAction({
            type: "updateAxisPointer",
            currTrigger,
            x: e2 && e2.offsetX,
            y: e2 && e2.offsetY
          });
        }
      });
    },
    /**
     * @override
     */
    remove: function(ecModel, api) {
      globalListener2.unregister(api.getZr(), "axisPointer");
      AxisPointerView.superApply(this._model, "remove", arguments);
    },
    /**
     * @override
     */
    dispose: function(ecModel, api) {
      globalListener2.unregister("axisPointer", api);
      AxisPointerView.superApply(this._model, "dispose", arguments);
    }
  });
  var _default2 = AxisPointerView;
  AxisPointerView_1 = _default2;
  return AxisPointerView_1;
}
var BaseAxisPointer_1;
var hasRequiredBaseAxisPointer;
function requireBaseAxisPointer() {
  if (hasRequiredBaseAxisPointer)
    return BaseAxisPointer_1;
  hasRequiredBaseAxisPointer = 1;
  var zrUtil2 = util$6;
  var clazzUtil2 = clazz;
  var graphic2 = graphic$4;
  var axisPointerModelHelper = requireModelHelper();
  var eventTool2 = event;
  var throttleUtil = throttle$1;
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var inner2 = makeInner2();
  var clone2 = zrUtil2.clone;
  var bind2 = zrUtil2.bind;
  function BaseAxisPointer() {
  }
  BaseAxisPointer.prototype = {
    /**
     * @private
     */
    _group: null,
    /**
     * @private
     */
    _lastGraphicKey: null,
    /**
     * @private
     */
    _handle: null,
    /**
     * @private
     */
    _dragging: false,
    /**
     * @private
     */
    _lastValue: null,
    /**
     * @private
     */
    _lastStatus: null,
    /**
     * @private
     */
    _payloadInfo: null,
    /**
     * In px, arbitrary value. Do not set too small,
     * no animation is ok for most cases.
     * @protected
     */
    animationThreshold: 15,
    /**
     * @implement
     */
    render: function(axisModel, axisPointerModel, api, forceRender) {
      var value = axisPointerModel.get("value");
      var status = axisPointerModel.get("status");
      this._axisModel = axisModel;
      this._axisPointerModel = axisPointerModel;
      this._api = api;
      if (!forceRender && this._lastValue === value && this._lastStatus === status) {
        return;
      }
      this._lastValue = value;
      this._lastStatus = status;
      var group = this._group;
      var handle = this._handle;
      if (!status || status === "hide") {
        group && group.hide();
        handle && handle.hide();
        return;
      }
      group && group.show();
      handle && handle.show();
      var elOption = {};
      this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
      var graphicKey = elOption.graphicKey;
      if (graphicKey !== this._lastGraphicKey) {
        this.clear(api);
      }
      this._lastGraphicKey = graphicKey;
      var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
      if (!group) {
        group = this._group = new graphic2.Group();
        this.createPointerEl(group, elOption, axisModel, axisPointerModel);
        this.createLabelEl(group, elOption, axisModel, axisPointerModel);
        api.getZr().add(group);
      } else {
        var doUpdateProps = zrUtil2.curry(updateProps2, axisPointerModel, moveAnimation);
        this.updatePointerEl(group, elOption, doUpdateProps, axisPointerModel);
        this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
      }
      updateMandatoryProps(group, axisPointerModel, true);
      this._renderHandle(value);
    },
    /**
     * @implement
     */
    remove: function(api) {
      this.clear(api);
    },
    /**
     * @implement
     */
    dispose: function(api) {
      this.clear(api);
    },
    /**
     * @protected
     */
    determineAnimation: function(axisModel, axisPointerModel) {
      var animation2 = axisPointerModel.get("animation");
      var axis2 = axisModel.axis;
      var isCategoryAxis = axis2.type === "category";
      var useSnap = axisPointerModel.get("snap");
      if (!useSnap && !isCategoryAxis) {
        return false;
      }
      if (animation2 === "auto" || animation2 == null) {
        var animationThreshold = this.animationThreshold;
        if (isCategoryAxis && axis2.getBandWidth() > animationThreshold) {
          return true;
        }
        if (useSnap) {
          var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
          var axisExtent = axis2.getExtent();
          return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
        }
        return false;
      }
      return animation2 === true;
    },
    /**
     * add {pointer, label, graphicKey} to elOption
     * @protected
     */
    makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
    },
    /**
     * @protected
     */
    createPointerEl: function(group, elOption, axisModel, axisPointerModel) {
      var pointerOption = elOption.pointer;
      if (pointerOption) {
        var pointerEl = inner2(group).pointerEl = new graphic2[pointerOption.type](clone2(elOption.pointer));
        group.add(pointerEl);
      }
    },
    /**
     * @protected
     */
    createLabelEl: function(group, elOption, axisModel, axisPointerModel) {
      if (elOption.label) {
        var labelEl = inner2(group).labelEl = new graphic2.Rect(clone2(elOption.label));
        group.add(labelEl);
        updateLabelShowHide(labelEl, axisPointerModel);
      }
    },
    /**
     * @protected
     */
    updatePointerEl: function(group, elOption, updateProps3) {
      var pointerEl = inner2(group).pointerEl;
      if (pointerEl && elOption.pointer) {
        pointerEl.setStyle(elOption.pointer.style);
        updateProps3(pointerEl, {
          shape: elOption.pointer.shape
        });
      }
    },
    /**
     * @protected
     */
    updateLabelEl: function(group, elOption, updateProps3, axisPointerModel) {
      var labelEl = inner2(group).labelEl;
      if (labelEl) {
        labelEl.setStyle(elOption.label.style);
        updateProps3(labelEl, {
          // Consider text length change in vertical axis, animation should
          // be used on shape, otherwise the effect will be weird.
          shape: elOption.label.shape,
          position: elOption.label.position
        });
        updateLabelShowHide(labelEl, axisPointerModel);
      }
    },
    /**
     * @private
     */
    _renderHandle: function(value) {
      if (this._dragging || !this.updateHandleTransform) {
        return;
      }
      var axisPointerModel = this._axisPointerModel;
      var zr = this._api.getZr();
      var handle = this._handle;
      var handleModel = axisPointerModel.getModel("handle");
      var status = axisPointerModel.get("status");
      if (!handleModel.get("show") || !status || status === "hide") {
        handle && zr.remove(handle);
        this._handle = null;
        return;
      }
      var isInit;
      if (!this._handle) {
        isInit = true;
        handle = this._handle = graphic2.createIcon(handleModel.get("icon"), {
          cursor: "move",
          draggable: true,
          onmousemove: function(e2) {
            eventTool2.stop(e2.event);
          },
          onmousedown: bind2(this._onHandleDragMove, this, 0, 0),
          drift: bind2(this._onHandleDragMove, this),
          ondragend: bind2(this._onHandleDragEnd, this)
        });
        zr.add(handle);
      }
      updateMandatoryProps(handle, axisPointerModel, false);
      var includeStyles = ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
      handle.setStyle(handleModel.getItemStyle(null, includeStyles));
      var handleSize = handleModel.get("size");
      if (!zrUtil2.isArray(handleSize)) {
        handleSize = [handleSize, handleSize];
      }
      handle.attr("scale", [handleSize[0] / 2, handleSize[1] / 2]);
      throttleUtil.createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
      this._moveHandleToValue(value, isInit);
    },
    /**
     * @private
     */
    _moveHandleToValue: function(value, isInit) {
      updateProps2(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
    },
    /**
     * @private
     */
    _onHandleDragMove: function(dx, dy) {
      var handle = this._handle;
      if (!handle) {
        return;
      }
      this._dragging = true;
      var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
      this._payloadInfo = trans;
      handle.stopAnimation();
      handle.attr(getHandleTransProps(trans));
      inner2(handle).lastProp = null;
      this._doDispatchAxisPointer();
    },
    /**
     * Throttled method.
     * @private
     */
    _doDispatchAxisPointer: function() {
      var handle = this._handle;
      if (!handle) {
        return;
      }
      var payloadInfo = this._payloadInfo;
      var axisModel = this._axisModel;
      this._api.dispatchAction({
        type: "updateAxisPointer",
        x: payloadInfo.cursorPoint[0],
        y: payloadInfo.cursorPoint[1],
        tooltipOption: payloadInfo.tooltipOption,
        axesInfo: [{
          axisDim: axisModel.axis.dim,
          axisIndex: axisModel.componentIndex
        }]
      });
    },
    /**
     * @private
     */
    _onHandleDragEnd: function(moveAnimation) {
      this._dragging = false;
      var handle = this._handle;
      if (!handle) {
        return;
      }
      var value = this._axisPointerModel.get("value");
      this._moveHandleToValue(value);
      this._api.dispatchAction({
        type: "hideTip"
      });
    },
    /**
     * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {number} value
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0}
     */
    getHandleTransform: null,
    /**
     * * Should be implemenented by sub-class if support `handle`.
     * @protected
     * @param {Object} transform {position, rotation}
     * @param {Array.<number>} delta [dx, dy]
     * @param {module:echarts/model/Model} axisModel
     * @param {module:echarts/model/Model} axisPointerModel
     * @return {Object} {position: [x, y], rotation: 0, cursorPoint: [x, y]}
     */
    updateHandleTransform: null,
    /**
     * @private
     */
    clear: function(api) {
      this._lastValue = null;
      this._lastStatus = null;
      var zr = api.getZr();
      var group = this._group;
      var handle = this._handle;
      if (zr && group) {
        this._lastGraphicKey = null;
        group && zr.remove(group);
        handle && zr.remove(handle);
        this._group = null;
        this._handle = null;
        this._payloadInfo = null;
      }
    },
    /**
     * @protected
     */
    doClear: function() {
    },
    /**
     * @protected
     * @param {Array.<number>} xy
     * @param {Array.<number>} wh
     * @param {number} [xDimIndex=0] or 1
     */
    buildLabel: function(xy, wh, xDimIndex) {
      xDimIndex = xDimIndex || 0;
      return {
        x: xy[xDimIndex],
        y: xy[1 - xDimIndex],
        width: wh[xDimIndex],
        height: wh[1 - xDimIndex]
      };
    }
  };
  BaseAxisPointer.prototype.constructor = BaseAxisPointer;
  function updateProps2(animationModel, moveAnimation, el, props) {
    if (!propsEqual(inner2(el).lastProp, props)) {
      inner2(el).lastProp = props;
      moveAnimation ? graphic2.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
    }
  }
  function propsEqual(lastProps, newProps) {
    if (zrUtil2.isObject(lastProps) && zrUtil2.isObject(newProps)) {
      var equals = true;
      zrUtil2.each(newProps, function(item, key) {
        equals = equals && propsEqual(lastProps[key], item);
      });
      return !!equals;
    } else {
      return lastProps === newProps;
    }
  }
  function updateLabelShowHide(labelEl, axisPointerModel) {
    labelEl[axisPointerModel.get("label.show") ? "show" : "hide"]();
  }
  function getHandleTransProps(trans) {
    return {
      position: trans.position.slice(),
      rotation: trans.rotation || 0
    };
  }
  function updateMandatoryProps(group, axisPointerModel, silent) {
    var z = axisPointerModel.get("z");
    var zlevel = axisPointerModel.get("zlevel");
    group && group.traverse(function(el) {
      if (el.type !== "group") {
        z != null && (el.z = z);
        zlevel != null && (el.zlevel = zlevel);
        el.silent = silent;
      }
    });
  }
  clazzUtil2.enableClassExtend(BaseAxisPointer);
  var _default2 = BaseAxisPointer;
  BaseAxisPointer_1 = _default2;
  return BaseAxisPointer_1;
}
var viewHelper = {};
var hasRequiredViewHelper;
function requireViewHelper() {
  if (hasRequiredViewHelper)
    return viewHelper;
  hasRequiredViewHelper = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var textContain2 = text;
  var formatUtil2 = requireFormat();
  var matrix2 = requireMatrix();
  var axisHelper2 = requireAxisHelper();
  var AxisBuilder = requireAxisBuilder();
  function buildElStyle(axisPointerModel) {
    var axisPointerType = axisPointerModel.get("type");
    var styleModel = axisPointerModel.getModel(axisPointerType + "Style");
    var style;
    if (axisPointerType === "line") {
      style = styleModel.getLineStyle();
      style.fill = null;
    } else if (axisPointerType === "shadow") {
      style = styleModel.getAreaStyle();
      style.stroke = null;
    }
    return style;
  }
  function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
    var value = axisPointerModel.get("value");
    var text2 = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
      precision: axisPointerModel.get("label.precision"),
      formatter: axisPointerModel.get("label.formatter")
    });
    var labelModel = axisPointerModel.getModel("label");
    var paddings = formatUtil2.normalizeCssArray(labelModel.get("padding") || 0);
    var font = labelModel.getFont();
    var textRect = textContain2.getBoundingRect(text2, font);
    var position = labelPos.position;
    var width = textRect.width + paddings[1] + paddings[3];
    var height = textRect.height + paddings[0] + paddings[2];
    var align = labelPos.align;
    align === "right" && (position[0] -= width);
    align === "center" && (position[0] -= width / 2);
    var verticalAlign = labelPos.verticalAlign;
    verticalAlign === "bottom" && (position[1] -= height);
    verticalAlign === "middle" && (position[1] -= height / 2);
    confineInContainer(position, width, height, api);
    var bgColor = labelModel.get("backgroundColor");
    if (!bgColor || bgColor === "auto") {
      bgColor = axisModel.get("axisLine.lineStyle.color");
    }
    elOption.label = {
      shape: {
        x: 0,
        y: 0,
        width,
        height,
        r: labelModel.get("borderRadius")
      },
      position: position.slice(),
      // TODO: rich
      style: {
        text: text2,
        textFont: font,
        textFill: labelModel.getTextColor(),
        textPosition: "inside",
        textPadding: paddings,
        fill: bgColor,
        stroke: labelModel.get("borderColor") || "transparent",
        lineWidth: labelModel.get("borderWidth") || 0,
        shadowBlur: labelModel.get("shadowBlur"),
        shadowColor: labelModel.get("shadowColor"),
        shadowOffsetX: labelModel.get("shadowOffsetX"),
        shadowOffsetY: labelModel.get("shadowOffsetY")
      },
      // Lable should be over axisPointer.
      z2: 10
    };
  }
  function confineInContainer(position, width, height, api) {
    var viewWidth = api.getWidth();
    var viewHeight = api.getHeight();
    position[0] = Math.min(position[0] + width, viewWidth) - width;
    position[1] = Math.min(position[1] + height, viewHeight) - height;
    position[0] = Math.max(position[0], 0);
    position[1] = Math.max(position[1], 0);
  }
  function getValueLabel(value, axis2, ecModel, seriesDataIndices, opt) {
    value = axis2.scale.parse(value);
    var text2 = axis2.scale.getLabel(
      // If `precision` is set, width can be fixed (like '12.00500'), which
      // helps to debounce when when moving label.
      value,
      {
        precision: opt.precision
      }
    );
    var formatter = opt.formatter;
    if (formatter) {
      var params = {
        value: axisHelper2.getAxisRawValue(axis2, value),
        axisDimension: axis2.dim,
        axisIndex: axis2.index,
        seriesData: []
      };
      zrUtil2.each(seriesDataIndices, function(idxItem) {
        var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
        var dataIndex = idxItem.dataIndexInside;
        var dataParams = series && series.getDataParams(dataIndex);
        dataParams && params.seriesData.push(dataParams);
      });
      if (zrUtil2.isString(formatter)) {
        text2 = formatter.replace("{value}", text2);
      } else if (zrUtil2.isFunction(formatter)) {
        text2 = formatter(params);
      }
    }
    return text2;
  }
  function getTransformedPosition(axis2, value, layoutInfo) {
    var transform = matrix2.create();
    matrix2.rotate(transform, transform, layoutInfo.rotation);
    matrix2.translate(transform, transform, layoutInfo.position);
    return graphic2.applyTransform([axis2.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
  }
  function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
    var textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
    layoutInfo.labelMargin = axisPointerModel.get("label.margin");
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
      position: getTransformedPosition(axisModel.axis, value, layoutInfo),
      align: textLayout.textAlign,
      verticalAlign: textLayout.textVerticalAlign
    });
  }
  function makeLineShape(p1, p2, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x1: p1[xDimIndex],
      y1: p1[1 - xDimIndex],
      x2: p2[xDimIndex],
      y2: p2[1 - xDimIndex]
    };
  }
  function makeRectShape(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
  function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
    return {
      cx,
      cy,
      r0,
      r,
      startAngle,
      endAngle,
      clockwise: true
    };
  }
  viewHelper.buildElStyle = buildElStyle;
  viewHelper.buildLabelElOption = buildLabelElOption;
  viewHelper.getValueLabel = getValueLabel;
  viewHelper.getTransformedPosition = getTransformedPosition;
  viewHelper.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
  viewHelper.makeLineShape = makeLineShape;
  viewHelper.makeRectShape = makeRectShape;
  viewHelper.makeSectorShape = makeSectorShape;
  return viewHelper;
}
var CartesianAxisPointer_1;
var hasRequiredCartesianAxisPointer;
function requireCartesianAxisPointer() {
  if (hasRequiredCartesianAxisPointer)
    return CartesianAxisPointer_1;
  hasRequiredCartesianAxisPointer = 1;
  var BaseAxisPointer = requireBaseAxisPointer();
  var viewHelper2 = requireViewHelper();
  var cartesianAxisHelper2 = requireCartesianAxisHelper();
  var AxisView = requireAxisView();
  var CartesianAxisPointer = BaseAxisPointer.extend({
    /**
     * @override
     */
    makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
      var axis2 = axisModel.axis;
      var grid2 = axis2.grid;
      var axisPointerType = axisPointerModel.get("type");
      var otherExtent = getCartesian(grid2, axis2).getOtherAxis(axis2).getGlobalExtent();
      var pixelValue = axis2.toGlobalCoord(axis2.dataToCoord(value, true));
      if (axisPointerType && axisPointerType !== "none") {
        var elStyle = viewHelper2.buildElStyle(axisPointerModel);
        var pointerOption = pointerShapeBuilder[axisPointerType](axis2, pixelValue, otherExtent);
        pointerOption.style = elStyle;
        elOption.graphicKey = pointerOption.type;
        elOption.pointer = pointerOption;
      }
      var layoutInfo = cartesianAxisHelper2.layout(grid2.model, axisModel);
      viewHelper2.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
    },
    /**
     * @override
     */
    getHandleTransform: function(value, axisModel, axisPointerModel) {
      var layoutInfo = cartesianAxisHelper2.layout(axisModel.axis.grid.model, axisModel, {
        labelInside: false
      });
      layoutInfo.labelMargin = axisPointerModel.get("handle.margin");
      return {
        position: viewHelper2.getTransformedPosition(axisModel.axis, value, layoutInfo),
        rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
      };
    },
    /**
     * @override
     */
    updateHandleTransform: function(transform, delta, axisModel, axisPointerModel) {
      var axis2 = axisModel.axis;
      var grid2 = axis2.grid;
      var axisExtent = axis2.getGlobalExtent(true);
      var otherExtent = getCartesian(grid2, axis2).getOtherAxis(axis2).getGlobalExtent();
      var dimIndex = axis2.dim === "x" ? 0 : 1;
      var currPosition = transform.position;
      currPosition[dimIndex] += delta[dimIndex];
      currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
      currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
      var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
      var cursorPoint = [cursorOtherValue, cursorOtherValue];
      cursorPoint[dimIndex] = currPosition[dimIndex];
      var tooltipOptions = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        position: currPosition,
        rotation: transform.rotation,
        cursorPoint,
        tooltipOption: tooltipOptions[dimIndex]
      };
    }
  });
  function getCartesian(grid2, axis2) {
    var opt = {};
    opt[axis2.dim + "AxisIndex"] = axis2.index;
    return grid2.getCartesian(opt);
  }
  var pointerShapeBuilder = {
    line: function(axis2, pixelValue, otherExtent) {
      var targetShape = viewHelper2.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis2));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: targetShape
      };
    },
    shadow: function(axis2, pixelValue, otherExtent) {
      var bandWidth = Math.max(1, axis2.getBandWidth());
      var span = otherExtent[1] - otherExtent[0];
      return {
        type: "Rect",
        shape: viewHelper2.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis2))
      };
    }
  };
  function getAxisDimIndex(axis2) {
    return axis2.dim === "x" ? 0 : 1;
  }
  AxisView.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer);
  var _default2 = CartesianAxisPointer;
  CartesianAxisPointer_1 = _default2;
  return CartesianAxisPointer_1;
}
var hasRequiredAxisPointer;
function requireAxisPointer() {
  if (hasRequiredAxisPointer)
    return axisPointer;
  hasRequiredAxisPointer = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var axisPointerModelHelper = requireModelHelper();
  var axisTrigger2 = requireAxisTrigger();
  requireAxisPointerModel();
  requireAxisPointerView();
  requireCartesianAxisPointer();
  echarts$12.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      var link = option.axisPointer.link;
      if (link && !zrUtil2.isArray(link)) {
        option.axisPointer.link = [link];
      }
    }
  });
  echarts$12.registerProcessor(echarts$12.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
  });
  echarts$12.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger2);
  return axisPointer;
}
var SingleAxisPointer_1;
var hasRequiredSingleAxisPointer;
function requireSingleAxisPointer() {
  if (hasRequiredSingleAxisPointer)
    return SingleAxisPointer_1;
  hasRequiredSingleAxisPointer = 1;
  var BaseAxisPointer = requireBaseAxisPointer();
  var viewHelper2 = requireViewHelper();
  var singleAxisHelper2 = requireSingleAxisHelper();
  var AxisView = requireAxisView();
  var XY = ["x", "y"];
  var WH = ["width", "height"];
  var SingleAxisPointer = BaseAxisPointer.extend({
    /**
     * @override
     */
    makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
      var axis2 = axisModel.axis;
      var coordSys = axis2.coordinateSystem;
      var otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis2));
      var pixelValue = coordSys.dataToPoint(value)[0];
      var axisPointerType = axisPointerModel.get("type");
      if (axisPointerType && axisPointerType !== "none") {
        var elStyle = viewHelper2.buildElStyle(axisPointerModel);
        var pointerOption = pointerShapeBuilder[axisPointerType](axis2, pixelValue, otherExtent);
        pointerOption.style = elStyle;
        elOption.graphicKey = pointerOption.type;
        elOption.pointer = pointerOption;
      }
      var layoutInfo = singleAxisHelper2.layout(axisModel);
      viewHelper2.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
    },
    /**
     * @override
     */
    getHandleTransform: function(value, axisModel, axisPointerModel) {
      var layoutInfo = singleAxisHelper2.layout(axisModel, {
        labelInside: false
      });
      layoutInfo.labelMargin = axisPointerModel.get("handle.margin");
      return {
        position: viewHelper2.getTransformedPosition(axisModel.axis, value, layoutInfo),
        rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
      };
    },
    /**
     * @override
     */
    updateHandleTransform: function(transform, delta, axisModel, axisPointerModel) {
      var axis2 = axisModel.axis;
      var coordSys = axis2.coordinateSystem;
      var dimIndex = getPointDimIndex(axis2);
      var axisExtent = getGlobalExtent(coordSys, dimIndex);
      var currPosition = transform.position;
      currPosition[dimIndex] += delta[dimIndex];
      currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
      currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
      var otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
      var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
      var cursorPoint = [cursorOtherValue, cursorOtherValue];
      cursorPoint[dimIndex] = currPosition[dimIndex];
      return {
        position: currPosition,
        rotation: transform.rotation,
        cursorPoint,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }
  });
  var pointerShapeBuilder = {
    line: function(axis2, pixelValue, otherExtent) {
      var targetShape = viewHelper2.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis2));
      return {
        type: "Line",
        subPixelOptimize: true,
        shape: targetShape
      };
    },
    shadow: function(axis2, pixelValue, otherExtent) {
      var bandWidth = axis2.getBandWidth();
      var span = otherExtent[1] - otherExtent[0];
      return {
        type: "Rect",
        shape: viewHelper2.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis2))
      };
    }
  };
  function getPointDimIndex(axis2) {
    return axis2.isHorizontal() ? 0 : 1;
  }
  function getGlobalExtent(coordSys, dimIndex) {
    var rect = coordSys.getRect();
    return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];
  }
  AxisView.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer);
  var _default2 = SingleAxisPointer;
  SingleAxisPointer_1 = _default2;
  return SingleAxisPointer_1;
}
var hasRequiredSingleAxis;
function requireSingleAxis() {
  if (hasRequiredSingleAxis)
    return singleAxis;
  hasRequiredSingleAxis = 1;
  var echarts$12 = echarts;
  requireSingleCreator();
  requireSingleAxisView();
  requireAxisModel$1();
  requireAxisPointer();
  requireSingleAxisPointer();
  echarts$12.extendComponentView({
    type: "single"
  });
  return singleAxis;
}
var ThemeRiverSeries_1;
var hasRequiredThemeRiverSeries;
function requireThemeRiverSeries() {
  if (hasRequiredThemeRiverSeries)
    return ThemeRiverSeries_1;
  hasRequiredThemeRiverSeries = 1;
  var SeriesModel2 = Series;
  var createDimensions2 = requireCreateDimensions();
  var _dimensionHelper = requireDimensionHelper();
  var getDimensionTypeByAxis = _dimensionHelper.getDimensionTypeByAxis;
  var List = requireList();
  var zrUtil2 = util$6;
  var _model2 = model;
  var groupData2 = _model2.groupData;
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var LegendVisualProvider = requireLegendVisualProvider();
  var DATA_NAME_INDEX = 2;
  var ThemeRiverSeries = SeriesModel2.extend({
    type: "series.themeRiver",
    dependencies: ["singleAxis"],
    /**
     * @readOnly
     * @type {module:zrender/core/util#HashMap}
     */
    nameMap: null,
    /**
     * @override
     */
    init: function(option) {
      ThemeRiverSeries.superApply(this, "init", arguments);
      this.legendVisualProvider = new LegendVisualProvider(zrUtil2.bind(this.getData, this), zrUtil2.bind(this.getRawData, this));
    },
    /**
     * If there is no value of a certain point in the time for some event,set it value to 0.
     *
     * @param {Array} data  initial data in the option
     * @return {Array}
     */
    fixData: function(data) {
      var rawDataLength = data.length;
      var timeValueKeys = {};
      var groupResult = groupData2(data, function(item) {
        if (!timeValueKeys.hasOwnProperty(item[0])) {
          timeValueKeys[item[0]] = -1;
        }
        return item[2];
      });
      var layData = [];
      groupResult.buckets.each(function(items, key) {
        layData.push({
          name: key,
          dataList: items
        });
      });
      var layerNum = layData.length;
      for (var k = 0; k < layerNum; ++k) {
        var name2 = layData[k].name;
        for (var j = 0; j < layData[k].dataList.length; ++j) {
          var timeValue = layData[k].dataList[j][0];
          timeValueKeys[timeValue] = k;
        }
        for (var timeValue in timeValueKeys) {
          if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
            timeValueKeys[timeValue] = k;
            data[rawDataLength] = [];
            data[rawDataLength][0] = timeValue;
            data[rawDataLength][1] = 0;
            data[rawDataLength][2] = name2;
            rawDataLength++;
          }
        }
      }
      return data;
    },
    /**
     * @override
     * @param  {Object} option  the initial option that user gived
     * @param  {module:echarts/model/Model} ecModel  the model object for themeRiver option
     * @return {module:echarts/data/List}
     */
    getInitialData: function(option, ecModel) {
      var singleAxisModel = ecModel.queryComponents({
        mainType: "singleAxis",
        index: this.get("singleAxisIndex"),
        id: this.get("singleAxisId")
      })[0];
      var axisType = singleAxisModel.get("type");
      var filterData = zrUtil2.filter(option.data, function(dataItem) {
        return dataItem[2] !== void 0;
      });
      var data = this.fixData(filterData || []);
      var nameList = [];
      var nameMap = this.nameMap = zrUtil2.createHashMap();
      var count = 0;
      for (var i = 0; i < data.length; ++i) {
        nameList.push(data[i][DATA_NAME_INDEX]);
        if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
          nameMap.set(data[i][DATA_NAME_INDEX], count);
          count++;
        }
      }
      var dimensionsInfo = createDimensions2(data, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: getDimensionTypeByAxis(axisType)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      });
      var list = new List(dimensionsInfo, this);
      list.initData(data);
      return list;
    },
    /**
     * The raw data is divided into multiple layers and each layer
     *     has same name.
     *
     * @return {Array.<Array.<number>>}
     */
    getLayerSeries: function() {
      var data = this.getData();
      var lenCount = data.count();
      var indexArr = [];
      for (var i = 0; i < lenCount; ++i) {
        indexArr[i] = i;
      }
      var timeDim = data.mapDimension("single");
      var groupResult = groupData2(indexArr, function(index2) {
        return data.get("name", index2);
      });
      var layerSeries = [];
      groupResult.buckets.each(function(items, key) {
        items.sort(function(index1, index2) {
          return data.get(timeDim, index1) - data.get(timeDim, index2);
        });
        layerSeries.push({
          name: key,
          indices: items
        });
      });
      return layerSeries;
    },
    /**
     * Get data indices for show tooltip content
      * @param {Array.<string>|string} dim  single coordinate dimension
     * @param {number} value axis value
     * @param {module:echarts/coord/single/SingleAxis} baseAxis  single Axis used
     *     the themeRiver.
     * @return {Object} {dataIndices, nestestValue}
     */
    getAxisTooltipData: function(dim, value, baseAxis) {
      if (!zrUtil2.isArray(dim)) {
        dim = dim ? [dim] : [];
      }
      var data = this.getData();
      var layerSeries = this.getLayerSeries();
      var indices = [];
      var layerNum = layerSeries.length;
      var nestestValue;
      for (var i = 0; i < layerNum; ++i) {
        var minDist = Number.MAX_VALUE;
        var nearestIdx = -1;
        var pointNum = layerSeries[i].indices.length;
        for (var j = 0; j < pointNum; ++j) {
          var theValue = data.get(dim[0], layerSeries[i].indices[j]);
          var dist2 = Math.abs(theValue - value);
          if (dist2 <= minDist) {
            nestestValue = theValue;
            minDist = dist2;
            nearestIdx = layerSeries[i].indices[j];
          }
        }
        indices.push(nearestIdx);
      }
      return {
        dataIndices: indices,
        nestestValue
      };
    },
    /**
     * @override
     * @param {number} dataIndex  index of data
     */
    formatTooltip: function(dataIndex) {
      var data = this.getData();
      var htmlName = data.getName(dataIndex);
      var htmlValue = data.get(data.mapDimension("value"), dataIndex);
      if (isNaN(htmlValue) || htmlValue == null) {
        htmlValue = "-";
      }
      return encodeHTML2(htmlName + " : " + htmlValue);
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: true,
        position: "left",
        color: "#000",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }
  });
  var _default2 = ThemeRiverSeries;
  ThemeRiverSeries_1 = _default2;
  return ThemeRiverSeries_1;
}
var ThemeRiverView;
var hasRequiredThemeRiverView;
function requireThemeRiverView() {
  if (hasRequiredThemeRiverView)
    return ThemeRiverView;
  hasRequiredThemeRiverView = 1;
  var echarts$12 = echarts;
  var _poly = requirePoly();
  var Polygon2 = _poly.Polygon;
  var graphic2 = graphic$4;
  var _util2 = util$6;
  var bind2 = _util2.bind;
  var extend2 = _util2.extend;
  var DataDiffer = requireDataDiffer();
  var _default2 = echarts$12.extendChartView({
    type: "themeRiver",
    init: function() {
      this._layers = [];
    },
    render: function(seriesModel, ecModel, api) {
      var data = seriesModel.getData();
      var group = this.group;
      var layerSeries = seriesModel.getLayerSeries();
      var layoutInfo = data.getLayout("layoutInfo");
      var rect = layoutInfo.rect;
      var boundaryGap = layoutInfo.boundaryGap;
      group.attr("position", [0, rect.y + boundaryGap[0]]);
      function keyGetter(item) {
        return item.name;
      }
      var dataDiffer = new DataDiffer(this._layersSeries || [], layerSeries, keyGetter, keyGetter);
      var newLayersGroups = {};
      dataDiffer.add(bind2(process, this, "add")).update(bind2(process, this, "update")).remove(bind2(process, this, "remove")).execute();
      function process(status, idx, oldIdx) {
        var oldLayersGroups = this._layers;
        if (status === "remove") {
          group.remove(oldLayersGroups[idx]);
          return;
        }
        var points0 = [];
        var points1 = [];
        var color2;
        var indices = layerSeries[idx].indices;
        for (var j = 0; j < indices.length; j++) {
          var layout2 = data.getItemLayout(indices[j]);
          var x = layout2.x;
          var y0 = layout2.y0;
          var y = layout2.y;
          points0.push([x, y0]);
          points1.push([x, y0 + y]);
          color2 = data.getItemVisual(indices[j], "color");
        }
        var polygon2;
        var text2;
        var textLayout = data.getItemLayout(indices[0]);
        var itemModel = data.getItemModel(indices[j - 1]);
        var labelModel = itemModel.getModel("label");
        var margin = labelModel.get("margin");
        if (status === "add") {
          var layerGroup = newLayersGroups[idx] = new graphic2.Group();
          polygon2 = new Polygon2({
            shape: {
              points: points0,
              stackedOnPoints: points1,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: false
            },
            z2: 0
          });
          text2 = new graphic2.Text({
            style: {
              x: textLayout.x - margin,
              y: textLayout.y0 + textLayout.y / 2
            }
          });
          layerGroup.add(polygon2);
          layerGroup.add(text2);
          group.add(layerGroup);
          polygon2.setClipPath(createGridClipShape(polygon2.getBoundingRect(), seriesModel, function() {
            polygon2.removeClipPath();
          }));
        } else {
          var layerGroup = oldLayersGroups[oldIdx];
          polygon2 = layerGroup.childAt(0);
          text2 = layerGroup.childAt(1);
          group.add(layerGroup);
          newLayersGroups[idx] = layerGroup;
          graphic2.updateProps(polygon2, {
            shape: {
              points: points0,
              stackedOnPoints: points1
            }
          }, seriesModel);
          graphic2.updateProps(text2, {
            style: {
              x: textLayout.x - margin,
              y: textLayout.y0 + textLayout.y / 2
            }
          }, seriesModel);
        }
        var hoverItemStyleModel = itemModel.getModel("emphasis.itemStyle");
        var itemStyleModel = itemModel.getModel("itemStyle");
        graphic2.setTextStyle(text2.style, labelModel, {
          text: labelModel.get("show") ? seriesModel.getFormattedLabel(indices[j - 1], "normal") || data.getName(indices[j - 1]) : null,
          textVerticalAlign: "middle"
        });
        polygon2.setStyle(extend2({
          fill: color2
        }, itemStyleModel.getItemStyle(["color"])));
        graphic2.setHoverStyle(polygon2, hoverItemStyleModel.getItemStyle());
      }
      this._layersSeries = layerSeries;
      this._layers = newLayersGroups;
    },
    dispose: function() {
    }
  });
  function createGridClipShape(rect, seriesModel, cb) {
    var rectEl = new graphic2.Rect({
      shape: {
        x: rect.x - 10,
        y: rect.y - 10,
        width: 0,
        height: rect.height + 20
      }
    });
    graphic2.initProps(rectEl, {
      shape: {
        width: rect.width + 20,
        height: rect.height + 20
      }
    }, seriesModel, cb);
    return rectEl;
  }
  ThemeRiverView = _default2;
  return ThemeRiverView;
}
var themeRiverLayout_1;
var hasRequiredThemeRiverLayout;
function requireThemeRiverLayout() {
  if (hasRequiredThemeRiverLayout)
    return themeRiverLayout_1;
  hasRequiredThemeRiverLayout = 1;
  var zrUtil2 = util$6;
  var numberUtil = requireNumber();
  function _default2(ecModel, api) {
    ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
      var data = seriesModel.getData();
      var single = seriesModel.coordinateSystem;
      var layoutInfo = {};
      var rect = single.getRect();
      layoutInfo.rect = rect;
      var boundaryGap = seriesModel.get("boundaryGap");
      var axis2 = single.getAxis();
      layoutInfo.boundaryGap = boundaryGap;
      if (axis2.orient === "horizontal") {
        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.height);
        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.height);
        var height = rect.height - boundaryGap[0] - boundaryGap[1];
        themeRiverLayout(data, seriesModel, height);
      } else {
        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], rect.width);
        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], rect.width);
        var width = rect.width - boundaryGap[0] - boundaryGap[1];
        themeRiverLayout(data, seriesModel, width);
      }
      data.setLayout("layoutInfo", layoutInfo);
    });
  }
  function themeRiverLayout(data, seriesModel, height) {
    if (!data.count()) {
      return;
    }
    var coordSys = seriesModel.coordinateSystem;
    var layerSeries = seriesModel.getLayerSeries();
    var timeDim = data.mapDimension("single");
    var valueDim = data.mapDimension("value");
    var layerPoints = zrUtil2.map(layerSeries, function(singleLayer) {
      return zrUtil2.map(singleLayer.indices, function(idx) {
        var pt = coordSys.dataToPoint(data.get(timeDim, idx));
        pt[1] = data.get(valueDim, idx);
        return pt;
      });
    });
    var base2 = computeBaseline(layerPoints);
    var baseLine = base2.y0;
    var ky = height / base2.max;
    var n = layerSeries.length;
    var m2 = layerSeries[0].indices.length;
    var baseY0;
    for (var j = 0; j < m2; ++j) {
      baseY0 = baseLine[j] * ky;
      data.setItemLayout(layerSeries[0].indices[j], {
        layerIndex: 0,
        x: layerPoints[0][j][0],
        y0: baseY0,
        y: layerPoints[0][j][1] * ky
      });
      for (var i = 1; i < n; ++i) {
        baseY0 += layerPoints[i - 1][j][1] * ky;
        data.setItemLayout(layerSeries[i].indices[j], {
          layerIndex: i,
          x: layerPoints[i][j][0],
          y0: baseY0,
          y: layerPoints[i][j][1] * ky
        });
      }
    }
  }
  function computeBaseline(data) {
    var layerNum = data.length;
    var pointNum = data[0].length;
    var sums = [];
    var y0 = [];
    var max3 = 0;
    var temp;
    var base2 = {};
    for (var i = 0; i < pointNum; ++i) {
      for (var j = 0, temp = 0; j < layerNum; ++j) {
        temp += data[j][i][1];
      }
      if (temp > max3) {
        max3 = temp;
      }
      sums.push(temp);
    }
    for (var k = 0; k < pointNum; ++k) {
      y0[k] = (max3 - sums[k]) / 2;
    }
    max3 = 0;
    for (var l = 0; l < pointNum; ++l) {
      var sum = sums[l] + y0[l];
      if (sum > max3) {
        max3 = sum;
      }
    }
    base2.y0 = y0;
    base2.max = max3;
    return base2;
  }
  themeRiverLayout_1 = _default2;
  return themeRiverLayout_1;
}
var themeRiverVisual;
var hasRequiredThemeRiverVisual;
function requireThemeRiverVisual() {
  if (hasRequiredThemeRiverVisual)
    return themeRiverVisual;
  hasRequiredThemeRiverVisual = 1;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  function _default2(ecModel) {
    ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
      var data = seriesModel.getData();
      var rawData = seriesModel.getRawData();
      var colorList = seriesModel.get("color");
      var idxMap = createHashMap2();
      data.each(function(idx) {
        idxMap.set(data.getRawIndex(idx), idx);
      });
      rawData.each(function(rawIndex) {
        var name2 = rawData.getName(rawIndex);
        var color2 = colorList[(seriesModel.nameMap.get(name2) - 1) % colorList.length];
        rawData.setItemVisual(rawIndex, "color", color2);
        var idx = idxMap.get(rawIndex);
        if (idx != null) {
          data.setItemVisual(idx, "color", color2);
        }
      });
    });
  }
  themeRiverVisual = _default2;
  return themeRiverVisual;
}
var hasRequiredThemeRiver;
function requireThemeRiver() {
  if (hasRequiredThemeRiver)
    return themeRiver;
  hasRequiredThemeRiver = 1;
  var echarts$12 = echarts;
  requireSingleAxis();
  requireThemeRiverSeries();
  requireThemeRiverView();
  var themeRiverLayout = requireThemeRiverLayout();
  var themeRiverVisual2 = requireThemeRiverVisual();
  var dataFilter2 = requireDataFilter();
  echarts$12.registerLayout(themeRiverLayout);
  echarts$12.registerVisual(themeRiverVisual2);
  echarts$12.registerProcessor(dataFilter2("themeRiver"));
  return themeRiver;
}
var sunburst = {};
var SunburstSeries;
var hasRequiredSunburstSeries;
function requireSunburstSeries() {
  if (hasRequiredSunburstSeries)
    return SunburstSeries;
  hasRequiredSunburstSeries = 1;
  var zrUtil2 = util$6;
  var SeriesModel2 = Series;
  var Tree = requireTree$1();
  var Model2 = requireModel();
  var _treeHelper = requireTreeHelper();
  var wrapTreePathInfo = _treeHelper.wrapTreePathInfo;
  var _default2 = SeriesModel2.extend({
    type: "series.sunburst",
    /**
     * @type {module:echarts/data/Tree~Node}
     */
    _viewRoot: null,
    getInitialData: function(option, ecModel) {
      var root = {
        name: option.name,
        children: option.data
      };
      completeTreeValue(root);
      var levelModels = zrUtil2.map(option.levels || [], function(levelDefine) {
        return new Model2(levelDefine, this, ecModel);
      }, this);
      var tree2 = Tree.createTree(root, this, beforeLink);
      function beforeLink(nodeData) {
        nodeData.wrapMethod("getItemModel", function(model2, idx) {
          var node = tree2.getNodeByDataIndex(idx);
          var levelModel = levelModels[node.depth];
          levelModel && (model2.parentModel = levelModel);
          return model2;
        });
      }
      return tree2.data;
    },
    optionUpdated: function() {
      this.resetViewRoot();
    },
    /*
     * @override
     */
    getDataParams: function(dataIndex) {
      var params = SeriesModel2.prototype.getDataParams.apply(this, arguments);
      var node = this.getData().tree.getNodeByDataIndex(dataIndex);
      params.treePathInfo = wrapTreePathInfo(node, this);
      return params;
    },
    defaultOption: {
      zlevel: 0,
      z: 2,
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: true,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: true,
      // Policy of highlighting pieces when hover on one
      // Valid values: 'none' (for not downplay others), 'descendant',
      // 'ancestor', 'self'
      highlightPolicy: "descendant",
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: false,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: true,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outter
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: true
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      highlight: {
        itemStyle: {
          opacity: 1
        }
      },
      downplay: {
        itemStyle: {
          opacity: 0.5
        },
        label: {
          opacity: 0.6
        }
      },
      // Animation type canbe expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      animationEasing: "cubicOut",
      data: [],
      levels: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    },
    getViewRoot: function() {
      return this._viewRoot;
    },
    /**
     * @param {module:echarts/data/Tree~Node} [viewRoot]
     */
    resetViewRoot: function(viewRoot) {
      viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
      var root = this.getRawData().tree.root;
      if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
        this._viewRoot = root;
      }
    }
  });
  function completeTreeValue(dataNode) {
    var sum = 0;
    zrUtil2.each(dataNode.children, function(child) {
      completeTreeValue(child);
      var childValue = child.value;
      zrUtil2.isArray(childValue) && (childValue = childValue[0]);
      sum += childValue;
    });
    var thisValue = dataNode.value;
    if (zrUtil2.isArray(thisValue)) {
      thisValue = thisValue[0];
    }
    if (thisValue == null || isNaN(thisValue)) {
      thisValue = sum;
    }
    if (thisValue < 0) {
      thisValue = 0;
    }
    zrUtil2.isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
  }
  SunburstSeries = _default2;
  return SunburstSeries;
}
var SunburstPiece_1;
var hasRequiredSunburstPiece;
function requireSunburstPiece() {
  if (hasRequiredSunburstPiece)
    return SunburstPiece_1;
  hasRequiredSunburstPiece = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var NodeHighlightPolicy = {
    NONE: "none",
    // not downplay others
    DESCENDANT: "descendant",
    ANCESTOR: "ancestor",
    SELF: "self"
  };
  var DEFAULT_SECTOR_Z = 2;
  var DEFAULT_TEXT_Z = 4;
  function SunburstPiece(node, seriesModel, ecModel) {
    graphic2.Group.call(this);
    var sector = new graphic2.Sector({
      z2: DEFAULT_SECTOR_Z
    });
    sector.seriesIndex = seriesModel.seriesIndex;
    var text2 = new graphic2.Text({
      z2: DEFAULT_TEXT_Z,
      silent: node.getModel("label").get("silent")
    });
    this.add(sector);
    this.add(text2);
    this.updateData(true, node, "normal", seriesModel, ecModel);
    function onEmphasis() {
      text2.ignore = text2.hoverIgnore;
    }
    function onNormal() {
      text2.ignore = text2.normalIgnore;
    }
    this.on("emphasis", onEmphasis).on("normal", onNormal).on("mouseover", onEmphasis).on("mouseout", onNormal);
  }
  var SunburstPieceProto = SunburstPiece.prototype;
  SunburstPieceProto.updateData = function(firstCreate, node, state, seriesModel, ecModel) {
    this.node = node;
    node.piece = this;
    seriesModel = seriesModel || this._seriesModel;
    ecModel = ecModel || this._ecModel;
    var sector = this.childAt(0);
    sector.dataIndex = node.dataIndex;
    var itemModel = node.getModel();
    var layout2 = node.getLayout();
    var sectorShape = zrUtil2.extend({}, layout2);
    sectorShape.label = null;
    var visualColor = getNodeColor(node, seriesModel, ecModel);
    fillDefaultColor(node, seriesModel, visualColor);
    var normalStyle = itemModel.getModel("itemStyle").getItemStyle();
    var style;
    if (state === "normal") {
      style = normalStyle;
    } else {
      var stateStyle = itemModel.getModel(state + ".itemStyle").getItemStyle();
      style = zrUtil2.merge(stateStyle, normalStyle);
    }
    style = zrUtil2.defaults({
      lineJoin: "bevel",
      fill: style.fill || visualColor
    }, style);
    if (firstCreate) {
      sector.setShape(sectorShape);
      sector.shape.r = layout2.r0;
      graphic2.updateProps(sector, {
        shape: {
          r: layout2.r
        }
      }, seriesModel, node.dataIndex);
      sector.useStyle(style);
    } else if (typeof style.fill === "object" && style.fill.type || typeof sector.style.fill === "object" && sector.style.fill.type) {
      graphic2.updateProps(sector, {
        shape: sectorShape
      }, seriesModel);
      sector.useStyle(style);
    } else {
      graphic2.updateProps(sector, {
        shape: sectorShape,
        style
      }, seriesModel);
    }
    this._updateLabel(seriesModel, visualColor, state);
    var cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    if (firstCreate) {
      var highlightPolicy = seriesModel.getShallow("highlightPolicy");
      this._initEvents(sector, node, seriesModel, highlightPolicy);
    }
    this._seriesModel = seriesModel || this._seriesModel;
    this._ecModel = ecModel || this._ecModel;
    graphic2.setHoverStyle(this);
  };
  SunburstPieceProto.onEmphasis = function(highlightPolicy) {
    var that = this;
    this.node.hostTree.root.eachNode(function(n) {
      if (n.piece) {
        if (that.node === n) {
          n.piece.updateData(false, n, "emphasis");
        } else if (isNodeHighlighted(n, that.node, highlightPolicy)) {
          n.piece.childAt(0).trigger("highlight");
        } else if (highlightPolicy !== NodeHighlightPolicy.NONE) {
          n.piece.childAt(0).trigger("downplay");
        }
      }
    });
  };
  SunburstPieceProto.onNormal = function() {
    this.node.hostTree.root.eachNode(function(n) {
      if (n.piece) {
        n.piece.updateData(false, n, "normal");
      }
    });
  };
  SunburstPieceProto.onHighlight = function() {
    this.updateData(false, this.node, "highlight");
  };
  SunburstPieceProto.onDownplay = function() {
    this.updateData(false, this.node, "downplay");
  };
  SunburstPieceProto._updateLabel = function(seriesModel, visualColor, state) {
    var itemModel = this.node.getModel();
    var normalModel = itemModel.getModel("label");
    var labelModel = state === "normal" || state === "emphasis" ? normalModel : itemModel.getModel(state + ".label");
    var labelHoverModel = itemModel.getModel("emphasis.label");
    var labelFormatter = labelModel.get("formatter");
    var labelState = labelFormatter ? state : "normal";
    var text2 = zrUtil2.retrieve(seriesModel.getFormattedLabel(this.node.dataIndex, labelState, null, null, "label"), this.node.name);
    if (getLabelAttr("show") === false) {
      text2 = "";
    }
    var layout2 = this.node.getLayout();
    var labelMinAngle = labelModel.get("minAngle");
    if (labelMinAngle == null) {
      labelMinAngle = normalModel.get("minAngle");
    }
    labelMinAngle = labelMinAngle / 180 * Math.PI;
    var angle = layout2.endAngle - layout2.startAngle;
    if (labelMinAngle != null && Math.abs(angle) < labelMinAngle) {
      text2 = "";
    }
    var label = this.childAt(1);
    graphic2.setLabelStyle(label.style, label.hoverStyle || {}, normalModel, labelHoverModel, {
      defaultText: labelModel.getShallow("show") ? text2 : null,
      autoColor: visualColor,
      useInsideStyle: true
    });
    var midAngle = (layout2.startAngle + layout2.endAngle) / 2;
    var dx = Math.cos(midAngle);
    var dy = Math.sin(midAngle);
    var r;
    var labelPosition = getLabelAttr("position");
    var labelPadding = getLabelAttr("distance") || 0;
    var textAlign = getLabelAttr("align");
    if (labelPosition === "outside") {
      r = layout2.r + labelPadding;
      textAlign = midAngle > Math.PI / 2 ? "right" : "left";
    } else {
      if (!textAlign || textAlign === "center") {
        r = (layout2.r + layout2.r0) / 2;
        textAlign = "center";
      } else if (textAlign === "left") {
        r = layout2.r0 + labelPadding;
        if (midAngle > Math.PI / 2) {
          textAlign = "right";
        }
      } else if (textAlign === "right") {
        r = layout2.r - labelPadding;
        if (midAngle > Math.PI / 2) {
          textAlign = "left";
        }
      }
    }
    label.attr("style", {
      text: text2,
      textAlign,
      textVerticalAlign: getLabelAttr("verticalAlign") || "middle",
      opacity: getLabelAttr("opacity")
    });
    var textX = r * dx + layout2.cx;
    var textY = r * dy + layout2.cy;
    label.attr("position", [textX, textY]);
    var rotateType = getLabelAttr("rotate");
    var rotate = 0;
    if (rotateType === "radial") {
      rotate = -midAngle;
      if (rotate < -Math.PI / 2) {
        rotate += Math.PI;
      }
    } else if (rotateType === "tangential") {
      rotate = Math.PI / 2 - midAngle;
      if (rotate > Math.PI / 2) {
        rotate -= Math.PI;
      } else if (rotate < -Math.PI / 2) {
        rotate += Math.PI;
      }
    } else if (typeof rotateType === "number") {
      rotate = rotateType * Math.PI / 180;
    }
    label.attr("rotation", rotate);
    function getLabelAttr(name2) {
      var stateAttr = labelModel.get(name2);
      if (stateAttr == null) {
        return normalModel.get(name2);
      } else {
        return stateAttr;
      }
    }
  };
  SunburstPieceProto._initEvents = function(sector, node, seriesModel, highlightPolicy) {
    sector.off("mouseover").off("mouseout").off("emphasis").off("normal");
    var that = this;
    var onEmphasis = function() {
      that.onEmphasis(highlightPolicy);
    };
    var onNormal = function() {
      that.onNormal();
    };
    var onDownplay = function() {
      that.onDownplay();
    };
    var onHighlight = function() {
      that.onHighlight();
    };
    if (seriesModel.isAnimationEnabled()) {
      sector.on("mouseover", onEmphasis).on("mouseout", onNormal).on("emphasis", onEmphasis).on("normal", onNormal).on("downplay", onDownplay).on("highlight", onHighlight);
    }
  };
  zrUtil2.inherits(SunburstPiece, graphic2.Group);
  var _default2 = SunburstPiece;
  function getNodeColor(node, seriesModel, ecModel) {
    var visualColor = node.getVisual("color");
    var visualMetaList = node.getVisual("visualMeta");
    if (!visualMetaList || visualMetaList.length === 0) {
      visualColor = null;
    }
    var color2 = node.getModel("itemStyle").get("color");
    if (color2) {
      return color2;
    } else if (visualColor) {
      return visualColor;
    } else if (node.depth === 0) {
      return ecModel.option.color[0];
    } else {
      var length = ecModel.option.color.length;
      color2 = ecModel.option.color[getRootId(node) % length];
    }
    return color2;
  }
  function getRootId(node) {
    var ancestor = node;
    while (ancestor.depth > 1) {
      ancestor = ancestor.parentNode;
    }
    var virtualRoot = node.getAncestors()[0];
    return zrUtil2.indexOf(virtualRoot.children, ancestor);
  }
  function isNodeHighlighted(node, activeNode, policy) {
    if (policy === NodeHighlightPolicy.NONE) {
      return false;
    } else if (policy === NodeHighlightPolicy.SELF) {
      return node === activeNode;
    } else if (policy === NodeHighlightPolicy.ANCESTOR) {
      return node === activeNode || node.isAncestorOf(activeNode);
    } else {
      return node === activeNode || node.isDescendantOf(activeNode);
    }
  }
  function fillDefaultColor(node, seriesModel, color2) {
    var data = seriesModel.getData();
    data.setItemVisual(node.dataIndex, "color", color2);
  }
  SunburstPiece_1 = _default2;
  return SunburstPiece_1;
}
var SunburstView_1;
var hasRequiredSunburstView;
function requireSunburstView() {
  if (hasRequiredSunburstView)
    return SunburstView_1;
  hasRequiredSunburstView = 1;
  var zrUtil2 = util$6;
  var ChartView = Chart_1;
  var SunburstPiece = requireSunburstPiece();
  var DataDiffer = requireDataDiffer();
  var _format2 = requireFormat();
  var windowOpen = _format2.windowOpen;
  var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
  var SunburstView = ChartView.extend({
    type: "sunburst",
    init: function() {
    },
    render: function(seriesModel, ecModel, api, payload) {
      var that = this;
      this.seriesModel = seriesModel;
      this.api = api;
      this.ecModel = ecModel;
      var data = seriesModel.getData();
      var virtualRoot = data.tree.root;
      var newRoot = seriesModel.getViewRoot();
      var group = this.group;
      var renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
      var newChildren = [];
      newRoot.eachNode(function(node) {
        newChildren.push(node);
      });
      var oldChildren = this._oldChildren || [];
      dualTravel(newChildren, oldChildren);
      renderRollUp(virtualRoot, newRoot);
      if (payload && payload.highlight && payload.highlight.piece) {
        var highlightPolicy = seriesModel.getShallow("highlightPolicy");
        payload.highlight.piece.onEmphasis(highlightPolicy);
      } else if (payload && payload.unhighlight) {
        var piece = this.virtualPiece;
        if (!piece && virtualRoot.children.length) {
          piece = virtualRoot.children[0].piece;
        }
        if (piece) {
          piece.onNormal();
        }
      }
      this._initEvents();
      this._oldChildren = newChildren;
      function dualTravel(newChildren2, oldChildren2) {
        if (newChildren2.length === 0 && oldChildren2.length === 0) {
          return;
        }
        new DataDiffer(oldChildren2, newChildren2, getKey, getKey).add(processNode).update(processNode).remove(zrUtil2.curry(processNode, null)).execute();
        function getKey(node) {
          return node.getId();
        }
        function processNode(newId, oldId) {
          var newNode = newId == null ? null : newChildren2[newId];
          var oldNode = oldId == null ? null : oldChildren2[oldId];
          doRenderNode(newNode, oldNode);
        }
      }
      function doRenderNode(newNode, oldNode) {
        if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
          newNode = null;
        }
        if (newNode !== virtualRoot && oldNode !== virtualRoot) {
          if (oldNode && oldNode.piece) {
            if (newNode) {
              oldNode.piece.updateData(false, newNode, "normal", seriesModel, ecModel);
              data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
            } else {
              removeNode(oldNode);
            }
          } else if (newNode) {
            var piece2 = new SunburstPiece(newNode, seriesModel, ecModel);
            group.add(piece2);
            data.setItemGraphicEl(newNode.dataIndex, piece2);
          }
        }
      }
      function removeNode(node) {
        if (!node) {
          return;
        }
        if (node.piece) {
          group.remove(node.piece);
          node.piece = null;
        }
      }
      function renderRollUp(virtualRoot2, viewRoot) {
        if (viewRoot.depth > 0) {
          if (that.virtualPiece) {
            that.virtualPiece.updateData(false, virtualRoot2, "normal", seriesModel, ecModel);
          } else {
            that.virtualPiece = new SunburstPiece(virtualRoot2, seriesModel, ecModel);
            group.add(that.virtualPiece);
          }
          if (viewRoot.piece._onclickEvent) {
            viewRoot.piece.off("click", viewRoot.piece._onclickEvent);
          }
          var event2 = function(e2) {
            that._rootToNode(viewRoot.parentNode);
          };
          viewRoot.piece._onclickEvent = event2;
          that.virtualPiece.on("click", event2);
        } else if (that.virtualPiece) {
          group.remove(that.virtualPiece);
          that.virtualPiece = null;
        }
      }
    },
    dispose: function() {
    },
    /**
     * @private
     */
    _initEvents: function() {
      var that = this;
      var event2 = function(e2) {
        var targetFound = false;
        var viewRoot = that.seriesModel.getViewRoot();
        viewRoot.eachNode(function(node) {
          if (!targetFound && node.piece && node.piece.childAt(0) === e2.target) {
            var nodeClick = node.getModel().get("nodeClick");
            if (nodeClick === "rootToNode") {
              that._rootToNode(node);
            } else if (nodeClick === "link") {
              var itemModel = node.getModel();
              var link = itemModel.get("link");
              if (link) {
                var linkTarget = itemModel.get("target", true) || "_blank";
                windowOpen(link, linkTarget);
              }
            }
            targetFound = true;
          }
        });
      };
      if (this.group._onclickEvent) {
        this.group.off("click", this.group._onclickEvent);
      }
      this.group.on("click", event2);
      this.group._onclickEvent = event2;
    },
    /**
     * @private
     */
    _rootToNode: function(node) {
      if (node !== this.seriesModel.getViewRoot()) {
        this.api.dispatchAction({
          type: ROOT_TO_NODE_ACTION,
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: node
        });
      }
    },
    /**
     * @implement
     */
    containPoint: function(point, seriesModel) {
      var treeRoot = seriesModel.getData();
      var itemLayout = treeRoot.getItemLayout(0);
      if (itemLayout) {
        var dx = point[0] - itemLayout.cx;
        var dy = point[1] - itemLayout.cy;
        var radius = Math.sqrt(dx * dx + dy * dy);
        return radius <= itemLayout.r && radius >= itemLayout.r0;
      }
    }
  });
  var _default2 = SunburstView;
  SunburstView_1 = _default2;
  return SunburstView_1;
}
var sunburstAction = {};
var hasRequiredSunburstAction;
function requireSunburstAction() {
  if (hasRequiredSunburstAction)
    return sunburstAction;
  hasRequiredSunburstAction = 1;
  var echarts$12 = echarts;
  var helper2 = requireTreeHelper();
  var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
  echarts$12.registerAction({
    type: ROOT_TO_NODE_ACTION,
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: payload
    }, handleRootToNode);
    function handleRootToNode(model2, index2) {
      var targetInfo = helper2.retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model2);
      if (targetInfo) {
        var originViewRoot = model2.getViewRoot();
        if (originViewRoot) {
          payload.direction = helper2.aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model2.resetViewRoot(targetInfo.node);
      }
    }
  });
  var HIGHLIGHT_ACTION = "sunburstHighlight";
  echarts$12.registerAction({
    type: HIGHLIGHT_ACTION,
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: payload
    }, handleHighlight);
    function handleHighlight(model2, index2) {
      var targetInfo = helper2.retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model2);
      if (targetInfo) {
        payload.highlight = targetInfo.node;
      }
    }
  });
  var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
  echarts$12.registerAction({
    type: UNHIGHLIGHT_ACTION,
    update: "updateView"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: payload
    }, handleUnhighlight);
    function handleUnhighlight(model2, index2) {
      payload.unhighlight = true;
    }
  });
  return sunburstAction;
}
var sunburstLayout;
var hasRequiredSunburstLayout;
function requireSunburstLayout() {
  if (hasRequiredSunburstLayout)
    return sunburstLayout;
  hasRequiredSunburstLayout = 1;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var zrUtil2 = util$6;
  var RADIAN = Math.PI / 180;
  function _default2(seriesType2, ecModel, api, payload) {
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      var center2 = seriesModel.get("center");
      var radius = seriesModel.get("radius");
      if (!zrUtil2.isArray(radius)) {
        radius = [0, radius];
      }
      if (!zrUtil2.isArray(center2)) {
        center2 = [center2, center2];
      }
      var width = api.getWidth();
      var height = api.getHeight();
      var size2 = Math.min(width, height);
      var cx = parsePercent2(center2[0], width);
      var cy = parsePercent2(center2[1], height);
      var r0 = parsePercent2(radius[0], size2 / 2);
      var r = parsePercent2(radius[1], size2 / 2);
      var startAngle = -seriesModel.get("startAngle") * RADIAN;
      var minAngle = seriesModel.get("minAngle") * RADIAN;
      var virtualRoot = seriesModel.getData().tree.root;
      var treeRoot = seriesModel.getViewRoot();
      var rootDepth = treeRoot.depth;
      var sort3 = seriesModel.get("sort");
      if (sort3 != null) {
        initChildren(treeRoot, sort3);
      }
      var validDataCount = 0;
      zrUtil2.each(treeRoot.children, function(child) {
        !isNaN(child.getValue()) && validDataCount++;
      });
      var sum = treeRoot.getValue();
      var unitRadian = Math.PI / (sum || validDataCount) * 2;
      var renderRollupNode = treeRoot.depth > 0;
      var levels = treeRoot.height - (renderRollupNode ? -1 : 1);
      var rPerLevel = (r - r0) / (levels || 1);
      var clockwise = seriesModel.get("clockwise");
      var stillShowZeroSum = seriesModel.get("stillShowZeroSum");
      var dir = clockwise ? 1 : -1;
      var renderNode = function(node, startAngle2) {
        if (!node) {
          return;
        }
        var endAngle = startAngle2;
        if (node !== virtualRoot) {
          var value = node.getValue();
          var angle2 = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
          if (angle2 < minAngle) {
            angle2 = minAngle;
          }
          endAngle = startAngle2 + dir * angle2;
          var depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
          var rStart2 = r0 + rPerLevel * depth;
          var rEnd2 = r0 + rPerLevel * (depth + 1);
          var itemModel = node.getModel();
          if (itemModel.get("r0") != null) {
            rStart2 = parsePercent2(itemModel.get("r0"), size2 / 2);
          }
          if (itemModel.get("r") != null) {
            rEnd2 = parsePercent2(itemModel.get("r"), size2 / 2);
          }
          node.setLayout({
            angle: angle2,
            startAngle: startAngle2,
            endAngle,
            clockwise,
            cx,
            cy,
            r0: rStart2,
            r: rEnd2
          });
        }
        if (node.children && node.children.length) {
          var siblingAngle = 0;
          zrUtil2.each(node.children, function(node2) {
            siblingAngle += renderNode(node2, startAngle2 + siblingAngle);
          });
        }
        return endAngle - startAngle2;
      };
      if (renderRollupNode) {
        var rStart = r0;
        var rEnd = r0 + rPerLevel;
        var angle = Math.PI * 2;
        virtualRoot.setLayout({
          angle,
          startAngle,
          endAngle: startAngle + angle,
          clockwise,
          cx,
          cy,
          r0: rStart,
          r: rEnd
        });
      }
      renderNode(treeRoot, startAngle);
    });
  }
  function initChildren(node, isAsc) {
    var children = node.children || [];
    node.children = sort2(children, isAsc);
    if (children.length) {
      zrUtil2.each(node.children, function(child) {
        initChildren(child, isAsc);
      });
    }
  }
  function sort2(children, sortOrder) {
    if (typeof sortOrder === "function") {
      return children.sort(sortOrder);
    } else {
      var isAsc = sortOrder === "asc";
      return children.sort(function(a, b) {
        var diff2 = (a.getValue() - b.getValue()) * (isAsc ? 1 : -1);
        return diff2 === 0 ? (a.dataIndex - b.dataIndex) * (isAsc ? -1 : 1) : diff2;
      });
    }
  }
  sunburstLayout = _default2;
  return sunburstLayout;
}
var hasRequiredSunburst;
function requireSunburst() {
  if (hasRequiredSunburst)
    return sunburst;
  hasRequiredSunburst = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  requireSunburstSeries();
  requireSunburstView();
  requireSunburstAction();
  var dataColor2 = requireDataColor();
  var sunburstLayout2 = requireSunburstLayout();
  var dataFilter2 = requireDataFilter();
  echarts$12.registerVisual(zrUtil2.curry(dataColor2, "sunburst"));
  echarts$12.registerLayout(zrUtil2.curry(sunburstLayout2, "sunburst"));
  echarts$12.registerProcessor(zrUtil2.curry(dataFilter2, "sunburst"));
  return sunburst;
}
var custom = {};
var prepareCustom$4;
var hasRequiredPrepareCustom$4;
function requirePrepareCustom$4() {
  if (hasRequiredPrepareCustom$4)
    return prepareCustom$4;
  hasRequiredPrepareCustom$4 = 1;
  var zrUtil2 = util$6;
  function dataToCoordSize(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return zrUtil2.map(["x", "y"], function(dim, dimIdx) {
      var axis2 = this.getAxis(dim);
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      return axis2.type === "category" ? axis2.getBandWidth() : Math.abs(axis2.dataToCoord(val - halfSize) - axis2.dataToCoord(val + halfSize));
    }, this);
  }
  function _default2(coordSys) {
    var rect = coordSys.grid.getRect();
    return {
      coordSys: {
        // The name exposed to user is always 'cartesian2d' but not 'grid'.
        type: "cartesian2d",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function(data) {
          return coordSys.dataToPoint(data);
        },
        size: zrUtil2.bind(dataToCoordSize, coordSys)
      }
    };
  }
  prepareCustom$4 = _default2;
  return prepareCustom$4;
}
var prepareCustom$3;
var hasRequiredPrepareCustom$3;
function requirePrepareCustom$3() {
  if (hasRequiredPrepareCustom$3)
    return prepareCustom$3;
  hasRequiredPrepareCustom$3 = 1;
  var zrUtil2 = util$6;
  function dataToCoordSize(dataSize, dataItem) {
    dataItem = dataItem || [0, 0];
    return zrUtil2.map([0, 1], function(dimIdx) {
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      var p1 = [];
      var p2 = [];
      p1[dimIdx] = val - halfSize;
      p2[dimIdx] = val + halfSize;
      p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
      return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
    }, this);
  }
  function _default2(coordSys) {
    var rect = coordSys.getBoundingRect();
    return {
      coordSys: {
        type: "geo",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        zoom: coordSys.getZoom()
      },
      api: {
        coord: function(data) {
          return coordSys.dataToPoint(data);
        },
        size: zrUtil2.bind(dataToCoordSize, coordSys)
      }
    };
  }
  prepareCustom$3 = _default2;
  return prepareCustom$3;
}
var prepareCustom$2;
var hasRequiredPrepareCustom$2;
function requirePrepareCustom$2() {
  if (hasRequiredPrepareCustom$2)
    return prepareCustom$2;
  hasRequiredPrepareCustom$2 = 1;
  var zrUtil2 = util$6;
  function dataToCoordSize(dataSize, dataItem) {
    var axis2 = this.getAxis();
    var val = dataItem instanceof Array ? dataItem[0] : dataItem;
    var halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
    return axis2.type === "category" ? axis2.getBandWidth() : Math.abs(axis2.dataToCoord(val - halfSize) - axis2.dataToCoord(val + halfSize));
  }
  function _default2(coordSys) {
    var rect = coordSys.getRect();
    return {
      coordSys: {
        type: "singleAxis",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function(val) {
          return coordSys.dataToPoint(val);
        },
        size: zrUtil2.bind(dataToCoordSize, coordSys)
      }
    };
  }
  prepareCustom$2 = _default2;
  return prepareCustom$2;
}
var prepareCustom$1;
var hasRequiredPrepareCustom$1;
function requirePrepareCustom$1() {
  if (hasRequiredPrepareCustom$1)
    return prepareCustom$1;
  hasRequiredPrepareCustom$1 = 1;
  var zrUtil2 = util$6;
  function dataToCoordSize(dataSize, dataItem) {
    return zrUtil2.map(["Radius", "Angle"], function(dim, dimIdx) {
      var axis2 = this["get" + dim + "Axis"]();
      var val = dataItem[dimIdx];
      var halfSize = dataSize[dimIdx] / 2;
      var method = "dataTo" + dim;
      var result = axis2.type === "category" ? axis2.getBandWidth() : Math.abs(axis2[method](val - halfSize) - axis2[method](val + halfSize));
      if (dim === "Angle") {
        result = result * Math.PI / 180;
      }
      return result;
    }, this);
  }
  function _default2(coordSys) {
    var radiusAxis2 = coordSys.getRadiusAxis();
    var angleAxis2 = coordSys.getAngleAxis();
    var radius = radiusAxis2.getExtent();
    radius[0] > radius[1] && radius.reverse();
    return {
      coordSys: {
        type: "polar",
        cx: coordSys.cx,
        cy: coordSys.cy,
        r: radius[1],
        r0: radius[0]
      },
      api: {
        coord: zrUtil2.bind(function(data) {
          var radius2 = radiusAxis2.dataToRadius(data[0]);
          var angle = angleAxis2.dataToAngle(data[1]);
          var coord = coordSys.coordToPoint([radius2, angle]);
          coord.push(radius2, angle * Math.PI / 180);
          return coord;
        }),
        size: zrUtil2.bind(dataToCoordSize, coordSys)
      }
    };
  }
  prepareCustom$1 = _default2;
  return prepareCustom$1;
}
var prepareCustom;
var hasRequiredPrepareCustom;
function requirePrepareCustom() {
  if (hasRequiredPrepareCustom)
    return prepareCustom;
  hasRequiredPrepareCustom = 1;
  function _default2(coordSys) {
    var rect = coordSys.getRect();
    var rangeInfo = coordSys.getRangeInfo();
    return {
      coordSys: {
        type: "calendar",
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        cellWidth: coordSys.getCellWidth(),
        cellHeight: coordSys.getCellHeight(),
        rangeInfo: {
          start: rangeInfo.start,
          end: rangeInfo.end,
          weeks: rangeInfo.weeks,
          dayCount: rangeInfo.allDay
        }
      },
      api: {
        coord: function(data, clamp) {
          return coordSys.dataToPoint(data, clamp);
        }
      }
    };
  }
  prepareCustom = _default2;
  return prepareCustom;
}
var hasRequiredCustom;
function requireCustom() {
  if (hasRequiredCustom)
    return custom;
  hasRequiredCustom = 1;
  var zrUtil2 = util$6;
  var graphicUtil2 = graphic$4;
  var _labelHelper = requireLabelHelper();
  var getDefaultLabel = _labelHelper.getDefaultLabel;
  var createListFromArray = requireCreateListFromArray();
  var _barGrid = requireBarGrid();
  var getLayoutOnAxis = _barGrid.getLayoutOnAxis;
  var DataDiffer = requireDataDiffer();
  var SeriesModel2 = Series;
  var Model2 = requireModel();
  var ChartView = Chart_1;
  var _createClipPathFromCoordSys = requireCreateClipPathFromCoordSys();
  var createClipPath = _createClipPathFromCoordSys.createClipPath;
  var prepareCartesian2d = requirePrepareCustom$4();
  var prepareGeo = requirePrepareCustom$3();
  var prepareSingleAxis = requirePrepareCustom$2();
  var preparePolar = requirePrepareCustom$1();
  var prepareCalendar = requirePrepareCustom();
  var CACHED_LABEL_STYLE_PROPERTIES2 = graphicUtil2.CACHED_LABEL_STYLE_PROPERTIES;
  var ITEM_STYLE_NORMAL_PATH = ["itemStyle"];
  var ITEM_STYLE_EMPHASIS_PATH = ["emphasis", "itemStyle"];
  var LABEL_NORMAL = ["label"];
  var LABEL_EMPHASIS = ["emphasis", "label"];
  var GROUP_DIFF_PREFIX = "e\0\0";
  var prepareCustoms = {
    cartesian2d: prepareCartesian2d,
    geo: prepareGeo,
    singleAxis: prepareSingleAxis,
    polar: preparePolar,
    calendar: prepareCalendar
  };
  SeriesModel2.extend({
    type: "series.custom",
    dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
    defaultOption: {
      coordinateSystem: "cartesian2d",
      // Can be set as 'none'
      zlevel: 0,
      z: 2,
      legendHoverLink: true,
      useTransform: true,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      // Only works on polar and cartesian2d coordinate system.
      clip: false
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // label: {}
      // itemStyle: {}
    },
    /**
     * @override
     */
    getInitialData: function(option, ecModel) {
      return createListFromArray(this.getSource(), this);
    },
    /**
     * @override
     */
    getDataParams: function(dataIndex, dataType, el) {
      var params = SeriesModel2.prototype.getDataParams.apply(this, arguments);
      el && (params.info = el.info);
      return params;
    }
  });
  ChartView.extend({
    type: "custom",
    /**
     * @private
     * @type {module:echarts/data/List}
     */
    _data: null,
    /**
     * @override
     */
    render: function(customSeries, ecModel, api, payload) {
      var oldData = this._data;
      var data = customSeries.getData();
      var group = this.group;
      var renderItem = makeRenderItem(customSeries, data, ecModel, api);
      data.diff(oldData).add(function(newIdx) {
        createOrUpdate2(null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
      }).update(function(newIdx, oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        createOrUpdate2(el, newIdx, renderItem(newIdx, payload), customSeries, group, data);
      }).remove(function(oldIdx) {
        var el = oldData.getItemGraphicEl(oldIdx);
        el && group.remove(el);
      }).execute();
      var clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
      if (clipPath) {
        group.setClipPath(clipPath);
      } else {
        group.removeClipPath();
      }
      this._data = data;
    },
    incrementalPrepareRender: function(customSeries, ecModel, api) {
      this.group.removeAll();
      this._data = null;
    },
    incrementalRender: function(params, customSeries, ecModel, api, payload) {
      var data = customSeries.getData();
      var renderItem = makeRenderItem(customSeries, data, ecModel, api);
      function setIncrementalAndHoverLayer(el2) {
        if (!el2.isGroup) {
          el2.incremental = true;
          el2.useHoverLayer = true;
        }
      }
      for (var idx = params.start; idx < params.end; idx++) {
        var el = createOrUpdate2(null, idx, renderItem(idx, payload), customSeries, this.group, data);
        el.traverse(setIncrementalAndHoverLayer);
      }
    },
    /**
     * @override
     */
    dispose: zrUtil2.noop,
    /**
     * @override
     */
    filterForExposedEvent: function(eventType, query, targetEl, packedEvent) {
      var elementName = query.element;
      if (elementName == null || targetEl.name === elementName) {
        return true;
      }
      while ((targetEl = targetEl.parent) && targetEl !== this.group) {
        if (targetEl.name === elementName) {
          return true;
        }
      }
      return false;
    }
  });
  function createEl(elOption) {
    var graphicType = elOption.type;
    var el;
    if (graphicType === "path") {
      var shape = elOption.shape;
      var pathRect = shape.width != null && shape.height != null ? {
        x: shape.x || 0,
        y: shape.y || 0,
        width: shape.width,
        height: shape.height
      } : null;
      var pathData = getPathData(shape);
      el = graphicUtil2.makePath(pathData, null, pathRect, shape.layout || "center");
      el.__customPathData = pathData;
    } else if (graphicType === "image") {
      el = new graphicUtil2.Image({});
      el.__customImagePath = elOption.style.image;
    } else if (graphicType === "text") {
      el = new graphicUtil2.Text({});
      el.__customText = elOption.style.text;
    } else if (graphicType === "group") {
      el = new graphicUtil2.Group();
    } else if (graphicType === "compoundPath") {
      throw new Error('"compoundPath" is not supported yet.');
    } else {
      var Clz = graphicUtil2.getShapeClass(graphicType);
      el = new Clz();
    }
    el.__customGraphicType = graphicType;
    el.name = elOption.name;
    return el;
  }
  function updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot) {
    var transitionProps = {};
    var elOptionStyle = elOption.style || {};
    elOption.shape && (transitionProps.shape = zrUtil2.clone(elOption.shape));
    elOption.position && (transitionProps.position = elOption.position.slice());
    elOption.scale && (transitionProps.scale = elOption.scale.slice());
    elOption.origin && (transitionProps.origin = elOption.origin.slice());
    elOption.rotation && (transitionProps.rotation = elOption.rotation);
    if (el.type === "image" && elOption.style) {
      var targetStyle = transitionProps.style = {};
      zrUtil2.each(["x", "y", "width", "height"], function(prop) {
        prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
      });
    }
    if (el.type === "text" && elOption.style) {
      var targetStyle = transitionProps.style = {};
      zrUtil2.each(["x", "y"], function(prop) {
        prepareStyleTransition(prop, targetStyle, elOptionStyle, el.style, isInit);
      });
      !elOptionStyle.hasOwnProperty("textFill") && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
      !elOptionStyle.hasOwnProperty("textStroke") && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
    }
    if (el.type !== "group") {
      el.useStyle(elOptionStyle);
      if (isInit) {
        el.style.opacity = 0;
        var targetOpacity = elOptionStyle.opacity;
        targetOpacity == null && (targetOpacity = 1);
        graphicUtil2.initProps(el, {
          style: {
            opacity: targetOpacity
          }
        }, animatableModel, dataIndex);
      }
    }
    if (isInit) {
      el.attr(transitionProps);
    } else {
      graphicUtil2.updateProps(el, transitionProps, animatableModel, dataIndex);
    }
    elOption.hasOwnProperty("z2") && el.attr("z2", elOption.z2 || 0);
    elOption.hasOwnProperty("silent") && el.attr("silent", elOption.silent);
    elOption.hasOwnProperty("invisible") && el.attr("invisible", elOption.invisible);
    elOption.hasOwnProperty("ignore") && el.attr("ignore", elOption.ignore);
    elOption.hasOwnProperty("info") && el.attr("info", elOption.info);
    var styleEmphasis = elOption.styleEmphasis;
    graphicUtil2.setElementHoverStyle(el, styleEmphasis);
    if (isRoot) {
      graphicUtil2.setAsHighDownDispatcher(el, styleEmphasis !== false);
    }
  }
  function prepareStyleTransition(prop, targetStyle, elOptionStyle, oldElStyle, isInit) {
    if (elOptionStyle[prop] != null && !isInit) {
      targetStyle[prop] = elOptionStyle[prop];
      elOptionStyle[prop] = oldElStyle[prop];
    }
  }
  function makeRenderItem(customSeries, data, ecModel, api) {
    var renderItem = customSeries.get("renderItem");
    var coordSys = customSeries.coordinateSystem;
    var prepareResult = {};
    if (coordSys) {
      prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms() : prepareCustoms[coordSys.type](coordSys);
    }
    var userAPI = zrUtil2.defaults({
      getWidth: api.getWidth,
      getHeight: api.getHeight,
      getZr: api.getZr,
      getDevicePixelRatio: api.getDevicePixelRatio,
      value,
      style,
      styleEmphasis,
      visual,
      barLayout,
      currentSeriesIndices,
      font
    }, prepareResult.api || {});
    var userParams = {
      // The life cycle of context: current round of rendering.
      // The global life cycle is probably not necessary, because
      // user can store global status by themselves.
      context: {},
      seriesId: customSeries.id,
      seriesName: customSeries.name,
      seriesIndex: customSeries.seriesIndex,
      coordSys: prepareResult.coordSys,
      dataInsideLength: data.count(),
      encode: wrapEncodeDef(customSeries.getData())
    };
    var currDataIndexInside;
    var currDirty = true;
    var currItemModel;
    var currLabelNormalModel;
    var currLabelEmphasisModel;
    var currVisualColor;
    return function(dataIndexInside, payload) {
      currDataIndexInside = dataIndexInside;
      currDirty = true;
      return renderItem && renderItem(zrUtil2.defaults({
        dataIndexInside,
        dataIndex: data.getRawIndex(dataIndexInside),
        // Can be used for optimization when zoom or roam.
        actionType: payload ? payload.type : null
      }, userParams), userAPI);
    };
    function updateCache(dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      if (currDirty) {
        currItemModel = data.getItemModel(dataIndexInside);
        currLabelNormalModel = currItemModel.getModel(LABEL_NORMAL);
        currLabelEmphasisModel = currItemModel.getModel(LABEL_EMPHASIS);
        currVisualColor = data.getItemVisual(dataIndexInside, "color");
        currDirty = false;
      }
    }
    function value(dim, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      return data.get(data.getDimension(dim || 0), dataIndexInside);
    }
    function style(extra, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      updateCache(dataIndexInside);
      var itemStyle2 = currItemModel.getModel(ITEM_STYLE_NORMAL_PATH).getItemStyle();
      currVisualColor != null && (itemStyle2.fill = currVisualColor);
      var opacity = data.getItemVisual(dataIndexInside, "opacity");
      opacity != null && (itemStyle2.opacity = opacity);
      var labelModel = extra ? applyExtraBefore(extra, currLabelNormalModel) : currLabelNormalModel;
      graphicUtil2.setTextStyle(itemStyle2, labelModel, null, {
        autoColor: currVisualColor,
        isRectText: true
      });
      itemStyle2.text = labelModel.getShallow("show") ? zrUtil2.retrieve2(customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null;
      extra && applyExtraAfter(itemStyle2, extra);
      return itemStyle2;
    }
    function styleEmphasis(extra, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      updateCache(dataIndexInside);
      var itemStyle2 = currItemModel.getModel(ITEM_STYLE_EMPHASIS_PATH).getItemStyle();
      var labelModel = extra ? applyExtraBefore(extra, currLabelEmphasisModel) : currLabelEmphasisModel;
      graphicUtil2.setTextStyle(itemStyle2, labelModel, null, {
        isRectText: true
      }, true);
      itemStyle2.text = labelModel.getShallow("show") ? zrUtil2.retrieve3(customSeries.getFormattedLabel(dataIndexInside, "emphasis"), customSeries.getFormattedLabel(dataIndexInside, "normal"), getDefaultLabel(data, dataIndexInside)) : null;
      extra && applyExtraAfter(itemStyle2, extra);
      return itemStyle2;
    }
    function visual(visualType, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside);
      return data.getItemVisual(dataIndexInside, visualType);
    }
    function barLayout(opt) {
      if (coordSys.getBaseAxis) {
        var baseAxis = coordSys.getBaseAxis();
        return getLayoutOnAxis(zrUtil2.defaults({
          axis: baseAxis
        }, opt), api);
      }
    }
    function currentSeriesIndices() {
      return ecModel.getCurrentSeriesIndices();
    }
    function font(opt) {
      return graphicUtil2.getFont(opt, ecModel);
    }
  }
  function wrapEncodeDef(data) {
    var encodeDef = {};
    zrUtil2.each(data.dimensions, function(dimName, dataDimIndex) {
      var dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isExtraCoord) {
        var coordDim = dimInfo.coordDim;
        var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
        dataDims[dimInfo.coordDimIndex] = dataDimIndex;
      }
    });
    return encodeDef;
  }
  function createOrUpdate2(el, dataIndex, elOption, animatableModel, group, data) {
    el = doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, true);
    el && data.setItemGraphicEl(dataIndex, el);
    return el;
  }
  function doCreateOrUpdate(el, dataIndex, elOption, animatableModel, group, data, isRoot) {
    var simplyRemove = !elOption;
    elOption = elOption || {};
    var elOptionType = elOption.type;
    var elOptionShape = elOption.shape;
    var elOptionStyle = elOption.style;
    if (el && (simplyRemove || elOptionType != null && elOptionType !== el.__customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== el.__customPathData || elOptionType === "image" && hasOwn2(elOptionStyle, "image") && elOptionStyle.image !== el.__customImagePath || elOptionType === "text" && hasOwn2(elOptionShape, "text") && elOptionStyle.text !== el.__customText)) {
      group.remove(el);
      el = null;
    }
    if (simplyRemove) {
      return;
    }
    var isInit = !el;
    !el && (el = createEl(elOption));
    updateEl(el, dataIndex, elOption, animatableModel, data, isInit, isRoot);
    if (elOptionType === "group") {
      mergeChildren(el, dataIndex, elOption, animatableModel, data);
    }
    group.add(el);
    return el;
  }
  function mergeChildren(el, dataIndex, elOption, animatableModel, data) {
    var newChildren = elOption.children;
    var newLen = newChildren ? newChildren.length : 0;
    var mergeChildren2 = elOption.$mergeChildren;
    var byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
    var notMerge = mergeChildren2 === false;
    if (!newLen && !byName && !notMerge) {
      return;
    }
    if (byName) {
      diffGroupChildren({
        oldChildren: el.children() || [],
        newChildren: newChildren || [],
        dataIndex,
        animatableModel,
        group: el,
        data
      });
      return;
    }
    notMerge && el.removeAll();
    var index2 = 0;
    for (; index2 < newLen; index2++) {
      newChildren[index2] && doCreateOrUpdate(el.childAt(index2), dataIndex, newChildren[index2], animatableModel, el, data);
    }
  }
  function diffGroupChildren(context) {
    new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
  }
  function getKey(item, idx) {
    var name2 = item && item.name;
    return name2 != null ? name2 : GROUP_DIFF_PREFIX + idx;
  }
  function processAddUpdate(newIndex, oldIndex) {
    var context = this.context;
    var childOption = newIndex != null ? context.newChildren[newIndex] : null;
    var child = oldIndex != null ? context.oldChildren[oldIndex] : null;
    doCreateOrUpdate(child, context.dataIndex, childOption, context.animatableModel, context.group, context.data);
  }
  function applyExtraBefore(extra, model2) {
    var dummyModel = new Model2({}, model2);
    zrUtil2.each(CACHED_LABEL_STYLE_PROPERTIES2, function(stylePropName, modelPropName) {
      if (extra.hasOwnProperty(stylePropName)) {
        dummyModel.option[modelPropName] = extra[stylePropName];
      }
    });
    return dummyModel;
  }
  function applyExtraAfter(itemStyle2, extra) {
    for (var key in extra) {
      if (extra.hasOwnProperty(key) || !CACHED_LABEL_STYLE_PROPERTIES2.hasOwnProperty(key)) {
        itemStyle2[key] = extra[key];
      }
    }
  }
  function processRemove(oldIndex) {
    var context = this.context;
    var child = context.oldChildren[oldIndex];
    child && context.group.remove(child);
  }
  function getPathData(shape) {
    return shape && (shape.pathData || shape.d);
  }
  function hasOwnPathData(shape) {
    return shape && (shape.hasOwnProperty("pathData") || shape.hasOwnProperty("d"));
  }
  function hasOwn2(host2, prop) {
    return host2 && host2.hasOwnProperty(prop);
  }
  return custom;
}
var grid = {};
var hasRequiredGrid;
function requireGrid() {
  if (hasRequiredGrid)
    return grid;
  hasRequiredGrid = 1;
  requireGridSimple();
  requireCartesianAxisPointer();
  requireAxisPointer();
  return grid;
}
var polar = {};
var barPolar;
var hasRequiredBarPolar;
function requireBarPolar() {
  if (hasRequiredBarPolar)
    return barPolar;
  hasRequiredBarPolar = 1;
  var zrUtil2 = util$6;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var _dataStackHelper = requireDataStackHelper();
  var isDimensionStacked = _dataStackHelper.isDimensionStacked;
  function getSeriesStackId(seriesModel) {
    return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
  }
  function getAxisKey(polar2, axis2) {
    return axis2.dim + polar2.model.componentIndex;
  }
  function barLayoutPolar(seriesType2, ecModel, api) {
    var lastStackCoords = {};
    var barWidthAndOffset = calRadialBar(zrUtil2.filter(ecModel.getSeriesByType(seriesType2), function(seriesModel) {
      return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
    }));
    ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
      if (seriesModel.coordinateSystem.type !== "polar") {
        return;
      }
      var data = seriesModel.getData();
      var polar2 = seriesModel.coordinateSystem;
      var baseAxis = polar2.getBaseAxis();
      var axisKey = getAxisKey(polar2, baseAxis);
      var stackId = getSeriesStackId(seriesModel);
      var columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
      var columnOffset = columnLayoutInfo.offset;
      var columnWidth = columnLayoutInfo.width;
      var valueAxis = polar2.getOtherAxis(baseAxis);
      var cx = seriesModel.coordinateSystem.cx;
      var cy = seriesModel.coordinateSystem.cy;
      var barMinHeight = seriesModel.get("barMinHeight") || 0;
      var barMinAngle = seriesModel.get("barMinAngle") || 0;
      lastStackCoords[stackId] = lastStackCoords[stackId] || [];
      var valueDim = data.mapDimension(valueAxis.dim);
      var baseDim = data.mapDimension(baseAxis.dim);
      var stacked = isDimensionStacked(
        data,
        valueDim
        /*, baseDim*/
      );
      var clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
      var valueAxisStart = valueAxis.dim === "radius" ? valueAxis.dataToRadius(0) : valueAxis.dataToAngle(0);
      for (var idx = 0, len = data.count(); idx < len; idx++) {
        var value = data.get(valueDim, idx);
        var baseValue = data.get(baseDim, idx);
        var sign = value >= 0 ? "p" : "n";
        var baseCoord = valueAxisStart;
        if (stacked) {
          if (!lastStackCoords[stackId][baseValue]) {
            lastStackCoords[stackId][baseValue] = {
              p: valueAxisStart,
              // Positive stack
              n: valueAxisStart
              // Negative stack
            };
          }
          baseCoord = lastStackCoords[stackId][baseValue][sign];
        }
        var r0;
        var r;
        var startAngle;
        var endAngle;
        if (valueAxis.dim === "radius") {
          var radiusSpan = valueAxis.dataToRadius(value) - valueAxisStart;
          var angle = baseAxis.dataToAngle(baseValue);
          if (Math.abs(radiusSpan) < barMinHeight) {
            radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
          }
          r0 = baseCoord;
          r = baseCoord + radiusSpan;
          startAngle = angle - columnOffset;
          endAngle = startAngle - columnWidth;
          stacked && (lastStackCoords[stackId][baseValue][sign] = r);
        } else {
          var angleSpan = valueAxis.dataToAngle(value, clampLayout) - valueAxisStart;
          var radius = baseAxis.dataToRadius(baseValue);
          if (Math.abs(angleSpan) < barMinAngle) {
            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
          }
          r0 = radius + columnOffset;
          r = r0 + columnWidth;
          startAngle = baseCoord;
          endAngle = baseCoord + angleSpan;
          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
        }
        data.setItemLayout(idx, {
          cx,
          cy,
          r0,
          r,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -startAngle * Math.PI / 180,
          endAngle: -endAngle * Math.PI / 180
        });
      }
    }, this);
  }
  function calRadialBar(barSeries, api) {
    var columnsMap = {};
    zrUtil2.each(barSeries, function(seriesModel, idx) {
      var data = seriesModel.getData();
      var polar2 = seriesModel.coordinateSystem;
      var baseAxis = polar2.getBaseAxis();
      var axisKey = getAxisKey(polar2, baseAxis);
      var axisExtent = baseAxis.getExtent();
      var bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
      var columnsOnAxis = columnsMap[axisKey] || {
        bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: "20%",
        gap: "30%",
        stacks: {}
      };
      var stacks = columnsOnAxis.stacks;
      columnsMap[axisKey] = columnsOnAxis;
      var stackId = getSeriesStackId(seriesModel);
      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++;
      }
      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      };
      var barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
      var barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
      var barGap = seriesModel.get("barGap");
      var barCategoryGap = seriesModel.get("barCategoryGap");
      if (barWidth && !stacks[stackId].width) {
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
        stacks[stackId].width = barWidth;
        columnsOnAxis.remainedWidth -= barWidth;
      }
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
      barGap != null && (columnsOnAxis.gap = barGap);
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
    });
    var result = {};
    zrUtil2.each(columnsMap, function(columnsOnAxis, coordSysName) {
      result[coordSysName] = {};
      var stacks = columnsOnAxis.stacks;
      var bandWidth = columnsOnAxis.bandWidth;
      var categoryGap = parsePercent2(columnsOnAxis.categoryGap, bandWidth);
      var barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
      var remainedWidth = columnsOnAxis.remainedWidth;
      var autoWidthCount = columnsOnAxis.autoWidthCount;
      var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      zrUtil2.each(stacks, function(column, stack2) {
        var maxWidth = column.maxWidth;
        if (maxWidth && maxWidth < autoWidth) {
          maxWidth = Math.min(maxWidth, remainedWidth);
          if (column.width) {
            maxWidth = Math.min(maxWidth, column.width);
          }
          remainedWidth -= maxWidth;
          column.width = maxWidth;
          autoWidthCount--;
        }
      });
      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
      autoWidth = Math.max(autoWidth, 0);
      var widthSum = 0;
      var lastColumn;
      zrUtil2.each(stacks, function(column, idx) {
        if (!column.width) {
          column.width = autoWidth;
        }
        lastColumn = column;
        widthSum += column.width * (1 + barGapPercent);
      });
      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent;
      }
      var offset = -widthSum / 2;
      zrUtil2.each(stacks, function(column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          offset,
          width: column.width
        };
        offset += column.width * (1 + barGapPercent);
      });
    });
    return result;
  }
  var _default2 = barLayoutPolar;
  barPolar = _default2;
  return barPolar;
}
var polarCreator = {};
var RadiusAxis_1;
var hasRequiredRadiusAxis$1;
function requireRadiusAxis$1() {
  if (hasRequiredRadiusAxis$1)
    return RadiusAxis_1;
  hasRequiredRadiusAxis$1 = 1;
  var zrUtil2 = util$6;
  var Axis = requireAxis$1();
  function RadiusAxis(scale, radiusExtent) {
    Axis.call(this, "radius", scale, radiusExtent);
    this.type = "category";
  }
  RadiusAxis.prototype = {
    constructor: RadiusAxis,
    /**
     * @override
     */
    pointToData: function(point, clamp) {
      return this.polar.pointToData(point, clamp)[this.dim === "radius" ? 0 : 1];
    },
    dataToRadius: Axis.prototype.dataToCoord,
    radiusToData: Axis.prototype.coordToData
  };
  zrUtil2.inherits(RadiusAxis, Axis);
  var _default2 = RadiusAxis;
  RadiusAxis_1 = _default2;
  return RadiusAxis_1;
}
var AngleAxis_1;
var hasRequiredAngleAxis$1;
function requireAngleAxis$1() {
  if (hasRequiredAngleAxis$1)
    return AngleAxis_1;
  hasRequiredAngleAxis$1 = 1;
  var zrUtil2 = util$6;
  var textContain2 = text;
  var Axis = requireAxis$1();
  var _model2 = model;
  var makeInner2 = _model2.makeInner;
  var inner2 = makeInner2();
  function AngleAxis(scale, angleExtent) {
    angleExtent = angleExtent || [0, 360];
    Axis.call(this, "angle", scale, angleExtent);
    this.type = "category";
  }
  AngleAxis.prototype = {
    constructor: AngleAxis,
    /**
     * @override
     */
    pointToData: function(point, clamp) {
      return this.polar.pointToData(point, clamp)[this.dim === "radius" ? 0 : 1];
    },
    dataToAngle: Axis.prototype.dataToCoord,
    angleToData: Axis.prototype.coordToData,
    /**
     * Only be called in category axis.
     * Angle axis uses text height to decide interval
     *
     * @override
     * @return {number} Auto interval for cateogry axis tick and label
     */
    calculateCategoryInterval: function() {
      var axis2 = this;
      var labelModel = axis2.getLabelModel();
      var ordinalScale = axis2.scale;
      var ordinalExtent = ordinalScale.getExtent();
      var tickCount = ordinalScale.count();
      if (ordinalExtent[1] - ordinalExtent[0] < 1) {
        return 0;
      }
      var tickValue = ordinalExtent[0];
      var unitSpan = axis2.dataToCoord(tickValue + 1) - axis2.dataToCoord(tickValue);
      var unitH = Math.abs(unitSpan);
      var rect = textContain2.getBoundingRect(tickValue, labelModel.getFont(), "center", "top");
      var maxH = Math.max(rect.height, 7);
      var dh = maxH / unitH;
      isNaN(dh) && (dh = Infinity);
      var interval = Math.max(0, Math.floor(dh));
      var cache = inner2(axis2.model);
      var lastAutoInterval = cache.lastAutoInterval;
      var lastTickCount = cache.lastTickCount;
      if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
        interval = lastAutoInterval;
      } else {
        cache.lastTickCount = tickCount;
        cache.lastAutoInterval = interval;
      }
      return interval;
    }
  };
  zrUtil2.inherits(AngleAxis, Axis);
  var _default2 = AngleAxis;
  AngleAxis_1 = _default2;
  return AngleAxis_1;
}
var Polar_1;
var hasRequiredPolar$1;
function requirePolar$1() {
  if (hasRequiredPolar$1)
    return Polar_1;
  hasRequiredPolar$1 = 1;
  var RadiusAxis = requireRadiusAxis$1();
  var AngleAxis = requireAngleAxis$1();
  var Polar = function(name2) {
    this.name = name2 || "";
    this.cx = 0;
    this.cy = 0;
    this._radiusAxis = new RadiusAxis();
    this._angleAxis = new AngleAxis();
    this._radiusAxis.polar = this._angleAxis.polar = this;
  };
  Polar.prototype = {
    type: "polar",
    axisPointerEnabled: true,
    constructor: Polar,
    /**
     * @param {Array.<string>}
     * @readOnly
     */
    dimensions: ["radius", "angle"],
    /**
     * @type {module:echarts/coord/PolarModel}
     */
    model: null,
    /**
     * If contain coord
     * @param {Array.<number>} point
     * @return {boolean}
     */
    containPoint: function(point) {
      var coord = this.pointToCoord(point);
      return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
    },
    /**
     * If contain data
     * @param {Array.<number>} data
     * @return {boolean}
     */
    containData: function(data) {
      return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
    },
    /**
     * @param {string} dim
     * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
     */
    getAxis: function(dim) {
      return this["_" + dim + "Axis"];
    },
    /**
     * @return {Array.<module:echarts/coord/Axis>}
     */
    getAxes: function() {
      return [this._radiusAxis, this._angleAxis];
    },
    /**
     * Get axes by type of scale
     * @param {string} scaleType
     * @return {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
     */
    getAxesByScale: function(scaleType) {
      var axes = [];
      var angleAxis2 = this._angleAxis;
      var radiusAxis2 = this._radiusAxis;
      angleAxis2.scale.type === scaleType && axes.push(angleAxis2);
      radiusAxis2.scale.type === scaleType && axes.push(radiusAxis2);
      return axes;
    },
    /**
     * @return {module:echarts/coord/polar/AngleAxis}
     */
    getAngleAxis: function() {
      return this._angleAxis;
    },
    /**
     * @return {module:echarts/coord/polar/RadiusAxis}
     */
    getRadiusAxis: function() {
      return this._radiusAxis;
    },
    /**
     * @param {module:echarts/coord/polar/Axis}
     * @return {module:echarts/coord/polar/Axis}
     */
    getOtherAxis: function(axis2) {
      var angleAxis2 = this._angleAxis;
      return axis2 === angleAxis2 ? this._radiusAxis : angleAxis2;
    },
    /**
     * Base axis will be used on stacking.
     *
     * @return {module:echarts/coord/polar/Axis}
     */
    getBaseAxis: function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    },
    /**
     * @param {string} [dim] 'radius' or 'angle' or 'auto' or null/undefined
     * @return {Object} {baseAxes: [], otherAxes: []}
     */
    getTooltipAxes: function(dim) {
      var baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
      return {
        baseAxes: [baseAxis],
        otherAxes: [this.getOtherAxis(baseAxis)]
      };
    },
    /**
     * Convert a single data item to (x, y) point.
     * Parameter data is an array which the first element is radius and the second is angle
     * @param {Array.<number>} data
     * @param {boolean} [clamp=false]
     * @return {Array.<number>}
     */
    dataToPoint: function(data, clamp) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)]);
    },
    /**
     * Convert a (x, y) point to data
     * @param {Array.<number>} point
     * @param {boolean} [clamp=false]
     * @return {Array.<number>}
     */
    pointToData: function(point, clamp) {
      var coord = this.pointToCoord(point);
      return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)];
    },
    /**
     * Convert a (x, y) point to (radius, angle) coord
     * @param {Array.<number>} point
     * @return {Array.<number>}
     */
    pointToCoord: function(point) {
      var dx = point[0] - this.cx;
      var dy = point[1] - this.cy;
      var angleAxis2 = this.getAngleAxis();
      var extent = angleAxis2.getExtent();
      var minAngle = Math.min(extent[0], extent[1]);
      var maxAngle = Math.max(extent[0], extent[1]);
      angleAxis2.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
      var radius = Math.sqrt(dx * dx + dy * dy);
      dx /= radius;
      dy /= radius;
      var radian = Math.atan2(-dy, dx) / Math.PI * 180;
      var dir = radian < minAngle ? 1 : -1;
      while (radian < minAngle || radian > maxAngle) {
        radian += dir * 360;
      }
      return [radius, radian];
    },
    /**
     * Convert a (radius, angle) coord to (x, y) point
     * @param {Array.<number>} coord
     * @return {Array.<number>}
     */
    coordToPoint: function(coord) {
      var radius = coord[0];
      var radian = coord[1] / 180 * Math.PI;
      var x = Math.cos(radian) * radius + this.cx;
      var y = -Math.sin(radian) * radius + this.cy;
      return [x, y];
    },
    /**
     * Get ring area of cartesian.
     * Area will have a contain function to determine if a point is in the coordinate system.
     * @return {Ring}
     */
    getArea: function() {
      var angleAxis2 = this.getAngleAxis();
      var radiusAxis2 = this.getRadiusAxis();
      var radiusExtent = radiusAxis2.getExtent().slice();
      radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
      var angleExtent = angleAxis2.getExtent();
      var RADIAN = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: radiusExtent[0],
        r: radiusExtent[1],
        startAngle: -angleExtent[0] * RADIAN,
        endAngle: -angleExtent[1] * RADIAN,
        clockwise: angleAxis2.inverse,
        contain: function(x, y) {
          var dx = x - this.cx;
          var dy = y - this.cy;
          var d2 = dx * dx + dy * dy;
          var r = this.r;
          var r0 = this.r0;
          return d2 <= r * r && d2 >= r0 * r0;
        }
      };
    }
  };
  var _default2 = Polar;
  Polar_1 = _default2;
  return Polar_1;
}
var AxisModel = {};
var hasRequiredAxisModel;
function requireAxisModel() {
  if (hasRequiredAxisModel)
    return AxisModel;
  hasRequiredAxisModel = 1;
  var zrUtil2 = util$6;
  var ComponentModel2 = Component$2;
  var axisModelCreator2 = requireAxisModelCreator();
  var axisModelCommonMixin2 = requireAxisModelCommonMixin();
  var PolarAxisModel = ComponentModel2.extend({
    type: "polarAxis",
    /**
     * @type {module:echarts/coord/polar/AngleAxis|module:echarts/coord/polar/RadiusAxis}
     */
    axis: null,
    /**
     * @override
     */
    getCoordSysModel: function() {
      return this.ecModel.queryComponents({
        mainType: "polar",
        index: this.option.polarIndex,
        id: this.option.polarId
      })[0];
    }
  });
  zrUtil2.merge(PolarAxisModel.prototype, axisModelCommonMixin2);
  var polarAxisDefaultExtendedOption = {
    angle: {
      // polarIndex: 0,
      // polarId: '',
      startAngle: 90,
      clockwise: true,
      splitNumber: 12,
      axisLabel: {
        rotate: false
      }
    },
    radius: {
      // polarIndex: 0,
      // polarId: '',
      splitNumber: 5
    }
  };
  function getAxisType(axisDim, option) {
    return option.type || (option.data ? "category" : "value");
  }
  axisModelCreator2("angle", PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);
  axisModelCreator2("radius", PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius);
  return AxisModel;
}
var PolarModel;
var hasRequiredPolarModel;
function requirePolarModel() {
  if (hasRequiredPolarModel)
    return PolarModel;
  hasRequiredPolarModel = 1;
  var echarts$12 = echarts;
  requireAxisModel();
  var _default2 = echarts$12.extendComponentModel({
    type: "polar",
    dependencies: ["polarAxis", "angleAxis"],
    /**
     * @type {module:echarts/coord/polar/Polar}
     */
    coordinateSystem: null,
    /**
     * @param {string} axisType
     * @return {module:echarts/coord/polar/AxisModel}
     */
    findAxisModel: function(axisType) {
      var foundAxisModel;
      var ecModel = this.ecModel;
      ecModel.eachComponent(axisType, function(axisModel) {
        if (axisModel.getCoordSysModel() === this) {
          foundAxisModel = axisModel;
        }
      }, this);
      return foundAxisModel;
    },
    defaultOption: {
      zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }
  });
  PolarModel = _default2;
  return PolarModel;
}
var hasRequiredPolarCreator;
function requirePolarCreator() {
  if (hasRequiredPolarCreator)
    return polarCreator;
  hasRequiredPolarCreator = 1;
  var zrUtil2 = util$6;
  var Polar = requirePolar$1();
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var _axisHelper = requireAxisHelper();
  var createScaleByModel = _axisHelper.createScaleByModel;
  var niceScaleExtent = _axisHelper.niceScaleExtent;
  var CoordinateSystem$1 = CoordinateSystem;
  var _dataStackHelper = requireDataStackHelper();
  var getStackedDimension = _dataStackHelper.getStackedDimension;
  requirePolarModel();
  function resizePolar(polar2, polarModel, api) {
    var center2 = polarModel.get("center");
    var width = api.getWidth();
    var height = api.getHeight();
    polar2.cx = parsePercent2(center2[0], width);
    polar2.cy = parsePercent2(center2[1], height);
    var radiusAxis2 = polar2.getRadiusAxis();
    var size2 = Math.min(width, height) / 2;
    var radius = polarModel.get("radius");
    if (radius == null) {
      radius = [0, "100%"];
    } else if (!zrUtil2.isArray(radius)) {
      radius = [0, radius];
    }
    radius = [parsePercent2(radius[0], size2), parsePercent2(radius[1], size2)];
    radiusAxis2.inverse ? radiusAxis2.setExtent(radius[1], radius[0]) : radiusAxis2.setExtent(radius[0], radius[1]);
  }
  function updatePolarScale(ecModel, api) {
    var polar2 = this;
    var angleAxis2 = polar2.getAngleAxis();
    var radiusAxis2 = polar2.getRadiusAxis();
    angleAxis2.scale.setExtent(Infinity, -Infinity);
    radiusAxis2.scale.setExtent(Infinity, -Infinity);
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem === polar2) {
        var data = seriesModel.getData();
        zrUtil2.each(data.mapDimension("radius", true), function(dim) {
          radiusAxis2.scale.unionExtentFromData(data, getStackedDimension(data, dim));
        });
        zrUtil2.each(data.mapDimension("angle", true), function(dim) {
          angleAxis2.scale.unionExtentFromData(data, getStackedDimension(data, dim));
        });
      }
    });
    niceScaleExtent(angleAxis2.scale, angleAxis2.model);
    niceScaleExtent(radiusAxis2.scale, radiusAxis2.model);
    if (angleAxis2.type === "category" && !angleAxis2.onBand) {
      var extent = angleAxis2.getExtent();
      var diff2 = 360 / angleAxis2.scale.count();
      angleAxis2.inverse ? extent[1] += diff2 : extent[1] -= diff2;
      angleAxis2.setExtent(extent[0], extent[1]);
    }
  }
  function setAxis(axis2, axisModel) {
    axis2.type = axisModel.get("type");
    axis2.scale = createScaleByModel(axisModel);
    axis2.onBand = axisModel.get("boundaryGap") && axis2.type === "category";
    axis2.inverse = axisModel.get("inverse");
    if (axisModel.mainType === "angleAxis") {
      axis2.inverse ^= axisModel.get("clockwise");
      var startAngle = axisModel.get("startAngle");
      axis2.setExtent(startAngle, startAngle + (axis2.inverse ? -360 : 360));
    }
    axisModel.axis = axis2;
    axis2.model = axisModel;
  }
  var polarCreator$1 = {
    dimensions: Polar.prototype.dimensions,
    create: function(ecModel, api) {
      var polarList = [];
      ecModel.eachComponent("polar", function(polarModel, idx) {
        var polar2 = new Polar(idx);
        polar2.update = updatePolarScale;
        var radiusAxis2 = polar2.getRadiusAxis();
        var angleAxis2 = polar2.getAngleAxis();
        var radiusAxisModel = polarModel.findAxisModel("radiusAxis");
        var angleAxisModel = polarModel.findAxisModel("angleAxis");
        setAxis(radiusAxis2, radiusAxisModel);
        setAxis(angleAxis2, angleAxisModel);
        resizePolar(polar2, polarModel, api);
        polarList.push(polar2);
        polarModel.coordinateSystem = polar2;
        polar2.model = polarModel;
      });
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.get("coordinateSystem") === "polar") {
          var polarModel = ecModel.queryComponents({
            mainType: "polar",
            index: seriesModel.get("polarIndex"),
            id: seriesModel.get("polarId")
          })[0];
          seriesModel.coordinateSystem = polarModel.coordinateSystem;
        }
      });
      return polarList;
    }
  };
  CoordinateSystem$1.register("polar", polarCreator$1);
  return polarCreator;
}
var angleAxis = {};
var AngleAxisView;
var hasRequiredAngleAxisView;
function requireAngleAxisView() {
  if (hasRequiredAngleAxisView)
    return AngleAxisView;
  hasRequiredAngleAxisView = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var Model2 = requireModel();
  var AxisView = requireAxisView();
  var AxisBuilder = requireAxisBuilder();
  var elementList = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
  function getAxisLineShape(polar2, rExtent, angle) {
    rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
    var start = polar2.coordToPoint([rExtent[0], angle]);
    var end = polar2.coordToPoint([rExtent[1], angle]);
    return {
      x1: start[0],
      y1: start[1],
      x2: end[0],
      y2: end[1]
    };
  }
  function getRadiusIdx(polar2) {
    var radiusAxis2 = polar2.getRadiusAxis();
    return radiusAxis2.inverse ? 0 : 1;
  }
  function fixAngleOverlap(list) {
    var firstItem = list[0];
    var lastItem = list[list.length - 1];
    if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
      list.pop();
    }
  }
  var _default2 = AxisView.extend({
    type: "angleAxis",
    axisPointerClass: "PolarAxisPointer",
    render: function(angleAxisModel, ecModel) {
      this.group.removeAll();
      if (!angleAxisModel.get("show")) {
        return;
      }
      var angleAxis2 = angleAxisModel.axis;
      var polar2 = angleAxis2.polar;
      var radiusExtent = polar2.getRadiusAxis().getExtent();
      var ticksAngles = angleAxis2.getTicksCoords();
      var minorTickAngles = angleAxis2.getMinorTicksCoords();
      var labels = zrUtil2.map(angleAxis2.getViewLabels(), function(labelItem) {
        var labelItem = zrUtil2.clone(labelItem);
        labelItem.coord = angleAxis2.dataToCoord(labelItem.tickValue);
        return labelItem;
      });
      fixAngleOverlap(labels);
      fixAngleOverlap(ticksAngles);
      zrUtil2.each(elementList, function(name2) {
        if (angleAxisModel.get(name2 + ".show") && (!angleAxis2.scale.isBlank() || name2 === "axisLine")) {
          this["_" + name2](angleAxisModel, polar2, ticksAngles, minorTickAngles, radiusExtent, labels);
        }
      }, this);
    },
    /**
     * @private
     */
    _axisLine: function(angleAxisModel, polar2, ticksAngles, minorTickAngles, radiusExtent) {
      var lineStyleModel = angleAxisModel.getModel("axisLine.lineStyle");
      var rId = getRadiusIdx(polar2);
      var r0Id = rId ? 0 : 1;
      var shape;
      if (radiusExtent[r0Id] === 0) {
        shape = new graphic2.Circle({
          shape: {
            cx: polar2.cx,
            cy: polar2.cy,
            r: radiusExtent[rId]
          },
          style: lineStyleModel.getLineStyle(),
          z2: 1,
          silent: true
        });
      } else {
        shape = new graphic2.Ring({
          shape: {
            cx: polar2.cx,
            cy: polar2.cy,
            r: radiusExtent[rId],
            r0: radiusExtent[r0Id]
          },
          style: lineStyleModel.getLineStyle(),
          z2: 1,
          silent: true
        });
      }
      shape.style.fill = null;
      this.group.add(shape);
    },
    /**
     * @private
     */
    _axisTick: function(angleAxisModel, polar2, ticksAngles, minorTickAngles, radiusExtent) {
      var tickModel = angleAxisModel.getModel("axisTick");
      var tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
      var radius = radiusExtent[getRadiusIdx(polar2)];
      var lines2 = zrUtil2.map(ticksAngles, function(tickAngleItem) {
        return new graphic2.Line({
          shape: getAxisLineShape(polar2, [radius, radius + tickLen], tickAngleItem.coord)
        });
      });
      this.group.add(graphic2.mergePath(lines2, {
        style: zrUtil2.defaults(tickModel.getModel("lineStyle").getLineStyle(), {
          stroke: angleAxisModel.get("axisLine.lineStyle.color")
        })
      }));
    },
    /**
     * @private
     */
    _minorTick: function(angleAxisModel, polar2, tickAngles, minorTickAngles, radiusExtent) {
      if (!minorTickAngles.length) {
        return;
      }
      var tickModel = angleAxisModel.getModel("axisTick");
      var minorTickModel = angleAxisModel.getModel("minorTick");
      var tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
      var radius = radiusExtent[getRadiusIdx(polar2)];
      var lines2 = [];
      for (var i = 0; i < minorTickAngles.length; i++) {
        for (var k = 0; k < minorTickAngles[i].length; k++) {
          lines2.push(new graphic2.Line({
            shape: getAxisLineShape(polar2, [radius, radius + tickLen], minorTickAngles[i][k].coord)
          }));
        }
      }
      this.group.add(graphic2.mergePath(lines2, {
        style: zrUtil2.defaults(minorTickModel.getModel("lineStyle").getLineStyle(), zrUtil2.defaults(tickModel.getLineStyle(), {
          stroke: angleAxisModel.get("axisLine.lineStyle.color")
        }))
      }));
    },
    /**
     * @private
     */
    _axisLabel: function(angleAxisModel, polar2, ticksAngles, minorTickAngles, radiusExtent, labels) {
      var rawCategoryData = angleAxisModel.getCategories(true);
      var commonLabelModel = angleAxisModel.getModel("axisLabel");
      var labelMargin = commonLabelModel.get("margin");
      var triggerEvent = angleAxisModel.get("triggerEvent");
      zrUtil2.each(labels, function(labelItem, idx) {
        var labelModel = commonLabelModel;
        var tickValue = labelItem.tickValue;
        var r = radiusExtent[getRadiusIdx(polar2)];
        var p2 = polar2.coordToPoint([r + labelMargin, labelItem.coord]);
        var cx = polar2.cx;
        var cy = polar2.cy;
        var labelTextAlign = Math.abs(p2[0] - cx) / r < 0.3 ? "center" : p2[0] > cx ? "left" : "right";
        var labelTextVerticalAlign = Math.abs(p2[1] - cy) / r < 0.3 ? "middle" : p2[1] > cy ? "top" : "bottom";
        if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {
          labelModel = new Model2(rawCategoryData[tickValue].textStyle, commonLabelModel, commonLabelModel.ecModel);
        }
        var textEl = new graphic2.Text({
          silent: AxisBuilder.isLabelSilent(angleAxisModel)
        });
        this.group.add(textEl);
        graphic2.setTextStyle(textEl.style, labelModel, {
          x: p2[0],
          y: p2[1],
          textFill: labelModel.getTextColor() || angleAxisModel.get("axisLine.lineStyle.color"),
          text: labelItem.formattedLabel,
          textAlign: labelTextAlign,
          textVerticalAlign: labelTextVerticalAlign
        });
        if (triggerEvent) {
          textEl.eventData = AxisBuilder.makeAxisEventDataBase(angleAxisModel);
          textEl.eventData.targetType = "axisLabel";
          textEl.eventData.value = labelItem.rawLabel;
        }
      }, this);
    },
    /**
     * @private
     */
    _splitLine: function(angleAxisModel, polar2, ticksAngles, minorTickAngles, radiusExtent) {
      var splitLineModel = angleAxisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var lineCount = 0;
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var splitLines = [];
      for (var i = 0; i < ticksAngles.length; i++) {
        var colorIndex = lineCount++ % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new graphic2.Line({
          shape: getAxisLineShape(polar2, radiusExtent, ticksAngles[i].coord)
        }));
      }
      for (var i = 0; i < splitLines.length; i++) {
        this.group.add(graphic2.mergePath(splitLines[i], {
          style: zrUtil2.defaults({
            stroke: lineColors[i % lineColors.length]
          }, lineStyleModel.getLineStyle()),
          silent: true,
          z: angleAxisModel.get("z")
        }));
      }
    },
    /**
     * @private
     */
    _minorSplitLine: function(angleAxisModel, polar2, ticksAngles, minorTickAngles, radiusExtent) {
      if (!minorTickAngles.length) {
        return;
      }
      var minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var lines2 = [];
      for (var i = 0; i < minorTickAngles.length; i++) {
        for (var k = 0; k < minorTickAngles[i].length; k++) {
          lines2.push(new graphic2.Line({
            shape: getAxisLineShape(polar2, radiusExtent, minorTickAngles[i][k].coord)
          }));
        }
      }
      this.group.add(graphic2.mergePath(lines2, {
        style: lineStyleModel.getLineStyle(),
        silent: true,
        z: angleAxisModel.get("z")
      }));
    },
    /**
     * @private
     */
    _splitArea: function(angleAxisModel, polar2, ticksAngles, minorTickAngles, radiusExtent) {
      if (!ticksAngles.length) {
        return;
      }
      var splitAreaModel = angleAxisModel.getModel("splitArea");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var areaColors = areaStyleModel.get("color");
      var lineCount = 0;
      areaColors = areaColors instanceof Array ? areaColors : [areaColors];
      var splitAreas = [];
      var RADIAN = Math.PI / 180;
      var prevAngle = -ticksAngles[0].coord * RADIAN;
      var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
      var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
      var clockwise = angleAxisModel.get("clockwise");
      for (var i = 1; i < ticksAngles.length; i++) {
        var colorIndex = lineCount++ % areaColors.length;
        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
        splitAreas[colorIndex].push(new graphic2.Sector({
          shape: {
            cx: polar2.cx,
            cy: polar2.cy,
            r0,
            r: r1,
            startAngle: prevAngle,
            endAngle: -ticksAngles[i].coord * RADIAN,
            clockwise
          },
          silent: true
        }));
        prevAngle = -ticksAngles[i].coord * RADIAN;
      }
      for (var i = 0; i < splitAreas.length; i++) {
        this.group.add(graphic2.mergePath(splitAreas[i], {
          style: zrUtil2.defaults({
            fill: areaColors[i % areaColors.length]
          }, areaStyleModel.getAreaStyle()),
          silent: true
        }));
      }
    }
  });
  AngleAxisView = _default2;
  return AngleAxisView;
}
var hasRequiredAngleAxis;
function requireAngleAxis() {
  if (hasRequiredAngleAxis)
    return angleAxis;
  hasRequiredAngleAxis = 1;
  requirePolarCreator();
  requireAngleAxisView();
  return angleAxis;
}
var radiusAxis = {};
var RadiusAxisView;
var hasRequiredRadiusAxisView;
function requireRadiusAxisView() {
  if (hasRequiredRadiusAxisView)
    return RadiusAxisView;
  hasRequiredRadiusAxisView = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var AxisBuilder = requireAxisBuilder();
  var AxisView = requireAxisView();
  var axisBuilderAttrs = ["axisLine", "axisTickLabel", "axisName"];
  var selfBuilderAttrs = ["splitLine", "splitArea", "minorSplitLine"];
  var _default2 = AxisView.extend({
    type: "radiusAxis",
    axisPointerClass: "PolarAxisPointer",
    render: function(radiusAxisModel, ecModel) {
      this.group.removeAll();
      if (!radiusAxisModel.get("show")) {
        return;
      }
      var radiusAxis2 = radiusAxisModel.axis;
      var polar2 = radiusAxis2.polar;
      var angleAxis2 = polar2.getAngleAxis();
      var ticksCoords = radiusAxis2.getTicksCoords();
      var minorTicksCoords = radiusAxis2.getMinorTicksCoords();
      var axisAngle = angleAxis2.getExtent()[0];
      var radiusExtent = radiusAxis2.getExtent();
      var layout2 = layoutAxis(polar2, radiusAxisModel, axisAngle);
      var axisBuilder = new AxisBuilder(radiusAxisModel, layout2);
      zrUtil2.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
      zrUtil2.each(selfBuilderAttrs, function(name2) {
        if (radiusAxisModel.get(name2 + ".show") && !radiusAxis2.scale.isBlank()) {
          this["_" + name2](radiusAxisModel, polar2, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
        }
      }, this);
    },
    /**
     * @private
     */
    _splitLine: function(radiusAxisModel, polar2, axisAngle, radiusExtent, ticksCoords) {
      var splitLineModel = radiusAxisModel.getModel("splitLine");
      var lineStyleModel = splitLineModel.getModel("lineStyle");
      var lineColors = lineStyleModel.get("color");
      var lineCount = 0;
      lineColors = lineColors instanceof Array ? lineColors : [lineColors];
      var splitLines = [];
      for (var i = 0; i < ticksCoords.length; i++) {
        var colorIndex = lineCount++ % lineColors.length;
        splitLines[colorIndex] = splitLines[colorIndex] || [];
        splitLines[colorIndex].push(new graphic2.Circle({
          shape: {
            cx: polar2.cx,
            cy: polar2.cy,
            r: ticksCoords[i].coord
          }
        }));
      }
      for (var i = 0; i < splitLines.length; i++) {
        this.group.add(graphic2.mergePath(splitLines[i], {
          style: zrUtil2.defaults({
            stroke: lineColors[i % lineColors.length],
            fill: null
          }, lineStyleModel.getLineStyle()),
          silent: true
        }));
      }
    },
    /**
     * @private
     */
    _minorSplitLine: function(radiusAxisModel, polar2, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
      if (!minorTicksCoords.length) {
        return;
      }
      var minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
      var lineStyleModel = minorSplitLineModel.getModel("lineStyle");
      var lines2 = [];
      for (var i = 0; i < minorTicksCoords.length; i++) {
        for (var k = 0; k < minorTicksCoords[i].length; k++) {
          lines2.push(new graphic2.Circle({
            shape: {
              cx: polar2.cx,
              cy: polar2.cy,
              r: minorTicksCoords[i][k].coord
            }
          }));
        }
      }
      this.group.add(graphic2.mergePath(lines2, {
        style: zrUtil2.defaults({
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    },
    /**
     * @private
     */
    _splitArea: function(radiusAxisModel, polar2, axisAngle, radiusExtent, ticksCoords) {
      if (!ticksCoords.length) {
        return;
      }
      var splitAreaModel = radiusAxisModel.getModel("splitArea");
      var areaStyleModel = splitAreaModel.getModel("areaStyle");
      var areaColors = areaStyleModel.get("color");
      var lineCount = 0;
      areaColors = areaColors instanceof Array ? areaColors : [areaColors];
      var splitAreas = [];
      var prevRadius = ticksCoords[0].coord;
      for (var i = 1; i < ticksCoords.length; i++) {
        var colorIndex = lineCount++ % areaColors.length;
        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
        splitAreas[colorIndex].push(new graphic2.Sector({
          shape: {
            cx: polar2.cx,
            cy: polar2.cy,
            r0: prevRadius,
            r: ticksCoords[i].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: true
        }));
        prevRadius = ticksCoords[i].coord;
      }
      for (var i = 0; i < splitAreas.length; i++) {
        this.group.add(graphic2.mergePath(splitAreas[i], {
          style: zrUtil2.defaults({
            fill: areaColors[i % areaColors.length]
          }, areaStyleModel.getAreaStyle()),
          silent: true
        }));
      }
    }
  });
  function layoutAxis(polar2, radiusAxisModel, axisAngle) {
    return {
      position: [polar2.cx, polar2.cy],
      rotation: axisAngle / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
      // Over splitLine and splitArea
      z2: 1
    };
  }
  RadiusAxisView = _default2;
  return RadiusAxisView;
}
var hasRequiredRadiusAxis;
function requireRadiusAxis() {
  if (hasRequiredRadiusAxis)
    return radiusAxis;
  hasRequiredRadiusAxis = 1;
  requirePolarCreator();
  requireRadiusAxisView();
  return radiusAxis;
}
var PolarAxisPointer_1;
var hasRequiredPolarAxisPointer;
function requirePolarAxisPointer() {
  if (hasRequiredPolarAxisPointer)
    return PolarAxisPointer_1;
  hasRequiredPolarAxisPointer = 1;
  var formatUtil2 = requireFormat();
  var BaseAxisPointer = requireBaseAxisPointer();
  var graphic2 = graphic$4;
  var viewHelper2 = requireViewHelper();
  var matrix2 = requireMatrix();
  var AxisBuilder = requireAxisBuilder();
  var AxisView = requireAxisView();
  var PolarAxisPointer = BaseAxisPointer.extend({
    /**
     * @override
     */
    makeElOption: function(elOption, value, axisModel, axisPointerModel, api) {
      var axis2 = axisModel.axis;
      if (axis2.dim === "angle") {
        this.animationThreshold = Math.PI / 18;
      }
      var polar2 = axis2.polar;
      var otherAxis = polar2.getOtherAxis(axis2);
      var otherExtent = otherAxis.getExtent();
      var coordValue;
      coordValue = axis2["dataTo" + formatUtil2.capitalFirst(axis2.dim)](value);
      var axisPointerType = axisPointerModel.get("type");
      if (axisPointerType && axisPointerType !== "none") {
        var elStyle = viewHelper2.buildElStyle(axisPointerModel);
        var pointerOption = pointerShapeBuilder[axisPointerType](axis2, polar2, coordValue, otherExtent, elStyle);
        pointerOption.style = elStyle;
        elOption.graphicKey = pointerOption.type;
        elOption.pointer = pointerOption;
      }
      var labelMargin = axisPointerModel.get("label.margin");
      var labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar2, labelMargin);
      viewHelper2.buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos);
    }
    // Do not support handle, utill any user requires it.
  });
  function getLabelPosition(value, axisModel, axisPointerModel, polar2, labelMargin) {
    var axis2 = axisModel.axis;
    var coord = axis2.dataToCoord(value);
    var axisAngle = polar2.getAngleAxis().getExtent()[0];
    axisAngle = axisAngle / 180 * Math.PI;
    var radiusExtent = polar2.getRadiusAxis().getExtent();
    var position;
    var align;
    var verticalAlign;
    if (axis2.dim === "radius") {
      var transform = matrix2.create();
      matrix2.rotate(transform, transform, axisAngle);
      matrix2.translate(transform, transform, [polar2.cx, polar2.cy]);
      position = graphic2.applyTransform([coord, -labelMargin], transform);
      var labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
      var labelLayout2 = AxisBuilder.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
      align = labelLayout2.textAlign;
      verticalAlign = labelLayout2.textVerticalAlign;
    } else {
      var r = radiusExtent[1];
      position = polar2.coordToPoint([r + labelMargin, coord]);
      var cx = polar2.cx;
      var cy = polar2.cy;
      align = Math.abs(position[0] - cx) / r < 0.3 ? "center" : position[0] > cx ? "left" : "right";
      verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? "middle" : position[1] > cy ? "top" : "bottom";
    }
    return {
      position,
      align,
      verticalAlign
    };
  }
  var pointerShapeBuilder = {
    line: function(axis2, polar2, coordValue, otherExtent, elStyle) {
      return axis2.dim === "angle" ? {
        type: "Line",
        shape: viewHelper2.makeLineShape(polar2.coordToPoint([otherExtent[0], coordValue]), polar2.coordToPoint([otherExtent[1], coordValue]))
      } : {
        type: "Circle",
        shape: {
          cx: polar2.cx,
          cy: polar2.cy,
          r: coordValue
        }
      };
    },
    shadow: function(axis2, polar2, coordValue, otherExtent, elStyle) {
      var bandWidth = Math.max(1, axis2.getBandWidth());
      var radian = Math.PI / 180;
      return axis2.dim === "angle" ? {
        type: "Sector",
        shape: viewHelper2.makeSectorShape(
          polar2.cx,
          polar2.cy,
          otherExtent[0],
          otherExtent[1],
          // In ECharts y is negative if angle is positive
          (-coordValue - bandWidth / 2) * radian,
          (-coordValue + bandWidth / 2) * radian
        )
      } : {
        type: "Sector",
        shape: viewHelper2.makeSectorShape(polar2.cx, polar2.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
      };
    }
  };
  AxisView.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer);
  var _default2 = PolarAxisPointer;
  PolarAxisPointer_1 = _default2;
  return PolarAxisPointer_1;
}
var hasRequiredPolar;
function requirePolar() {
  if (hasRequiredPolar)
    return polar;
  hasRequiredPolar = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var barPolar2 = requireBarPolar();
  requirePolarCreator();
  requireAngleAxis();
  requireRadiusAxis();
  requireAxisPointer();
  requirePolarAxisPointer();
  echarts$12.registerLayout(zrUtil2.curry(barPolar2, "bar"));
  echarts$12.extendComponentView({
    type: "polar"
  });
  return polar;
}
var geo = {};
var GeoModel_1;
var hasRequiredGeoModel;
function requireGeoModel() {
  if (hasRequiredGeoModel)
    return GeoModel_1;
  hasRequiredGeoModel = 1;
  var zrUtil2 = util$6;
  var modelUtil2 = model;
  var ComponentModel2 = Component$2;
  var Model2 = requireModel();
  var selectableMixin2 = requireSelectableMixin();
  var geoCreator = requireGeoCreator();
  var GeoModel = ComponentModel2.extend({
    type: "geo",
    /**
     * @type {module:echarts/coord/geo/Geo}
     */
    coordinateSystem: null,
    layoutMode: "box",
    init: function(option) {
      ComponentModel2.prototype.init.apply(this, arguments);
      modelUtil2.defaultEmphasis(option, "label", ["show"]);
    },
    optionUpdated: function() {
      var option = this.option;
      var self2 = this;
      option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap);
      this._optionModelMap = zrUtil2.reduce(option.regions || [], function(optionModelMap, regionOpt) {
        if (regionOpt.name) {
          optionModelMap.set(regionOpt.name, new Model2(regionOpt, self2));
        }
        return optionModelMap;
      }, zrUtil2.createHashMap());
      this.updateSelectedMap(option.regions);
    },
    defaultOption: {
      zlevel: 0,
      z: 0,
      show: true,
      left: "center",
      top: "center",
      // width:,
      // height:,
      // right
      // bottom
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // If svg used, aspectScale is 1 by default.
      // aspectScale: 0.75,
      aspectScale: null,
      ///// Layout with center and size
      // If you wan't to put map in a fixed size box with right aspect ratio
      // This two properties may more conveninet
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: false,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: false,
        color: "#000"
      },
      itemStyle: {
        // color: 各异,
        borderWidth: 0.5,
        borderColor: "#444",
        color: "#eee"
      },
      emphasis: {
        label: {
          show: true,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
    },
    /**
     * Get model of region
     * @param  {string} name
     * @return {module:echarts/model/Model}
     */
    getRegionModel: function(name2) {
      return this._optionModelMap.get(name2) || new Model2(null, this, this.ecModel);
    },
    /**
     * Format label
     * @param {string} name Region name
     * @param {string} [status='normal'] 'normal' or 'emphasis'
     * @return {string}
     */
    getFormattedLabel: function(name2, status) {
      status = status || "normal";
      var regionModel = this.getRegionModel(name2);
      var formatter = regionModel.get((status === "normal" ? "" : status + ".") + "label.formatter");
      var params = {
        name: name2
      };
      if (typeof formatter === "function") {
        params.status = status;
        return formatter(params);
      } else if (typeof formatter === "string") {
        return formatter.replace("{a}", name2 != null ? name2 : "");
      }
    },
    setZoom: function(zoom) {
      this.option.zoom = zoom;
    },
    setCenter: function(center2) {
      this.option.center = center2;
    }
  });
  zrUtil2.mixin(GeoModel, selectableMixin2);
  var _default2 = GeoModel;
  GeoModel_1 = _default2;
  return GeoModel_1;
}
var GeoView;
var hasRequiredGeoView;
function requireGeoView() {
  if (hasRequiredGeoView)
    return GeoView;
  hasRequiredGeoView = 1;
  var MapDraw = requireMapDraw();
  var echarts$12 = echarts;
  var _default2 = echarts$12.extendComponentView({
    type: "geo",
    init: function(ecModel, api) {
      var mapDraw = new MapDraw(api, true);
      this._mapDraw = mapDraw;
      this.group.add(mapDraw.group);
    },
    render: function(geoModel, ecModel, api, payload) {
      if (payload && payload.type === "geoToggleSelect" && payload.from === this.uid) {
        return;
      }
      var mapDraw = this._mapDraw;
      if (geoModel.get("show")) {
        mapDraw.draw(geoModel, ecModel, api, this, payload);
      } else {
        this._mapDraw.group.removeAll();
      }
      this.group.silent = geoModel.get("silent");
    },
    dispose: function() {
      this._mapDraw && this._mapDraw.remove();
    }
  });
  GeoView = _default2;
  return GeoView;
}
var hasRequiredGeo;
function requireGeo() {
  if (hasRequiredGeo)
    return geo;
  hasRequiredGeo = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  requireGeoModel();
  requireGeoCreator();
  requireGeoView();
  requireGeoRoam();
  function makeAction(method, actionInfo) {
    actionInfo.update = "updateView";
    echarts$12.registerAction(actionInfo, function(payload, ecModel) {
      var selected = {};
      ecModel.eachComponent({
        mainType: "geo",
        query: payload
      }, function(geoModel) {
        geoModel[method](payload.name);
        var geo2 = geoModel.coordinateSystem;
        zrUtil2.each(geo2.regions, function(region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
      });
      return {
        selected,
        name: payload.name
      };
    });
  }
  makeAction("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  });
  makeAction("select", {
    type: "geoSelect",
    event: "geoselected"
  });
  makeAction("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  });
  return geo;
}
var calendar = {};
var Calendar_1;
var hasRequiredCalendar$1;
function requireCalendar$1() {
  if (hasRequiredCalendar$1)
    return Calendar_1;
  hasRequiredCalendar$1 = 1;
  var zrUtil2 = util$6;
  var layout2 = layout$1;
  var numberUtil = requireNumber();
  var CoordinateSystem$1 = CoordinateSystem;
  var PROXIMATE_ONE_DAY = 864e5;
  function Calendar(calendarModel, ecModel, api) {
    this._model = calendarModel;
  }
  Calendar.prototype = {
    constructor: Calendar,
    type: "calendar",
    dimensions: ["time", "value"],
    // Required in createListFromData
    getDimensionsInfo: function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    },
    getRangeInfo: function() {
      return this._rangeInfo;
    },
    getModel: function() {
      return this._model;
    },
    getRect: function() {
      return this._rect;
    },
    getCellWidth: function() {
      return this._sw;
    },
    getCellHeight: function() {
      return this._sh;
    },
    getOrient: function() {
      return this._orient;
    },
    /**
     * getFirstDayOfWeek
     *
     * @example
     *     0 : start at Sunday
     *     1 : start at Monday
     *
     * @return {number}
     */
    getFirstDayOfWeek: function() {
      return this._firstDayOfWeek;
    },
    /**
     * get date info
     *
     * @param  {string|number} date date
     * @return {Object}
     * {
     *      y: string, local full year, eg., '1940',
     *      m: string, local month, from '01' ot '12',
     *      d: string, local date, from '01' to '31' (if exists),
     *      day: It is not date.getDay(). It is the location of the cell in a week, from 0 to 6,
     *      time: timestamp,
     *      formatedDate: string, yyyy-MM-dd,
     *      date: original date object.
     * }
     */
    getDateInfo: function(date) {
      date = numberUtil.parseDate(date);
      var y = date.getFullYear();
      var m2 = date.getMonth() + 1;
      m2 = m2 < 10 ? "0" + m2 : m2;
      var d = date.getDate();
      d = d < 10 ? "0" + d : d;
      var day = date.getDay();
      day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
      return {
        y,
        m: m2,
        d,
        day,
        time: date.getTime(),
        formatedDate: y + "-" + m2 + "-" + d,
        date
      };
    },
    getNextNDay: function(date, n) {
      n = n || 0;
      if (n === 0) {
        return this.getDateInfo(date);
      }
      date = new Date(this.getDateInfo(date).time);
      date.setDate(date.getDate() + n);
      return this.getDateInfo(date);
    },
    update: function(ecModel, api) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
      this._orient = this._model.get("orient");
      this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
      this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var weeks = this._rangeInfo.weeks || 1;
      var whNames = ["width", "height"];
      var cellSize = this._model.get("cellSize").slice();
      var layoutParams = this._model.getBoxLayoutParams();
      var cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
      zrUtil2.each([0, 1], function(idx) {
        if (cellSizeSpecified(cellSize, idx)) {
          layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
        }
      });
      var whGlobal = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var calendarRect = this._rect = layout2.getLayoutRect(layoutParams, whGlobal);
      zrUtil2.each([0, 1], function(idx) {
        if (!cellSizeSpecified(cellSize, idx)) {
          cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
        }
      });
      function cellSizeSpecified(cellSize2, idx) {
        return cellSize2[idx] != null && cellSize2[idx] !== "auto";
      }
      this._sw = cellSize[0];
      this._sh = cellSize[1];
    },
    /**
     * Convert a time data(time, value) item to (x, y) point.
     *
     * @override
     * @param  {Array|number} data data
     * @param  {boolean} [clamp=true] out of range
     * @return {Array} point
     */
    dataToPoint: function(data, clamp) {
      zrUtil2.isArray(data) && (data = data[0]);
      clamp == null && (clamp = true);
      var dayInfo = this.getDateInfo(data);
      var range = this._rangeInfo;
      var date = dayInfo.formatedDate;
      if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
        return [NaN, NaN];
      }
      var week = dayInfo.day;
      var nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
      if (this._orient === "vertical") {
        return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2];
      }
      return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2];
    },
    /**
     * Convert a (x, y) point to time data
     *
     * @override
     * @param  {string} point point
     * @return {string}       data
     */
    pointToData: function(point) {
      var date = this.pointToDate(point);
      return date && date.time;
    },
    /**
     * Convert a time date item to (x, y) four point.
     *
     * @param  {Array} data  date[0] is date
     * @param  {boolean} [clamp=true]  out of range
     * @return {Object}       point
     */
    dataToRect: function(data, clamp) {
      var point = this.dataToPoint(data, clamp);
      return {
        contentShape: {
          x: point[0] - (this._sw - this._lineWidth) / 2,
          y: point[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: point,
        tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
        tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
        br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
        bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
      };
    },
    /**
     * Convert a (x, y) point to time date
     *
     * @param  {Array} point point
     * @return {Object}       date
     */
    pointToDate: function(point) {
      var nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
      var nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
      var range = this._rangeInfo.range;
      if (this._orient === "vertical") {
        return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
      }
      return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
    },
    /**
     * @inheritDoc
     */
    convertToPixel: zrUtil2.curry(doConvert, "dataToPoint"),
    /**
     * @inheritDoc
     */
    convertFromPixel: zrUtil2.curry(doConvert, "pointToData"),
    /**
     * initRange
     *
     * @private
     * @return {Array} [start, end]
     */
    _initRangeOption: function() {
      var range = this._model.get("range");
      var rg = range;
      if (zrUtil2.isArray(rg) && rg.length === 1) {
        rg = rg[0];
      }
      if (/^\d{4}$/.test(rg)) {
        range = [rg + "-01-01", rg + "-12-31"];
      }
      if (/^\d{4}[\/|-]\d{1,2}$/.test(rg)) {
        var start = this.getDateInfo(rg);
        var firstDay = start.date;
        firstDay.setMonth(firstDay.getMonth() + 1);
        var end = this.getNextNDay(firstDay, -1);
        range = [start.formatedDate, end.formatedDate];
      }
      if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rg)) {
        range = [rg, rg];
      }
      var tmp = this._getRangeInfo(range);
      if (tmp.start.time > tmp.end.time) {
        range.reverse();
      }
      return range;
    },
    /**
     * range info
     *
     * @private
     * @param  {Array} range range ['2017-01-01', '2017-07-08']
     *  If range[0] > range[1], they will not be reversed.
     * @return {Object}       obj
     */
    _getRangeInfo: function(range) {
      range = [this.getDateInfo(range[0]), this.getDateInfo(range[1])];
      var reversed;
      if (range[0].time > range[1].time) {
        reversed = true;
        range.reverse();
      }
      var allDay = Math.floor(range[1].time / PROXIMATE_ONE_DAY) - Math.floor(range[0].time / PROXIMATE_ONE_DAY) + 1;
      var date = new Date(range[0].time);
      var startDateNum = date.getDate();
      var endDateNum = range[1].date.getDate();
      date.setDate(startDateNum + allDay - 1);
      var dateNum = date.getDate();
      if (dateNum !== endDateNum) {
        var sign = date.getTime() - range[1].time > 0 ? 1 : -1;
        while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - range[1].time) * sign > 0) {
          allDay -= sign;
          date.setDate(dateNum - sign);
        }
      }
      var weeks = Math.floor((allDay + range[0].day + 6) / 7);
      var nthWeek = reversed ? -weeks + 1 : weeks - 1;
      reversed && range.reverse();
      return {
        range: [range[0].formatedDate, range[1].formatedDate],
        start: range[0],
        end: range[1],
        allDay,
        weeks,
        // From 0.
        nthWeek,
        fweek: range[0].day,
        lweek: range[1].day
      };
    },
    /**
     * get date by nthWeeks and week day in range
     *
     * @private
     * @param  {number} nthWeek the week
     * @param  {number} day   the week day
     * @param  {Array} range [d1, d2]
     * @return {Object}
     */
    _getDateByWeeksAndDay: function(nthWeek, day, range) {
      var rangeInfo = this._getRangeInfo(range);
      if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
        return false;
      }
      var nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
      var date = new Date(rangeInfo.start.time);
      date.setDate(rangeInfo.start.d + nthDay);
      return this.getDateInfo(date);
    }
  };
  Calendar.dimensions = Calendar.prototype.dimensions;
  Calendar.getDimensionsInfo = Calendar.prototype.getDimensionsInfo;
  Calendar.create = function(ecModel, api) {
    var calendarList = [];
    ecModel.eachComponent("calendar", function(calendarModel) {
      var calendar2 = new Calendar(calendarModel);
      calendarList.push(calendar2);
      calendarModel.coordinateSystem = calendar2;
    });
    ecModel.eachSeries(function(calendarSeries) {
      if (calendarSeries.get("coordinateSystem") === "calendar") {
        calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
      }
    });
    return calendarList;
  };
  function doConvert(methodName, ecModel, finder, value) {
    var calendarModel = finder.calendarModel;
    var seriesModel = finder.seriesModel;
    var coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
    return coordSys === this ? coordSys[methodName](value) : null;
  }
  CoordinateSystem$1.register("calendar", Calendar);
  var _default2 = Calendar;
  Calendar_1 = _default2;
  return Calendar_1;
}
var CalendarModel_1;
var hasRequiredCalendarModel;
function requireCalendarModel() {
  if (hasRequiredCalendarModel)
    return CalendarModel_1;
  hasRequiredCalendarModel = 1;
  var zrUtil2 = util$6;
  var ComponentModel2 = Component$2;
  var _layout2 = layout$1;
  var getLayoutParams2 = _layout2.getLayoutParams;
  var sizeCalculable2 = _layout2.sizeCalculable;
  var mergeLayoutParam2 = _layout2.mergeLayoutParam;
  var CalendarModel = ComponentModel2.extend({
    type: "calendar",
    /**
     * @type {module:echarts/coord/calendar/Calendar}
     */
    coordinateSystem: null,
    defaultOption: {
      zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: true,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: true,
        // a week first day
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        // 50% of cellSize
        nameMap: "en",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: true,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        // cn en []
        nameMap: "en",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: true,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    },
    /**
     * @override
     */
    init: function(option, parentModel, ecModel, extraOpt) {
      var inputPositionParams = getLayoutParams2(option);
      CalendarModel.superApply(this, "init", arguments);
      mergeAndNormalizeLayoutParams(option, inputPositionParams);
    },
    /**
     * @override
     */
    mergeOption: function(option, extraOpt) {
      CalendarModel.superApply(this, "mergeOption", arguments);
      mergeAndNormalizeLayoutParams(this.option, option);
    }
  });
  function mergeAndNormalizeLayoutParams(target, raw) {
    var cellSize = target.cellSize;
    if (!zrUtil2.isArray(cellSize)) {
      cellSize = target.cellSize = [cellSize, cellSize];
    } else if (cellSize.length === 1) {
      cellSize[1] = cellSize[0];
    }
    var ignoreSize = zrUtil2.map([0, 1], function(hvIdx) {
      if (sizeCalculable2(raw, hvIdx)) {
        cellSize[hvIdx] = "auto";
      }
      return cellSize[hvIdx] != null && cellSize[hvIdx] !== "auto";
    });
    mergeLayoutParam2(target, raw, {
      type: "box",
      ignoreSize
    });
  }
  var _default2 = CalendarModel;
  CalendarModel_1 = _default2;
  return CalendarModel_1;
}
var CalendarView;
var hasRequiredCalendarView;
function requireCalendarView() {
  if (hasRequiredCalendarView)
    return CalendarView;
  hasRequiredCalendarView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var formatUtil2 = requireFormat();
  var numberUtil = requireNumber();
  var MONTH_TEXT = {
    EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    CN: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
  };
  var WEEK_TEXT = {
    EN: ["S", "M", "T", "W", "T", "F", "S"],
    CN: ["日", "一", "二", "三", "四", "五", "六"]
  };
  var _default2 = echarts$12.extendComponentView({
    type: "calendar",
    /**
     * top/left line points
     *  @private
     */
    _tlpoints: null,
    /**
     * bottom/right line points
     *  @private
     */
    _blpoints: null,
    /**
     * first day of month
     *  @private
     */
    _firstDayOfMonth: null,
    /**
     * first day point of month
     *  @private
     */
    _firstDayPoints: null,
    render: function(calendarModel, ecModel, api) {
      var group = this.group;
      group.removeAll();
      var coordSys = calendarModel.coordinateSystem;
      var rangeData = coordSys.getRangeInfo();
      var orient = coordSys.getOrient();
      this._renderDayRect(calendarModel, rangeData, group);
      this._renderLines(calendarModel, rangeData, orient, group);
      this._renderYearText(calendarModel, rangeData, orient, group);
      this._renderMonthText(calendarModel, orient, group);
      this._renderWeekText(calendarModel, rangeData, orient, group);
    },
    // render day rect
    _renderDayRect: function(calendarModel, rangeData, group) {
      var coordSys = calendarModel.coordinateSystem;
      var itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
      var sw = coordSys.getCellWidth();
      var sh = coordSys.getCellHeight();
      for (var i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
        var point = coordSys.dataToRect([i], false).tl;
        var rect = new graphic2.Rect({
          shape: {
            x: point[0],
            y: point[1],
            width: sw,
            height: sh
          },
          cursor: "default",
          style: itemRectStyleModel
        });
        group.add(rect);
      }
    },
    // render separate line
    _renderLines: function(calendarModel, rangeData, orient, group) {
      var self2 = this;
      var coordSys = calendarModel.coordinateSystem;
      var lineStyleModel = calendarModel.getModel("splitLine.lineStyle").getLineStyle();
      var show = calendarModel.get("splitLine.show");
      var lineWidth = lineStyleModel.lineWidth;
      this._tlpoints = [];
      this._blpoints = [];
      this._firstDayOfMonth = [];
      this._firstDayPoints = [];
      var firstDay = rangeData.start;
      for (var i = 0; firstDay.time <= rangeData.end.time; i++) {
        addPoints(firstDay.formatedDate);
        if (i === 0) {
          firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
        }
        var date = firstDay.date;
        date.setMonth(date.getMonth() + 1);
        firstDay = coordSys.getDateInfo(date);
      }
      addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
      function addPoints(date2) {
        self2._firstDayOfMonth.push(coordSys.getDateInfo(date2));
        self2._firstDayPoints.push(coordSys.dataToRect([date2], false).tl);
        var points2 = self2._getLinePointsOfOneWeek(calendarModel, date2, orient);
        self2._tlpoints.push(points2[0]);
        self2._blpoints.push(points2[points2.length - 1]);
        show && self2._drawSplitline(points2, lineStyleModel, group);
      }
      show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
      show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
    },
    // get points at both ends
    _getEdgesPoints: function(points2, lineWidth, orient) {
      var rs = [points2[0].slice(), points2[points2.length - 1].slice()];
      var idx = orient === "horizontal" ? 0 : 1;
      rs[0][idx] = rs[0][idx] - lineWidth / 2;
      rs[1][idx] = rs[1][idx] + lineWidth / 2;
      return rs;
    },
    // render split line
    _drawSplitline: function(points2, lineStyleModel, group) {
      var poyline = new graphic2.Polyline({
        z2: 20,
        shape: {
          points: points2
        },
        style: lineStyleModel
      });
      group.add(poyline);
    },
    // render month line of one week points
    _getLinePointsOfOneWeek: function(calendarModel, date, orient) {
      var coordSys = calendarModel.coordinateSystem;
      date = coordSys.getDateInfo(date);
      var points2 = [];
      for (var i = 0; i < 7; i++) {
        var tmpD = coordSys.getNextNDay(date.time, i);
        var point = coordSys.dataToRect([tmpD.time], false);
        points2[2 * tmpD.day] = point.tl;
        points2[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
      }
      return points2;
    },
    _formatterLabel: function(formatter, params) {
      if (typeof formatter === "string" && formatter) {
        return formatUtil2.formatTplSimple(formatter, params);
      }
      if (typeof formatter === "function") {
        return formatter(params);
      }
      return params.nameMap;
    },
    _yearTextPositionControl: function(textEl, point, orient, position, margin) {
      point = point.slice();
      var aligns = ["center", "bottom"];
      if (position === "bottom") {
        point[1] += margin;
        aligns = ["center", "top"];
      } else if (position === "left") {
        point[0] -= margin;
      } else if (position === "right") {
        point[0] += margin;
        aligns = ["center", "top"];
      } else {
        point[1] -= margin;
      }
      var rotate = 0;
      if (position === "left" || position === "right") {
        rotate = Math.PI / 2;
      }
      return {
        rotation: rotate,
        position: point,
        style: {
          textAlign: aligns[0],
          textVerticalAlign: aligns[1]
        }
      };
    },
    // render year
    _renderYearText: function(calendarModel, rangeData, orient, group) {
      var yearLabel = calendarModel.getModel("yearLabel");
      if (!yearLabel.get("show")) {
        return;
      }
      var margin = yearLabel.get("margin");
      var pos = yearLabel.get("position");
      if (!pos) {
        pos = orient !== "horizontal" ? "top" : "left";
      }
      var points2 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
      var xc = (points2[0][0] + points2[1][0]) / 2;
      var yc = (points2[0][1] + points2[1][1]) / 2;
      var idx = orient === "horizontal" ? 0 : 1;
      var posPoints = {
        top: [xc, points2[idx][1]],
        bottom: [xc, points2[1 - idx][1]],
        left: [points2[1 - idx][0], yc],
        right: [points2[idx][0], yc]
      };
      var name2 = rangeData.start.y;
      if (+rangeData.end.y > +rangeData.start.y) {
        name2 = name2 + "-" + rangeData.end.y;
      }
      var formatter = yearLabel.get("formatter");
      var params = {
        start: rangeData.start.y,
        end: rangeData.end.y,
        nameMap: name2
      };
      var content = this._formatterLabel(formatter, params);
      var yearText = new graphic2.Text({
        z2: 30
      });
      graphic2.setTextStyle(yearText.style, yearLabel, {
        text: content
      }), yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
      group.add(yearText);
    },
    _monthTextPositionControl: function(point, isCenter, orient, position, margin) {
      var align = "left";
      var vAlign = "top";
      var x = point[0];
      var y = point[1];
      if (orient === "horizontal") {
        y = y + margin;
        if (isCenter) {
          align = "center";
        }
        if (position === "start") {
          vAlign = "bottom";
        }
      } else {
        x = x + margin;
        if (isCenter) {
          vAlign = "middle";
        }
        if (position === "start") {
          align = "right";
        }
      }
      return {
        x,
        y,
        textAlign: align,
        textVerticalAlign: vAlign
      };
    },
    // render month and year text
    _renderMonthText: function(calendarModel, orient, group) {
      var monthLabel = calendarModel.getModel("monthLabel");
      if (!monthLabel.get("show")) {
        return;
      }
      var nameMap = monthLabel.get("nameMap");
      var margin = monthLabel.get("margin");
      var pos = monthLabel.get("position");
      var align = monthLabel.get("align");
      var termPoints = [this._tlpoints, this._blpoints];
      if (zrUtil2.isString(nameMap)) {
        nameMap = MONTH_TEXT[nameMap.toUpperCase()] || [];
      }
      var idx = pos === "start" ? 0 : 1;
      var axis2 = orient === "horizontal" ? 0 : 1;
      margin = pos === "start" ? -margin : margin;
      var isCenter = align === "center";
      for (var i = 0; i < termPoints[idx].length - 1; i++) {
        var tmp = termPoints[idx][i].slice();
        var firstDay = this._firstDayOfMonth[i];
        if (isCenter) {
          var firstDayPoints = this._firstDayPoints[i];
          tmp[axis2] = (firstDayPoints[axis2] + termPoints[0][i + 1][axis2]) / 2;
        }
        var formatter = monthLabel.get("formatter");
        var name2 = nameMap[+firstDay.m - 1];
        var params = {
          yyyy: firstDay.y,
          yy: (firstDay.y + "").slice(2),
          MM: firstDay.m,
          M: +firstDay.m,
          nameMap: name2
        };
        var content = this._formatterLabel(formatter, params);
        var monthText = new graphic2.Text({
          z2: 30
        });
        zrUtil2.extend(graphic2.setTextStyle(monthText.style, monthLabel, {
          text: content
        }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin));
        group.add(monthText);
      }
    },
    _weekTextPositionControl: function(point, orient, position, margin, cellSize) {
      var align = "center";
      var vAlign = "middle";
      var x = point[0];
      var y = point[1];
      var isStart = position === "start";
      if (orient === "horizontal") {
        x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
        align = isStart ? "right" : "left";
      } else {
        y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
        vAlign = isStart ? "bottom" : "top";
      }
      return {
        x,
        y,
        textAlign: align,
        textVerticalAlign: vAlign
      };
    },
    // render weeks
    _renderWeekText: function(calendarModel, rangeData, orient, group) {
      var dayLabel = calendarModel.getModel("dayLabel");
      if (!dayLabel.get("show")) {
        return;
      }
      var coordSys = calendarModel.coordinateSystem;
      var pos = dayLabel.get("position");
      var nameMap = dayLabel.get("nameMap");
      var margin = dayLabel.get("margin");
      var firstDayOfWeek = coordSys.getFirstDayOfWeek();
      if (zrUtil2.isString(nameMap)) {
        nameMap = WEEK_TEXT[nameMap.toUpperCase()] || [];
      }
      var start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
      var cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
      margin = numberUtil.parsePercent(margin, cellSize[orient === "horizontal" ? 0 : 1]);
      if (pos === "start") {
        start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
        margin = -margin;
      }
      for (var i = 0; i < 7; i++) {
        var tmpD = coordSys.getNextNDay(start, i);
        var point = coordSys.dataToRect([tmpD.time], false).center;
        var day = i;
        day = Math.abs((i + firstDayOfWeek) % 7);
        var weekText = new graphic2.Text({
          z2: 30
        });
        zrUtil2.extend(graphic2.setTextStyle(weekText.style, dayLabel, {
          text: nameMap[day]
        }), this._weekTextPositionControl(point, orient, pos, margin, cellSize));
        group.add(weekText);
      }
    }
  });
  CalendarView = _default2;
  return CalendarView;
}
var hasRequiredCalendar;
function requireCalendar() {
  if (hasRequiredCalendar)
    return calendar;
  hasRequiredCalendar = 1;
  requireCalendar$1();
  requireCalendarModel();
  requireCalendarView();
  return calendar;
}
var graphic$2 = {};
var hasRequiredGraphic$2;
function requireGraphic$2() {
  if (hasRequiredGraphic$2)
    return graphic$2;
  hasRequiredGraphic$2 = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var modelUtil2 = model;
  var graphicUtil2 = graphic$4;
  var layoutUtil = layout$1;
  var _number2 = requireNumber();
  var parsePercent2 = _number2.parsePercent;
  var _nonShapeGraphicElements = {
    // Reserved but not supported in graphic component.
    path: null,
    compoundPath: null,
    // Supported in graphic component.
    group: graphicUtil2.Group,
    image: graphicUtil2.Image,
    text: graphicUtil2.Text
  };
  echarts$12.registerPreprocessor(function(option) {
    var graphicOption = option.graphic;
    if (zrUtil2.isArray(graphicOption)) {
      if (!graphicOption[0] || !graphicOption[0].elements) {
        option.graphic = [{
          elements: graphicOption
        }];
      } else {
        option.graphic = [option.graphic[0]];
      }
    } else if (graphicOption && !graphicOption.elements) {
      option.graphic = [{
        elements: [graphicOption]
      }];
    }
  });
  var GraphicModel = echarts$12.extendComponentModel({
    type: "graphic",
    defaultOption: {
      // Extra properties for each elements:
      //
      // left/right/top/bottom: (like 12, '22%', 'center', default undefined)
      //      If left/rigth is set, shape.x/shape.cx/position will not be used.
      //      If top/bottom is set, shape.y/shape.cy/position will not be used.
      //      This mechanism is useful when you want to position a group/element
      //      against the right side or the center of this container.
      //
      // width/height: (can only be pixel value, default 0)
      //      Only be used to specify contianer(group) size, if needed. And
      //      can not be percentage value (like '33%'). See the reason in the
      //      layout algorithm below.
      //
      // bounding: (enum: 'all' (default) | 'raw')
      //      Specify how to calculate boundingRect when locating.
      //      'all': Get uioned and transformed boundingRect
      //          from both itself and its descendants.
      //          This mode simplies confining a group of elements in the bounding
      //          of their ancester container (e.g., using 'right: 0').
      //      'raw': Only use the boundingRect of itself and before transformed.
      //          This mode is similar to css behavior, which is useful when you
      //          want an element to be able to overflow its container. (Consider
      //          a rotated circle needs to be located in a corner.)
      // info: custom info. enables user to mount some info on elements and use them
      //      in event handlers. Update them only when user specified, otherwise, remain.
      // Note: elements is always behind its ancestors in this elements array.
      elements: [],
      parentId: null
    },
    /**
     * Save el options for the sake of the performance (only update modified graphics).
     * The order is the same as those in option. (ancesters -> descendants)
     *
     * @private
     * @type {Array.<Object>}
     */
    _elOptionsToUpdate: null,
    /**
     * @override
     */
    mergeOption: function(option) {
      var elements = this.option.elements;
      this.option.elements = null;
      GraphicModel.superApply(this, "mergeOption", arguments);
      this.option.elements = elements;
    },
    /**
     * @override
     */
    optionUpdated: function(newOption, isInit) {
      var thisOption = this.option;
      var newList = (isInit ? thisOption : newOption).elements;
      var existList = thisOption.elements = isInit ? [] : thisOption.elements;
      var flattenedList = [];
      this._flatten(newList, flattenedList);
      var mappingResult = modelUtil2.mappingToExists(existList, flattenedList);
      modelUtil2.makeIdAndName(mappingResult);
      var elOptionsToUpdate = this._elOptionsToUpdate = [];
      zrUtil2.each(mappingResult, function(resultItem, index2) {
        var newElOption = resultItem.option;
        if (!newElOption) {
          return;
        }
        elOptionsToUpdate.push(newElOption);
        setKeyInfoToNewElOption(resultItem, newElOption);
        mergeNewElOptionToExist(existList, index2, newElOption);
        setLayoutInfoToExist(existList[index2], newElOption);
      }, this);
      for (var i = existList.length - 1; i >= 0; i--) {
        if (existList[i] == null) {
          existList.splice(i, 1);
        } else {
          delete existList[i].$action;
        }
      }
    },
    /**
     * Convert
     * [{
     *  type: 'group',
     *  id: 'xx',
     *  children: [{type: 'circle'}, {type: 'polygon'}]
     * }]
     * to
     * [
     *  {type: 'group', id: 'xx'},
     *  {type: 'circle', parentId: 'xx'},
     *  {type: 'polygon', parentId: 'xx'}
     * ]
     *
     * @private
     * @param {Array.<Object>} optionList option list
     * @param {Array.<Object>} result result of flatten
     * @param {Object} parentOption parent option
     */
    _flatten: function(optionList, result, parentOption) {
      zrUtil2.each(optionList, function(option) {
        if (!option) {
          return;
        }
        if (parentOption) {
          option.parentOption = parentOption;
        }
        result.push(option);
        var children = option.children;
        if (option.type === "group" && children) {
          this._flatten(children, result, option);
        }
        delete option.children;
      }, this);
    },
    // FIXME
    // Pass to view using payload? setOption has a payload?
    useElOptionsToUpdate: function() {
      var els = this._elOptionsToUpdate;
      this._elOptionsToUpdate = null;
      return els;
    }
  });
  echarts$12.extendComponentView({
    type: "graphic",
    /**
     * @override
     */
    init: function(ecModel, api) {
      this._elMap = zrUtil2.createHashMap();
      this._lastGraphicModel;
    },
    /**
     * @override
     */
    render: function(graphicModel, ecModel, api) {
      if (graphicModel !== this._lastGraphicModel) {
        this._clear();
      }
      this._lastGraphicModel = graphicModel;
      this._updateElements(graphicModel);
      this._relocate(graphicModel, api);
    },
    /**
     * Update graphic elements.
     *
     * @private
     * @param {Object} graphicModel graphic model
     */
    _updateElements: function(graphicModel) {
      var elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
      if (!elOptionsToUpdate) {
        return;
      }
      var elMap = this._elMap;
      var rootGroup = this.group;
      zrUtil2.each(elOptionsToUpdate, function(elOption) {
        var $action = elOption.$action;
        var id = elOption.id;
        var existEl = elMap.get(id);
        var parentId = elOption.parentId;
        var targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
        var elOptionStyle = elOption.style;
        if (elOption.type === "text" && elOptionStyle) {
          if (elOption.hv && elOption.hv[1]) {
            elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = null;
          }
          !elOptionStyle.hasOwnProperty("textFill") && elOptionStyle.fill && (elOptionStyle.textFill = elOptionStyle.fill);
          !elOptionStyle.hasOwnProperty("textStroke") && elOptionStyle.stroke && (elOptionStyle.textStroke = elOptionStyle.stroke);
        }
        var elOptionCleaned = getCleanedElOption(elOption);
        if (!$action || $action === "merge") {
          existEl ? existEl.attr(elOptionCleaned) : createEl(id, targetElParent, elOptionCleaned, elMap);
        } else if ($action === "replace") {
          removeEl(existEl, elMap);
          createEl(id, targetElParent, elOptionCleaned, elMap);
        } else if ($action === "remove") {
          removeEl(existEl, elMap);
        }
        var el = elMap.get(id);
        if (el) {
          el.__ecGraphicWidthOption = elOption.width;
          el.__ecGraphicHeightOption = elOption.height;
          setEventData(el, graphicModel);
        }
      });
    },
    /**
     * Locate graphic elements.
     *
     * @private
     * @param {Object} graphicModel graphic model
     * @param {module:echarts/ExtensionAPI} api extension API
     */
    _relocate: function(graphicModel, api) {
      var elOptions = graphicModel.option.elements;
      var rootGroup = this.group;
      var elMap = this._elMap;
      var apiWidth = api.getWidth();
      var apiHeight = api.getHeight();
      for (var i = 0; i < elOptions.length; i++) {
        var elOption = elOptions[i];
        var el = elMap.get(elOption.id);
        if (!el || !el.isGroup) {
          continue;
        }
        var parentEl = el.parent;
        var isParentRoot = parentEl === rootGroup;
        el.__ecGraphicWidth = parsePercent2(el.__ecGraphicWidthOption, isParentRoot ? apiWidth : parentEl.__ecGraphicWidth) || 0;
        el.__ecGraphicHeight = parsePercent2(el.__ecGraphicHeightOption, isParentRoot ? apiHeight : parentEl.__ecGraphicHeight) || 0;
      }
      for (var i = elOptions.length - 1; i >= 0; i--) {
        var elOption = elOptions[i];
        var el = elMap.get(elOption.id);
        if (!el) {
          continue;
        }
        var parentEl = el.parent;
        var containerInfo = parentEl === rootGroup ? {
          width: apiWidth,
          height: apiHeight
        } : {
          width: parentEl.__ecGraphicWidth,
          height: parentEl.__ecGraphicHeight
        };
        layoutUtil.positionElement(el, elOption, containerInfo, null, {
          hv: elOption.hv,
          boundingMode: elOption.bounding
        });
      }
    },
    /**
     * Clear all elements.
     *
     * @private
     */
    _clear: function() {
      var elMap = this._elMap;
      elMap.each(function(el) {
        removeEl(el, elMap);
      });
      this._elMap = zrUtil2.createHashMap();
    },
    /**
     * @override
     */
    dispose: function() {
      this._clear();
    }
  });
  function createEl(id, targetElParent, elOption, elMap) {
    var graphicType = elOption.type;
    var Clz = _nonShapeGraphicElements.hasOwnProperty(graphicType) ? _nonShapeGraphicElements[graphicType] : graphicUtil2.getShapeClass(graphicType);
    var el = new Clz(elOption);
    targetElParent.add(el);
    elMap.set(id, el);
    el.__ecGraphicId = id;
  }
  function removeEl(existEl, elMap) {
    var existElParent = existEl && existEl.parent;
    if (existElParent) {
      existEl.type === "group" && existEl.traverse(function(el) {
        removeEl(el, elMap);
      });
      elMap.removeKey(existEl.__ecGraphicId);
      existElParent.remove(existEl);
    }
  }
  function getCleanedElOption(elOption) {
    elOption = zrUtil2.extend({}, elOption);
    zrUtil2.each(["id", "parentId", "$action", "hv", "bounding"].concat(layoutUtil.LOCATION_PARAMS), function(name2) {
      delete elOption[name2];
    });
    return elOption;
  }
  function isSetLoc(obj, props) {
    var isSet2;
    zrUtil2.each(props, function(prop) {
      obj[prop] != null && obj[prop] !== "auto" && (isSet2 = true);
    });
    return isSet2;
  }
  function setKeyInfoToNewElOption(resultItem, newElOption) {
    var existElOption = resultItem.exist;
    newElOption.id = resultItem.keyInfo.id;
    !newElOption.type && existElOption && (newElOption.type = existElOption.type);
    if (newElOption.parentId == null) {
      var newElParentOption = newElOption.parentOption;
      if (newElParentOption) {
        newElOption.parentId = newElParentOption.id;
      } else if (existElOption) {
        newElOption.parentId = existElOption.parentId;
      }
    }
    newElOption.parentOption = null;
  }
  function mergeNewElOptionToExist(existList, index2, newElOption) {
    var newElOptCopy = zrUtil2.extend({}, newElOption);
    var existElOption = existList[index2];
    var $action = newElOption.$action || "merge";
    if ($action === "merge") {
      if (existElOption) {
        zrUtil2.merge(existElOption, newElOptCopy, true);
        layoutUtil.mergeLayoutParam(existElOption, newElOptCopy, {
          ignoreSize: true
        });
        layoutUtil.copyLayoutParams(newElOption, existElOption);
      } else {
        existList[index2] = newElOptCopy;
      }
    } else if ($action === "replace") {
      existList[index2] = newElOptCopy;
    } else if ($action === "remove") {
      existElOption && (existList[index2] = null);
    }
  }
  function setLayoutInfoToExist(existItem, newElOption) {
    if (!existItem) {
      return;
    }
    existItem.hv = newElOption.hv = [
      // Rigid body, dont care `width`.
      isSetLoc(newElOption, ["left", "right"]),
      // Rigid body, dont care `height`.
      isSetLoc(newElOption, ["top", "bottom"])
    ];
    if (existItem.type === "group") {
      existItem.width == null && (existItem.width = newElOption.width = 0);
      existItem.height == null && (existItem.height = newElOption.height = 0);
    }
  }
  function setEventData(el, graphicModel, elOption) {
    var eventData = el.eventData;
    if (!el.silent && !el.ignore && !eventData) {
      eventData = el.eventData = {
        componentType: "graphic",
        componentIndex: graphicModel.componentIndex,
        name: el.name
      };
    }
    if (eventData) {
      eventData.info = el.info;
    }
  }
  return graphic$2;
}
var toolbox = {};
var featureManager = {};
var hasRequiredFeatureManager;
function requireFeatureManager() {
  if (hasRequiredFeatureManager)
    return featureManager;
  hasRequiredFeatureManager = 1;
  var features = {};
  function register(name2, ctor) {
    features[name2] = ctor;
  }
  function get2(name2) {
    return features[name2];
  }
  featureManager.register = register;
  featureManager.get = get2;
  return featureManager;
}
var ToolboxModel_1;
var hasRequiredToolboxModel;
function requireToolboxModel() {
  if (hasRequiredToolboxModel)
    return ToolboxModel_1;
  hasRequiredToolboxModel = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var featureManager2 = requireFeatureManager();
  var ToolboxModel = echarts$12.extendComponentModel({
    type: "toolbox",
    layoutMode: {
      type: "box",
      ignoreSize: true
    },
    optionUpdated: function() {
      ToolboxModel.superApply(this, "optionUpdated", arguments);
      zrUtil2.each(this.option.feature, function(featureOpt, featureName) {
        var Feature = featureManager2.get(featureName);
        Feature && zrUtil2.merge(featureOpt, Feature.defaultOption);
      });
    },
    defaultOption: {
      show: true,
      z: 6,
      zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: true,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: false
      }
    }
  });
  var _default2 = ToolboxModel;
  ToolboxModel_1 = _default2;
  return ToolboxModel_1;
}
var listComponent = {};
var hasRequiredListComponent;
function requireListComponent() {
  if (hasRequiredListComponent)
    return listComponent;
  hasRequiredListComponent = 1;
  var _layout2 = layout$1;
  var getLayoutRect2 = _layout2.getLayoutRect;
  var layoutBox = _layout2.box;
  var positionElement2 = _layout2.positionElement;
  var formatUtil2 = requireFormat();
  var graphic2 = graphic$4;
  function layout2(group, componentModel, api) {
    var boxLayoutParams = componentModel.getBoxLayoutParams();
    var padding = componentModel.get("padding");
    var viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var rect = getLayoutRect2(boxLayoutParams, viewportSize, padding);
    layoutBox(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
    positionElement2(group, boxLayoutParams, viewportSize, padding);
  }
  function makeBackground(rect, componentModel) {
    var padding = formatUtil2.normalizeCssArray(componentModel.get("padding"));
    var style = componentModel.getItemStyle(["color", "opacity"]);
    style.fill = componentModel.get("backgroundColor");
    var rect = new graphic2.Rect({
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[1] + padding[3],
        height: rect.height + padding[0] + padding[2],
        r: componentModel.get("borderRadius")
      },
      style,
      silent: true,
      z2: -1
    });
    return rect;
  }
  listComponent.layout = layout2;
  listComponent.makeBackground = makeBackground;
  return listComponent;
}
var ToolboxView;
var hasRequiredToolboxView;
function requireToolboxView() {
  if (hasRequiredToolboxView)
    return ToolboxView;
  hasRequiredToolboxView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var textContain2 = text;
  var featureManager2 = requireFeatureManager();
  var graphic2 = graphic$4;
  var Model2 = requireModel();
  var DataDiffer = requireDataDiffer();
  var listComponentHelper = requireListComponent();
  var _default2 = echarts$12.extendComponentView({
    type: "toolbox",
    render: function(toolboxModel, ecModel, api, payload) {
      var group = this.group;
      group.removeAll();
      if (!toolboxModel.get("show")) {
        return;
      }
      var itemSize = +toolboxModel.get("itemSize");
      var featureOpts = toolboxModel.get("feature") || {};
      var features = this._features || (this._features = {});
      var featureNames = [];
      zrUtil2.each(featureOpts, function(opt, name2) {
        featureNames.push(name2);
      });
      new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(zrUtil2.curry(processFeature, null)).execute();
      this._featureNames = featureNames;
      function processFeature(newIndex, oldIndex) {
        var featureName = featureNames[newIndex];
        var oldName = featureNames[oldIndex];
        var featureOpt = featureOpts[featureName];
        var featureModel = new Model2(featureOpt, toolboxModel, toolboxModel.ecModel);
        var feature;
        if (payload && payload.newTitle != null && payload.featureName === featureName) {
          featureOpt.title = payload.newTitle;
        }
        if (featureName && !oldName) {
          if (isUserFeatureName(featureName)) {
            feature = {
              model: featureModel,
              onclick: featureModel.option.onclick,
              featureName
            };
          } else {
            var Feature = featureManager2.get(featureName);
            if (!Feature) {
              return;
            }
            feature = new Feature(featureModel, ecModel, api);
          }
          features[featureName] = feature;
        } else {
          feature = features[oldName];
          if (!feature) {
            return;
          }
          feature.model = featureModel;
          feature.ecModel = ecModel;
          feature.api = api;
        }
        if (!featureName && oldName) {
          feature.dispose && feature.dispose(ecModel, api);
          return;
        }
        if (!featureModel.get("show") || feature.unusable) {
          feature.remove && feature.remove(ecModel, api);
          return;
        }
        createIconPaths(featureModel, feature, featureName);
        featureModel.setIconStatus = function(iconName, status) {
          var option = this.option;
          var iconPaths = this.iconPaths;
          option.iconStatus = option.iconStatus || {};
          option.iconStatus[iconName] = status;
          iconPaths[iconName] && iconPaths[iconName].trigger(status);
        };
        if (feature.render) {
          feature.render(featureModel, ecModel, api, payload);
        }
      }
      function createIconPaths(featureModel, feature, featureName) {
        var iconStyleModel = featureModel.getModel("iconStyle");
        var iconStyleEmphasisModel = featureModel.getModel("emphasis.iconStyle");
        var icons = feature.getIcons ? feature.getIcons() : featureModel.get("icon");
        var titles = featureModel.get("title") || {};
        if (typeof icons === "string") {
          var icon = icons;
          var title2 = titles;
          icons = {};
          titles = {};
          icons[featureName] = icon;
          titles[featureName] = title2;
        }
        var iconPaths = featureModel.iconPaths = {};
        zrUtil2.each(icons, function(iconStr, iconName) {
          var path2 = graphic2.createIcon(iconStr, {}, {
            x: -itemSize / 2,
            y: -itemSize / 2,
            width: itemSize,
            height: itemSize
          });
          path2.setStyle(iconStyleModel.getItemStyle());
          path2.hoverStyle = iconStyleEmphasisModel.getItemStyle();
          path2.setStyle({
            text: titles[iconName],
            textAlign: iconStyleEmphasisModel.get("textAlign"),
            textBorderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
            textPadding: iconStyleEmphasisModel.get("textPadding"),
            textFill: null
          });
          var tooltipModel = toolboxModel.getModel("tooltip");
          if (tooltipModel && tooltipModel.get("show")) {
            path2.attr("tooltip", zrUtil2.extend({
              content: titles[iconName],
              formatter: tooltipModel.get("formatter", true) || function() {
                return titles[iconName];
              },
              formatterParams: {
                componentType: "toolbox",
                name: iconName,
                title: titles[iconName],
                $vars: ["name", "title"]
              },
              position: tooltipModel.get("position", true) || "bottom"
            }, tooltipModel.option));
          }
          graphic2.setHoverStyle(path2);
          if (toolboxModel.get("showTitle")) {
            path2.__title = titles[iconName];
            path2.on("mouseover", function() {
              var hoverStyle = iconStyleEmphasisModel.getItemStyle();
              var defaultTextPosition = toolboxModel.get("orient") === "vertical" ? toolboxModel.get("right") == null ? "right" : "left" : toolboxModel.get("bottom") == null ? "bottom" : "top";
              path2.setStyle({
                textFill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
                textBackgroundColor: iconStyleEmphasisModel.get("textBackgroundColor"),
                textPosition: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
              });
            }).on("mouseout", function() {
              path2.setStyle({
                textFill: null,
                textBackgroundColor: null
              });
            });
          }
          path2.trigger(featureModel.get("iconStatus." + iconName) || "normal");
          group.add(path2);
          path2.on("click", zrUtil2.bind(feature.onclick, feature, ecModel, api, iconName));
          iconPaths[iconName] = path2;
        });
      }
      listComponentHelper.layout(group, toolboxModel, api);
      group.add(listComponentHelper.makeBackground(group.getBoundingRect(), toolboxModel));
      group.eachChild(function(icon) {
        var titleText = icon.__title;
        var hoverStyle = icon.hoverStyle;
        if (hoverStyle && titleText) {
          var rect = textContain2.getBoundingRect(titleText, textContain2.makeFont(hoverStyle));
          var offsetX = icon.position[0] + group.position[0];
          var offsetY = icon.position[1] + group.position[1] + itemSize;
          var needPutOnTop = false;
          if (offsetY + rect.height > api.getHeight()) {
            hoverStyle.textPosition = "top";
            needPutOnTop = true;
          }
          var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;
          if (offsetX + rect.width / 2 > api.getWidth()) {
            hoverStyle.textPosition = ["100%", topOffset];
            hoverStyle.textAlign = "right";
          } else if (offsetX - rect.width / 2 < 0) {
            hoverStyle.textPosition = [0, topOffset];
            hoverStyle.textAlign = "left";
          }
        }
      });
    },
    updateView: function(toolboxModel, ecModel, api, payload) {
      zrUtil2.each(this._features, function(feature) {
        feature.updateView && feature.updateView(feature.model, ecModel, api, payload);
      });
    },
    // updateLayout: function (toolboxModel, ecModel, api, payload) {
    //     zrUtil.each(this._features, function (feature) {
    //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
    //     });
    // },
    remove: function(ecModel, api) {
      zrUtil2.each(this._features, function(feature) {
        feature.remove && feature.remove(ecModel, api);
      });
      this.group.removeAll();
    },
    dispose: function(ecModel, api) {
      zrUtil2.each(this._features, function(feature) {
        feature.dispose && feature.dispose(ecModel, api);
      });
    }
  });
  function isUserFeatureName(featureName) {
    return featureName.indexOf("my") === 0;
  }
  ToolboxView = _default2;
  return ToolboxView;
}
var SaveAsImage_1;
var hasRequiredSaveAsImage;
function requireSaveAsImage() {
  if (hasRequiredSaveAsImage)
    return SaveAsImage_1;
  hasRequiredSaveAsImage = 1;
  var env2 = env_1;
  var lang2 = lang$1;
  var featureManager2 = requireFeatureManager();
  var saveAsImageLang = lang2.toolbox.saveAsImage;
  function SaveAsImage(model2) {
    this.model = model2;
  }
  SaveAsImage.defaultOption = {
    show: true,
    icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
    title: saveAsImageLang.title,
    type: "png",
    // Default use option.backgroundColor
    // backgroundColor: '#fff',
    connectedBackgroundColor: "#fff",
    name: "",
    excludeComponents: ["toolbox"],
    pixelRatio: 1,
    lang: saveAsImageLang.lang.slice()
  };
  SaveAsImage.prototype.unusable = !env2.canvasSupported;
  var proto2 = SaveAsImage.prototype;
  proto2.onclick = function(ecModel, api) {
    var model2 = this.model;
    var title2 = model2.get("name") || ecModel.get("title.0.text") || "echarts";
    var isSvg = api.getZr().painter.getType() === "svg";
    var type = isSvg ? "svg" : model2.get("type", true) || "png";
    var url = api.getConnectedDataURL({
      type,
      backgroundColor: model2.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
      connectedBackgroundColor: model2.get("connectedBackgroundColor"),
      excludeComponents: model2.get("excludeComponents"),
      pixelRatio: model2.get("pixelRatio")
    });
    if (typeof MouseEvent === "function" && !env2.browser.ie && !env2.browser.edge) {
      var $a = document.createElement("a");
      $a.download = title2 + "." + type;
      $a.target = "_blank";
      $a.href = url;
      var evt = new MouseEvent("click", {
        // some micro front-end framework， window maybe is a Proxy
        view: document.defaultView,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } else {
      if (window.navigator.msSaveOrOpenBlob) {
        var bstr = atob(url.split(",")[1]);
        var n = bstr.length;
        var u8arr = new Uint8Array(n);
        while (n--) {
          u8arr[n] = bstr.charCodeAt(n);
        }
        var blob = new Blob([u8arr]);
        window.navigator.msSaveOrOpenBlob(blob, title2 + "." + type);
      } else {
        var lang3 = model2.get("lang");
        var html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang3 && lang3[0] || "") + '" /></body>';
        var tab = window.open();
        tab.document.write(html);
      }
    }
  };
  featureManager2.register("saveAsImage", SaveAsImage);
  var _default2 = SaveAsImage;
  SaveAsImage_1 = _default2;
  return SaveAsImage_1;
}
var MagicType_1;
var hasRequiredMagicType;
function requireMagicType() {
  if (hasRequiredMagicType)
    return MagicType_1;
  hasRequiredMagicType = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var lang2 = lang$1;
  var featureManager2 = requireFeatureManager();
  var magicTypeLang = lang2.toolbox.magicType;
  var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
  function MagicType(model2) {
    this.model = model2;
  }
  MagicType.defaultOption = {
    show: true,
    type: [],
    // Icon group
    icon: {
      /* eslint-disable */
      line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
      bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
      stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
      // jshint ignore:line
      /* eslint-enable */
    },
    // `line`, `bar`, `stack`, `tiled`
    title: zrUtil2.clone(magicTypeLang.title),
    option: {},
    seriesIndex: {}
  };
  var proto2 = MagicType.prototype;
  proto2.getIcons = function() {
    var model2 = this.model;
    var availableIcons = model2.get("icon");
    var icons = {};
    zrUtil2.each(model2.get("type"), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  var seriesOptGenreator = {
    "line": function(seriesType2, seriesId, seriesModel, model2) {
      if (seriesType2 === "bar") {
        return zrUtil2.merge({
          id: seriesId,
          type: "line",
          // Preserve data related option
          data: seriesModel.get("data"),
          stack: seriesModel.get("stack"),
          markPoint: seriesModel.get("markPoint"),
          markLine: seriesModel.get("markLine")
        }, model2.get("option.line") || {}, true);
      }
    },
    "bar": function(seriesType2, seriesId, seriesModel, model2) {
      if (seriesType2 === "line") {
        return zrUtil2.merge({
          id: seriesId,
          type: "bar",
          // Preserve data related option
          data: seriesModel.get("data"),
          stack: seriesModel.get("stack"),
          markPoint: seriesModel.get("markPoint"),
          markLine: seriesModel.get("markLine")
        }, model2.get("option.bar") || {}, true);
      }
    },
    "stack": function(seriesType2, seriesId, seriesModel, model2) {
      var isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
      if (seriesType2 === "line" || seriesType2 === "bar") {
        model2.setIconStatus("stack", isStack ? "normal" : "emphasis");
        return zrUtil2.merge({
          id: seriesId,
          stack: isStack ? "" : INNER_STACK_KEYWORD
        }, model2.get("option.stack") || {}, true);
      }
    }
  };
  var radioTypes = [["line", "bar"], ["stack"]];
  proto2.onclick = function(ecModel, api, type) {
    var model2 = this.model;
    var seriesIndex = model2.get("seriesIndex." + type);
    if (!seriesOptGenreator[type]) {
      return;
    }
    var newOption = {
      series: []
    };
    var generateNewSeriesTypes = function(seriesModel) {
      var seriesType2 = seriesModel.subType;
      var seriesId = seriesModel.id;
      var newSeriesOpt = seriesOptGenreator[type](seriesType2, seriesId, seriesModel, model2);
      if (newSeriesOpt) {
        zrUtil2.defaults(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      }
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
        var categoryAxis = coordSys.getAxesByScale("ordinal")[0];
        if (categoryAxis) {
          var axisDim = categoryAxis.dim;
          var axisType = axisDim + "Axis";
          var axisModel = ecModel.queryComponents({
            mainType: axisType,
            index: seriesModel.get(name + "Index"),
            id: seriesModel.get(name + "Id")
          })[0];
          var axisIndex = axisModel.componentIndex;
          newOption[axisType] = newOption[axisType] || [];
          for (var i = 0; i <= axisIndex; i++) {
            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
          }
          newOption[axisType][axisIndex].boundaryGap = type === "bar";
        }
      }
    };
    zrUtil2.each(radioTypes, function(radio) {
      if (zrUtil2.indexOf(radio, type) >= 0) {
        zrUtil2.each(radio, function(item) {
          model2.setIconStatus(item, "normal");
        });
      }
    });
    model2.setIconStatus(type, "emphasis");
    ecModel.eachComponent({
      mainType: "series",
      query: seriesIndex == null ? null : {
        seriesIndex
      }
    }, generateNewSeriesTypes);
    var newTitle;
    if (type === "stack") {
      var isStack = newOption.series && newOption.series[0] && newOption.series[0].stack === INNER_STACK_KEYWORD;
      newTitle = isStack ? zrUtil2.merge({
        stack: magicTypeLang.title.tiled
      }, magicTypeLang.title) : zrUtil2.clone(magicTypeLang.title);
    }
    api.dispatchAction({
      type: "changeMagicType",
      currentType: type,
      newOption,
      newTitle,
      featureName: "magicType"
    });
  };
  echarts$12.registerAction({
    type: "changeMagicType",
    event: "magicTypeChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel) {
    ecModel.mergeOption(payload.newOption);
  });
  featureManager2.register("magicType", MagicType);
  var _default2 = MagicType;
  MagicType_1 = _default2;
  return MagicType_1;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView)
    return _DataView;
  hasRequired_DataView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var eventTool2 = event;
  var lang2 = lang$1;
  var featureManager2 = requireFeatureManager();
  var dataViewLang = lang2.toolbox.dataView;
  var BLOCK_SPLITER = new Array(60).join("-");
  var ITEM_SPLITER = "	";
  function groupSeries(ecModel) {
    var seriesGroupByCategoryAxis = {};
    var otherSeries = [];
    var meta = [];
    ecModel.eachRawSeries(function(seriesModel) {
      var coordSys = seriesModel.coordinateSystem;
      if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
        var baseAxis = coordSys.getBaseAxis();
        if (baseAxis.type === "category") {
          var key = baseAxis.dim + "_" + baseAxis.index;
          if (!seriesGroupByCategoryAxis[key]) {
            seriesGroupByCategoryAxis[key] = {
              categoryAxis: baseAxis,
              valueAxis: coordSys.getOtherAxis(baseAxis),
              series: []
            };
            meta.push({
              axisDim: baseAxis.dim,
              axisIndex: baseAxis.index
            });
          }
          seriesGroupByCategoryAxis[key].series.push(seriesModel);
        } else {
          otherSeries.push(seriesModel);
        }
      } else {
        otherSeries.push(seriesModel);
      }
    });
    return {
      seriesGroupByCategoryAxis,
      other: otherSeries,
      meta
    };
  }
  function assembleSeriesWithCategoryAxis(series) {
    var tables = [];
    zrUtil2.each(series, function(group, key) {
      var categoryAxis = group.categoryAxis;
      var valueAxis = group.valueAxis;
      var valueAxisDim = valueAxis.dim;
      var headers = [" "].concat(zrUtil2.map(group.series, function(series2) {
        return series2.name;
      }));
      var columns = [categoryAxis.model.getCategories()];
      zrUtil2.each(group.series, function(series2) {
        var rawData = series2.getRawData();
        columns.push(series2.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
          return val;
        }));
      });
      var lines2 = [headers.join(ITEM_SPLITER)];
      for (var i = 0; i < columns[0].length; i++) {
        var items = [];
        for (var j = 0; j < columns.length; j++) {
          items.push(columns[j][i]);
        }
        lines2.push(items.join(ITEM_SPLITER));
      }
      tables.push(lines2.join("\n"));
    });
    return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
  }
  function assembleOtherSeries(series) {
    return zrUtil2.map(series, function(series2) {
      var data = series2.getRawData();
      var lines2 = [series2.name];
      var vals = [];
      data.each(data.dimensions, function() {
        var argLen = arguments.length;
        var dataIndex = arguments[argLen - 1];
        var name2 = data.getName(dataIndex);
        for (var i = 0; i < argLen - 1; i++) {
          vals[i] = arguments[i];
        }
        lines2.push((name2 ? name2 + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
      });
      return lines2.join("\n");
    }).join("\n\n" + BLOCK_SPLITER + "\n\n");
  }
  function getContentFromModel(ecModel) {
    var result = groupSeries(ecModel);
    return {
      value: zrUtil2.filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function(str) {
        return str.replace(/[\n\t\s]/g, "");
      }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
      meta: result.meta
    };
  }
  function trim2(str) {
    return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  function isTSVFormat(block) {
    var firstLine = block.slice(0, block.indexOf("\n"));
    if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
      return true;
    }
  }
  var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
  function parseTSVContents(tsv) {
    var tsvLines = tsv.split(/\n+/g);
    var headers = trim2(tsvLines.shift()).split(itemSplitRegex);
    var categories = [];
    var series = zrUtil2.map(headers, function(header) {
      return {
        name: header,
        data: []
      };
    });
    for (var i = 0; i < tsvLines.length; i++) {
      var items = trim2(tsvLines[i]).split(itemSplitRegex);
      categories.push(items.shift());
      for (var j = 0; j < items.length; j++) {
        series[j] && (series[j].data[i] = items[j]);
      }
    }
    return {
      series,
      categories
    };
  }
  function parseListContents(str) {
    var lines2 = str.split(/\n+/g);
    var seriesName = trim2(lines2.shift());
    var data = [];
    for (var i = 0; i < lines2.length; i++) {
      var line2 = trim2(lines2[i]);
      if (!line2) {
        continue;
      }
      var items = line2.split(itemSplitRegex);
      var name2 = "";
      var value;
      var hasName = false;
      if (isNaN(items[0])) {
        hasName = true;
        name2 = items[0];
        items = items.slice(1);
        data[i] = {
          name: name2,
          value: []
        };
        value = data[i].value;
      } else {
        value = data[i] = [];
      }
      for (var j = 0; j < items.length; j++) {
        value.push(+items[j]);
      }
      if (value.length === 1) {
        hasName ? data[i].value = value[0] : data[i] = value[0];
      }
    }
    return {
      name: seriesName,
      data
    };
  }
  function parseContents(str, blockMetaList) {
    var blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
    var newOption = {
      series: []
    };
    zrUtil2.each(blocks, function(block, idx) {
      if (isTSVFormat(block)) {
        var result = parseTSVContents(block);
        var blockMeta = blockMetaList[idx];
        var axisKey = blockMeta.axisDim + "Axis";
        if (blockMeta) {
          newOption[axisKey] = newOption[axisKey] || [];
          newOption[axisKey][blockMeta.axisIndex] = {
            data: result.categories
          };
          newOption.series = newOption.series.concat(result.series);
        }
      } else {
        var result = parseListContents(block);
        newOption.series.push(result);
      }
    });
    return newOption;
  }
  function DataView(model2) {
    this._dom = null;
    this.model = model2;
  }
  DataView.defaultOption = {
    show: true,
    readOnly: false,
    optionToContent: null,
    contentToOption: null,
    icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
    title: zrUtil2.clone(dataViewLang.title),
    lang: zrUtil2.clone(dataViewLang.lang),
    backgroundColor: "#fff",
    textColor: "#000",
    textareaColor: "#fff",
    textareaBorderColor: "#333",
    buttonColor: "#c23531",
    buttonTextColor: "#fff"
  };
  DataView.prototype.onclick = function(ecModel, api) {
    var container = api.getDom();
    var model2 = this.model;
    if (this._dom) {
      container.removeChild(this._dom);
    }
    var root = document.createElement("div");
    root.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;";
    root.style.backgroundColor = model2.get("backgroundColor") || "#fff";
    var header = document.createElement("h4");
    var lang3 = model2.get("lang") || [];
    header.innerHTML = lang3[0] || model2.get("title");
    header.style.cssText = "margin: 10px 20px;";
    header.style.color = model2.get("textColor");
    var viewMain = document.createElement("div");
    var textarea = document.createElement("textarea");
    viewMain.style.cssText = "display:block;width:100%;overflow:auto;";
    var optionToContent = model2.get("optionToContent");
    var contentToOption = model2.get("contentToOption");
    var result = getContentFromModel(ecModel);
    if (typeof optionToContent === "function") {
      var htmlOrDom = optionToContent(api.getOption());
      if (typeof htmlOrDom === "string") {
        viewMain.innerHTML = htmlOrDom;
      } else if (zrUtil2.isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      viewMain.appendChild(textarea);
      textarea.readOnly = model2.get("readOnly");
      textarea.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;";
      textarea.style.color = model2.get("textColor");
      textarea.style.borderColor = model2.get("textareaBorderColor");
      textarea.style.backgroundColor = model2.get("textareaColor");
      textarea.value = result.value;
    }
    var blockMetaList = result.meta;
    var buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
    var buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
    var closeButton = document.createElement("div");
    var refreshButton = document.createElement("div");
    buttonStyle += ";background-color:" + model2.get("buttonColor");
    buttonStyle += ";color:" + model2.get("buttonTextColor");
    var self2 = this;
    function close() {
      container.removeChild(root);
      self2._dom = null;
    }
    eventTool2.addEventListener(closeButton, "click", close);
    eventTool2.addEventListener(refreshButton, "click", function() {
      var newOption;
      try {
        if (typeof contentToOption === "function") {
          newOption = contentToOption(viewMain, api.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e2) {
        close();
        throw new Error("Data view format error " + e2);
      }
      if (newOption) {
        api.dispatchAction({
          type: "changeDataView",
          newOption
        });
      }
      close();
    });
    closeButton.innerHTML = lang3[1];
    refreshButton.innerHTML = lang3[2];
    refreshButton.style.cssText = buttonStyle;
    closeButton.style.cssText = buttonStyle;
    !model2.get("readOnly") && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    root.appendChild(header);
    root.appendChild(viewMain);
    root.appendChild(buttonContainer);
    viewMain.style.height = container.clientHeight - 80 + "px";
    container.appendChild(root);
    this._dom = root;
  };
  DataView.prototype.remove = function(ecModel, api) {
    this._dom && api.getDom().removeChild(this._dom);
  };
  DataView.prototype.dispose = function(ecModel, api) {
    this.remove(ecModel, api);
  };
  function tryMergeDataOption(newData, originalData) {
    return zrUtil2.map(newData, function(newVal, idx) {
      var original = originalData && originalData[idx];
      if (zrUtil2.isObject(original) && !zrUtil2.isArray(original)) {
        var newValIsObject = zrUtil2.isObject(newVal) && !zrUtil2.isArray(newVal);
        if (!newValIsObject) {
          newVal = {
            value: newVal
          };
        }
        var shouldDeleteName = original.name != null && newVal.name == null;
        newVal = zrUtil2.defaults(newVal, original);
        shouldDeleteName && delete newVal.name;
        return newVal;
      } else {
        return newVal;
      }
    });
  }
  featureManager2.register("dataView", DataView);
  echarts$12.registerAction({
    type: "changeDataView",
    event: "dataViewChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel) {
    var newSeriesOptList = [];
    zrUtil2.each(payload.newOption.series, function(seriesOpt) {
      var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
      if (!seriesModel) {
        newSeriesOptList.push(zrUtil2.extend({
          // Default is scatter
          type: "scatter"
        }, seriesOpt));
      } else {
        var originalData = seriesModel.get("data");
        newSeriesOptList.push({
          name: seriesOpt.name,
          data: tryMergeDataOption(seriesOpt.data, originalData)
        });
      }
    });
    ecModel.mergeOption(zrUtil2.defaults({
      series: newSeriesOptList
    }, payload.newOption));
  });
  var _default2 = DataView;
  _DataView = _default2;
  return _DataView;
}
var BrushTargetManager_1;
var hasRequiredBrushTargetManager;
function requireBrushTargetManager() {
  if (hasRequiredBrushTargetManager)
    return BrushTargetManager_1;
  hasRequiredBrushTargetManager = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var modelUtil2 = model;
  var brushHelper2 = requireBrushHelper();
  var each2 = zrUtil2.each;
  var indexOf2 = zrUtil2.indexOf;
  var curry2 = zrUtil2.curry;
  var COORD_CONVERTS = ["dataToPoint", "pointToData"];
  var INCLUDE_FINDER_MAIN_TYPES = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
  function BrushTargetManager(option, ecModel, opt) {
    var targetInfoList = this._targetInfoList = [];
    var info = {};
    var foundCpts = parseFinder2(ecModel, option);
    each2(targetInfoBuilders, function(builder, type) {
      if (!opt || !opt.include || indexOf2(opt.include, type) >= 0) {
        builder(foundCpts, targetInfoList, info);
      }
    });
  }
  var proto2 = BrushTargetManager.prototype;
  proto2.setOutputRanges = function(areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      (area.coordRanges || (area.coordRanges = [])).push(coordRange);
      if (!area.coordRange) {
        area.coordRange = coordRange;
        var result = coordConvert[area.brushType](0, coordSys, coordRange);
        area.__rangeOffset = {
          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
          xyMinMax: result.xyMinMax
        };
      }
    });
  };
  proto2.matchOutputRanges = function(areas, ecModel, cb) {
    each2(areas, function(area) {
      var targetInfo = this.findTargetInfo(area, ecModel);
      if (targetInfo && targetInfo !== true) {
        zrUtil2.each(targetInfo.coordSyses, function(coordSys) {
          var result = coordConvert[area.brushType](1, coordSys, area.range);
          cb(area, result.values, coordSys, ecModel);
        });
      }
    }, this);
  };
  proto2.setInputRanges = function(areas, ecModel) {
    each2(areas, function(area) {
      var targetInfo = this.findTargetInfo(area, ecModel);
      area.range = area.range || [];
      if (targetInfo && targetInfo !== true) {
        area.panelId = targetInfo.panelId;
        var result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
        var rangeOffset = area.__rangeOffset;
        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
      }
    }, this);
  };
  proto2.makePanelOpts = function(api, getDefaultBrushType) {
    return zrUtil2.map(this._targetInfoList, function(targetInfo) {
      var rect = targetInfo.getPanelRect();
      return {
        panelId: targetInfo.panelId,
        defaultBrushType: getDefaultBrushType && getDefaultBrushType(targetInfo),
        clipPath: brushHelper2.makeRectPanelClipPath(rect),
        isTargetByCursor: brushHelper2.makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
        getLinearBrushOtherExtent: brushHelper2.makeLinearBrushOtherExtent(rect)
      };
    });
  };
  proto2.controlSeries = function(area, seriesModel, ecModel) {
    var targetInfo = this.findTargetInfo(area, ecModel);
    return targetInfo === true || targetInfo && indexOf2(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
  };
  proto2.findTargetInfo = function(area, ecModel) {
    var targetInfoList = this._targetInfoList;
    var foundCpts = parseFinder2(ecModel, area);
    for (var i = 0; i < targetInfoList.length; i++) {
      var targetInfo = targetInfoList[i];
      var areaPanelId = area.panelId;
      if (areaPanelId) {
        if (targetInfo.panelId === areaPanelId) {
          return targetInfo;
        }
      } else {
        for (var i = 0; i < targetInfoMatchers.length; i++) {
          if (targetInfoMatchers[i](foundCpts, targetInfo)) {
            return targetInfo;
          }
        }
      }
    }
    return true;
  };
  function formatMinMax(minMax) {
    minMax[0] > minMax[1] && minMax.reverse();
    return minMax;
  }
  function parseFinder2(ecModel, option) {
    return modelUtil2.parseFinder(ecModel, option, {
      includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
    });
  }
  var targetInfoBuilders = {
    grid: function(foundCpts, targetInfoList) {
      var xAxisModels = foundCpts.xAxisModels;
      var yAxisModels = foundCpts.yAxisModels;
      var gridModels = foundCpts.gridModels;
      var gridModelMap = zrUtil2.createHashMap();
      var xAxesHas = {};
      var yAxesHas = {};
      if (!xAxisModels && !yAxisModels && !gridModels) {
        return;
      }
      each2(xAxisModels, function(axisModel) {
        var gridModel = axisModel.axis.grid.model;
        gridModelMap.set(gridModel.id, gridModel);
        xAxesHas[gridModel.id] = true;
      });
      each2(yAxisModels, function(axisModel) {
        var gridModel = axisModel.axis.grid.model;
        gridModelMap.set(gridModel.id, gridModel);
        yAxesHas[gridModel.id] = true;
      });
      each2(gridModels, function(gridModel) {
        gridModelMap.set(gridModel.id, gridModel);
        xAxesHas[gridModel.id] = true;
        yAxesHas[gridModel.id] = true;
      });
      gridModelMap.each(function(gridModel) {
        var grid2 = gridModel.coordinateSystem;
        var cartesians = [];
        each2(grid2.getCartesians(), function(cartesian, index2) {
          if (indexOf2(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf2(yAxisModels, cartesian.getAxis("y").model) >= 0) {
            cartesians.push(cartesian);
          }
        });
        targetInfoList.push({
          panelId: "grid--" + gridModel.id,
          gridModel,
          coordSysModel: gridModel,
          // Use the first one as the representitive coordSys.
          coordSys: cartesians[0],
          coordSyses: cartesians,
          getPanelRect: panelRectBuilder.grid,
          xAxisDeclared: xAxesHas[gridModel.id],
          yAxisDeclared: yAxesHas[gridModel.id]
        });
      });
    },
    geo: function(foundCpts, targetInfoList) {
      each2(foundCpts.geoModels, function(geoModel) {
        var coordSys = geoModel.coordinateSystem;
        targetInfoList.push({
          panelId: "geo--" + geoModel.id,
          geoModel,
          coordSysModel: geoModel,
          coordSys,
          coordSyses: [coordSys],
          getPanelRect: panelRectBuilder.geo
        });
      });
    }
  };
  var targetInfoMatchers = [
    // grid
    function(foundCpts, targetInfo) {
      var xAxisModel = foundCpts.xAxisModel;
      var yAxisModel = foundCpts.yAxisModel;
      var gridModel = foundCpts.gridModel;
      !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
      !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
      return gridModel && gridModel === targetInfo.gridModel;
    },
    // geo
    function(foundCpts, targetInfo) {
      var geoModel = foundCpts.geoModel;
      return geoModel && geoModel === targetInfo.geoModel;
    }
  ];
  var panelRectBuilder = {
    grid: function() {
      return this.coordSys.grid.getRect().clone();
    },
    geo: function() {
      var coordSys = this.coordSys;
      var rect = coordSys.getBoundingRect().clone();
      rect.applyTransform(graphic2.getTransform(coordSys));
      return rect;
    }
  };
  var coordConvert = {
    lineX: curry2(axisConvert, 0),
    lineY: curry2(axisConvert, 1),
    rect: function(to, coordSys, rangeOrCoordRange) {
      var xminymin = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]]);
      var xmaxymax = coordSys[COORD_CONVERTS[to]]([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]]);
      var values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])];
      return {
        values,
        xyMinMax: values
      };
    },
    polygon: function(to, coordSys, rangeOrCoordRange) {
      var xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
      var values = zrUtil2.map(rangeOrCoordRange, function(item) {
        var p2 = coordSys[COORD_CONVERTS[to]](item);
        xyMinMax[0][0] = Math.min(xyMinMax[0][0], p2[0]);
        xyMinMax[1][0] = Math.min(xyMinMax[1][0], p2[1]);
        xyMinMax[0][1] = Math.max(xyMinMax[0][1], p2[0]);
        xyMinMax[1][1] = Math.max(xyMinMax[1][1], p2[1]);
        return p2;
      });
      return {
        values,
        xyMinMax
      };
    }
  };
  function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
    var axis2 = coordSys.getAxis(["x", "y"][axisNameIndex]);
    var values = formatMinMax(zrUtil2.map([0, 1], function(i) {
      return to ? axis2.coordToData(axis2.toLocalCoord(rangeOrCoordRange[i])) : axis2.toGlobalCoord(axis2.dataToCoord(rangeOrCoordRange[i]));
    }));
    var xyMinMax = [];
    xyMinMax[axisNameIndex] = values;
    xyMinMax[1 - axisNameIndex] = [NaN, NaN];
    return {
      values,
      xyMinMax
    };
  }
  var diffProcessor = {
    lineX: curry2(axisDiffProcessor, 0),
    lineY: curry2(axisDiffProcessor, 1),
    rect: function(values, refer, scales) {
      return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]];
    },
    polygon: function(values, refer, scales) {
      return zrUtil2.map(values, function(item, idx) {
        return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
      });
    }
  };
  function axisDiffProcessor(axisNameIndex, values, refer, scales) {
    return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]];
  }
  function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
    var sizeCurr = getSize(xyMinMaxCurr);
    var sizeOrigin = getSize(xyMinMaxOrigin);
    var scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
    isNaN(scales[0]) && (scales[0] = 1);
    isNaN(scales[1]) && (scales[1] = 1);
    return scales;
  }
  function getSize(xyMinMax) {
    return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
  }
  var _default2 = BrushTargetManager;
  BrushTargetManager_1 = _default2;
  return BrushTargetManager_1;
}
var history = {};
var hasRequiredHistory;
function requireHistory() {
  if (hasRequiredHistory)
    return history;
  hasRequiredHistory = 1;
  var zrUtil2 = util$6;
  var each2 = zrUtil2.each;
  var ATTR = "\0_ec_hist_store";
  function push(ecModel, newSnapshot) {
    var store = giveStore(ecModel);
    each2(newSnapshot, function(batchItem, dataZoomId) {
      var i = store.length - 1;
      for (; i >= 0; i--) {
        var snapshot = store[i];
        if (snapshot[dataZoomId]) {
          break;
        }
      }
      if (i < 0) {
        var dataZoomModel = ecModel.queryComponents({
          mainType: "dataZoom",
          subType: "select",
          id: dataZoomId
        })[0];
        if (dataZoomModel) {
          var percentRange = dataZoomModel.getPercentRange();
          store[0][dataZoomId] = {
            dataZoomId,
            start: percentRange[0],
            end: percentRange[1]
          };
        }
      }
    });
    store.push(newSnapshot);
  }
  function pop(ecModel) {
    var store = giveStore(ecModel);
    var head = store[store.length - 1];
    store.length > 1 && store.pop();
    var snapshot = {};
    each2(head, function(batchItem, dataZoomId) {
      for (var i = store.length - 1; i >= 0; i--) {
        var batchItem = store[i][dataZoomId];
        if (batchItem) {
          snapshot[dataZoomId] = batchItem;
          break;
        }
      }
    });
    return snapshot;
  }
  function clear2(ecModel) {
    ecModel[ATTR] = null;
  }
  function count(ecModel) {
    return giveStore(ecModel).length;
  }
  function giveStore(ecModel) {
    var store = ecModel[ATTR];
    if (!store) {
      store = ecModel[ATTR] = [{}];
    }
    return store;
  }
  history.push = push;
  history.pop = pop;
  history.clear = clear2;
  history.count = count;
  return history;
}
var dataZoomSelect = {};
var typeDefaulter$2 = {};
var hasRequiredTypeDefaulter$2;
function requireTypeDefaulter$2() {
  if (hasRequiredTypeDefaulter$2)
    return typeDefaulter$2;
  hasRequiredTypeDefaulter$2 = 1;
  var Component2 = Component$2;
  Component2.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  });
  return typeDefaulter$2;
}
var helper$1 = {};
var hasRequiredHelper$1;
function requireHelper$1() {
  if (hasRequiredHelper$1)
    return helper$1;
  hasRequiredHelper$1 = 1;
  var zrUtil2 = util$6;
  var formatUtil2 = requireFormat();
  var AXIS_DIMS = ["x", "y", "z", "radius", "angle", "single"];
  var COORDS = ["cartesian2d", "polar", "singleAxis"];
  function isCoordSupported(coordType) {
    return zrUtil2.indexOf(COORDS, coordType) >= 0;
  }
  function createNameEach(names, attrs) {
    names = names.slice();
    var capitalNames = zrUtil2.map(names, formatUtil2.capitalFirst);
    attrs = (attrs || []).slice();
    var capitalAttrs = zrUtil2.map(attrs, formatUtil2.capitalFirst);
    return function(callback, context) {
      zrUtil2.each(names, function(name2, index2) {
        var nameObj = {
          name: name2,
          capital: capitalNames[index2]
        };
        for (var j = 0; j < attrs.length; j++) {
          nameObj[attrs[j]] = name2 + capitalAttrs[j];
        }
        callback.call(context, nameObj);
      });
    };
  }
  var eachAxisDim = createNameEach(AXIS_DIMS, ["axisIndex", "axis", "index", "id"]);
  function createLinkedNodesFinder(forEachNode, forEachEdgeType, edgeIdGetter) {
    return function(sourceNode) {
      var result = {
        nodes: [],
        records: {}
        // key: edgeType.name, value: Object (key: edge id, value: boolean).
      };
      forEachEdgeType(function(edgeType) {
        result.records[edgeType.name] = {};
      });
      if (!sourceNode) {
        return result;
      }
      absorb(sourceNode, result);
      var existsLink;
      do {
        existsLink = false;
        forEachNode(processSingleNode);
      } while (existsLink);
      function processSingleNode(node) {
        if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
          absorb(node, result);
          existsLink = true;
        }
      }
      return result;
    };
    function isNodeAbsorded(node, result) {
      return zrUtil2.indexOf(result.nodes, node) >= 0;
    }
    function isLinked(node, result) {
      var hasLink = false;
      forEachEdgeType(function(edgeType) {
        zrUtil2.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
          result.records[edgeType.name][edgeId] && (hasLink = true);
        });
      });
      return hasLink;
    }
    function absorb(node, result) {
      result.nodes.push(node);
      forEachEdgeType(function(edgeType) {
        zrUtil2.each(edgeIdGetter(node, edgeType) || [], function(edgeId) {
          result.records[edgeType.name][edgeId] = true;
        });
      });
    }
  }
  helper$1.isCoordSupported = isCoordSupported;
  helper$1.createNameEach = createNameEach;
  helper$1.eachAxisDim = eachAxisDim;
  helper$1.createLinkedNodesFinder = createLinkedNodesFinder;
  return helper$1;
}
var AxisProxy_1;
var hasRequiredAxisProxy;
function requireAxisProxy() {
  if (hasRequiredAxisProxy)
    return AxisProxy_1;
  hasRequiredAxisProxy = 1;
  var zrUtil2 = util$6;
  var numberUtil = requireNumber();
  var helper2 = requireHelper$1();
  var sliderMove2 = requireSliderMove();
  var each2 = zrUtil2.each;
  var asc = numberUtil.asc;
  var AxisProxy = function(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this._valueWindow;
    this._percentWindow;
    this._dataExtent;
    this._minMaxSpan;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  };
  AxisProxy.prototype = {
    constructor: AxisProxy,
    /**
     * Whether the axisProxy is hosted by dataZoomModel.
     *
     * @public
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     * @return {boolean}
     */
    hostedBy: function(dataZoomModel) {
      return this._dataZoomModel === dataZoomModel;
    },
    /**
     * @return {Array.<number>} Value can only be NaN or finite value.
     */
    getDataValueWindow: function() {
      return this._valueWindow.slice();
    },
    /**
     * @return {Array.<number>}
     */
    getDataPercentWindow: function() {
      return this._percentWindow.slice();
    },
    /**
     * @public
     * @param {number} axisIndex
     * @return {Array} seriesModels
     */
    getTargetSeriesModels: function() {
      var seriesModels = [];
      var ecModel = this.ecModel;
      ecModel.eachSeries(function(seriesModel) {
        if (helper2.isCoordSupported(seriesModel.get("coordinateSystem"))) {
          var dimName = this._dimName;
          var axisModel = ecModel.queryComponents({
            mainType: dimName + "Axis",
            index: seriesModel.get(dimName + "AxisIndex"),
            id: seriesModel.get(dimName + "AxisId")
          })[0];
          if (this._axisIndex === (axisModel && axisModel.componentIndex)) {
            seriesModels.push(seriesModel);
          }
        }
      }, this);
      return seriesModels;
    },
    getAxisModel: function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    },
    getOtherAxisModel: function() {
      var axisDim = this._dimName;
      var ecModel = this.ecModel;
      var axisModel = this.getAxisModel();
      var isCartesian = axisDim === "x" || axisDim === "y";
      var otherAxisDim;
      var coordSysIndexName;
      if (isCartesian) {
        coordSysIndexName = "gridIndex";
        otherAxisDim = axisDim === "x" ? "y" : "x";
      } else {
        coordSysIndexName = "polarIndex";
        otherAxisDim = axisDim === "angle" ? "radius" : "angle";
      }
      var foundOtherAxisModel;
      ecModel.eachComponent(otherAxisDim + "Axis", function(otherAxisModel) {
        if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
          foundOtherAxisModel = otherAxisModel;
        }
      });
      return foundOtherAxisModel;
    },
    getMinMaxSpan: function() {
      return zrUtil2.clone(this._minMaxSpan);
    },
    /**
     * Only calculate by given range and this._dataExtent, do not change anything.
     *
     * @param {Object} opt
     * @param {number} [opt.start]
     * @param {number} [opt.end]
     * @param {number} [opt.startValue]
     * @param {number} [opt.endValue]
     */
    calculateDataWindow: function(opt) {
      var dataExtent = this._dataExtent;
      var axisModel = this.getAxisModel();
      var scale = axisModel.axis.scale;
      var rangePropMode = this._dataZoomModel.getRangePropMode();
      var percentExtent = [0, 100];
      var percentWindow = [];
      var valueWindow = [];
      var hasPropModeValue;
      each2(["start", "end"], function(prop, idx) {
        var boundPercent = opt[prop];
        var boundValue = opt[prop + "Value"];
        if (rangePropMode[idx] === "percent") {
          boundPercent == null && (boundPercent = percentExtent[idx]);
          boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));
        } else {
          hasPropModeValue = true;
          boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue);
          boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);
        }
        valueWindow[idx] = boundValue;
        percentWindow[idx] = boundPercent;
      });
      asc(valueWindow);
      asc(percentWindow);
      var spans = this._minMaxSpan;
      hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
      function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
        var suffix = toValue ? "Span" : "ValueSpan";
        sliderMove2(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
        for (var i = 0; i < 2; i++) {
          toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);
          toValue && (toWindow[i] = scale.parse(toWindow[i]));
        }
      }
      return {
        valueWindow,
        percentWindow
      };
    },
    /**
     * Notice: reset should not be called before series.restoreData() called,
     * so it is recommanded to be called in "process stage" but not "model init
     * stage".
     *
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */
    reset: function(dataZoomModel) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      var targetSeries = this.getTargetSeriesModels();
      this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
      setMinMaxSpan(this);
      var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
      this._valueWindow = dataWindow.valueWindow;
      this._percentWindow = dataWindow.percentWindow;
      setAxisModel(this);
    },
    /**
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */
    restore: function(dataZoomModel) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      this._valueWindow = this._percentWindow = null;
      setAxisModel(this, true);
    },
    /**
     * @param {module: echarts/component/dataZoom/DataZoomModel} dataZoomModel
     */
    filterData: function(dataZoomModel, api) {
      if (dataZoomModel !== this._dataZoomModel) {
        return;
      }
      var axisDim = this._dimName;
      var seriesModels = this.getTargetSeriesModels();
      var filterMode = dataZoomModel.get("filterMode");
      var valueWindow = this._valueWindow;
      if (filterMode === "none") {
        return;
      }
      each2(seriesModels, function(seriesModel) {
        var seriesData = seriesModel.getData();
        var dataDims = seriesData.mapDimension(axisDim, true);
        if (!dataDims.length) {
          return;
        }
        if (filterMode === "weakFilter") {
          seriesData.filterSelf(function(dataIndex) {
            var leftOut;
            var rightOut;
            var hasValue;
            for (var i = 0; i < dataDims.length; i++) {
              var value = seriesData.get(dataDims[i], dataIndex);
              var thisHasValue = !isNaN(value);
              var thisLeftOut = value < valueWindow[0];
              var thisRightOut = value > valueWindow[1];
              if (thisHasValue && !thisLeftOut && !thisRightOut) {
                return true;
              }
              thisHasValue && (hasValue = true);
              thisLeftOut && (leftOut = true);
              thisRightOut && (rightOut = true);
            }
            return hasValue && leftOut && rightOut;
          });
        } else {
          each2(dataDims, function(dim) {
            if (filterMode === "empty") {
              seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
                return !isInWindow(value) ? NaN : value;
              }));
            } else {
              var range = {};
              range[dim] = valueWindow;
              seriesData.selectRange(range);
            }
          });
        }
        each2(dataDims, function(dim) {
          seriesData.setApproximateExtent(valueWindow, dim);
        });
      });
      function isInWindow(value) {
        return value >= valueWindow[0] && value <= valueWindow[1];
      }
    }
  };
  function calculateDataExtent(axisProxy, axisDim, seriesModels) {
    var dataExtent = [Infinity, -Infinity];
    each2(seriesModels, function(seriesModel) {
      var seriesData = seriesModel.getData();
      if (seriesData) {
        each2(seriesData.mapDimension(axisDim, true), function(dim) {
          var seriesExtent = seriesData.getApproximateExtent(dim);
          seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
          seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
        });
      }
    });
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    fixExtentByAxis(axisProxy, dataExtent);
    return dataExtent;
  }
  function fixExtentByAxis(axisProxy, dataExtent) {
    var axisModel = axisProxy.getAxisModel();
    var min3 = axisModel.getMin(true);
    var isCategoryAxis = axisModel.get("type") === "category";
    var axisDataLen = isCategoryAxis && axisModel.getCategories().length;
    if (min3 != null && min3 !== "dataMin" && typeof min3 !== "function") {
      dataExtent[0] = min3;
    } else if (isCategoryAxis) {
      dataExtent[0] = axisDataLen > 0 ? 0 : NaN;
    }
    var max3 = axisModel.getMax(true);
    if (max3 != null && max3 !== "dataMax" && typeof max3 !== "function") {
      dataExtent[1] = max3;
    } else if (isCategoryAxis) {
      dataExtent[1] = axisDataLen > 0 ? axisDataLen - 1 : NaN;
    }
    if (!axisModel.get("scale", true)) {
      dataExtent[0] > 0 && (dataExtent[0] = 0);
      dataExtent[1] < 0 && (dataExtent[1] = 0);
    }
    return dataExtent;
  }
  function setAxisModel(axisProxy, isRestore) {
    var axisModel = axisProxy.getAxisModel();
    var percentWindow = axisProxy._percentWindow;
    var valueWindow = axisProxy._valueWindow;
    if (!percentWindow) {
      return;
    }
    var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20);
    var useOrigin = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
    axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
  }
  function setMinMaxSpan(axisProxy) {
    var minMaxSpan = axisProxy._minMaxSpan = {};
    var dataZoomModel = axisProxy._dataZoomModel;
    var dataExtent = axisProxy._dataExtent;
    each2(["min", "max"], function(minMax) {
      var percentSpan = dataZoomModel.get(minMax + "Span");
      var valueSpan = dataZoomModel.get(minMax + "ValueSpan");
      valueSpan != null && (valueSpan = axisProxy.getAxisModel().axis.scale.parse(valueSpan));
      if (valueSpan != null) {
        percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }
      minMaxSpan[minMax + "Span"] = percentSpan;
      minMaxSpan[minMax + "ValueSpan"] = valueSpan;
    });
  }
  var _default2 = AxisProxy;
  AxisProxy_1 = _default2;
  return AxisProxy_1;
}
var DataZoomModel_1;
var hasRequiredDataZoomModel;
function requireDataZoomModel() {
  if (hasRequiredDataZoomModel)
    return DataZoomModel_1;
  hasRequiredDataZoomModel = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var env2 = env_1;
  var modelUtil2 = model;
  var helper2 = requireHelper$1();
  var AxisProxy = requireAxisProxy();
  var each2 = zrUtil2.each;
  var eachAxisDim = helper2.eachAxisDim;
  var DataZoomModel = echarts$12.extendComponentModel({
    type: "dataZoom",
    dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"],
    /**
     * @protected
     */
    defaultOption: {
      zlevel: 0,
      z: 4,
      // Higher than normal component (z: 2).
      orient: null,
      // Default auto by axisIndex. Possible value: 'horizontal', 'vertical'.
      xAxisIndex: null,
      // Default the first horizontal category axis.
      yAxisIndex: null,
      // Default the first vertical category axis.
      filterMode: "filter",
      // Possible values: 'filter' or 'empty' or 'weakFilter'.
      // 'filter': data items which are out of window will be removed. This option is
      //          applicable when filtering outliers. For each data item, it will be
      //          filtered if one of the relevant dimensions is out of the window.
      // 'weakFilter': data items which are out of window will be removed. This option
      //          is applicable when filtering outliers. For each data item, it will be
      //          filtered only if all  of the relevant dimensions are out of the same
      //          side of the window.
      // 'empty': data items which are out of window will be set to empty.
      //          This option is applicable when user should not neglect
      //          that there are some data items out of window.
      // 'none': Do not filter.
      // Taking line chart as an example, line will be broken in
      // the filtered points when filterModel is set to 'empty', but
      // be connected when set to 'filter'.
      throttle: null,
      // Dispatch action by the fixed rate, avoid frequency.
      // default 100. Do not throttle when use null/undefined.
      // If animation === true and animationDurationUpdate > 0,
      // default value is 100, otherwise 20.
      start: 0,
      // Start percent. 0 ~ 100
      end: 100,
      // End percent. 0 ~ 100
      startValue: null,
      // Start value. If startValue specified, start is ignored.
      endValue: null,
      // End value. If endValue specified, end is ignored.
      minSpan: null,
      // 0 ~ 100
      maxSpan: null,
      // 0 ~ 100
      minValueSpan: null,
      // The range of dataZoom can not be smaller than that.
      maxValueSpan: null,
      // The range of dataZoom can not be larger than that.
      rangeMode: null
      // Array, can be 'value' or 'percent'.
    },
    /**
     * @override
     */
    init: function(option, parentModel, ecModel) {
      this._dataIntervalByAxis = {};
      this._dataInfo = {};
      this._axisProxies = {};
      this.textStyleModel;
      this._autoThrottle = true;
      this._rangePropMode = ["percent", "percent"];
      var inputRawOption = retrieveRawOption(option);
      this.settledOption = inputRawOption;
      this.mergeDefaultAndTheme(option, ecModel);
      this.doInit(inputRawOption);
    },
    /**
     * @override
     */
    mergeOption: function(newOption) {
      var inputRawOption = retrieveRawOption(newOption);
      zrUtil2.merge(this.option, newOption, true);
      zrUtil2.merge(this.settledOption, inputRawOption, true);
      this.doInit(inputRawOption);
    },
    /**
     * @protected
     */
    doInit: function(inputRawOption) {
      var thisOption = this.option;
      if (!env2.canvasSupported) {
        thisOption.realtime = false;
      }
      this._setDefaultThrottle(inputRawOption);
      updateRangeUse(this, inputRawOption);
      var settledOption = this.settledOption;
      each2([["start", "startValue"], ["end", "endValue"]], function(names, index2) {
        if (this._rangePropMode[index2] === "value") {
          thisOption[names[0]] = settledOption[names[0]] = null;
        }
      }, this);
      this.textStyleModel = this.getModel("textStyle");
      this._resetTarget();
      this._giveAxisProxies();
    },
    /**
     * @private
     */
    _giveAxisProxies: function() {
      var axisProxies = this._axisProxies;
      this.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel, ecModel) {
        var axisModel = this.dependentModels[dimNames.axis][axisIndex];
        var axisProxy = axisModel.__dzAxisProxy || // Use the first dataZoomModel as the main model of axisProxy.
        (axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel));
        axisProxies[dimNames.name + "_" + axisIndex] = axisProxy;
      }, this);
    },
    /**
     * @private
     */
    _resetTarget: function() {
      var thisOption = this.option;
      var autoMode = this._judgeAutoMode();
      eachAxisDim(function(dimNames) {
        var axisIndexName = dimNames.axisIndex;
        thisOption[axisIndexName] = modelUtil2.normalizeToArray(thisOption[axisIndexName]);
      }, this);
      if (autoMode === "axisIndex") {
        this._autoSetAxisIndex();
      } else if (autoMode === "orient") {
        this._autoSetOrient();
      }
    },
    /**
     * @private
     */
    _judgeAutoMode: function() {
      var thisOption = this.option;
      var hasIndexSpecified = false;
      eachAxisDim(function(dimNames) {
        if (thisOption[dimNames.axisIndex] != null) {
          hasIndexSpecified = true;
        }
      }, this);
      var orient = thisOption.orient;
      if (orient == null && hasIndexSpecified) {
        return "orient";
      } else if (!hasIndexSpecified) {
        if (orient == null) {
          thisOption.orient = "horizontal";
        }
        return "axisIndex";
      }
    },
    /**
     * @private
     */
    _autoSetAxisIndex: function() {
      var autoAxisIndex = true;
      var orient = this.get("orient", true);
      var thisOption = this.option;
      var dependentModels = this.dependentModels;
      if (autoAxisIndex) {
        var dimName = orient === "vertical" ? "y" : "x";
        if (dependentModels[dimName + "Axis"].length) {
          thisOption[dimName + "AxisIndex"] = [0];
          autoAxisIndex = false;
        } else {
          each2(dependentModels.singleAxis, function(singleAxisModel) {
            if (autoAxisIndex && singleAxisModel.get("orient", true) === orient) {
              thisOption.singleAxisIndex = [singleAxisModel.componentIndex];
              autoAxisIndex = false;
            }
          });
        }
      }
      if (autoAxisIndex) {
        eachAxisDim(function(dimNames) {
          if (!autoAxisIndex) {
            return;
          }
          var axisIndices = [];
          var axisModels = this.dependentModels[dimNames.axis];
          if (axisModels.length && !axisIndices.length) {
            for (var i = 0, len = axisModels.length; i < len; i++) {
              if (axisModels[i].get("type") === "category") {
                axisIndices.push(i);
              }
            }
          }
          thisOption[dimNames.axisIndex] = axisIndices;
          if (axisIndices.length) {
            autoAxisIndex = false;
          }
        }, this);
      }
      if (autoAxisIndex) {
        this.ecModel.eachSeries(function(seriesModel) {
          if (this._isSeriesHasAllAxesTypeOf(seriesModel, "value")) {
            eachAxisDim(function(dimNames) {
              var axisIndices = thisOption[dimNames.axisIndex];
              var axisIndex = seriesModel.get(dimNames.axisIndex);
              var axisId = seriesModel.get(dimNames.axisId);
              var axisModel = seriesModel.ecModel.queryComponents({
                mainType: dimNames.axis,
                index: axisIndex,
                id: axisId
              })[0];
              axisIndex = axisModel.componentIndex;
              if (zrUtil2.indexOf(axisIndices, axisIndex) < 0) {
                axisIndices.push(axisIndex);
              }
            });
          }
        }, this);
      }
    },
    /**
     * @private
     */
    _autoSetOrient: function() {
      var dim;
      this.eachTargetAxis(function(dimNames) {
        !dim && (dim = dimNames.name);
      }, this);
      this.option.orient = dim === "y" ? "vertical" : "horizontal";
    },
    /**
     * @private
     */
    _isSeriesHasAllAxesTypeOf: function(seriesModel, axisType) {
      var is = true;
      eachAxisDim(function(dimNames) {
        var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
        var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];
        if (!axisModel || axisModel.get("type") !== axisType) {
          is = false;
        }
      }, this);
      return is;
    },
    /**
     * @private
     */
    _setDefaultThrottle: function(inputRawOption) {
      if (inputRawOption.hasOwnProperty("throttle")) {
        this._autoThrottle = false;
      }
      if (this._autoThrottle) {
        var globalOption = this.ecModel.option;
        this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
      }
    },
    /**
     * @public
     */
    getFirstTargetAxisModel: function() {
      var firstAxisModel;
      eachAxisDim(function(dimNames) {
        if (firstAxisModel == null) {
          var indices = this.get(dimNames.axisIndex);
          if (indices.length) {
            firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
          }
        }
      }, this);
      return firstAxisModel;
    },
    /**
     * @public
     * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
     */
    eachTargetAxis: function(callback, context) {
      var ecModel = this.ecModel;
      eachAxisDim(function(dimNames) {
        each2(this.get(dimNames.axisIndex), function(axisIndex) {
          callback.call(context, dimNames, axisIndex, this, ecModel);
        }, this);
      }, this);
    },
    /**
     * @param {string} dimName
     * @param {number} axisIndex
     * @return {module:echarts/component/dataZoom/AxisProxy} If not found, return null/undefined.
     */
    getAxisProxy: function(dimName, axisIndex) {
      return this._axisProxies[dimName + "_" + axisIndex];
    },
    /**
     * @param {string} dimName
     * @param {number} axisIndex
     * @return {module:echarts/model/Model} If not found, return null/undefined.
     */
    getAxisModel: function(dimName, axisIndex) {
      var axisProxy = this.getAxisProxy(dimName, axisIndex);
      return axisProxy && axisProxy.getAxisModel();
    },
    /**
     * If not specified, set to undefined.
     *
     * @public
     * @param {Object} opt
     * @param {number} [opt.start]
     * @param {number} [opt.end]
     * @param {number} [opt.startValue]
     * @param {number} [opt.endValue]
     */
    setRawRange: function(opt) {
      var thisOption = this.option;
      var settledOption = this.settledOption;
      each2([["start", "startValue"], ["end", "endValue"]], function(names) {
        if (opt[names[0]] != null || opt[names[1]] != null) {
          thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
          thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
        }
      }, this);
      updateRangeUse(this, opt);
    },
    /**
     * @public
     * @param {Object} opt
     * @param {number} [opt.start]
     * @param {number} [opt.end]
     * @param {number} [opt.startValue]
     * @param {number} [opt.endValue]
     */
    setCalculatedRange: function(opt) {
      var option = this.option;
      each2(["start", "startValue", "end", "endValue"], function(name2) {
        option[name2] = opt[name2];
      });
    },
    /**
     * @public
     * @return {Array.<number>} [startPercent, endPercent]
     */
    getPercentRange: function() {
      var axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataPercentWindow();
      }
    },
    /**
     * @public
     * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
     *
     * @param {string} [axisDimName]
     * @param {number} [axisIndex]
     * @return {Array.<number>} [startValue, endValue] value can only be '-' or finite number.
     */
    getValueRange: function(axisDimName, axisIndex) {
      if (axisDimName == null && axisIndex == null) {
        var axisProxy = this.findRepresentativeAxisProxy();
        if (axisProxy) {
          return axisProxy.getDataValueWindow();
        }
      } else {
        return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
      }
    },
    /**
     * @public
     * @param {module:echarts/model/Model} [axisModel] If axisModel given, find axisProxy
     *      corresponding to the axisModel
     * @return {module:echarts/component/dataZoom/AxisProxy}
     */
    findRepresentativeAxisProxy: function(axisModel) {
      if (axisModel) {
        return axisModel.__dzAxisProxy;
      }
      var axisProxies = this._axisProxies;
      for (var key in axisProxies) {
        if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
          return axisProxies[key];
        }
      }
      for (var key in axisProxies) {
        if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
          return axisProxies[key];
        }
      }
    },
    /**
     * @return {Array.<string>}
     */
    getRangePropMode: function() {
      return this._rangePropMode.slice();
    }
  });
  function retrieveRawOption(option) {
    var ret = {};
    each2(["start", "end", "startValue", "endValue", "throttle"], function(name2) {
      option.hasOwnProperty(name2) && (ret[name2] = option[name2]);
    });
    return ret;
  }
  function updateRangeUse(dataZoomModel, inputRawOption) {
    var rangePropMode = dataZoomModel._rangePropMode;
    var rangeModeInOption = dataZoomModel.get("rangeMode");
    each2([["start", "startValue"], ["end", "endValue"]], function(names, index2) {
      var percentSpecified = inputRawOption[names[0]] != null;
      var valueSpecified = inputRawOption[names[1]] != null;
      if (percentSpecified && !valueSpecified) {
        rangePropMode[index2] = "percent";
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index2] = "value";
      } else if (rangeModeInOption) {
        rangePropMode[index2] = rangeModeInOption[index2];
      } else if (percentSpecified) {
        rangePropMode[index2] = "percent";
      }
    });
  }
  var _default2 = DataZoomModel;
  DataZoomModel_1 = _default2;
  return DataZoomModel_1;
}
var DataZoomView;
var hasRequiredDataZoomView;
function requireDataZoomView() {
  if (hasRequiredDataZoomView)
    return DataZoomView;
  hasRequiredDataZoomView = 1;
  var ComponentView = Component_1;
  var _default2 = ComponentView.extend({
    type: "dataZoom",
    render: function(dataZoomModel, ecModel, api, payload) {
      this.dataZoomModel = dataZoomModel;
      this.ecModel = ecModel;
      this.api = api;
    },
    /**
     * Find the first target coordinate system.
     *
     * @protected
     * @return {Object} {
     *                   grid: [
     *                       {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
     *                       {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
     *                       ...
     *                   ],  // cartesians must not be null/undefined.
     *                   polar: [
     *                       {model: coord0, axisModels: [axis4], coordIndex: 0},
     *                       ...
     *                   ],  // polars must not be null/undefined.
     *                   singleAxis: [
     *                       {model: coord0, axisModels: [], coordIndex: 0}
     *                   ]
     */
    getTargetCoordInfo: function() {
      var dataZoomModel = this.dataZoomModel;
      var ecModel = this.ecModel;
      var coordSysLists = {};
      dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
        var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);
        if (axisModel) {
          var coordModel = axisModel.getCoordSysModel();
          coordModel && save(coordModel, axisModel, coordSysLists[coordModel.mainType] || (coordSysLists[coordModel.mainType] = []), coordModel.componentIndex);
        }
      }, this);
      function save(coordModel, axisModel, store, coordIndex) {
        var item;
        for (var i = 0; i < store.length; i++) {
          if (store[i].model === coordModel) {
            item = store[i];
            break;
          }
        }
        if (!item) {
          store.push(item = {
            model: coordModel,
            axisModels: [],
            coordIndex
          });
        }
        item.axisModels.push(axisModel);
      }
      return coordSysLists;
    }
  });
  DataZoomView = _default2;
  return DataZoomView;
}
var SelectZoomModel;
var hasRequiredSelectZoomModel;
function requireSelectZoomModel() {
  if (hasRequiredSelectZoomModel)
    return SelectZoomModel;
  hasRequiredSelectZoomModel = 1;
  var DataZoomModel = requireDataZoomModel();
  var _default2 = DataZoomModel.extend({
    type: "dataZoom.select"
  });
  SelectZoomModel = _default2;
  return SelectZoomModel;
}
var SelectZoomView;
var hasRequiredSelectZoomView;
function requireSelectZoomView() {
  if (hasRequiredSelectZoomView)
    return SelectZoomView;
  hasRequiredSelectZoomView = 1;
  var DataZoomView2 = requireDataZoomView();
  var _default2 = DataZoomView2.extend({
    type: "dataZoom.select"
  });
  SelectZoomView = _default2;
  return SelectZoomView;
}
var dataZoomProcessor = {};
var hasRequiredDataZoomProcessor;
function requireDataZoomProcessor() {
  if (hasRequiredDataZoomProcessor)
    return dataZoomProcessor;
  hasRequiredDataZoomProcessor = 1;
  var echarts$12 = echarts;
  var _util2 = util$6;
  var createHashMap2 = _util2.createHashMap;
  var each2 = _util2.each;
  echarts$12.registerProcessor({
    // `dataZoomProcessor` will only be performed in needed series. Consider if
    // there is a line series and a pie series, it is better not to update the
    // line series if only pie series is needed to be updated.
    getTargetSeries: function(ecModel) {
      var seriesModelMap = createHashMap2();
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
          var axisProxy = dataZoomModel2.getAxisProxy(dimNames.name, axisIndex);
          each2(axisProxy.getTargetSeriesModels(), function(seriesModel) {
            seriesModelMap.set(seriesModel.uid, seriesModel);
          });
        });
      });
      return seriesModelMap;
    },
    modifyOutputEnd: true,
    // Consider appendData, where filter should be performed. Because data process is
    // in block mode currently, it is not need to worry about that the overallProgress
    // execute every frame.
    overallReset: function(ecModel, api) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
          dataZoomModel2.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel2, api);
        });
        dataZoomModel.eachTargetAxis(function(dimNames, axisIndex, dataZoomModel2) {
          dataZoomModel2.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel2, api);
        });
      });
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
        var percentRange = axisProxy.getDataPercentWindow();
        var valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      });
    }
  });
  return dataZoomProcessor;
}
var dataZoomAction = {};
var hasRequiredDataZoomAction;
function requireDataZoomAction() {
  if (hasRequiredDataZoomAction)
    return dataZoomAction;
  hasRequiredDataZoomAction = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var helper2 = requireHelper$1();
  echarts$12.registerAction("dataZoom", function(payload, ecModel) {
    var linkedNodesFinder = helper2.createLinkedNodesFinder(zrUtil2.bind(ecModel.eachComponent, ecModel, "dataZoom"), helper2.eachAxisDim, function(model2, dimNames) {
      return model2.get(dimNames.axisIndex);
    });
    var effectedModels = [];
    ecModel.eachComponent({
      mainType: "dataZoom",
      query: payload
    }, function(model2, index2) {
      effectedModels.push.apply(effectedModels, linkedNodesFinder(model2).nodes);
    });
    zrUtil2.each(effectedModels, function(dataZoomModel, index2) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
  return dataZoomAction;
}
var hasRequiredDataZoomSelect;
function requireDataZoomSelect() {
  if (hasRequiredDataZoomSelect)
    return dataZoomSelect;
  hasRequiredDataZoomSelect = 1;
  requireTypeDefaulter$2();
  requireDataZoomModel();
  requireDataZoomView();
  requireSelectZoomModel();
  requireSelectZoomView();
  requireDataZoomProcessor();
  requireDataZoomAction();
  return dataZoomSelect;
}
var DataZoom_1;
var hasRequiredDataZoom$1;
function requireDataZoom$1() {
  if (hasRequiredDataZoom$1)
    return DataZoom_1;
  hasRequiredDataZoom$1 = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var BrushController = requireBrushController();
  var BrushTargetManager = requireBrushTargetManager();
  var history2 = requireHistory();
  var sliderMove2 = requireSliderMove();
  var lang2 = lang$1;
  var featureManager2 = requireFeatureManager();
  requireDataZoomSelect();
  var dataZoomLang = lang2.toolbox.dataZoom;
  var each2 = zrUtil2.each;
  var DATA_ZOOM_ID_BASE = "\0_ec_\0toolbox-dataZoom_";
  function DataZoom(model2, ecModel, api) {
    (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil2.bind(this._onBrush, this)).mount();
    this._isZoomActive;
  }
  DataZoom.defaultOption = {
    show: true,
    filterMode: "filter",
    // Icon group
    icon: {
      zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
      back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
    },
    // `zoom`, `back`
    title: zrUtil2.clone(dataZoomLang.title),
    brushStyle: {
      borderWidth: 0,
      color: "rgba(0,0,0,0.2)"
    }
  };
  var proto2 = DataZoom.prototype;
  proto2.render = function(featureModel, ecModel, api, payload) {
    this.model = featureModel;
    this.ecModel = ecModel;
    this.api = api;
    updateZoomBtnStatus(featureModel, ecModel, this, payload, api);
    updateBackBtnStatus(featureModel, ecModel);
  };
  proto2.onclick = function(ecModel, api, type) {
    handlers[type].call(this);
  };
  proto2.remove = function(ecModel, api) {
    this._brushController.unmount();
  };
  proto2.dispose = function(ecModel, api) {
    this._brushController.dispose();
  };
  var handlers = {
    zoom: function() {
      var nextActive = !this._isZoomActive;
      this.api.dispatchAction({
        type: "takeGlobalCursor",
        key: "dataZoomSelect",
        dataZoomSelectActive: nextActive
      });
    },
    back: function() {
      this._dispatchZoomAction(history2.pop(this.ecModel));
    }
  };
  proto2._onBrush = function(areas, opt) {
    if (!opt.isEnd || !areas.length) {
      return;
    }
    var snapshot = {};
    var ecModel = this.ecModel;
    this._brushController.updateCovers([]);
    var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(this.model.option), ecModel, {
      include: ["grid"]
    });
    brushTargetManager.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      var brushType = area.brushType;
      if (brushType === "rect") {
        setBatch("x", coordSys, coordRange[0]);
        setBatch("y", coordSys, coordRange[1]);
      } else {
        setBatch({
          lineX: "x",
          lineY: "y"
        }[brushType], coordSys, coordRange);
      }
    });
    history2.push(ecModel, snapshot);
    this._dispatchZoomAction(snapshot);
    function setBatch(dimName, coordSys, minMax) {
      var axis2 = coordSys.getAxis(dimName);
      var axisModel = axis2.model;
      var dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
        minMax = sliderMove2(0, minMax.slice(), axis2.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
      }
      dataZoomModel && (snapshot[dataZoomModel.id] = {
        dataZoomId: dataZoomModel.id,
        startValue: minMax[0],
        endValue: minMax[1]
      });
    }
    function findDataZoom(dimName, axisModel, ecModel2) {
      var found;
      ecModel2.eachComponent({
        mainType: "dataZoom",
        subType: "select"
      }, function(dzModel) {
        var has2 = dzModel.getAxisModel(dimName, axisModel.componentIndex);
        has2 && (found = dzModel);
      });
      return found;
    }
  };
  proto2._dispatchZoomAction = function(snapshot) {
    var batch = [];
    each2(snapshot, function(batchItem, dataZoomId) {
      batch.push(zrUtil2.clone(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      batch
    });
  };
  function retrieveAxisSetting(option) {
    var setting = {};
    zrUtil2.each(["xAxisIndex", "yAxisIndex"], function(name2) {
      setting[name2] = option[name2];
      setting[name2] == null && (setting[name2] = "all");
      (setting[name2] === false || setting[name2] === "none") && (setting[name2] = []);
    });
    return setting;
  }
  function updateBackBtnStatus(featureModel, ecModel) {
    featureModel.setIconStatus("back", history2.count(ecModel) > 1 ? "emphasis" : "normal");
  }
  function updateZoomBtnStatus(featureModel, ecModel, view, payload, api) {
    var zoomActive = view._isZoomActive;
    if (payload && payload.type === "takeGlobalCursor") {
      zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
    }
    view._isZoomActive = zoomActive;
    featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
    var brushTargetManager = new BrushTargetManager(retrieveAxisSetting(featureModel.option), ecModel, {
      include: ["grid"]
    });
    view._brushController.setPanels(brushTargetManager.makePanelOpts(api, function(targetInfo) {
      return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
    })).enableBrush(zoomActive ? {
      brushType: "auto",
      brushStyle: featureModel.getModel("brushStyle").getItemStyle()
    } : false);
  }
  featureManager2.register("dataZoom", DataZoom);
  echarts$12.registerPreprocessor(function(option) {
    if (!option) {
      return;
    }
    var dataZoomOpts = option.dataZoom || (option.dataZoom = []);
    if (!zrUtil2.isArray(dataZoomOpts)) {
      option.dataZoom = dataZoomOpts = [dataZoomOpts];
    }
    var toolboxOpt = option.toolbox;
    if (toolboxOpt) {
      if (zrUtil2.isArray(toolboxOpt)) {
        toolboxOpt = toolboxOpt[0];
      }
      if (toolboxOpt && toolboxOpt.feature) {
        var dataZoomOpt = toolboxOpt.feature.dataZoom;
        addForAxis("xAxis", dataZoomOpt);
        addForAxis("yAxis", dataZoomOpt);
      }
    }
    function addForAxis(axisName, dataZoomOpt2) {
      if (!dataZoomOpt2) {
        return;
      }
      var axisIndicesName = axisName + "Index";
      var givenAxisIndices = dataZoomOpt2[axisIndicesName];
      if (givenAxisIndices != null && givenAxisIndices !== "all" && !zrUtil2.isArray(givenAxisIndices)) {
        givenAxisIndices = givenAxisIndices === false || givenAxisIndices === "none" ? [] : [givenAxisIndices];
      }
      forEachComponent(axisName, function(axisOpt, axisIndex) {
        if (givenAxisIndices != null && givenAxisIndices !== "all" && zrUtil2.indexOf(givenAxisIndices, axisIndex) === -1) {
          return;
        }
        var newOpt = {
          type: "select",
          $fromToolbox: true,
          // Default to be filter
          filterMode: dataZoomOpt2.filterMode || "filter",
          // Id for merge mapping.
          id: DATA_ZOOM_ID_BASE + axisName + axisIndex
        };
        newOpt[axisIndicesName] = axisIndex;
        dataZoomOpts.push(newOpt);
      });
    }
    function forEachComponent(mainType, cb) {
      var opts = option[mainType];
      if (!zrUtil2.isArray(opts)) {
        opts = opts ? [opts] : [];
      }
      each2(opts, cb);
    }
  });
  var _default2 = DataZoom;
  DataZoom_1 = _default2;
  return DataZoom_1;
}
var Restore_1;
var hasRequiredRestore;
function requireRestore() {
  if (hasRequiredRestore)
    return Restore_1;
  hasRequiredRestore = 1;
  var echarts$12 = echarts;
  var history2 = requireHistory();
  var lang2 = lang$1;
  var featureManager2 = requireFeatureManager();
  var restoreLang = lang2.toolbox.restore;
  function Restore(model2) {
    this.model = model2;
  }
  Restore.defaultOption = {
    show: true,
    /* eslint-disable */
    icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
    /* eslint-enable */
    title: restoreLang.title
  };
  var proto2 = Restore.prototype;
  proto2.onclick = function(ecModel, api, type) {
    history2.clear(ecModel);
    api.dispatchAction({
      type: "restore",
      from: this.uid
    });
  };
  featureManager2.register("restore", Restore);
  echarts$12.registerAction({
    type: "restore",
    event: "restore",
    update: "prepareAndUpdate"
  }, function(payload, ecModel) {
    ecModel.resetOption("recreate");
  });
  var _default2 = Restore;
  Restore_1 = _default2;
  return Restore_1;
}
var hasRequiredToolbox;
function requireToolbox() {
  if (hasRequiredToolbox)
    return toolbox;
  hasRequiredToolbox = 1;
  requireToolboxModel();
  requireToolboxView();
  requireSaveAsImage();
  requireMagicType();
  require_DataView();
  requireDataZoom$1();
  requireRestore();
  return toolbox;
}
var tooltip = {};
var TooltipModel;
var hasRequiredTooltipModel;
function requireTooltipModel() {
  if (hasRequiredTooltipModel)
    return TooltipModel;
  hasRequiredTooltipModel = 1;
  var echarts$12 = echarts;
  var _default2 = echarts$12.extendComponentModel({
    type: "tooltip",
    dependencies: ["axisPointer"],
    defaultOption: {
      zlevel: 0,
      z: 60,
      show: true,
      // tooltip主体内容
      showContent: true,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: false,
      displayMode: "single",
      // 'single' | 'multipleByCoordSys'
      renderMode: "auto",
      // 'auto' | 'html' | 'richText'
      // 'auto': use html by default, and use non-html if `document` is not defined
      // 'html': use html for tooltip
      // 'richText': use canvas, svg, and etc. for tooltip
      // 位置 {Array} | {Function}
      // position: null
      // Consider triggered from axisPointer handle, verticalAlign should be 'middle'
      // align: null,
      // verticalAlign: null,
      // 是否约束 content 在 viewRect 中。默认 false 是为了兼容以前版本。
      confine: false,
      // 内容格式器：{string}（Template） ¦ {Function}
      // formatter: null
      showDelay: 0,
      // 隐藏延迟，单位ms
      hideDelay: 100,
      // 动画变换时间，单位s
      transitionDuration: 0.4,
      enterable: false,
      // 提示背景颜色，默认为透明度为0.7的黑色
      backgroundColor: "rgba(50,50,50,0.7)",
      // 提示边框颜色
      borderColor: "#333",
      // 提示边框圆角，单位px，默认为4
      borderRadius: 4,
      // 提示边框线宽，单位px，默认为0（无边框）
      borderWidth: 0,
      // 提示内边距，单位px，默认各方向内边距为5，
      // 接受数组分别设定上右下左边距，同css
      padding: 5,
      // Extra css text
      extraCssText: "",
      // 坐标轴指示器，坐标轴触发有效
      axisPointer: {
        // 默认为直线
        // 可选为：'line' | 'shadow' | 'cross'
        type: "line",
        // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选
        // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // 默认 'auto'，会选择类型为 category 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴
        // 极坐标系会默认选择 angle 轴
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
          // lineStyle and shadowStyle should not be specified here,
          // otherwise it will always override those styles on option.axisPointer.
        }
      },
      textStyle: {
        color: "#fff",
        fontSize: 14
      }
    }
  });
  TooltipModel = _default2;
  return TooltipModel;
}
var TooltipContent_1;
var hasRequiredTooltipContent;
function requireTooltipContent() {
  if (hasRequiredTooltipContent)
    return TooltipContent_1;
  hasRequiredTooltipContent = 1;
  var zrUtil2 = util$6;
  var zrColor = color$1;
  var eventUtil2 = event;
  var domUtil = dom;
  var env2 = env_1;
  var formatUtil2 = requireFormat();
  var each2 = zrUtil2.each;
  var toCamelCase = formatUtil2.toCamelCase;
  var vendors = ["", "-webkit-", "-moz-", "-o-"];
  var gCssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;";
  function assembleTransition(duration) {
    var transitionCurve = "cubic-bezier(0.23, 1, 0.32, 1)";
    var transitionText = "left " + duration + "s " + transitionCurve + ",top " + duration + "s " + transitionCurve;
    return zrUtil2.map(vendors, function(vendorPrefix) {
      return vendorPrefix + "transition:" + transitionText;
    }).join(";");
  }
  function assembleFont(textStyleModel) {
    var cssText = [];
    var fontSize = textStyleModel.get("fontSize");
    var color2 = textStyleModel.getTextColor();
    color2 && cssText.push("color:" + color2);
    cssText.push("font:" + textStyleModel.getFont());
    var lineHeight = textStyleModel.get("lineHeight");
    if (lineHeight == null) {
      lineHeight = Math.round(fontSize * 3 / 2);
    }
    fontSize && cssText.push("line-height:" + lineHeight + "px");
    var shadowColor = textStyleModel.get("textShadowColor");
    var shadowBlur = textStyleModel.get("textShadowBlur") || 0;
    var shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
    var shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
    shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
    each2(["decoration", "align"], function(name2) {
      var val = textStyleModel.get(name2);
      val && cssText.push("text-" + name2 + ":" + val);
    });
    return cssText.join(";");
  }
  function assembleCssText(tooltipModel) {
    var cssText = [];
    var transitionDuration = tooltipModel.get("transitionDuration");
    var backgroundColor = tooltipModel.get("backgroundColor");
    var textStyleModel = tooltipModel.getModel("textStyle");
    var padding = tooltipModel.get("padding");
    transitionDuration && cssText.push(assembleTransition(transitionDuration));
    if (backgroundColor) {
      if (env2.canvasSupported) {
        cssText.push("background-Color:" + backgroundColor);
      } else {
        cssText.push("background-Color:#" + zrColor.toHex(backgroundColor));
        cssText.push("filter:alpha(opacity=70)");
      }
    }
    each2(["width", "color", "radius"], function(name2) {
      var borderName = "border-" + name2;
      var camelCase = toCamelCase(borderName);
      var val = tooltipModel.get(camelCase);
      val != null && cssText.push(borderName + ":" + val + (name2 === "color" ? "" : "px"));
    });
    cssText.push(assembleFont(textStyleModel));
    if (padding != null) {
      cssText.push("padding:" + formatUtil2.normalizeCssArray(padding).join("px ") + "px");
    }
    return cssText.join(";") + ";";
  }
  function makeStyleCoord(out2, zr, appendToBody, zrX, zrY) {
    var zrPainter = zr && zr.painter;
    if (appendToBody) {
      var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
      if (zrViewportRoot) {
        domUtil.transformLocalCoord(out2, zrViewportRoot, document.body, zrX, zrY);
      }
    } else {
      out2[0] = zrX;
      out2[1] = zrY;
      var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
      if (viewportRootOffset) {
        out2[0] += viewportRootOffset.offsetLeft;
        out2[1] += viewportRootOffset.offsetTop;
      }
    }
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  function TooltipContent(container, api, opt) {
    if (env2.wxa) {
      return null;
    }
    var el = document.createElement("div");
    el.domBelongToZr = true;
    this.el = el;
    var zr = this._zr = api.getZr();
    var appendToBody = this._appendToBody = opt && opt.appendToBody;
    this._styleCoord = [0, 0, 0, 0];
    makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
    if (appendToBody) {
      document.body.appendChild(el);
    } else {
      container.appendChild(el);
    }
    this._container = container;
    this._show = false;
    this._hideTimeout;
    var self2 = this;
    el.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el.onmousemove = function(e2) {
      e2 = e2 || window.event;
      if (!self2._enterable) {
        var handler = zr.handler;
        var zrViewportRoot = zr.painter.getViewportRoot();
        eventUtil2.normalizeEvent(zrViewportRoot, e2, true);
        handler.dispatch("mousemove", e2);
      }
    };
    el.onmouseleave = function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    };
  }
  TooltipContent.prototype = {
    constructor: TooltipContent,
    /**
     * @private
     * @type {boolean}
     */
    _enterable: true,
    /**
     * Update when tooltip is rendered
     */
    update: function(tooltipModel) {
      var container = this._container;
      var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
      var domStyle = container.style;
      if (domStyle.position !== "absolute" && stl.position !== "absolute") {
        domStyle.position = "relative";
      }
      var alwaysShowContent = tooltipModel.get("alwaysShowContent");
      alwaysShowContent && this._moveTooltipIfResized();
    },
    /**
     * when `alwaysShowContent` is true,
     * we should move the tooltip after chart resized
     */
    _moveTooltipIfResized: function() {
      var ratioX = this._styleCoord[2];
      var ratioY = this._styleCoord[3];
      var realX = ratioX * this._zr.getWidth();
      var realY = ratioY * this._zr.getHeight();
      this.moveTo(realX, realY);
    },
    show: function(tooltipModel) {
      clearTimeout(this._hideTimeout);
      var el = this.el;
      var styleCoord = this._styleCoord;
      el.style.cssText = gCssText + assembleCssText(tooltipModel) + ";left:" + styleCoord[0] + "px;top:" + styleCoord[1] + "px;" + (tooltipModel.get("extraCssText") || "");
      el.style.display = el.innerHTML ? "block" : "none";
      el.style.pointerEvents = this._enterable ? "auto" : "none";
      this._show = true;
    },
    setContent: function(content) {
      this.el.innerHTML = content == null ? "" : content;
    },
    setEnterable: function(enterable) {
      this._enterable = enterable;
    },
    getSize: function() {
      var el = this.el;
      return [el.clientWidth, el.clientHeight];
    },
    moveTo: function(zrX, zrY) {
      var styleCoord = this._styleCoord;
      makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
      var style = this.el.style;
      style.left = styleCoord[0] + "px";
      style.top = styleCoord[1] + "px";
    },
    hide: function() {
      this.el.style.display = "none";
      this._show = false;
    },
    hideLater: function(time) {
      if (this._show && !(this._inContent && this._enterable)) {
        if (time) {
          this._hideDelay = time;
          this._show = false;
          this._hideTimeout = setTimeout(zrUtil2.bind(this.hide, this), time);
        } else {
          this.hide();
        }
      }
    },
    isShow: function() {
      return this._show;
    },
    dispose: function() {
      this.el.parentNode.removeChild(this.el);
    },
    getOuterSize: function() {
      var width = this.el.clientWidth;
      var height = this.el.clientHeight;
      if (document.defaultView && document.defaultView.getComputedStyle) {
        var stl = document.defaultView.getComputedStyle(this.el);
        if (stl) {
          width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
          height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
        }
      }
      return {
        width,
        height
      };
    }
  };
  var _default2 = TooltipContent;
  TooltipContent_1 = _default2;
  return TooltipContent_1;
}
var TooltipRichContent_1;
var hasRequiredTooltipRichContent;
function requireTooltipRichContent() {
  if (hasRequiredTooltipRichContent)
    return TooltipRichContent_1;
  hasRequiredTooltipRichContent = 1;
  var zrUtil2 = util$6;
  var Text2 = Text_1;
  var graphicUtil2 = graphic$4;
  function makeStyleCoord(out2, zr, zrX, zrY) {
    out2[0] = zrX;
    out2[1] = zrY;
    out2[2] = out2[0] / zr.getWidth();
    out2[3] = out2[1] / zr.getHeight();
  }
  function TooltipRichContent(api) {
    var zr = this._zr = api.getZr();
    this._styleCoord = [0, 0, 0, 0];
    makeStyleCoord(this._styleCoord, zr, api.getWidth() / 2, api.getHeight() / 2);
    this._show = false;
    this._hideTimeout;
  }
  TooltipRichContent.prototype = {
    constructor: TooltipRichContent,
    /**
     * @private
     * @type {boolean}
     */
    _enterable: true,
    /**
     * Update when tooltip is rendered
     */
    update: function(tooltipModel) {
      var alwaysShowContent = tooltipModel.get("alwaysShowContent");
      alwaysShowContent && this._moveTooltipIfResized();
    },
    /**
     * when `alwaysShowContent` is true,
     * we should move the tooltip after chart resized
     */
    _moveTooltipIfResized: function() {
      var ratioX = this._styleCoord[2];
      var ratioY = this._styleCoord[3];
      var realX = ratioX * this._zr.getWidth();
      var realY = ratioY * this._zr.getHeight();
      this.moveTo(realX, realY);
    },
    show: function(tooltipModel) {
      if (this._hideTimeout) {
        clearTimeout(this._hideTimeout);
      }
      this.el.attr("show", true);
      this._show = true;
    },
    /**
     * Set tooltip content
     *
     * @param {string} content rich text string of content
     * @param {Object} markerRich rich text style
     * @param {Object} tooltipModel tooltip model
     */
    setContent: function(content, markerRich, tooltipModel) {
      if (this.el) {
        this._zr.remove(this.el);
      }
      var markers = {};
      var text2 = content;
      var prefix = "{marker";
      var suffix = "|}";
      var startId = text2.indexOf(prefix);
      while (startId >= 0) {
        var endId = text2.indexOf(suffix);
        var name2 = text2.substr(startId + prefix.length, endId - startId - prefix.length);
        if (name2.indexOf("sub") > -1) {
          markers["marker" + name2] = {
            textWidth: 4,
            textHeight: 4,
            textBorderRadius: 2,
            textBackgroundColor: markerRich[name2],
            // TODO: textOffset is not implemented for rich text
            textOffset: [3, 0]
          };
        } else {
          markers["marker" + name2] = {
            textWidth: 10,
            textHeight: 10,
            textBorderRadius: 5,
            textBackgroundColor: markerRich[name2]
          };
        }
        text2 = text2.substr(endId + 1);
        startId = text2.indexOf("{marker");
      }
      var textStyleModel = tooltipModel.getModel("textStyle");
      var fontSize = textStyleModel.get("fontSize");
      var lineHeight = tooltipModel.get("textLineHeight");
      if (lineHeight == null) {
        lineHeight = Math.round(fontSize * 3 / 2);
      }
      this.el = new Text2({
        style: graphicUtil2.setTextStyle({}, textStyleModel, {
          rich: markers,
          text: content,
          textBackgroundColor: tooltipModel.get("backgroundColor"),
          textBorderRadius: tooltipModel.get("borderRadius"),
          textFill: tooltipModel.get("textStyle.color"),
          textPadding: tooltipModel.get("padding"),
          textLineHeight: lineHeight
        }),
        z: tooltipModel.get("z")
      });
      this._zr.add(this.el);
      var self2 = this;
      this.el.on("mouseover", function() {
        if (self2._enterable) {
          clearTimeout(self2._hideTimeout);
          self2._show = true;
        }
        self2._inContent = true;
      });
      this.el.on("mouseout", function() {
        if (self2._enterable) {
          if (self2._show) {
            self2.hideLater(self2._hideDelay);
          }
        }
        self2._inContent = false;
      });
    },
    setEnterable: function(enterable) {
      this._enterable = enterable;
    },
    getSize: function() {
      var bounding = this.el.getBoundingRect();
      return [bounding.width, bounding.height];
    },
    moveTo: function(x, y) {
      if (this.el) {
        var styleCoord = this._styleCoord;
        makeStyleCoord(styleCoord, this._zr, x, y);
        this.el.attr("position", [styleCoord[0], styleCoord[1]]);
      }
    },
    hide: function() {
      if (this.el) {
        this.el.hide();
      }
      this._show = false;
    },
    hideLater: function(time) {
      if (this._show && !(this._inContent && this._enterable)) {
        if (time) {
          this._hideDelay = time;
          this._show = false;
          this._hideTimeout = setTimeout(zrUtil2.bind(this.hide, this), time);
        } else {
          this.hide();
        }
      }
    },
    isShow: function() {
      return this._show;
    },
    dispose: function() {
      clearTimeout(this._hideTimeout);
      if (this.el) {
        this._zr.remove(this.el);
      }
    },
    getOuterSize: function() {
      var size2 = this.getSize();
      return {
        width: size2[0],
        height: size2[1]
      };
    }
  };
  var _default2 = TooltipRichContent;
  TooltipRichContent_1 = _default2;
  return TooltipRichContent_1;
}
var TooltipView;
var hasRequiredTooltipView;
function requireTooltipView() {
  if (hasRequiredTooltipView)
    return TooltipView;
  hasRequiredTooltipView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var env2 = env_1;
  var TooltipContent = requireTooltipContent();
  var TooltipRichContent = requireTooltipRichContent();
  var formatUtil2 = requireFormat();
  var numberUtil = requireNumber();
  var graphic2 = graphic$4;
  var findPointFromSeries2 = requireFindPointFromSeries();
  var layoutUtil = layout$1;
  var Model2 = requireModel();
  var globalListener2 = requireGlobalListener();
  var axisHelper2 = requireAxisHelper();
  var axisPointerViewHelper = requireViewHelper();
  var _model2 = model;
  var getTooltipRenderMode2 = _model2.getTooltipRenderMode;
  var bind2 = zrUtil2.bind;
  var each2 = zrUtil2.each;
  var parsePercent2 = numberUtil.parsePercent;
  var proxyRect = new graphic2.Rect({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  });
  var _default2 = echarts$12.extendComponentView({
    type: "tooltip",
    init: function(ecModel, api) {
      if (env2.node) {
        return;
      }
      var tooltipModel = ecModel.getComponent("tooltip");
      var renderMode = tooltipModel.get("renderMode");
      this._renderMode = getTooltipRenderMode2(renderMode);
      var tooltipContent;
      if (this._renderMode === "html") {
        tooltipContent = new TooltipContent(api.getDom(), api, {
          appendToBody: tooltipModel.get("appendToBody", true)
        });
        this._newLine = "<br/>";
      } else {
        tooltipContent = new TooltipRichContent(api);
        this._newLine = "\n";
      }
      this._tooltipContent = tooltipContent;
    },
    render: function(tooltipModel, ecModel, api) {
      if (env2.node) {
        return;
      }
      this.group.removeAll();
      this._tooltipModel = tooltipModel;
      this._ecModel = ecModel;
      this._api = api;
      this._lastDataByCoordSys = null;
      this._alwaysShowContent = tooltipModel.get("alwaysShowContent");
      var tooltipContent = this._tooltipContent;
      tooltipContent.update(tooltipModel);
      tooltipContent.setEnterable(tooltipModel.get("enterable"));
      this._initGlobalListener();
      this._keepShow();
    },
    _initGlobalListener: function() {
      var tooltipModel = this._tooltipModel;
      var triggerOn = tooltipModel.get("triggerOn");
      globalListener2.register("itemTooltip", this._api, bind2(function(currTrigger, e2, dispatchAction) {
        if (triggerOn !== "none") {
          if (triggerOn.indexOf(currTrigger) >= 0) {
            this._tryShow(e2, dispatchAction);
          } else if (currTrigger === "leave") {
            this._hide(dispatchAction);
          }
        }
      }, this));
    },
    _keepShow: function() {
      var tooltipModel = this._tooltipModel;
      var ecModel = this._ecModel;
      var api = this._api;
      if (this._lastX != null && this._lastY != null && tooltipModel.get("triggerOn") !== "none") {
        var self2 = this;
        clearTimeout(this._refreshUpdateTimeout);
        this._refreshUpdateTimeout = setTimeout(function() {
          !api.isDisposed() && self2.manuallyShowTip(tooltipModel, ecModel, api, {
            x: self2._lastX,
            y: self2._lastY
          });
        });
      }
    },
    /**
     * Show tip manually by
     * dispatchAction({
     *     type: 'showTip',
     *     x: 10,
     *     y: 10
     * });
     * Or
     * dispatchAction({
     *      type: 'showTip',
     *      seriesIndex: 0,
     *      dataIndex or dataIndexInside or name
     * });
     *
     *  TODO Batch
     */
    manuallyShowTip: function(tooltipModel, ecModel, api, payload) {
      if (payload.from === this.uid || env2.node) {
        return;
      }
      var dispatchAction = makeDispatchAction(payload, api);
      this._ticket = "";
      var dataByCoordSys = payload.dataByCoordSys;
      if (payload.tooltip && payload.x != null && payload.y != null) {
        var el = proxyRect;
        el.position = [payload.x, payload.y];
        el.update();
        el.tooltip = payload.tooltip;
        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          target: el
        }, dispatchAction);
      } else if (dataByCoordSys) {
        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          position: payload.position,
          dataByCoordSys: payload.dataByCoordSys,
          tooltipOption: payload.tooltipOption
        }, dispatchAction);
      } else if (payload.seriesIndex != null) {
        if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
          return;
        }
        var pointInfo = findPointFromSeries2(payload, ecModel);
        var cx = pointInfo.point[0];
        var cy = pointInfo.point[1];
        if (cx != null && cy != null) {
          this._tryShow({
            offsetX: cx,
            offsetY: cy,
            position: payload.position,
            target: pointInfo.el
          }, dispatchAction);
        }
      } else if (payload.x != null && payload.y != null) {
        api.dispatchAction({
          type: "updateAxisPointer",
          x: payload.x,
          y: payload.y
        });
        this._tryShow({
          offsetX: payload.x,
          offsetY: payload.y,
          position: payload.position,
          target: api.getZr().findHover(payload.x, payload.y).target
        }, dispatchAction);
      }
    },
    manuallyHideTip: function(tooltipModel, ecModel, api, payload) {
      var tooltipContent = this._tooltipContent;
      if (!this._alwaysShowContent && this._tooltipModel) {
        tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
      }
      this._lastX = this._lastY = null;
      if (payload.from !== this.uid) {
        this._hide(makeDispatchAction(payload, api));
      }
    },
    // Be compatible with previous design, that is, when tooltip.type is 'axis' and
    // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
    // and tooltip.
    _manuallyAxisShowTip: function(tooltipModel, ecModel, api, payload) {
      var seriesIndex = payload.seriesIndex;
      var dataIndex = payload.dataIndex;
      var coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
      if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
        return;
      }
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      if (!seriesModel) {
        return;
      }
      var data = seriesModel.getData();
      var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);
      if (tooltipModel.get("trigger") !== "axis") {
        return;
      }
      api.dispatchAction({
        type: "updateAxisPointer",
        seriesIndex,
        dataIndex,
        position: payload.position
      });
      return true;
    },
    _tryShow: function(e2, dispatchAction) {
      var el = e2.target;
      var tooltipModel = this._tooltipModel;
      if (!tooltipModel) {
        return;
      }
      this._lastX = e2.offsetX;
      this._lastY = e2.offsetY;
      var dataByCoordSys = e2.dataByCoordSys;
      if (dataByCoordSys && dataByCoordSys.length) {
        this._showAxisTooltip(dataByCoordSys, e2);
      } else if (el && el.dataIndex != null) {
        this._lastDataByCoordSys = null;
        this._showSeriesItemTooltip(e2, el, dispatchAction);
      } else if (el && el.tooltip) {
        this._lastDataByCoordSys = null;
        this._showComponentItemTooltip(e2, el, dispatchAction);
      } else {
        this._lastDataByCoordSys = null;
        this._hide(dispatchAction);
      }
    },
    _showOrMove: function(tooltipModel, cb) {
      var delay = tooltipModel.get("showDelay");
      cb = zrUtil2.bind(cb, this);
      clearTimeout(this._showTimout);
      delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
    },
    _showAxisTooltip: function(dataByCoordSys, e2) {
      var ecModel = this._ecModel;
      var globalTooltipModel = this._tooltipModel;
      var point = [e2.offsetX, e2.offsetY];
      var singleDefaultHTML = [];
      var singleParamsList = [];
      var singleTooltipModel = buildTooltipModel([e2.tooltipOption, globalTooltipModel]);
      var renderMode = this._renderMode;
      var newLine = this._newLine;
      var markers = {};
      each2(dataByCoordSys, function(itemCoordSys) {
        each2(itemCoordSys.dataByAxis, function(item) {
          var axisModel = ecModel.getComponent(item.axisDim + "Axis", item.axisIndex);
          var axisValue = item.value;
          var seriesDefaultHTML = [];
          if (!axisModel || axisValue == null) {
            return;
          }
          var valueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, item.seriesDataIndices, item.valueLabelOpt);
          zrUtil2.each(item.seriesDataIndices, function(idxItem) {
            var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
            var dataIndex = idxItem.dataIndexInside;
            var dataParams = series && series.getDataParams(dataIndex);
            dataParams.axisDim = item.axisDim;
            dataParams.axisIndex = item.axisIndex;
            dataParams.axisType = item.axisType;
            dataParams.axisId = item.axisId;
            dataParams.axisValue = axisHelper2.getAxisRawValue(axisModel.axis, axisValue);
            dataParams.axisValueLabel = valueLabel;
            if (dataParams) {
              singleParamsList.push(dataParams);
              var seriesTooltip = series.formatTooltip(dataIndex, true, null, renderMode);
              var html;
              if (zrUtil2.isObject(seriesTooltip)) {
                html = seriesTooltip.html;
                var newMarkers = seriesTooltip.markers;
                zrUtil2.merge(markers, newMarkers);
              } else {
                html = seriesTooltip;
              }
              seriesDefaultHTML.push(html);
            }
          });
          var firstLine = valueLabel;
          if (renderMode !== "html") {
            singleDefaultHTML.push(seriesDefaultHTML.join(newLine));
          } else {
            singleDefaultHTML.push((firstLine ? formatUtil2.encodeHTML(firstLine) + newLine : "") + seriesDefaultHTML.join(newLine));
          }
        });
      }, this);
      singleDefaultHTML.reverse();
      singleDefaultHTML = singleDefaultHTML.join(this._newLine + this._newLine);
      var positionExpr = e2.position;
      this._showOrMove(singleTooltipModel, function() {
        if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
          this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, singleParamsList);
        } else {
          this._showTooltipContent(singleTooltipModel, singleDefaultHTML, singleParamsList, Math.random(), point[0], point[1], positionExpr, void 0, markers);
        }
      });
    },
    _showSeriesItemTooltip: function(e2, el, dispatchAction) {
      var ecModel = this._ecModel;
      var seriesIndex = el.seriesIndex;
      var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
      var dataModel = el.dataModel || seriesModel;
      var dataIndex = el.dataIndex;
      var dataType = el.dataType;
      var data = dataModel.getData(dataType);
      var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
      var tooltipTrigger = tooltipModel.get("trigger");
      if (tooltipTrigger != null && tooltipTrigger !== "item") {
        return;
      }
      var params = dataModel.getDataParams(dataIndex, dataType);
      var seriesTooltip = dataModel.formatTooltip(dataIndex, false, dataType, this._renderMode);
      var defaultHtml;
      var markers;
      if (zrUtil2.isObject(seriesTooltip)) {
        defaultHtml = seriesTooltip.html;
        markers = seriesTooltip.markers;
      } else {
        defaultHtml = seriesTooltip;
        markers = null;
      }
      var asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
      this._showOrMove(tooltipModel, function() {
        this._showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markers);
      });
      dispatchAction({
        type: "showTip",
        dataIndexInside: dataIndex,
        dataIndex: data.getRawIndex(dataIndex),
        seriesIndex,
        from: this.uid
      });
    },
    _showComponentItemTooltip: function(e2, el, dispatchAction) {
      var tooltipOpt = el.tooltip;
      if (typeof tooltipOpt === "string") {
        var content = tooltipOpt;
        tooltipOpt = {
          content,
          // Fixed formatter
          formatter: content
        };
      }
      var subTooltipModel = new Model2(tooltipOpt, this._tooltipModel, this._ecModel);
      var defaultHtml = subTooltipModel.get("content");
      var asyncTicket = Math.random();
      this._showOrMove(subTooltipModel, function() {
        this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get("formatterParams") || {}, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el);
      });
      dispatchAction({
        type: "showTip",
        from: this.uid
      });
    },
    _showTooltipContent: function(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markers) {
      this._ticket = "";
      if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
        return;
      }
      var tooltipContent = this._tooltipContent;
      var formatter = tooltipModel.get("formatter");
      positionExpr = positionExpr || tooltipModel.get("position");
      var html = defaultHtml;
      if (formatter && typeof formatter === "string") {
        html = formatUtil2.formatTpl(formatter, params, true);
      } else if (typeof formatter === "function") {
        var callback = bind2(function(cbTicket, html2) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html2, markers, tooltipModel);
            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      }
      tooltipContent.setContent(html, markers, tooltipModel);
      tooltipContent.show(tooltipModel);
      this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
    },
    /**
     * @param  {string|Function|Array.<number>|Object} positionExpr
     * @param  {number} x Mouse x
     * @param  {number} y Mouse y
     * @param  {boolean} confine Whether confine tooltip content in view rect.
     * @param  {Object|<Array.<Object>} params
     * @param  {module:zrender/Element} el target element
     * @param  {module:echarts/ExtensionAPI} api
     * @return {Array.<number>}
     */
    _updatePosition: function(tooltipModel, positionExpr, x, y, content, params, el) {
      var viewWidth = this._api.getWidth();
      var viewHeight = this._api.getHeight();
      positionExpr = positionExpr || tooltipModel.get("position");
      var contentSize = content.getSize();
      var align = tooltipModel.get("align");
      var vAlign = tooltipModel.get("verticalAlign");
      var rect = el && el.getBoundingRect().clone();
      el && rect.applyTransform(el.transform);
      if (typeof positionExpr === "function") {
        positionExpr = positionExpr([x, y], params, content.el, rect, {
          viewSize: [viewWidth, viewHeight],
          contentSize: contentSize.slice()
        });
      }
      if (zrUtil2.isArray(positionExpr)) {
        x = parsePercent2(positionExpr[0], viewWidth);
        y = parsePercent2(positionExpr[1], viewHeight);
      } else if (zrUtil2.isObject(positionExpr)) {
        positionExpr.width = contentSize[0];
        positionExpr.height = contentSize[1];
        var layoutRect = layoutUtil.getLayoutRect(positionExpr, {
          width: viewWidth,
          height: viewHeight
        });
        x = layoutRect.x;
        y = layoutRect.y;
        align = null;
        vAlign = null;
      } else if (typeof positionExpr === "string" && el) {
        var pos = calcTooltipPosition(positionExpr, rect, contentSize);
        x = pos[0];
        y = pos[1];
      } else {
        var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
        x = pos[0];
        y = pos[1];
      }
      align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
      vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
      if (tooltipModel.get("confine")) {
        var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
        x = pos[0];
        y = pos[1];
      }
      content.moveTo(x, y);
    },
    // FIXME
    // Should we remove this but leave this to user?
    _updateContentNotChangedOnAxis: function(dataByCoordSys) {
      var lastCoordSys = this._lastDataByCoordSys;
      var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
      contentNotChanged && each2(lastCoordSys, function(lastItemCoordSys, indexCoordSys) {
        var lastDataByAxis = lastItemCoordSys.dataByAxis || {};
        var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
        var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
        contentNotChanged &= lastDataByAxis.length === thisDataByAxis.length;
        contentNotChanged && each2(lastDataByAxis, function(lastItem, indexAxis) {
          var thisItem = thisDataByAxis[indexAxis] || {};
          var lastIndices = lastItem.seriesDataIndices || [];
          var newIndices = thisItem.seriesDataIndices || [];
          contentNotChanged &= lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
          contentNotChanged && each2(lastIndices, function(lastIdxItem, j) {
            var newIdxItem = newIndices[j];
            contentNotChanged &= lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
          });
        });
      });
      this._lastDataByCoordSys = dataByCoordSys;
      return !!contentNotChanged;
    },
    _hide: function(dispatchAction) {
      this._lastDataByCoordSys = null;
      dispatchAction({
        type: "hideTip",
        from: this.uid
      });
    },
    dispose: function(ecModel, api) {
      if (env2.node) {
        return;
      }
      this._tooltipContent.dispose();
      globalListener2.unregister("itemTooltip", api);
    }
  });
  function buildTooltipModel(modelCascade) {
    var resultModel = modelCascade.pop();
    while (modelCascade.length) {
      var tooltipOpt = modelCascade.pop();
      if (tooltipOpt) {
        if (Model2.isInstance(tooltipOpt)) {
          tooltipOpt = tooltipOpt.get("tooltip", true);
        }
        if (typeof tooltipOpt === "string") {
          tooltipOpt = {
            formatter: tooltipOpt
          };
        }
        resultModel = new Model2(tooltipOpt, resultModel, resultModel.ecModel);
      }
    }
    return resultModel;
  }
  function makeDispatchAction(payload, api) {
    return payload.dispatchAction || zrUtil2.bind(api.dispatchAction, api);
  }
  function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
    var size2 = content.getOuterSize();
    var width = size2.width;
    var height = size2.height;
    if (gapH != null) {
      if (x + width + gapH > viewWidth) {
        x -= width + gapH;
      } else {
        x += gapH;
      }
    }
    if (gapV != null) {
      if (y + height + gapV > viewHeight) {
        y -= height + gapV;
      } else {
        y += gapV;
      }
    }
    return [x, y];
  }
  function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
    var size2 = content.getOuterSize();
    var width = size2.width;
    var height = size2.height;
    x = Math.min(x + width, viewWidth) - width;
    y = Math.min(y + height, viewHeight) - height;
    x = Math.max(x, 0);
    y = Math.max(y, 0);
    return [x, y];
  }
  function calcTooltipPosition(position, rect, contentSize) {
    var domWidth = contentSize[0];
    var domHeight = contentSize[1];
    var gap = 5;
    var x = 0;
    var y = 0;
    var rectWidth = rect.width;
    var rectHeight = rect.height;
    switch (position) {
      case "inside":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "top":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y - domHeight - gap;
        break;
      case "bottom":
        x = rect.x + rectWidth / 2 - domWidth / 2;
        y = rect.y + rectHeight + gap;
        break;
      case "left":
        x = rect.x - domWidth - gap;
        y = rect.y + rectHeight / 2 - domHeight / 2;
        break;
      case "right":
        x = rect.x + rectWidth + gap;
        y = rect.y + rectHeight / 2 - domHeight / 2;
    }
    return [x, y];
  }
  function isCenterAlign(align) {
    return align === "center" || align === "middle";
  }
  TooltipView = _default2;
  return TooltipView;
}
var hasRequiredTooltip;
function requireTooltip() {
  if (hasRequiredTooltip)
    return tooltip;
  hasRequiredTooltip = 1;
  var echarts$12 = echarts;
  requireAxisPointer();
  requireTooltipModel();
  requireTooltipView();
  echarts$12.registerAction(
    {
      type: "showTip",
      event: "showTip",
      update: "tooltip:manuallyShowTip"
    },
    // noop
    function() {
    }
  );
  echarts$12.registerAction(
    {
      type: "hideTip",
      event: "hideTip",
      update: "tooltip:manuallyHideTip"
    },
    // noop
    function() {
    }
  );
  return tooltip;
}
var brush = {};
var preprocessor$2;
var hasRequiredPreprocessor$2;
function requirePreprocessor$2() {
  if (hasRequiredPreprocessor$2)
    return preprocessor$2;
  hasRequiredPreprocessor$2 = 1;
  var zrUtil2 = util$6;
  var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
  function _default2(option, isNew) {
    var brushComponents = option && option.brush;
    if (!zrUtil2.isArray(brushComponents)) {
      brushComponents = brushComponents ? [brushComponents] : [];
    }
    if (!brushComponents.length) {
      return;
    }
    var brushComponentSpecifiedBtns = [];
    zrUtil2.each(brushComponents, function(brushOpt) {
      var tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
      if (tbs instanceof Array) {
        brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
      }
    });
    var toolbox2 = option && option.toolbox;
    if (zrUtil2.isArray(toolbox2)) {
      toolbox2 = toolbox2[0];
    }
    if (!toolbox2) {
      toolbox2 = {
        feature: {}
      };
      option.toolbox = [toolbox2];
    }
    var toolboxFeature = toolbox2.feature || (toolbox2.feature = {});
    var toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
    var brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
    brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
    removeDuplicate(brushTypes);
    if (isNew && !brushTypes.length) {
      brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
    }
  }
  function removeDuplicate(arr) {
    var map2 = {};
    zrUtil2.each(arr, function(val) {
      map2[val] = 1;
    });
    arr.length = 0;
    zrUtil2.each(map2, function(flag, val) {
      arr.push(val);
    });
  }
  preprocessor$2 = _default2;
  return preprocessor$2;
}
var visualEncoding$1 = {};
var visualSolution = {};
var hasRequiredVisualSolution;
function requireVisualSolution() {
  if (hasRequiredVisualSolution)
    return visualSolution;
  hasRequiredVisualSolution = 1;
  var zrUtil2 = util$6;
  var VisualMapping = requireVisualMapping();
  var each2 = zrUtil2.each;
  function hasKeys(obj) {
    if (obj) {
      for (var name2 in obj) {
        if (obj.hasOwnProperty(name2)) {
          return true;
        }
      }
    }
  }
  function createVisualMappings(option, stateList, supplementVisualOption) {
    var visualMappings = {};
    each2(stateList, function(state) {
      var mappings = visualMappings[state] = createMappings();
      each2(option[state], function(visualData, visualType) {
        if (!VisualMapping.isValidType(visualType)) {
          return;
        }
        var mappingOption = {
          type: visualType,
          visual: visualData
        };
        supplementVisualOption && supplementVisualOption(mappingOption, state);
        mappings[visualType] = new VisualMapping(mappingOption);
        if (visualType === "opacity") {
          mappingOption = zrUtil2.clone(mappingOption);
          mappingOption.type = "colorAlpha";
          mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);
        }
      });
    });
    return visualMappings;
    function createMappings() {
      var Creater = function() {
      };
      Creater.prototype.__hidden = Creater.prototype;
      var obj = new Creater();
      return obj;
    }
  }
  function replaceVisualOption(thisOption, newOption, keys) {
    var has2;
    zrUtil2.each(keys, function(key) {
      if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
        has2 = true;
      }
    });
    has2 && zrUtil2.each(keys, function(key) {
      if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
        thisOption[key] = zrUtil2.clone(newOption[key]);
      } else {
        delete thisOption[key];
      }
    });
  }
  function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
    var visualTypesMap = {};
    zrUtil2.each(stateList, function(state) {
      var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
      visualTypesMap[state] = visualTypes;
    });
    var dataIndex;
    function getVisual(key) {
      return data.getItemVisual(dataIndex, key);
    }
    function setVisual(key, value) {
      data.setItemVisual(dataIndex, key, value);
    }
    if (dimension == null) {
      data.each(eachItem);
    } else {
      data.each([dimension], eachItem);
    }
    function eachItem(valueOrIndex, index2) {
      dataIndex = dimension == null ? valueOrIndex : index2;
      var rawDataItem = data.getRawDataItem(dataIndex);
      if (rawDataItem && rawDataItem.visualMap === false) {
        return;
      }
      var valueState = getValueState.call(scope, valueOrIndex);
      var mappings = visualMappings[valueState];
      var visualTypes = visualTypesMap[valueState];
      for (var i = 0, len = visualTypes.length; i < len; i++) {
        var type = visualTypes[i];
        mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
      }
    }
  }
  function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
    var visualTypesMap = {};
    zrUtil2.each(stateList, function(state) {
      var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
      visualTypesMap[state] = visualTypes;
    });
    function progress(params, data) {
      if (dim != null) {
        dim = data.getDimension(dim);
      }
      function getVisual(key) {
        return data.getItemVisual(dataIndex, key);
      }
      function setVisual(key, value2) {
        data.setItemVisual(dataIndex, key, value2);
      }
      var dataIndex;
      while ((dataIndex = params.next()) != null) {
        var rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }
        var value = dim != null ? data.get(dim, dataIndex, true) : dataIndex;
        var valueState = getValueState(value);
        var mappings = visualMappings[valueState];
        var visualTypes = visualTypesMap[valueState];
        for (var i = 0, len = visualTypes.length; i < len; i++) {
          var type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
    return {
      progress
    };
  }
  visualSolution.createVisualMappings = createVisualMappings;
  visualSolution.replaceVisualOption = replaceVisualOption;
  visualSolution.applyVisual = applyVisual;
  visualSolution.incrementalApplyVisual = incrementalApplyVisual;
  return visualSolution;
}
var selector_1;
var hasRequiredSelector;
function requireSelector() {
  if (hasRequiredSelector)
    return selector_1;
  hasRequiredSelector = 1;
  var polygonContain = requirePolygon();
  var BoundingRect2 = BoundingRect_1;
  var _graphic = graphic$4;
  var linePolygonIntersect2 = _graphic.linePolygonIntersect;
  var selector = {
    lineX: getLineSelectors(0),
    lineY: getLineSelectors(1),
    rect: {
      point: function(itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
      },
      rect: function(itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.intersect(itemLayout);
      }
    },
    polygon: {
      point: function(itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && polygonContain.contain(area.range, itemLayout[0], itemLayout[1]);
      },
      rect: function(itemLayout, selectors, area) {
        var points2 = area.range;
        if (!itemLayout || points2.length <= 1) {
          return false;
        }
        var x = itemLayout.x;
        var y = itemLayout.y;
        var width = itemLayout.width;
        var height = itemLayout.height;
        var p2 = points2[0];
        if (polygonContain.contain(points2, x, y) || polygonContain.contain(points2, x + width, y) || polygonContain.contain(points2, x, y + height) || polygonContain.contain(points2, x + width, y + height) || BoundingRect2.create(itemLayout).contain(p2[0], p2[1]) || linePolygonIntersect2(x, y, x + width, y, points2) || linePolygonIntersect2(x, y, x, y + height, points2) || linePolygonIntersect2(x + width, y, x + width, y + height, points2) || linePolygonIntersect2(x, y + height, x + width, y + height, points2)) {
          return true;
        }
      }
    }
  };
  function getLineSelectors(xyIndex) {
    var xy = ["x", "y"];
    var wh = ["width", "height"];
    return {
      point: function(itemLayout, selectors, area) {
        if (itemLayout) {
          var range = area.range;
          var p2 = itemLayout[xyIndex];
          return inLineRange(p2, range);
        }
      },
      rect: function(itemLayout, selectors, area) {
        if (itemLayout) {
          var range = area.range;
          var layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]];
          layoutRange[1] < layoutRange[0] && layoutRange.reverse();
          return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
        }
      }
    };
  }
  function inLineRange(p2, range) {
    return range[0] <= p2 && p2 <= range[1];
  }
  var _default2 = selector;
  selector_1 = _default2;
  return selector_1;
}
var hasRequiredVisualEncoding$1;
function requireVisualEncoding$1() {
  if (hasRequiredVisualEncoding$1)
    return visualEncoding$1;
  hasRequiredVisualEncoding$1 = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var BoundingRect2 = BoundingRect_1;
  var visualSolution2 = requireVisualSolution();
  var selector = requireSelector();
  var throttleUtil = throttle$1;
  var BrushTargetManager = requireBrushTargetManager();
  var STATE_LIST = ["inBrush", "outOfBrush"];
  var DISPATCH_METHOD = "__ecBrushSelect";
  var DISPATCH_FLAG = "__ecInBrushSelectEvent";
  var PRIORITY_BRUSH = echarts$12.PRIORITY.VISUAL.BRUSH;
  echarts$12.registerLayout(PRIORITY_BRUSH, function(ecModel, api, payload) {
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel) {
      payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {
        brushType: false
      });
    });
    layoutCovers(ecModel);
  });
  function layoutCovers(ecModel) {
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel) {
      var brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel);
      brushTargetManager.setInputRanges(brushModel.areas, ecModel);
    });
  }
  echarts$12.registerVisual(PRIORITY_BRUSH, function(ecModel, api, payload) {
    var brushSelected = [];
    var throttleType;
    var throttleDelay;
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel, brushIndex) {
      var thisBrushSelected = {
        brushId: brushModel.id,
        brushIndex,
        brushName: brushModel.name,
        areas: zrUtil2.clone(brushModel.areas),
        selected: []
      };
      brushSelected.push(thisBrushSelected);
      var brushOption = brushModel.option;
      var brushLink = brushOption.brushLink;
      var linkedSeriesMap = [];
      var selectedDataIndexForLink = [];
      var rangeInfoBySeries = [];
      var hasBrushExists = 0;
      if (!brushIndex) {
        throttleType = brushOption.throttleType;
        throttleDelay = brushOption.throttleDelay;
      }
      var areas = zrUtil2.map(brushModel.areas, function(area) {
        return bindSelector(zrUtil2.defaults({
          boundingRect: boundingRectBuilders[area.brushType](area)
        }, area));
      });
      var visualMappings = visualSolution2.createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
        mappingOption.mappingMethod = "fixed";
      });
      zrUtil2.isArray(brushLink) && zrUtil2.each(brushLink, function(seriesIndex) {
        linkedSeriesMap[seriesIndex] = 1;
      });
      function linkOthers(seriesIndex) {
        return brushLink === "all" || linkedSeriesMap[seriesIndex];
      }
      function brushed(rangeInfoList) {
        return !!rangeInfoList.length;
      }
      ecModel.eachSeries(function(seriesModel, seriesIndex) {
        var rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
        seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
      });
      function stepAParallel(seriesModel, seriesIndex) {
        var coordSys = seriesModel.coordinateSystem;
        hasBrushExists |= coordSys.hasAxisBrushed();
        linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
          activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
        });
      }
      function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
        var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
        if (!selectorsByBrushType || brushModelNotControll(brushModel, seriesIndex)) {
          return;
        }
        zrUtil2.each(areas, function(area) {
          selectorsByBrushType[area.brushType] && brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel) && rangeInfoList.push(area);
          hasBrushExists |= brushed(rangeInfoList);
        });
        if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
          var data = seriesModel.getData();
          data.each(function(dataIndex) {
            if (checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex)) {
              selectedDataIndexForLink[dataIndex] = 1;
            }
          });
        }
      }
      ecModel.eachSeries(function(seriesModel, seriesIndex) {
        var seriesBrushSelected = {
          seriesId: seriesModel.id,
          seriesIndex,
          seriesName: seriesModel.name,
          dataIndex: []
        };
        thisBrushSelected.selected.push(seriesBrushSelected);
        var selectorsByBrushType = getSelectorsByBrushType(seriesModel);
        var rangeInfoList = rangeInfoBySeries[seriesIndex];
        var data = seriesModel.getData();
        var getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
          return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
        } : function(dataIndex) {
          return checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
        };
        (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && visualSolution2.applyVisual(STATE_LIST, visualMappings, data, getValueState);
      });
    });
    dispatchAction(api, throttleType, throttleDelay, brushSelected, payload);
  });
  function dispatchAction(api, throttleType, throttleDelay, brushSelected, payload) {
    if (!payload) {
      return;
    }
    var zr = api.getZr();
    if (zr[DISPATCH_FLAG]) {
      return;
    }
    if (!zr[DISPATCH_METHOD]) {
      zr[DISPATCH_METHOD] = doDispatch;
    }
    var fn = throttleUtil.createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
    fn(api, brushSelected);
  }
  function doDispatch(api, brushSelected) {
    if (!api.isDisposed()) {
      var zr = api.getZr();
      zr[DISPATCH_FLAG] = true;
      api.dispatchAction({
        type: "brushSelect",
        batch: brushSelected
      });
      zr[DISPATCH_FLAG] = false;
    }
  }
  function checkInRange(selectorsByBrushType, rangeInfoList, data, dataIndex) {
    for (var i = 0, len = rangeInfoList.length; i < len; i++) {
      var area = rangeInfoList[i];
      if (selectorsByBrushType[area.brushType](dataIndex, data, area.selectors, area)) {
        return true;
      }
    }
  }
  function getSelectorsByBrushType(seriesModel) {
    var brushSelector = seriesModel.brushSelector;
    if (zrUtil2.isString(brushSelector)) {
      var sels = [];
      zrUtil2.each(selector, function(selectorsByElementType, brushType) {
        sels[brushType] = function(dataIndex, data, selectors, area) {
          var itemLayout = data.getItemLayout(dataIndex);
          return selectorsByElementType[brushSelector](itemLayout, selectors, area);
        };
      });
      return sels;
    } else if (zrUtil2.isFunction(brushSelector)) {
      var bSelector = {};
      zrUtil2.each(selector, function(sel, brushType) {
        bSelector[brushType] = brushSelector;
      });
      return bSelector;
    }
    return brushSelector;
  }
  function brushModelNotControll(brushModel, seriesIndex) {
    var seriesIndices = brushModel.option.seriesIndex;
    return seriesIndices != null && seriesIndices !== "all" && (zrUtil2.isArray(seriesIndices) ? zrUtil2.indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
  }
  function bindSelector(area) {
    var selectors = area.selectors = {};
    zrUtil2.each(selector[area.brushType], function(selFn, elType) {
      selectors[elType] = function(itemLayout) {
        return selFn(itemLayout, selectors, area);
      };
    });
    return area;
  }
  var boundingRectBuilders = {
    lineX: zrUtil2.noop,
    lineY: zrUtil2.noop,
    rect: function(area) {
      return getBoundingRectFromMinMax(area.range);
    },
    polygon: function(area) {
      var minMax;
      var range = area.range;
      for (var i = 0, len = range.length; i < len; i++) {
        minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
        var rg = range[i];
        rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
        rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
        rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
        rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
      }
      return minMax && getBoundingRectFromMinMax(minMax);
    }
  };
  function getBoundingRectFromMinMax(minMax) {
    return new BoundingRect2(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
  }
  visualEncoding$1.layoutCovers = layoutCovers;
  return visualEncoding$1;
}
var BrushModel_1;
var hasRequiredBrushModel;
function requireBrushModel() {
  if (hasRequiredBrushModel)
    return BrushModel_1;
  hasRequiredBrushModel = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var visualSolution2 = requireVisualSolution();
  var Model2 = requireModel();
  var DEFAULT_OUT_OF_BRUSH_COLOR = ["#ddd"];
  var BrushModel = echarts$12.extendComponentModel({
    type: "brush",
    dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
    /**
     * @protected
     */
    defaultOption: {
      // inBrush: null,
      // outOfBrush: null,
      toolbox: null,
      // Default value see preprocessor.
      brushLink: null,
      // Series indices array, broadcast using dataIndex.
      // or 'all', which means all series. 'none' or null means no series.
      seriesIndex: "all",
      // seriesIndex array, specify series controlled by this brush component.
      geoIndex: null,
      //
      xAxisIndex: null,
      yAxisIndex: null,
      brushType: "rect",
      // Default brushType, see BrushController.
      brushMode: "single",
      // Default brushMode, 'single' or 'multiple'
      transformable: true,
      // Default transformable.
      brushStyle: {
        // Default brushStyle
        borderWidth: 1,
        color: "rgba(120,140,180,0.3)",
        borderColor: "rgba(120,140,180,0.8)"
      },
      throttleType: "fixRate",
      // Throttle in brushSelected event. 'fixRate' or 'debounce'.
      // If null, no throttle. Valid only in the first brush component
      throttleDelay: 0,
      // Unit: ms, 0 means every event will be triggered.
      // FIXME
      // 试验效果
      removeOnClick: true,
      z: 1e4
    },
    /**
     * @readOnly
     * @type {Array.<Object>}
     */
    areas: [],
    /**
     * Current activated brush type.
     * If null, brush is inactived.
     * see module:echarts/component/helper/BrushController
     * @readOnly
     * @type {string}
     */
    brushType: null,
    /**
     * Current brush opt.
     * see module:echarts/component/helper/BrushController
     * @readOnly
     * @type {Object}
     */
    brushOption: {},
    /**
     * @readOnly
     * @type {Array.<Object>}
     */
    coordInfoList: [],
    optionUpdated: function(newOption, isInit) {
      var thisOption = this.option;
      !isInit && visualSolution2.replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
      var inBrush = thisOption.inBrush = thisOption.inBrush || {};
      thisOption.outOfBrush = thisOption.outOfBrush || {
        color: DEFAULT_OUT_OF_BRUSH_COLOR
      };
      if (!inBrush.hasOwnProperty("liftZ")) {
        inBrush.liftZ = 5;
      }
    },
    /**
     * If ranges is null/undefined, range state remain.
     *
     * @param {Array.<Object>} [ranges]
     */
    setAreas: function(areas) {
      if (!areas) {
        return;
      }
      this.areas = zrUtil2.map(areas, function(area) {
        return generateBrushOption(this.option, area);
      }, this);
    },
    /**
     * see module:echarts/component/helper/BrushController
     * @param {Object} brushOption
     */
    setBrushOption: function(brushOption) {
      this.brushOption = generateBrushOption(this.option, brushOption);
      this.brushType = this.brushOption.brushType;
    }
  });
  function generateBrushOption(option, brushOption) {
    return zrUtil2.merge({
      brushType: option.brushType,
      brushMode: option.brushMode,
      transformable: option.transformable,
      brushStyle: new Model2(option.brushStyle).getItemStyle(),
      removeOnClick: option.removeOnClick,
      z: option.z
    }, brushOption, true);
  }
  var _default2 = BrushModel;
  BrushModel_1 = _default2;
  return BrushModel_1;
}
var BrushView;
var hasRequiredBrushView;
function requireBrushView() {
  if (hasRequiredBrushView)
    return BrushView;
  hasRequiredBrushView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var BrushController = requireBrushController();
  var _visualEncoding = requireVisualEncoding$1();
  var layoutCovers = _visualEncoding.layoutCovers;
  var _default2 = echarts$12.extendComponentView({
    type: "brush",
    init: function(ecModel, api) {
      this.ecModel = ecModel;
      this.api = api;
      this.model;
      (this._brushController = new BrushController(api.getZr())).on("brush", zrUtil2.bind(this._onBrush, this)).mount();
    },
    /**
     * @override
     */
    render: function(brushModel) {
      this.model = brushModel;
      return updateController.apply(this, arguments);
    },
    /**
     * @override
     */
    updateTransform: function(brushModel, ecModel) {
      layoutCovers(ecModel);
      return updateController.apply(this, arguments);
    },
    /**
     * @override
     */
    updateView: updateController,
    // /**
    //  * @override
    //  */
    // updateLayout: updateController,
    // /**
    //  * @override
    //  */
    // updateVisual: updateController,
    /**
     * @override
     */
    dispose: function() {
      this._brushController.dispose();
    },
    /**
     * @private
     */
    _onBrush: function(areas, opt) {
      var modelId = this.model.id;
      this.model.brushTargetManager.setOutputRanges(areas, this.ecModel);
      (!opt.isEnd || opt.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: modelId,
        areas: zrUtil2.clone(areas),
        $from: modelId
      });
      opt.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: modelId,
        areas: zrUtil2.clone(areas),
        $from: modelId
      });
    }
  });
  function updateController(brushModel, ecModel, api, payload) {
    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
  }
  BrushView = _default2;
  return BrushView;
}
var brushAction = {};
var hasRequiredBrushAction;
function requireBrushAction() {
  if (hasRequiredBrushAction)
    return brushAction;
  hasRequiredBrushAction = 1;
  var echarts$12 = echarts;
  echarts$12.registerAction({
    type: "brush",
    event: "brush"
    /*, update: 'updateView' */
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "brush",
      query: payload
    }, function(brushModel) {
      brushModel.setAreas(payload.areas);
    });
  });
  echarts$12.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, function() {
  });
  echarts$12.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, function() {
  });
  return brushAction;
}
var Brush_1;
var hasRequiredBrush$1;
function requireBrush$1() {
  if (hasRequiredBrush$1)
    return Brush_1;
  hasRequiredBrush$1 = 1;
  var zrUtil2 = util$6;
  var featureManager2 = requireFeatureManager();
  var lang2 = lang$1;
  var brushLang = lang2.toolbox.brush;
  function Brush(model2, ecModel, api) {
    this.model = model2;
    this.ecModel = ecModel;
    this.api = api;
    this._brushType;
    this._brushMode;
  }
  Brush.defaultOption = {
    show: true,
    type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
    icon: {
      /* eslint-disable */
      rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
      // jshint ignore:line
      polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
      // jshint ignore:line
      lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
      // jshint ignore:line
      lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
      // jshint ignore:line
      keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
      // jshint ignore:line
      clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
      // jshint ignore:line
      /* eslint-enable */
    },
    // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
    title: zrUtil2.clone(brushLang.title)
  };
  var proto2 = Brush.prototype;
  proto2.render = /* eslint-enable */
  proto2.updateView = function(featureModel, ecModel, api) {
    var brushType;
    var brushMode;
    var isBrushed;
    ecModel.eachComponent({
      mainType: "brush"
    }, function(brushModel) {
      brushType = brushModel.brushType;
      brushMode = brushModel.brushOption.brushMode || "single";
      isBrushed |= brushModel.areas.length;
    });
    this._brushType = brushType;
    this._brushMode = brushMode;
    zrUtil2.each(featureModel.get("type", true), function(type) {
      featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
    });
  };
  proto2.getIcons = function() {
    var model2 = this.model;
    var availableIcons = model2.get("icon", true);
    var icons = {};
    zrUtil2.each(model2.get("type", true), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  };
  proto2.onclick = function(ecModel, api, type) {
    var brushType = this._brushType;
    var brushMode = this._brushMode;
    if (type === "clear") {
      api.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      });
      api.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      });
    } else {
      api.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: type === "keep" ? brushType : brushType === type ? false : type,
          brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
        }
      });
    }
  };
  featureManager2.register("brush", Brush);
  var _default2 = Brush;
  Brush_1 = _default2;
  return Brush_1;
}
var hasRequiredBrush;
function requireBrush() {
  if (hasRequiredBrush)
    return brush;
  hasRequiredBrush = 1;
  var echarts$12 = echarts;
  var preprocessor2 = requirePreprocessor$2();
  requireVisualEncoding$1();
  requireBrushModel();
  requireBrushView();
  requireBrushAction();
  requireBrush$1();
  echarts$12.registerPreprocessor(preprocessor2);
  return brush;
}
var title = {};
var hasRequiredTitle;
function requireTitle() {
  if (hasRequiredTitle)
    return title;
  hasRequiredTitle = 1;
  var zrUtil2 = util$6;
  var echarts$12 = echarts;
  var graphic2 = graphic$4;
  var _layout2 = layout$1;
  var getLayoutRect2 = _layout2.getLayoutRect;
  var _format2 = requireFormat();
  var windowOpen = _format2.windowOpen;
  echarts$12.extendComponentModel({
    type: "title",
    layoutMode: {
      type: "box",
      ignoreSize: true
    },
    defaultOption: {
      // 一级层叠
      zlevel: 0,
      // 二级层叠
      z: 6,
      show: true,
      text: "",
      // 超链接跳转
      // link: null,
      // 仅支持self | blank
      target: "blank",
      subtext: "",
      // 超链接跳转
      // sublink: null,
      // 仅支持self | blank
      subtarget: "blank",
      // 'center' ¦ 'left' ¦ 'right'
      // ¦ {number}（x坐标，单位px）
      left: 0,
      // 'top' ¦ 'bottom' ¦ 'center'
      // ¦ {number}（y坐标，单位px）
      top: 0,
      // 水平对齐
      // 'auto' | 'left' | 'right' | 'center'
      // 默认根据 left 的位置判断是左对齐还是右对齐
      // textAlign: null
      //
      // 垂直对齐
      // 'auto' | 'top' | 'bottom' | 'middle'
      // 默认根据 top 位置判断是上对齐还是下对齐
      // textVerticalAlign: null
      // textBaseline: null // The same as textVerticalAlign.
      backgroundColor: "rgba(0,0,0,0)",
      // 标题边框颜色
      borderColor: "#ccc",
      // 标题边框线宽，单位px，默认为0（无边框）
      borderWidth: 0,
      // 标题内边距，单位px，默认各方向内边距为5，
      // 接受数组分别设定上右下左边距，同css
      padding: 5,
      // 主副标题纵向间隔，单位px，默认为10，
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bolder",
        color: "#333"
      },
      subtextStyle: {
        color: "#aaa"
      }
    }
  });
  echarts$12.extendComponentView({
    type: "title",
    render: function(titleModel, ecModel, api) {
      this.group.removeAll();
      if (!titleModel.get("show")) {
        return;
      }
      var group = this.group;
      var textStyleModel = titleModel.getModel("textStyle");
      var subtextStyleModel = titleModel.getModel("subtextStyle");
      var textAlign = titleModel.get("textAlign");
      var textVerticalAlign = zrUtil2.retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
      var textEl = new graphic2.Text({
        style: graphic2.setTextStyle({}, textStyleModel, {
          text: titleModel.get("text"),
          textFill: textStyleModel.getTextColor()
        }, {
          disableBox: true
        }),
        z2: 10
      });
      var textRect = textEl.getBoundingRect();
      var subText = titleModel.get("subtext");
      var subTextEl = new graphic2.Text({
        style: graphic2.setTextStyle({}, subtextStyleModel, {
          text: subText,
          textFill: subtextStyleModel.getTextColor(),
          y: textRect.height + titleModel.get("itemGap"),
          textVerticalAlign: "top"
        }, {
          disableBox: true
        }),
        z2: 10
      });
      var link = titleModel.get("link");
      var sublink = titleModel.get("sublink");
      var triggerEvent = titleModel.get("triggerEvent", true);
      textEl.silent = !link && !triggerEvent;
      subTextEl.silent = !sublink && !triggerEvent;
      if (link) {
        textEl.on("click", function() {
          windowOpen(link, "_" + titleModel.get("target"));
        });
      }
      if (sublink) {
        subTextEl.on("click", function() {
          windowOpen(sublink, "_" + titleModel.get("subtarget"));
        });
      }
      textEl.eventData = subTextEl.eventData = triggerEvent ? {
        componentType: "title",
        componentIndex: titleModel.componentIndex
      } : null;
      group.add(textEl);
      subText && group.add(subTextEl);
      var groupRect = group.getBoundingRect();
      var layoutOption = titleModel.getBoxLayoutParams();
      layoutOption.width = groupRect.width;
      layoutOption.height = groupRect.height;
      var layoutRect = getLayoutRect2(layoutOption, {
        width: api.getWidth(),
        height: api.getHeight()
      }, titleModel.get("padding"));
      if (!textAlign) {
        textAlign = titleModel.get("left") || titleModel.get("right");
        if (textAlign === "middle") {
          textAlign = "center";
        }
        if (textAlign === "right") {
          layoutRect.x += layoutRect.width;
        } else if (textAlign === "center") {
          layoutRect.x += layoutRect.width / 2;
        }
      }
      if (!textVerticalAlign) {
        textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
        if (textVerticalAlign === "center") {
          textVerticalAlign = "middle";
        }
        if (textVerticalAlign === "bottom") {
          layoutRect.y += layoutRect.height;
        } else if (textVerticalAlign === "middle") {
          layoutRect.y += layoutRect.height / 2;
        }
        textVerticalAlign = textVerticalAlign || "top";
      }
      group.attr("position", [layoutRect.x, layoutRect.y]);
      var alignStyle = {
        textAlign,
        textVerticalAlign
      };
      textEl.setStyle(alignStyle);
      subTextEl.setStyle(alignStyle);
      groupRect = group.getBoundingRect();
      var padding = layoutRect.margin;
      var style = titleModel.getItemStyle(["color", "opacity"]);
      style.fill = titleModel.get("backgroundColor");
      var rect = new graphic2.Rect({
        shape: {
          x: groupRect.x - padding[3],
          y: groupRect.y - padding[0],
          width: groupRect.width + padding[1] + padding[3],
          height: groupRect.height + padding[0] + padding[2],
          r: titleModel.get("borderRadius")
        },
        style,
        subPixelOptimize: true,
        silent: true
      });
      group.add(rect);
    }
  });
  return title;
}
var timeline = {};
var preprocessor$1;
var hasRequiredPreprocessor$1;
function requirePreprocessor$1() {
  if (hasRequiredPreprocessor$1)
    return preprocessor$1;
  hasRequiredPreprocessor$1 = 1;
  var zrUtil2 = util$6;
  function _default2(option) {
    var timelineOpt = option && option.timeline;
    if (!zrUtil2.isArray(timelineOpt)) {
      timelineOpt = timelineOpt ? [timelineOpt] : [];
    }
    zrUtil2.each(timelineOpt, function(opt) {
      if (!opt) {
        return;
      }
      compatibleEC2(opt);
    });
  }
  function compatibleEC2(opt) {
    var type = opt.type;
    var ec2Types = {
      "number": "value",
      "time": "time"
    };
    if (ec2Types[type]) {
      opt.axisType = ec2Types[type];
      delete opt.type;
    }
    transferItem(opt);
    if (has2(opt, "controlPosition")) {
      var controlStyle = opt.controlStyle || (opt.controlStyle = {});
      if (!has2(controlStyle, "position")) {
        controlStyle.position = opt.controlPosition;
      }
      if (controlStyle.position === "none" && !has2(controlStyle, "show")) {
        controlStyle.show = false;
        delete controlStyle.position;
      }
      delete opt.controlPosition;
    }
    zrUtil2.each(opt.data || [], function(dataItem) {
      if (zrUtil2.isObject(dataItem) && !zrUtil2.isArray(dataItem)) {
        if (!has2(dataItem, "value") && has2(dataItem, "name")) {
          dataItem.value = dataItem.name;
        }
        transferItem(dataItem);
      }
    });
  }
  function transferItem(opt) {
    var itemStyle2 = opt.itemStyle || (opt.itemStyle = {});
    var itemStyleEmphasis = itemStyle2.emphasis || (itemStyle2.emphasis = {});
    var label = opt.label || opt.label || {};
    var labelNormal = label.normal || (label.normal = {});
    var excludeLabelAttr = {
      normal: 1,
      emphasis: 1
    };
    zrUtil2.each(label, function(value, name2) {
      if (!excludeLabelAttr[name2] && !has2(labelNormal, name2)) {
        labelNormal[name2] = value;
      }
    });
    if (itemStyleEmphasis.label && !has2(label, "emphasis")) {
      label.emphasis = itemStyleEmphasis.label;
      delete itemStyleEmphasis.label;
    }
  }
  function has2(obj, attr) {
    return obj.hasOwnProperty(attr);
  }
  preprocessor$1 = _default2;
  return preprocessor$1;
}
var typeDefaulter$1 = {};
var hasRequiredTypeDefaulter$1;
function requireTypeDefaulter$1() {
  if (hasRequiredTypeDefaulter$1)
    return typeDefaulter$1;
  hasRequiredTypeDefaulter$1 = 1;
  var Component2 = Component$2;
  Component2.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  });
  return typeDefaulter$1;
}
var timelineAction = {};
var hasRequiredTimelineAction;
function requireTimelineAction() {
  if (hasRequiredTimelineAction)
    return timelineAction;
  hasRequiredTimelineAction = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  echarts$12.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(payload, ecModel) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);
      if (!timelineModel.get("loop", true) && timelineModel.isIndexMax()) {
        timelineModel.setPlayState(false);
      }
    }
    ecModel.resetOption("timeline");
    return zrUtil2.defaults({
      currentIndex: timelineModel.option.currentIndex
    }, payload);
  });
  echarts$12.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(payload, ecModel) {
    var timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
  return timelineAction;
}
var TimelineModel_1;
var hasRequiredTimelineModel;
function requireTimelineModel() {
  if (hasRequiredTimelineModel)
    return TimelineModel_1;
  hasRequiredTimelineModel = 1;
  var zrUtil2 = util$6;
  var ComponentModel2 = Component$2;
  var List = requireList();
  var modelUtil2 = model;
  var TimelineModel = ComponentModel2.extend({
    type: "timeline",
    layoutMode: "box",
    /**
     * @protected
     */
    defaultOption: {
      zlevel: 0,
      // 一级层叠
      z: 4,
      // 二级层叠
      show: true,
      axisType: "time",
      // 模式是时间类型，支持 value, category
      realtime: true,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      // 'left' 'right' 'top' 'bottom' 'none'
      autoPlay: false,
      rewind: false,
      // 反向播放
      loop: true,
      playInterval: 2e3,
      // 播放时间间隔，单位ms
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    },
    /**
     * @override
     */
    init: function(option, parentModel, ecModel) {
      this._data;
      this._names;
      this.mergeDefaultAndTheme(option, ecModel);
      this._initData();
    },
    /**
     * @override
     */
    mergeOption: function(option) {
      TimelineModel.superApply(this, "mergeOption", arguments);
      this._initData();
    },
    /**
     * @param {number} [currentIndex]
     */
    setCurrentIndex: function(currentIndex) {
      if (currentIndex == null) {
        currentIndex = this.option.currentIndex;
      }
      var count = this._data.count();
      if (this.option.loop) {
        currentIndex = (currentIndex % count + count) % count;
      } else {
        currentIndex >= count && (currentIndex = count - 1);
        currentIndex < 0 && (currentIndex = 0);
      }
      this.option.currentIndex = currentIndex;
    },
    /**
     * @return {number} currentIndex
     */
    getCurrentIndex: function() {
      return this.option.currentIndex;
    },
    /**
     * @return {boolean}
     */
    isIndexMax: function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    },
    /**
     * @param {boolean} state true: play, false: stop
     */
    setPlayState: function(state) {
      this.option.autoPlay = !!state;
    },
    /**
     * @return {boolean} true: play, false: stop
     */
    getPlayState: function() {
      return !!this.option.autoPlay;
    },
    /**
     * @private
     */
    _initData: function() {
      var thisOption = this.option;
      var dataArr = thisOption.data || [];
      var axisType = thisOption.axisType;
      var names = this._names = [];
      if (axisType === "category") {
        var idxArr = [];
        zrUtil2.each(dataArr, function(item, index2) {
          var value = modelUtil2.getDataItemValue(item);
          var newItem;
          if (zrUtil2.isObject(item)) {
            newItem = zrUtil2.clone(item);
            newItem.value = index2;
          } else {
            newItem = index2;
          }
          idxArr.push(newItem);
          if (!zrUtil2.isString(value) && (value == null || isNaN(value))) {
            value = "";
          }
          names.push(value + "");
        });
        dataArr = idxArr;
      }
      var dimType = {
        category: "ordinal",
        time: "time"
      }[axisType] || "number";
      var data = this._data = new List([{
        name: "value",
        type: dimType
      }], this);
      data.initData(dataArr, names);
    },
    getData: function() {
      return this._data;
    },
    /**
     * @public
     * @return {Array.<string>} categoreis
     */
    getCategories: function() {
      if (this.get("axisType") === "category") {
        return this._names.slice();
      }
    }
  });
  var _default2 = TimelineModel;
  TimelineModel_1 = _default2;
  return TimelineModel_1;
}
var SliderTimelineModel_1;
var hasRequiredSliderTimelineModel;
function requireSliderTimelineModel() {
  if (hasRequiredSliderTimelineModel)
    return SliderTimelineModel_1;
  hasRequiredSliderTimelineModel = 1;
  var zrUtil2 = util$6;
  var TimelineModel = requireTimelineModel();
  var dataFormatMixin2 = dataFormat;
  var SliderTimelineModel = TimelineModel.extend({
    type: "timeline.slider",
    /**
     * @protected
     */
    defaultOption: {
      backgroundColor: "rgba(0,0,0,0)",
      // 时间轴背景颜色
      borderColor: "#ccc",
      // 时间轴边框颜色
      borderWidth: 0,
      // 时间轴边框线宽，单位px，默认为0（无边框）
      orient: "horizontal",
      // 'vertical'
      inverse: false,
      tooltip: {
        // boolean or Object
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "emptyCircle",
      symbolSize: 10,
      lineStyle: {
        show: true,
        width: 2,
        color: "#304654"
      },
      label: {
        // 文本标签
        position: "auto",
        // auto left right top bottom
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: true,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#304654"
      },
      itemStyle: {
        color: "#304654",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 13,
        color: "#c23531",
        borderWidth: 5,
        borderColor: "rgba(194,53,49, 0.5)",
        animation: true,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: true,
        showPlayBtn: true,
        showPrevBtn: true,
        showNextBtn: true,
        itemSize: 22,
        itemGap: 12,
        position: "left",
        // 'left' 'right' 'top' 'bottom'
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        // jshint ignore:line
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // jshint ignore:line
        nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
        // jshint ignore:line
        prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
        // jshint ignore:line
        color: "#304654",
        borderColor: "#304654",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: true,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#c23531"
        },
        itemStyle: {
          color: "#c23531"
        },
        controlStyle: {
          color: "#c23531",
          borderColor: "#c23531",
          borderWidth: 2
        }
      },
      data: []
    }
  });
  zrUtil2.mixin(SliderTimelineModel, dataFormatMixin2);
  var _default2 = SliderTimelineModel;
  SliderTimelineModel_1 = _default2;
  return SliderTimelineModel_1;
}
var TimelineView;
var hasRequiredTimelineView;
function requireTimelineView() {
  if (hasRequiredTimelineView)
    return TimelineView;
  hasRequiredTimelineView = 1;
  var ComponentView = Component_1;
  var _default2 = ComponentView.extend({
    type: "timeline"
  });
  TimelineView = _default2;
  return TimelineView;
}
var TimelineAxis_1;
var hasRequiredTimelineAxis;
function requireTimelineAxis() {
  if (hasRequiredTimelineAxis)
    return TimelineAxis_1;
  hasRequiredTimelineAxis = 1;
  var zrUtil2 = util$6;
  var Axis = requireAxis$1();
  var TimelineAxis = function(dim, scale, coordExtent, axisType) {
    Axis.call(this, dim, scale, coordExtent);
    this.type = axisType || "value";
    this.model = null;
  };
  TimelineAxis.prototype = {
    constructor: TimelineAxis,
    /**
     * @override
     */
    getLabelModel: function() {
      return this.model.getModel("label");
    },
    /**
     * @override
     */
    isHorizontal: function() {
      return this.model.get("orient") === "horizontal";
    }
  };
  zrUtil2.inherits(TimelineAxis, Axis);
  var _default2 = TimelineAxis;
  TimelineAxis_1 = _default2;
  return TimelineAxis_1;
}
var SliderTimelineView;
var hasRequiredSliderTimelineView;
function requireSliderTimelineView() {
  if (hasRequiredSliderTimelineView)
    return SliderTimelineView;
  hasRequiredSliderTimelineView = 1;
  var zrUtil2 = util$6;
  var BoundingRect2 = BoundingRect_1;
  var matrix2 = requireMatrix();
  var graphic2 = graphic$4;
  var layout2 = layout$1;
  var TimelineView2 = requireTimelineView();
  var TimelineAxis = requireTimelineAxis();
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var axisHelper2 = requireAxisHelper();
  var numberUtil = requireNumber();
  var _format2 = requireFormat();
  var encodeHTML2 = _format2.encodeHTML;
  var bind2 = zrUtil2.bind;
  var each2 = zrUtil2.each;
  var PI3 = Math.PI;
  var _default2 = TimelineView2.extend({
    type: "timeline.slider",
    init: function(ecModel, api) {
      this.api = api;
      this._axis;
      this._viewRect;
      this._timer;
      this._currentPointer;
      this._mainGroup;
      this._labelGroup;
    },
    /**
     * @override
     */
    render: function(timelineModel, ecModel, api, payload) {
      this.model = timelineModel;
      this.api = api;
      this.ecModel = ecModel;
      this.group.removeAll();
      if (timelineModel.get("show", true)) {
        var layoutInfo = this._layout(timelineModel, api);
        var mainGroup = this._createGroup("mainGroup");
        var labelGroup = this._createGroup("labelGroup");
        var axis2 = this._axis = this._createAxis(layoutInfo, timelineModel);
        timelineModel.formatTooltip = function(dataIndex) {
          return encodeHTML2(axis2.scale.getLabel(dataIndex));
        };
        each2(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name2) {
          this["_render" + name2](layoutInfo, mainGroup, axis2, timelineModel);
        }, this);
        this._renderAxisLabel(layoutInfo, labelGroup, axis2, timelineModel);
        this._position(layoutInfo, timelineModel);
      }
      this._doPlayStop();
    },
    /**
     * @override
     */
    remove: function() {
      this._clearTimer();
      this.group.removeAll();
    },
    /**
     * @override
     */
    dispose: function() {
      this._clearTimer();
    },
    _layout: function(timelineModel, api) {
      var labelPosOpt = timelineModel.get("label.position");
      var orient = timelineModel.get("orient");
      var viewRect2 = getViewRect(timelineModel, api);
      if (labelPosOpt == null || labelPosOpt === "auto") {
        labelPosOpt = orient === "horizontal" ? viewRect2.y + viewRect2.height / 2 < api.getHeight() / 2 ? "-" : "+" : viewRect2.x + viewRect2.width / 2 < api.getWidth() / 2 ? "+" : "-";
      } else if (isNaN(labelPosOpt)) {
        labelPosOpt = {
          horizontal: {
            top: "-",
            bottom: "+"
          },
          vertical: {
            left: "-",
            right: "+"
          }
        }[orient][labelPosOpt];
      }
      var labelAlignMap = {
        horizontal: "center",
        vertical: labelPosOpt >= 0 || labelPosOpt === "+" ? "left" : "right"
      };
      var labelBaselineMap = {
        horizontal: labelPosOpt >= 0 || labelPosOpt === "+" ? "top" : "bottom",
        vertical: "middle"
      };
      var rotationMap = {
        horizontal: 0,
        vertical: PI3 / 2
      };
      var mainLength = orient === "vertical" ? viewRect2.height : viewRect2.width;
      var controlModel = timelineModel.getModel("controlStyle");
      var showControl = controlModel.get("show", true);
      var controlSize = showControl ? controlModel.get("itemSize") : 0;
      var controlGap = showControl ? controlModel.get("itemGap") : 0;
      var sizePlusGap = controlSize + controlGap;
      var labelRotation = timelineModel.get("label.rotate") || 0;
      labelRotation = labelRotation * PI3 / 180;
      var playPosition;
      var prevBtnPosition;
      var nextBtnPosition;
      var axisExtent;
      var controlPosition = controlModel.get("position", true);
      var showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
      var showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
      var showNextBtn = showControl && controlModel.get("showNextBtn", true);
      var xLeft = 0;
      var xRight = mainLength;
      if (controlPosition === "left" || controlPosition === "bottom") {
        showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
        showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
        showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      } else {
        showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
        showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
        showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      }
      axisExtent = [xLeft, xRight];
      if (timelineModel.get("inverse")) {
        axisExtent.reverse();
      }
      return {
        viewRect: viewRect2,
        mainLength,
        orient,
        rotation: rotationMap[orient],
        labelRotation,
        labelPosOpt,
        labelAlign: timelineModel.get("label.align") || labelAlignMap[orient],
        labelBaseline: timelineModel.get("label.verticalAlign") || timelineModel.get("label.baseline") || labelBaselineMap[orient],
        // Based on mainGroup.
        playPosition,
        prevBtnPosition,
        nextBtnPosition,
        axisExtent,
        controlSize,
        controlGap
      };
    },
    _position: function(layoutInfo, timelineModel) {
      var mainGroup = this._mainGroup;
      var labelGroup = this._labelGroup;
      var viewRect2 = layoutInfo.viewRect;
      if (layoutInfo.orient === "vertical") {
        var m2 = matrix2.create();
        var rotateOriginX = viewRect2.x;
        var rotateOriginY = viewRect2.y + viewRect2.height;
        matrix2.translate(m2, m2, [-rotateOriginX, -rotateOriginY]);
        matrix2.rotate(m2, m2, -PI3 / 2);
        matrix2.translate(m2, m2, [rotateOriginX, rotateOriginY]);
        viewRect2 = viewRect2.clone();
        viewRect2.applyTransform(m2);
      }
      var viewBound = getBound(viewRect2);
      var mainBound = getBound(mainGroup.getBoundingRect());
      var labelBound = getBound(labelGroup.getBoundingRect());
      var mainPosition = mainGroup.position;
      var labelsPosition = labelGroup.position;
      labelsPosition[0] = mainPosition[0] = viewBound[0][0];
      var labelPosOpt = layoutInfo.labelPosOpt;
      if (isNaN(labelPosOpt)) {
        var mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
        toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
      } else {
        var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
        labelsPosition[1] = mainPosition[1] + labelPosOpt;
      }
      mainGroup.attr("position", mainPosition);
      labelGroup.attr("position", labelsPosition);
      mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
      setOrigin(mainGroup);
      setOrigin(labelGroup);
      function setOrigin(targetGroup) {
        var pos = targetGroup.position;
        targetGroup.origin = [viewBound[0][0] - pos[0], viewBound[1][0] - pos[1]];
      }
      function getBound(rect) {
        return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]];
      }
      function toBound(fromPos, from, to, dimIdx, boundIdx) {
        fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
      }
    },
    _createAxis: function(layoutInfo, timelineModel) {
      var data = timelineModel.getData();
      var axisType = timelineModel.get("axisType");
      var scale = axisHelper2.createScaleByModel(timelineModel, axisType);
      scale.getTicks = function() {
        return data.mapArray(["value"], function(value) {
          return value;
        });
      };
      var dataExtent = data.getDataExtent("value");
      scale.setExtent(dataExtent[0], dataExtent[1]);
      scale.niceTicks();
      var axis2 = new TimelineAxis("value", scale, layoutInfo.axisExtent, axisType);
      axis2.model = timelineModel;
      return axis2;
    },
    _createGroup: function(name2) {
      var newGroup = this["_" + name2] = new graphic2.Group();
      this.group.add(newGroup);
      return newGroup;
    },
    _renderAxisLine: function(layoutInfo, group, axis2, timelineModel) {
      var axisExtent = axis2.getExtent();
      if (!timelineModel.get("lineStyle.show")) {
        return;
      }
      group.add(new graphic2.Line({
        shape: {
          x1: axisExtent[0],
          y1: 0,
          x2: axisExtent[1],
          y2: 0
        },
        style: zrUtil2.extend({
          lineCap: "round"
        }, timelineModel.getModel("lineStyle").getLineStyle()),
        silent: true,
        z2: 1
      }));
    },
    /**
     * @private
     */
    _renderAxisTick: function(layoutInfo, group, axis2, timelineModel) {
      var data = timelineModel.getData();
      var ticks = axis2.scale.getTicks();
      each2(ticks, function(value) {
        var tickCoord = axis2.dataToCoord(value);
        var itemModel = data.getItemModel(value);
        var itemStyleModel = itemModel.getModel("itemStyle");
        var hoverStyleModel = itemModel.getModel("emphasis.itemStyle");
        var symbolOpt = {
          position: [tickCoord, 0],
          onclick: bind2(this._changeTimeline, this, value)
        };
        var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
        graphic2.setHoverStyle(el, hoverStyleModel.getItemStyle());
        if (itemModel.get("tooltip")) {
          el.dataIndex = value;
          el.dataModel = timelineModel;
        } else {
          el.dataIndex = el.dataModel = null;
        }
      }, this);
    },
    /**
     * @private
     */
    _renderAxisLabel: function(layoutInfo, group, axis2, timelineModel) {
      var labelModel = axis2.getLabelModel();
      if (!labelModel.get("show")) {
        return;
      }
      var data = timelineModel.getData();
      var labels = axis2.getViewLabels();
      each2(labels, function(labelItem) {
        var dataIndex = labelItem.tickValue;
        var itemModel = data.getItemModel(dataIndex);
        var normalLabelModel = itemModel.getModel("label");
        var hoverLabelModel = itemModel.getModel("emphasis.label");
        var tickCoord = axis2.dataToCoord(labelItem.tickValue);
        var textEl = new graphic2.Text({
          position: [tickCoord, 0],
          rotation: layoutInfo.labelRotation - layoutInfo.rotation,
          onclick: bind2(this._changeTimeline, this, dataIndex),
          silent: false
        });
        graphic2.setTextStyle(textEl.style, normalLabelModel, {
          text: labelItem.formattedLabel,
          textAlign: layoutInfo.labelAlign,
          textVerticalAlign: layoutInfo.labelBaseline
        });
        group.add(textEl);
        graphic2.setHoverStyle(textEl, graphic2.setTextStyle({}, hoverLabelModel));
      }, this);
    },
    /**
     * @private
     */
    _renderControl: function(layoutInfo, group, axis2, timelineModel) {
      var controlSize = layoutInfo.controlSize;
      var rotation = layoutInfo.rotation;
      var itemStyle2 = timelineModel.getModel("controlStyle").getItemStyle();
      var hoverStyle = timelineModel.getModel("emphasis.controlStyle").getItemStyle();
      var rect = [0, -controlSize / 2, controlSize, controlSize];
      var playState = timelineModel.getPlayState();
      var inverse = timelineModel.get("inverse", true);
      makeBtn(layoutInfo.nextBtnPosition, "controlStyle.nextIcon", bind2(this._changeTimeline, this, inverse ? "-" : "+"));
      makeBtn(layoutInfo.prevBtnPosition, "controlStyle.prevIcon", bind2(this._changeTimeline, this, inverse ? "+" : "-"));
      makeBtn(layoutInfo.playPosition, "controlStyle." + (playState ? "stopIcon" : "playIcon"), bind2(this._handlePlayClick, this, !playState), true);
      function makeBtn(position, iconPath, onclick, willRotate) {
        if (!position) {
          return;
        }
        var opt = {
          position,
          origin: [controlSize / 2, 0],
          rotation: willRotate ? -rotation : 0,
          rectHover: true,
          style: itemStyle2,
          onclick
        };
        var btn = makeIcon(timelineModel, iconPath, rect, opt);
        group.add(btn);
        graphic2.setHoverStyle(btn, hoverStyle);
      }
    },
    _renderCurrentPointer: function(layoutInfo, group, axis2, timelineModel) {
      var data = timelineModel.getData();
      var currentIndex = timelineModel.getCurrentIndex();
      var pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
      var me = this;
      var callback = {
        onCreate: function(pointer) {
          pointer.draggable = true;
          pointer.drift = bind2(me._handlePointerDrag, me);
          pointer.ondragend = bind2(me._handlePointerDragend, me);
          pointerMoveTo(pointer, currentIndex, axis2, timelineModel, true);
        },
        onUpdate: function(pointer) {
          pointerMoveTo(pointer, currentIndex, axis2, timelineModel);
        }
      };
      this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
    },
    _handlePlayClick: function(nextState) {
      this._clearTimer();
      this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: nextState,
        from: this.uid
      });
    },
    _handlePointerDrag: function(dx, dy, e2) {
      this._clearTimer();
      this._pointerChangeTimeline([e2.offsetX, e2.offsetY]);
    },
    _handlePointerDragend: function(e2) {
      this._pointerChangeTimeline([e2.offsetX, e2.offsetY], true);
    },
    _pointerChangeTimeline: function(mousePos, trigger2) {
      var toCoord = this._toAxisCoord(mousePos)[0];
      var axis2 = this._axis;
      var axisExtent = numberUtil.asc(axis2.getExtent().slice());
      toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
      toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
      this._currentPointer.position[0] = toCoord;
      this._currentPointer.dirty();
      var targetDataIndex = this._findNearestTick(toCoord);
      var timelineModel = this.model;
      if (trigger2 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
        this._changeTimeline(targetDataIndex);
      }
    },
    _doPlayStop: function() {
      this._clearTimer();
      if (this.model.getPlayState()) {
        this._timer = setTimeout(bind2(handleFrame, this), this.model.get("playInterval"));
      }
      function handleFrame() {
        var timelineModel = this.model;
        this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
      }
    },
    _toAxisCoord: function(vertex) {
      var trans = this._mainGroup.getLocalTransform();
      return graphic2.applyTransform(vertex, trans, true);
    },
    _findNearestTick: function(axisCoord) {
      var data = this.model.getData();
      var dist2 = Infinity;
      var targetDataIndex;
      var axis2 = this._axis;
      data.each(["value"], function(value, dataIndex) {
        var coord = axis2.dataToCoord(value);
        var d = Math.abs(coord - axisCoord);
        if (d < dist2) {
          dist2 = d;
          targetDataIndex = dataIndex;
        }
      });
      return targetDataIndex;
    },
    _clearTimer: function() {
      if (this._timer) {
        clearTimeout(this._timer);
        this._timer = null;
      }
    },
    _changeTimeline: function(nextIndex) {
      var currentIndex = this.model.getCurrentIndex();
      if (nextIndex === "+") {
        nextIndex = currentIndex + 1;
      } else if (nextIndex === "-") {
        nextIndex = currentIndex - 1;
      }
      this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: nextIndex,
        from: this.uid
      });
    }
  });
  function getViewRect(model2, api) {
    return layout2.getLayoutRect(model2.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    }, model2.get("padding"));
  }
  function makeIcon(timelineModel, objPath, rect, opts) {
    var style = opts.style;
    var icon = graphic2.createIcon(timelineModel.get(objPath), opts || {}, new BoundingRect2(rect[0], rect[1], rect[2], rect[3]));
    if (style) {
      icon.setStyle(style);
    }
    return icon;
  }
  function giveSymbol(hostModel, itemStyleModel, group, opt, symbol2, callback) {
    var color2 = itemStyleModel.get("color");
    if (!symbol2) {
      var symbolType = hostModel.get("symbol");
      symbol2 = createSymbol(symbolType, -1, -1, 2, 2, color2);
      symbol2.setStyle("strokeNoScale", true);
      group.add(symbol2);
      callback && callback.onCreate(symbol2);
    } else {
      symbol2.setColor(color2);
      group.add(symbol2);
      callback && callback.onUpdate(symbol2);
    }
    var itemStyle2 = itemStyleModel.getItemStyle(["color", "symbol", "symbolSize"]);
    symbol2.setStyle(itemStyle2);
    opt = zrUtil2.merge({
      rectHover: true,
      z2: 100
    }, opt, true);
    var symbolSize = hostModel.get("symbolSize");
    symbolSize = symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
    symbolSize[0] /= 2;
    symbolSize[1] /= 2;
    opt.scale = symbolSize;
    var symbolOffset = hostModel.get("symbolOffset");
    if (symbolOffset) {
      var pos = opt.position = opt.position || [0, 0];
      pos[0] += numberUtil.parsePercent(symbolOffset[0], symbolSize[0]);
      pos[1] += numberUtil.parsePercent(symbolOffset[1], symbolSize[1]);
    }
    var symbolRotate = hostModel.get("symbolRotate");
    opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    symbol2.attr(opt);
    symbol2.updateTransform();
    return symbol2;
  }
  function pointerMoveTo(pointer, dataIndex, axis2, timelineModel, noAnimation) {
    if (pointer.dragging) {
      return;
    }
    var pointerModel = timelineModel.getModel("checkpointStyle");
    var toCoord = axis2.dataToCoord(timelineModel.getData().get(["value"], dataIndex));
    if (noAnimation || !pointerModel.get("animation", true)) {
      pointer.attr({
        position: [toCoord, 0]
      });
    } else {
      pointer.stopAnimation(true);
      pointer.animateTo({
        position: [toCoord, 0]
      }, pointerModel.get("animationDuration", true), pointerModel.get("animationEasing", true));
    }
  }
  SliderTimelineView = _default2;
  return SliderTimelineView;
}
var hasRequiredTimeline;
function requireTimeline() {
  if (hasRequiredTimeline)
    return timeline;
  hasRequiredTimeline = 1;
  var echarts$12 = echarts;
  var preprocessor2 = requirePreprocessor$1();
  requireTypeDefaulter$1();
  requireTimelineAction();
  requireSliderTimelineModel();
  requireSliderTimelineView();
  echarts$12.registerPreprocessor(preprocessor2);
  return timeline;
}
var markPoint = {};
var MarkerModel_1;
var hasRequiredMarkerModel;
function requireMarkerModel() {
  if (hasRequiredMarkerModel)
    return MarkerModel_1;
  hasRequiredMarkerModel = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var env2 = env_1;
  var modelUtil2 = model;
  var formatUtil2 = requireFormat();
  var dataFormatMixin2 = dataFormat;
  var addCommas2 = formatUtil2.addCommas;
  var encodeHTML2 = formatUtil2.encodeHTML;
  function fillLabel(opt) {
    modelUtil2.defaultEmphasis(opt, "label", ["show"]);
  }
  var MarkerModel = echarts$12.extendComponentModel({
    type: "marker",
    dependencies: ["series", "grid", "polar", "geo"],
    /**
     * @overrite
     */
    init: function(option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
      this._mergeOption(option, ecModel, false, true);
    },
    /**
     * @return {boolean}
     */
    isAnimationEnabled: function() {
      if (env2.node) {
        return false;
      }
      var hostSeries = this.__hostSeries;
      return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
    },
    /**
     * @overrite
     */
    mergeOption: function(newOpt, ecModel) {
      this._mergeOption(newOpt, ecModel, false, false);
    },
    _mergeOption: function(newOpt, ecModel, createdBySelf, isInit) {
      var MarkerModel2 = this.constructor;
      var modelPropName = this.mainType + "Model";
      if (!createdBySelf) {
        ecModel.eachSeries(function(seriesModel) {
          var markerOpt = seriesModel.get(this.mainType, true);
          var markerModel = seriesModel[modelPropName];
          if (!markerOpt || !markerOpt.data) {
            seriesModel[modelPropName] = null;
            return;
          }
          if (!markerModel) {
            if (isInit) {
              fillLabel(markerOpt);
            }
            zrUtil2.each(markerOpt.data, function(item) {
              if (item instanceof Array) {
                fillLabel(item[0]);
                fillLabel(item[1]);
              } else {
                fillLabel(item);
              }
            });
            markerModel = new MarkerModel2(markerOpt, this, ecModel);
            zrUtil2.extend(markerModel, {
              mainType: this.mainType,
              // Use the same series index and name
              seriesIndex: seriesModel.seriesIndex,
              name: seriesModel.name,
              createdBySelf: true
            });
            markerModel.__hostSeries = seriesModel;
          } else {
            markerModel._mergeOption(markerOpt, ecModel, true);
          }
          seriesModel[modelPropName] = markerModel;
        }, this);
      }
    },
    formatTooltip: function(dataIndex, multipleSeries, dataType, renderMode) {
      var data = this.getData();
      var value = this.getRawValue(dataIndex);
      var formattedValue = zrUtil2.isArray(value) ? zrUtil2.map(value, addCommas2).join(", ") : addCommas2(value);
      var name2 = data.getName(dataIndex);
      var html = encodeHTML2(this.name);
      var newLine = renderMode === "html" ? "<br/>" : "\n";
      if (value != null || name2) {
        html += newLine;
      }
      if (name2) {
        html += encodeHTML2(name2);
        if (value != null) {
          html += " : ";
        }
      }
      if (value != null) {
        html += encodeHTML2(formattedValue);
      }
      return html;
    },
    getData: function() {
      return this._data;
    },
    setData: function(data) {
      this._data = data;
    }
  });
  zrUtil2.mixin(MarkerModel, dataFormatMixin2);
  var _default2 = MarkerModel;
  MarkerModel_1 = _default2;
  return MarkerModel_1;
}
var MarkPointModel;
var hasRequiredMarkPointModel;
function requireMarkPointModel() {
  if (hasRequiredMarkPointModel)
    return MarkPointModel;
  hasRequiredMarkPointModel = 1;
  var MarkerModel = requireMarkerModel();
  var _default2 = MarkerModel.extend({
    type: "markPoint",
    defaultOption: {
      zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      //symbolRotate: 0,
      //symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: true
        }
      }
    }
  });
  MarkPointModel = _default2;
  return MarkPointModel;
}
var markerHelper = {};
var hasRequiredMarkerHelper;
function requireMarkerHelper() {
  if (hasRequiredMarkerHelper)
    return markerHelper;
  hasRequiredMarkerHelper = 1;
  var zrUtil2 = util$6;
  var numberUtil = requireNumber();
  var _dataStackHelper = requireDataStackHelper();
  var isDimensionStacked = _dataStackHelper.isDimensionStacked;
  var indexOf2 = zrUtil2.indexOf;
  function hasXOrY(item) {
    return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
  }
  function hasXAndY(item) {
    return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
  }
  function markerTypeCalculatorWithExtent(mlType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
    var coordArr = [];
    var stacked = isDimensionStacked(
      data,
      targetDataDim
      /*, otherDataDim*/
    );
    var calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
    var value = numCalculate(data, calcDataDim, mlType);
    var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
    coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
    coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
    var coordArrValue = data.get(targetDataDim, dataIndex);
    var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));
    precision = Math.min(precision, 20);
    if (precision >= 0) {
      coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
    }
    return [coordArr, coordArrValue];
  }
  var curry2 = zrUtil2.curry;
  var markerTypeCalculator = {
    /**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */
    min: curry2(markerTypeCalculatorWithExtent, "min"),
    /**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */
    max: curry2(markerTypeCalculatorWithExtent, "max"),
    /**
     * @method
     * @param {module:echarts/data/List} data
     * @param {string} baseAxisDim
     * @param {string} valueAxisDim
     */
    average: curry2(markerTypeCalculatorWithExtent, "average")
  };
  function dataTransform(seriesModel, item) {
    var data = seriesModel.getData();
    var coordSys = seriesModel.coordinateSystem;
    if (item && !hasXAndY(item) && !zrUtil2.isArray(item.coord) && coordSys) {
      var dims = coordSys.dimensions;
      var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
      item = zrUtil2.clone(item);
      if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
        var otherCoordIndex = indexOf2(dims, axisInfo.baseAxis.dim);
        var targetCoordIndex = indexOf2(dims, axisInfo.valueAxis.dim);
        var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
        item.coord = coordInfo[0];
        item.value = coordInfo[1];
      } else {
        var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
        for (var i = 0; i < 2; i++) {
          if (markerTypeCalculator[coord[i]]) {
            coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
          }
        }
        item.coord = coord;
      }
    }
    return item;
  }
  function getAxisInfo(item, data, coordSys, seriesModel) {
    var ret = {};
    if (item.valueIndex != null || item.valueDim != null) {
      ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
      ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
      ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    } else {
      ret.baseAxis = seriesModel.getBaseAxis();
      ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
      ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
    }
    return ret;
  }
  function dataDimToCoordDim(seriesModel, dataDim) {
    var data = seriesModel.getData();
    var dimensions = data.dimensions;
    dataDim = data.getDimension(dataDim);
    for (var i = 0; i < dimensions.length; i++) {
      var dimItem = data.getDimensionInfo(dimensions[i]);
      if (dimItem.name === dataDim) {
        return dimItem.coordDim;
      }
    }
  }
  function dataFilter2(coordSys, item) {
    return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
  }
  function dimValueGetter(item, dimName, dataIndex, dimIndex) {
    if (dimIndex < 2) {
      return item.coord && item.coord[dimIndex];
    }
    return item.value;
  }
  function numCalculate(data, valueDataDim, type) {
    if (type === "average") {
      var sum = 0;
      var count = 0;
      data.each(valueDataDim, function(val, idx) {
        if (!isNaN(val)) {
          sum += val;
          count++;
        }
      });
      return sum / count;
    } else if (type === "median") {
      return data.getMedian(valueDataDim);
    } else {
      return data.getDataExtent(valueDataDim, true)[type === "max" ? 1 : 0];
    }
  }
  markerHelper.dataTransform = dataTransform;
  markerHelper.getAxisInfo = getAxisInfo;
  markerHelper.dataFilter = dataFilter2;
  markerHelper.dimValueGetter = dimValueGetter;
  markerHelper.numCalculate = numCalculate;
  return markerHelper;
}
var MarkerView;
var hasRequiredMarkerView;
function requireMarkerView() {
  if (hasRequiredMarkerView)
    return MarkerView;
  hasRequiredMarkerView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var _default2 = echarts$12.extendComponentView({
    type: "marker",
    init: function() {
      this.markerGroupMap = zrUtil2.createHashMap();
    },
    render: function(markerModel, ecModel, api) {
      var markerGroupMap = this.markerGroupMap;
      markerGroupMap.each(function(item) {
        item.__keep = false;
      });
      var markerModelKey = this.type + "Model";
      ecModel.eachSeries(function(seriesModel) {
        var markerModel2 = seriesModel[markerModelKey];
        markerModel2 && this.renderSeries(seriesModel, markerModel2, ecModel, api);
      }, this);
      markerGroupMap.each(function(item) {
        !item.__keep && this.group.remove(item.group);
      }, this);
    },
    renderSeries: function() {
    }
  });
  MarkerView = _default2;
  return MarkerView;
}
var MarkPointView;
var hasRequiredMarkPointView;
function requireMarkPointView() {
  if (hasRequiredMarkPointView)
    return MarkPointView;
  hasRequiredMarkPointView = 1;
  var zrUtil2 = util$6;
  var SymbolDraw = requireSymbolDraw();
  var numberUtil = requireNumber();
  var List = requireList();
  var markerHelper2 = requireMarkerHelper();
  var MarkerView2 = requireMarkerView();
  function updateMarkerLayout(mpData, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    mpData.each(function(idx) {
      var itemModel = mpData.getItemModel(idx);
      var point;
      var xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth());
      var yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx];
      } else if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
      } else if (coordSys) {
        var x = mpData.get(coordSys.dimensions[0], idx);
        var y = mpData.get(coordSys.dimensions[1], idx);
        point = coordSys.dataToPoint([x, y]);
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
      mpData.setItemLayout(idx, point);
    });
  }
  var _default2 = MarkerView2.extend({
    type: "markPoint",
    // updateLayout: function (markPointModel, ecModel, api) {
    //     ecModel.eachSeries(function (seriesModel) {
    //         var mpModel = seriesModel.markPointModel;
    //         if (mpModel) {
    //             updateMarkerLayout(mpModel.getData(), seriesModel, api);
    //             this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
    //         }
    //     }, this);
    // },
    updateTransform: function(markPointModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var mpModel = seriesModel.markPointModel;
        if (mpModel) {
          updateMarkerLayout(mpModel.getData(), seriesModel, api);
          this.markerGroupMap.get(seriesModel.id).updateLayout(mpModel);
        }
      }, this);
    },
    renderSeries: function(seriesModel, mpModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var symbolDrawMap = this.markerGroupMap;
      var symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw());
      var mpData = createList(coordSys, seriesModel, mpModel);
      mpModel.setData(mpData);
      updateMarkerLayout(mpModel.getData(), seriesModel, api);
      mpData.each(function(idx) {
        var itemModel = mpData.getItemModel(idx);
        var symbol2 = itemModel.getShallow("symbol");
        var symbolSize = itemModel.getShallow("symbolSize");
        var symbolRotate = itemModel.getShallow("symbolRotate");
        var isFnSymbol = zrUtil2.isFunction(symbol2);
        var isFnSymbolSize = zrUtil2.isFunction(symbolSize);
        var isFnSymbolRotate = zrUtil2.isFunction(symbolRotate);
        if (isFnSymbol || isFnSymbolSize || isFnSymbolRotate) {
          var rawIdx = mpModel.getRawValue(idx);
          var dataParams = mpModel.getDataParams(idx);
          if (isFnSymbol) {
            symbol2 = symbol2(rawIdx, dataParams);
          }
          if (isFnSymbolSize) {
            symbolSize = symbolSize(rawIdx, dataParams);
          }
          if (isFnSymbolRotate) {
            symbolRotate = symbolRotate(rawIdx, dataParams);
          }
        }
        mpData.setItemVisual(idx, {
          symbol: symbol2,
          symbolSize,
          symbolRotate,
          color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
        });
      });
      symbolDraw.updateData(mpData);
      this.group.add(symbolDraw.group);
      mpData.eachItemGraphicEl(function(el) {
        el.traverse(function(child) {
          child.dataModel = mpModel;
        });
      });
      symbolDraw.__keep = true;
      symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
    }
  });
  function createList(coordSys, seriesModel, mpModel) {
    var coordDimsInfos;
    if (coordSys) {
      coordDimsInfos = zrUtil2.map(coordSys && coordSys.dimensions, function(coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
        return zrUtil2.defaults({
          name: coordDim
        }, info);
      });
    } else {
      coordDimsInfos = [{
        name: "value",
        type: "float"
      }];
    }
    var mpData = new List(coordDimsInfos, mpModel);
    var dataOpt = zrUtil2.map(mpModel.get("data"), zrUtil2.curry(markerHelper2.dataTransform, seriesModel));
    if (coordSys) {
      dataOpt = zrUtil2.filter(dataOpt, zrUtil2.curry(markerHelper2.dataFilter, coordSys));
    }
    mpData.initData(dataOpt, null, coordSys ? markerHelper2.dimValueGetter : function(item) {
      return item.value;
    });
    return mpData;
  }
  MarkPointView = _default2;
  return MarkPointView;
}
var hasRequiredMarkPoint;
function requireMarkPoint() {
  if (hasRequiredMarkPoint)
    return markPoint;
  hasRequiredMarkPoint = 1;
  var echarts$12 = echarts;
  requireMarkPointModel();
  requireMarkPointView();
  echarts$12.registerPreprocessor(function(opt) {
    opt.markPoint = opt.markPoint || {};
  });
  return markPoint;
}
var markLine = {};
var MarkLineModel;
var hasRequiredMarkLineModel;
function requireMarkLineModel() {
  if (hasRequiredMarkLineModel)
    return MarkLineModel;
  hasRequiredMarkLineModel = 1;
  var MarkerModel = requireMarkerModel();
  var _default2 = MarkerModel.extend({
    type: "markLine",
    defaultOption: {
      zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      //symbolRotate: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: true,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: true
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }
  });
  MarkLineModel = _default2;
  return MarkLineModel;
}
var MarkLineView;
var hasRequiredMarkLineView;
function requireMarkLineView() {
  if (hasRequiredMarkLineView)
    return MarkLineView;
  hasRequiredMarkLineView = 1;
  var zrUtil2 = util$6;
  var List = requireList();
  var numberUtil = requireNumber();
  var markerHelper2 = requireMarkerHelper();
  var LineDraw = requireLineDraw();
  var MarkerView2 = requireMarkerView();
  var _dataStackHelper = requireDataStackHelper();
  var getStackedDimension = _dataStackHelper.getStackedDimension;
  var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
    var data = seriesModel.getData();
    var mlType = item.type;
    if (!zrUtil2.isArray(item) && (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || item.xAxis != null || item.yAxis != null)) {
      var valueAxis;
      var value;
      if (item.yAxis != null || item.xAxis != null) {
        valueAxis = coordSys.getAxis(item.yAxis != null ? "y" : "x");
        value = zrUtil2.retrieve(item.yAxis, item.xAxis);
      } else {
        var axisInfo = markerHelper2.getAxisInfo(item, data, coordSys, seriesModel);
        valueAxis = axisInfo.valueAxis;
        var valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
        value = markerHelper2.numCalculate(data, valueDataDim, mlType);
      }
      var valueIndex = valueAxis.dim === "x" ? 0 : 1;
      var baseIndex = 1 - valueIndex;
      var mlFrom = zrUtil2.clone(item);
      var mlTo = {};
      mlFrom.type = null;
      mlFrom.coord = [];
      mlTo.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      var precision = mlModel.get("precision");
      if (precision >= 0 && typeof value === "number") {
        value = +value.toFixed(Math.min(precision, 20));
      }
      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      item = [mlFrom, mlTo, {
        // Extra option for tooltip and label
        type: mlType,
        valueIndex: item.valueIndex,
        // Force to use the value of calculated value.
        value
      }];
    }
    item = [markerHelper2.dataTransform(seriesModel, item[0]), markerHelper2.dataTransform(seriesModel, item[1]), zrUtil2.extend({}, item[2])];
    item[2].type = item[2].type || "";
    zrUtil2.merge(item[2], item[0]);
    zrUtil2.merge(item[2], item[1]);
    return item;
  };
  function isInifinity(val) {
    return !isNaN(val) && !isFinite(val);
  }
  function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    var dimName = coordSys.dimensions[dimIndex];
    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
  }
  function markLineFilter(coordSys, item) {
    if (coordSys.type === "cartesian2d") {
      var fromCoord = item[0].coord;
      var toCoord = item[1].coord;
      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
        return true;
      }
    }
    return markerHelper2.dataFilter(coordSys, item[0]) && markerHelper2.dataFilter(coordSys, item[1]);
  }
  function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = numberUtil.parsePercent(itemModel.get("x"), api.getWidth());
    var yPx = numberUtil.parsePercent(itemModel.get("y"), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
      } else {
        var dims = coordSys.dimensions;
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        point = coordSys.dataToPoint([x, y]);
      }
      if (coordSys.type === "cartesian2d") {
        var xAxis = coordSys.getAxis("x");
        var yAxis = coordSys.getAxis("y");
        var dims = coordSys.dimensions;
        if (isInifinity(data.get(dims[0], idx))) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
        } else if (isInifinity(data.get(dims[1], idx))) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
        }
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }
    data.setItemLayout(idx, point);
  }
  var _default2 = MarkerView2.extend({
    type: "markLine",
    // updateLayout: function (markLineModel, ecModel, api) {
    //     ecModel.eachSeries(function (seriesModel) {
    //         var mlModel = seriesModel.markLineModel;
    //         if (mlModel) {
    //             var mlData = mlModel.getData();
    //             var fromData = mlModel.__from;
    //             var toData = mlModel.__to;
    //             // Update visual and layout of from symbol and to symbol
    //             fromData.each(function (idx) {
    //                 updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
    //                 updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
    //             });
    //             // Update layout of line
    //             mlData.each(function (idx) {
    //                 mlData.setItemLayout(idx, [
    //                     fromData.getItemLayout(idx),
    //                     toData.getItemLayout(idx)
    //                 ]);
    //             });
    //             this.markerGroupMap.get(seriesModel.id).updateLayout();
    //         }
    //     }, this);
    // },
    updateTransform: function(markLineModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var mlModel = seriesModel.markLineModel;
        if (mlModel) {
          var mlData = mlModel.getData();
          var fromData = mlModel.__from;
          var toData = mlModel.__to;
          fromData.each(function(idx) {
            updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api);
            updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api);
          });
          mlData.each(function(idx) {
            mlData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
          });
          this.markerGroupMap.get(seriesModel.id).updateLayout();
        }
      }, this);
    },
    renderSeries: function(seriesModel, mlModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var lineDrawMap = this.markerGroupMap;
      var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw());
      this.group.add(lineDraw.group);
      var mlData = createList(coordSys, seriesModel, mlModel);
      var fromData = mlData.from;
      var toData = mlData.to;
      var lineData = mlData.line;
      mlModel.__from = fromData;
      mlModel.__to = toData;
      mlModel.setData(lineData);
      var symbolType = mlModel.get("symbol");
      var symbolSize = mlModel.get("symbolSize");
      if (!zrUtil2.isArray(symbolType)) {
        symbolType = [symbolType, symbolType];
      }
      if (typeof symbolSize === "number") {
        symbolSize = [symbolSize, symbolSize];
      }
      mlData.from.each(function(idx) {
        updateDataVisualAndLayout(fromData, idx, true);
        updateDataVisualAndLayout(toData, idx, false);
      });
      lineData.each(function(idx) {
        var lineColor = lineData.getItemModel(idx).get("lineStyle.color");
        lineData.setItemVisual(idx, {
          color: lineColor || fromData.getItemVisual(idx, "color")
        });
        lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
        lineData.setItemVisual(idx, {
          "fromSymbolRotate": fromData.getItemVisual(idx, "symbolRotate"),
          "fromSymbolSize": fromData.getItemVisual(idx, "symbolSize"),
          "fromSymbol": fromData.getItemVisual(idx, "symbol"),
          "toSymbolRotate": toData.getItemVisual(idx, "symbolRotate"),
          "toSymbolSize": toData.getItemVisual(idx, "symbolSize"),
          "toSymbol": toData.getItemVisual(idx, "symbol")
        });
      });
      lineDraw.updateData(lineData);
      mlData.line.eachItemGraphicEl(function(el, idx) {
        el.traverse(function(child) {
          child.dataModel = mlModel;
        });
      });
      function updateDataVisualAndLayout(data, idx, isFrom) {
        var itemModel = data.getItemModel(idx);
        updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
        data.setItemVisual(idx, {
          symbolRotate: itemModel.get("symbolRotate"),
          symbolSize: itemModel.get("symbolSize") || symbolSize[isFrom ? 0 : 1],
          symbol: itemModel.get("symbol", true) || symbolType[isFrom ? 0 : 1],
          color: itemModel.get("itemStyle.color") || seriesData.getVisual("color")
        });
      }
      lineDraw.__keep = true;
      lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
    }
  });
  function createList(coordSys, seriesModel, mlModel) {
    var coordDimsInfos;
    if (coordSys) {
      coordDimsInfos = zrUtil2.map(coordSys && coordSys.dimensions, function(coordDim) {
        var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
        return zrUtil2.defaults({
          name: coordDim
        }, info);
      });
    } else {
      coordDimsInfos = [{
        name: "value",
        type: "float"
      }];
    }
    var fromData = new List(coordDimsInfos, mlModel);
    var toData = new List(coordDimsInfos, mlModel);
    var lineData = new List([], mlModel);
    var optData = zrUtil2.map(mlModel.get("data"), zrUtil2.curry(markLineTransform, seriesModel, coordSys, mlModel));
    if (coordSys) {
      optData = zrUtil2.filter(optData, zrUtil2.curry(markLineFilter, coordSys));
    }
    var dimValueGetter = coordSys ? markerHelper2.dimValueGetter : function(item) {
      return item.value;
    };
    fromData.initData(zrUtil2.map(optData, function(item) {
      return item[0];
    }), null, dimValueGetter);
    toData.initData(zrUtil2.map(optData, function(item) {
      return item[1];
    }), null, dimValueGetter);
    lineData.initData(zrUtil2.map(optData, function(item) {
      return item[2];
    }));
    lineData.hasItemOption = true;
    return {
      from: fromData,
      to: toData,
      line: lineData
    };
  }
  MarkLineView = _default2;
  return MarkLineView;
}
var hasRequiredMarkLine;
function requireMarkLine() {
  if (hasRequiredMarkLine)
    return markLine;
  hasRequiredMarkLine = 1;
  var echarts$12 = echarts;
  requireMarkLineModel();
  requireMarkLineView();
  echarts$12.registerPreprocessor(function(opt) {
    opt.markLine = opt.markLine || {};
  });
  return markLine;
}
var markArea = {};
var MarkAreaModel;
var hasRequiredMarkAreaModel;
function requireMarkAreaModel() {
  if (hasRequiredMarkAreaModel)
    return MarkAreaModel;
  hasRequiredMarkAreaModel = 1;
  var MarkerModel = requireMarkerModel();
  var _default2 = MarkerModel.extend({
    type: "markArea",
    defaultOption: {
      zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: false,
      label: {
        show: true,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: true,
          position: "top"
        }
      }
    }
  });
  MarkAreaModel = _default2;
  return MarkAreaModel;
}
var MarkAreaView = {};
var hasRequiredMarkAreaView;
function requireMarkAreaView() {
  if (hasRequiredMarkAreaView)
    return MarkAreaView;
  hasRequiredMarkAreaView = 1;
  var zrUtil2 = util$6;
  var colorUtil = color$1;
  var List = requireList();
  var numberUtil = requireNumber();
  var graphic2 = graphic$4;
  var markerHelper2 = requireMarkerHelper();
  var MarkerView2 = requireMarkerView();
  var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
    var lt = markerHelper2.dataTransform(seriesModel, item[0]);
    var rb = markerHelper2.dataTransform(seriesModel, item[1]);
    var retrieve4 = zrUtil2.retrieve;
    var ltCoord = lt.coord;
    var rbCoord = rb.coord;
    ltCoord[0] = retrieve4(ltCoord[0], -Infinity);
    ltCoord[1] = retrieve4(ltCoord[1], -Infinity);
    rbCoord[0] = retrieve4(rbCoord[0], Infinity);
    rbCoord[1] = retrieve4(rbCoord[1], Infinity);
    var result = zrUtil2.mergeAll([{}, lt, rb]);
    result.coord = [lt.coord, rb.coord];
    result.x0 = lt.x;
    result.y0 = lt.y;
    result.x1 = rb.x;
    result.y1 = rb.y;
    return result;
  };
  function isInifinity(val) {
    return !isNaN(val) && !isFinite(val);
  }
  function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
    var otherDimIndex = 1 - dimIndex;
    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]);
  }
  function markAreaFilter(coordSys, item) {
    var fromCoord = item.coord[0];
    var toCoord = item.coord[1];
    if (coordSys.type === "cartesian2d") {
      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord))) {
        return true;
      }
    }
    return markerHelper2.dataFilter(coordSys, {
      coord: fromCoord,
      x: item.x0,
      y: item.y0
    }) || markerHelper2.dataFilter(coordSys, {
      coord: toCoord,
      x: item.x1,
      y: item.y1
    });
  }
  function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api) {
    var coordSys = seriesModel.coordinateSystem;
    var itemModel = data.getItemModel(idx);
    var point;
    var xPx = numberUtil.parsePercent(itemModel.get(dims[0]), api.getWidth());
    var yPx = numberUtil.parsePercent(itemModel.get(dims[1]), api.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else {
      if (seriesModel.getMarkerPosition) {
        point = seriesModel.getMarkerPosition(data.getValues(dims, idx));
      } else {
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        var pt = [x, y];
        coordSys.clampData && coordSys.clampData(pt, pt);
        point = coordSys.dataToPoint(pt, true);
      }
      if (coordSys.type === "cartesian2d") {
        var xAxis = coordSys.getAxis("x");
        var yAxis = coordSys.getAxis("y");
        var x = data.get(dims[0], idx);
        var y = data.get(dims[1], idx);
        if (isInifinity(x)) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
        } else if (isInifinity(y)) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
        }
      }
      if (!isNaN(xPx)) {
        point[0] = xPx;
      }
      if (!isNaN(yPx)) {
        point[1] = yPx;
      }
    }
    return point;
  }
  var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
  MarkerView2.extend({
    type: "markArea",
    // updateLayout: function (markAreaModel, ecModel, api) {
    //     ecModel.eachSeries(function (seriesModel) {
    //         var maModel = seriesModel.markAreaModel;
    //         if (maModel) {
    //             var areaData = maModel.getData();
    //             areaData.each(function (idx) {
    //                 var points = zrUtil.map(dimPermutations, function (dim) {
    //                     return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
    //                 });
    //                 // Layout
    //                 areaData.setItemLayout(idx, points);
    //                 var el = areaData.getItemGraphicEl(idx);
    //                 el.setShape('points', points);
    //             });
    //         }
    //     }, this);
    // },
    updateTransform: function(markAreaModel, ecModel, api) {
      ecModel.eachSeries(function(seriesModel) {
        var maModel = seriesModel.markAreaModel;
        if (maModel) {
          var areaData = maModel.getData();
          areaData.each(function(idx) {
            var points2 = zrUtil2.map(dimPermutations, function(dim) {
              return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
            });
            areaData.setItemLayout(idx, points2);
            var el = areaData.getItemGraphicEl(idx);
            el.setShape("points", points2);
          });
        }
      }, this);
    },
    renderSeries: function(seriesModel, maModel, ecModel, api) {
      var coordSys = seriesModel.coordinateSystem;
      var seriesId = seriesModel.id;
      var seriesData = seriesModel.getData();
      var areaGroupMap = this.markerGroupMap;
      var polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
        group: new graphic2.Group()
      });
      this.group.add(polygonGroup.group);
      polygonGroup.__keep = true;
      var areaData = createList(coordSys, seriesModel, maModel);
      maModel.setData(areaData);
      areaData.each(function(idx) {
        var points2 = zrUtil2.map(dimPermutations, function(dim) {
          return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api);
        });
        var allClipped = true;
        zrUtil2.each(dimPermutations, function(dim) {
          if (!allClipped) {
            return;
          }
          var xValue = areaData.get(dim[0], idx);
          var yValue = areaData.get(dim[1], idx);
          if ((isInifinity(xValue) || coordSys.getAxis("x").containData(xValue)) && (isInifinity(yValue) || coordSys.getAxis("y").containData(yValue))) {
            allClipped = false;
          }
        });
        areaData.setItemLayout(idx, {
          points: points2,
          allClipped
        });
        areaData.setItemVisual(idx, {
          color: seriesData.getVisual("color")
        });
      });
      areaData.diff(polygonGroup.__data).add(function(idx) {
        var layout2 = areaData.getItemLayout(idx);
        if (!layout2.allClipped) {
          var polygon2 = new graphic2.Polygon({
            shape: {
              points: layout2.points
            }
          });
          areaData.setItemGraphicEl(idx, polygon2);
          polygonGroup.group.add(polygon2);
        }
      }).update(function(newIdx, oldIdx) {
        var polygon2 = polygonGroup.__data.getItemGraphicEl(oldIdx);
        var layout2 = areaData.getItemLayout(newIdx);
        if (!layout2.allClipped) {
          if (polygon2) {
            graphic2.updateProps(polygon2, {
              shape: {
                points: layout2.points
              }
            }, maModel, newIdx);
          } else {
            polygon2 = new graphic2.Polygon({
              shape: {
                points: layout2.points
              }
            });
          }
          areaData.setItemGraphicEl(newIdx, polygon2);
          polygonGroup.group.add(polygon2);
        } else if (polygon2) {
          polygonGroup.group.remove(polygon2);
        }
      }).remove(function(idx) {
        var polygon2 = polygonGroup.__data.getItemGraphicEl(idx);
        polygonGroup.group.remove(polygon2);
      }).execute();
      areaData.eachItemGraphicEl(function(polygon2, idx) {
        var itemModel = areaData.getItemModel(idx);
        var labelModel = itemModel.getModel("label");
        var labelHoverModel = itemModel.getModel("emphasis.label");
        var color2 = areaData.getItemVisual(idx, "color");
        polygon2.useStyle(zrUtil2.defaults(itemModel.getModel("itemStyle").getItemStyle(), {
          fill: colorUtil.modifyAlpha(color2, 0.4),
          stroke: color2
        }));
        polygon2.hoverStyle = itemModel.getModel("emphasis.itemStyle").getItemStyle();
        graphic2.setLabelStyle(polygon2.style, polygon2.hoverStyle, labelModel, labelHoverModel, {
          labelFetcher: maModel,
          labelDataIndex: idx,
          defaultText: areaData.getName(idx) || "",
          isRectText: true,
          autoColor: color2
        });
        graphic2.setHoverStyle(polygon2, {});
        polygon2.dataModel = maModel;
      });
      polygonGroup.__data = areaData;
      polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
    }
  });
  function createList(coordSys, seriesModel, maModel) {
    var coordDimsInfos;
    var areaData;
    var dims = ["x0", "y0", "x1", "y1"];
    if (coordSys) {
      coordDimsInfos = zrUtil2.map(coordSys && coordSys.dimensions, function(coordDim) {
        var data = seriesModel.getData();
        var info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
        return zrUtil2.defaults({
          name: coordDim
        }, info);
      });
      areaData = new List(zrUtil2.map(dims, function(dim, idx) {
        return {
          name: dim,
          type: coordDimsInfos[idx % 2].type
        };
      }), maModel);
    } else {
      coordDimsInfos = [{
        name: "value",
        type: "float"
      }];
      areaData = new List(coordDimsInfos, maModel);
    }
    var optData = zrUtil2.map(maModel.get("data"), zrUtil2.curry(markAreaTransform, seriesModel, coordSys, maModel));
    if (coordSys) {
      optData = zrUtil2.filter(optData, zrUtil2.curry(markAreaFilter, coordSys));
    }
    var dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
      return item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    } : function(item) {
      return item.value;
    };
    areaData.initData(optData, null, dimValueGetter);
    areaData.hasItemOption = true;
    return areaData;
  }
  return MarkAreaView;
}
var hasRequiredMarkArea;
function requireMarkArea() {
  if (hasRequiredMarkArea)
    return markArea;
  hasRequiredMarkArea = 1;
  var echarts$12 = echarts;
  requireMarkAreaModel();
  requireMarkAreaView();
  echarts$12.registerPreprocessor(function(opt) {
    opt.markArea = opt.markArea || {};
  });
  return markArea;
}
var legendScroll = {};
var legend = {};
var LegendModel_1;
var hasRequiredLegendModel;
function requireLegendModel() {
  if (hasRequiredLegendModel)
    return LegendModel_1;
  hasRequiredLegendModel = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var Model2 = requireModel();
  var _model2 = model;
  var isNameSpecified2 = _model2.isNameSpecified;
  var lang2 = lang$1;
  var langSelector = lang2.legend.selector;
  var defaultSelectorOption = {
    all: {
      type: "all",
      title: zrUtil2.clone(langSelector.all)
    },
    inverse: {
      type: "inverse",
      title: zrUtil2.clone(langSelector.inverse)
    }
  };
  var LegendModel = echarts$12.extendComponentModel({
    type: "legend.plain",
    dependencies: ["series"],
    layoutMode: {
      type: "box",
      // legend.width/height are maxWidth/maxHeight actually,
      // whereas realy width/height is calculated by its content.
      // (Setting {left: 10, right: 10} does not make sense).
      // So consider the case:
      // `setOption({legend: {left: 10});`
      // then `setOption({legend: {right: 10});`
      // The previous `left` should be cleared by setting `ignoreSize`.
      ignoreSize: true
    },
    init: function(option, parentModel, ecModel) {
      this.mergeDefaultAndTheme(option, ecModel);
      option.selected = option.selected || {};
      this._updateSelector(option);
    },
    mergeOption: function(option) {
      LegendModel.superCall(this, "mergeOption", option);
      this._updateSelector(option);
    },
    _updateSelector: function(option) {
      var selector = option.selector;
      if (selector === true) {
        selector = option.selector = ["all", "inverse"];
      }
      if (zrUtil2.isArray(selector)) {
        zrUtil2.each(selector, function(item, index2) {
          zrUtil2.isString(item) && (item = {
            type: item
          });
          selector[index2] = zrUtil2.merge(item, defaultSelectorOption[item.type]);
        });
      }
    },
    optionUpdated: function() {
      this._updateData(this.ecModel);
      var legendData = this._data;
      if (legendData[0] && this.get("selectedMode") === "single") {
        var hasSelected = false;
        for (var i = 0; i < legendData.length; i++) {
          var name2 = legendData[i].get("name");
          if (this.isSelected(name2)) {
            this.select(name2);
            hasSelected = true;
            break;
          }
        }
        !hasSelected && this.select(legendData[0].get("name"));
      }
    },
    _updateData: function(ecModel) {
      var potentialData = [];
      var availableNames = [];
      ecModel.eachRawSeries(function(seriesModel) {
        var seriesName = seriesModel.name;
        availableNames.push(seriesName);
        var isPotential;
        if (seriesModel.legendVisualProvider) {
          var provider = seriesModel.legendVisualProvider;
          var names = provider.getAllNames();
          if (!ecModel.isSeriesFiltered(seriesModel)) {
            availableNames = availableNames.concat(names);
          }
          if (names.length) {
            potentialData = potentialData.concat(names);
          } else {
            isPotential = true;
          }
        } else {
          isPotential = true;
        }
        if (isPotential && isNameSpecified2(seriesModel)) {
          potentialData.push(seriesModel.name);
        }
      });
      this._availableNames = availableNames;
      var rawData = this.get("data") || potentialData;
      var legendData = zrUtil2.map(rawData, function(dataItem) {
        if (typeof dataItem === "string" || typeof dataItem === "number") {
          dataItem = {
            name: dataItem
          };
        }
        return new Model2(dataItem, this, this.ecModel);
      }, this);
      this._data = legendData;
    },
    /**
     * @return {Array.<module:echarts/model/Model>}
     */
    getData: function() {
      return this._data;
    },
    /**
     * @param {string} name
     */
    select: function(name2) {
      var selected = this.option.selected;
      var selectedMode = this.get("selectedMode");
      if (selectedMode === "single") {
        var data = this._data;
        zrUtil2.each(data, function(dataItem) {
          selected[dataItem.get("name")] = false;
        });
      }
      selected[name2] = true;
    },
    /**
     * @param {string} name
     */
    unSelect: function(name2) {
      if (this.get("selectedMode") !== "single") {
        this.option.selected[name2] = false;
      }
    },
    /**
     * @param {string} name
     */
    toggleSelected: function(name2) {
      var selected = this.option.selected;
      if (!selected.hasOwnProperty(name2)) {
        selected[name2] = true;
      }
      this[selected[name2] ? "unSelect" : "select"](name2);
    },
    allSelect: function() {
      var data = this._data;
      var selected = this.option.selected;
      zrUtil2.each(data, function(dataItem) {
        selected[dataItem.get("name", true)] = true;
      });
    },
    inverseSelect: function() {
      var data = this._data;
      var selected = this.option.selected;
      zrUtil2.each(data, function(dataItem) {
        var name2 = dataItem.get("name", true);
        if (!selected.hasOwnProperty(name2)) {
          selected[name2] = true;
        }
        selected[name2] = !selected[name2];
      });
    },
    /**
     * @param {string} name
     */
    isSelected: function(name2) {
      var selected = this.option.selected;
      return !(selected.hasOwnProperty(name2) && !selected[name2]) && zrUtil2.indexOf(this._availableNames, name2) >= 0;
    },
    getOrient: function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    },
    defaultOption: {
      // 一级层叠
      zlevel: 0,
      // 二级层叠
      z: 4,
      show: true,
      // 布局方式，默认为水平布局，可选为：
      // 'horizontal' | 'vertical'
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      // 水平对齐
      // 'auto' | 'left' | 'right'
      // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      // 图例边框颜色
      borderColor: "#ccc",
      borderRadius: 0,
      // 图例边框线宽，单位px，默认为0（无边框）
      borderWidth: 0,
      // 图例内边距，单位px，默认各方向内边距为5，
      // 接受数组分别设定上右下左边距，同css
      padding: 5,
      // 各个item之间的间隔，单位px，默认为10，
      // 横向布局时为水平间隔，纵向布局时为纵向间隔
      itemGap: 10,
      // the width of legend symbol
      itemWidth: 25,
      // the height of legend symbol
      itemHeight: 14,
      // the color of unselected legend symbol
      inactiveColor: "#ccc",
      // the borderColor of unselected legend symbol
      inactiveBorderColor: "#ccc",
      itemStyle: {
        // the default borderWidth of legend symbol
        borderWidth: 0
      },
      textStyle: {
        // 图例文字颜色
        color: "#333"
      },
      // formatter: '',
      // 选择模式，默认开启图例开关
      selectedMode: true,
      // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入
      // selected: null,
      // 图例内容（详见legend.data，数组中每一项代表一个item
      // data: [],
      // Usage:
      // selector: [{type: 'all or inverse', title: xxx}]
      // or
      // selector: true
      // or
      // selector: ['all', 'inverse']
      selector: false,
      selectorLabel: {
        show: true,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: " sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: true,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      // Value can be 'start' or 'end'
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      // Tooltip 相关配置
      tooltip: {
        show: false
      }
    }
  });
  var _default2 = LegendModel;
  LegendModel_1 = _default2;
  return LegendModel_1;
}
var legendAction = {};
var hasRequiredLegendAction;
function requireLegendAction() {
  if (hasRequiredLegendAction)
    return legendAction;
  hasRequiredLegendAction = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  function legendSelectActionHandler(methodName, payload, ecModel) {
    var selectedMap = {};
    var isToggleSelect = methodName === "toggleSelected";
    var isSelected;
    ecModel.eachComponent("legend", function(legendModel) {
      if (isToggleSelect && isSelected != null) {
        legendModel[isSelected ? "select" : "unSelect"](payload.name);
      } else if (methodName === "allSelect" || methodName === "inverseSelect") {
        legendModel[methodName]();
      } else {
        legendModel[methodName](payload.name);
        isSelected = legendModel.isSelected(payload.name);
      }
      var legendData = legendModel.getData();
      zrUtil2.each(legendData, function(model2) {
        var name2 = model2.get("name");
        if (name2 === "\n" || name2 === "") {
          return;
        }
        var isItemSelected = legendModel.isSelected(name2);
        if (selectedMap.hasOwnProperty(name2)) {
          selectedMap[name2] = selectedMap[name2] && isItemSelected;
        } else {
          selectedMap[name2] = isItemSelected;
        }
      });
    });
    return methodName === "allSelect" || methodName === "inverseSelect" ? {
      selected: selectedMap
    } : {
      name: payload.name,
      selected: selectedMap
    };
  }
  echarts$12.registerAction("legendToggleSelect", "legendselectchanged", zrUtil2.curry(legendSelectActionHandler, "toggleSelected"));
  echarts$12.registerAction("legendAllSelect", "legendselectall", zrUtil2.curry(legendSelectActionHandler, "allSelect"));
  echarts$12.registerAction("legendInverseSelect", "legendinverseselect", zrUtil2.curry(legendSelectActionHandler, "inverseSelect"));
  echarts$12.registerAction("legendSelect", "legendselected", zrUtil2.curry(legendSelectActionHandler, "select"));
  echarts$12.registerAction("legendUnSelect", "legendunselected", zrUtil2.curry(legendSelectActionHandler, "unSelect"));
  return legendAction;
}
var LegendView;
var hasRequiredLegendView;
function requireLegendView() {
  if (hasRequiredLegendView)
    return LegendView;
  hasRequiredLegendView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var graphic2 = graphic$4;
  var _listComponent = requireListComponent();
  var makeBackground = _listComponent.makeBackground;
  var layoutUtil = layout$1;
  var curry2 = zrUtil2.curry;
  var each2 = zrUtil2.each;
  var Group2 = graphic2.Group;
  var _default2 = echarts$12.extendComponentView({
    type: "legend.plain",
    newlineDisabled: false,
    /**
     * @override
     */
    init: function() {
      this.group.add(this._contentGroup = new Group2());
      this._backgroundEl;
      this.group.add(this._selectorGroup = new Group2());
      this._isFirstRender = true;
    },
    /**
     * @protected
     */
    getContentGroup: function() {
      return this._contentGroup;
    },
    /**
     * @protected
     */
    getSelectorGroup: function() {
      return this._selectorGroup;
    },
    /**
     * @override
     */
    render: function(legendModel, ecModel, api) {
      var isFirstRender = this._isFirstRender;
      this._isFirstRender = false;
      this.resetInner();
      if (!legendModel.get("show", true)) {
        return;
      }
      var itemAlign = legendModel.get("align");
      var orient = legendModel.get("orient");
      if (!itemAlign || itemAlign === "auto") {
        itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
      }
      var selector = legendModel.get("selector", true);
      var selectorPosition = legendModel.get("selectorPosition", true);
      if (selector && (!selectorPosition || selectorPosition === "auto")) {
        selectorPosition = orient === "horizontal" ? "end" : "start";
      }
      this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
      var positionInfo = legendModel.getBoxLayoutParams();
      var viewportSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var padding = legendModel.get("padding");
      var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
      var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
      var layoutRect = layoutUtil.getLayoutRect(zrUtil2.defaults({
        width: mainRect.width,
        height: mainRect.height
      }, positionInfo), viewportSize, padding);
      this.group.attr("position", [layoutRect.x - mainRect.x, layoutRect.y - mainRect.y]);
      this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
    },
    /**
     * @protected
     */
    resetInner: function() {
      this.getContentGroup().removeAll();
      this._backgroundEl && this.group.remove(this._backgroundEl);
      this.getSelectorGroup().removeAll();
    },
    /**
     * @protected
     */
    renderInner: function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
      var contentGroup = this.getContentGroup();
      var legendDrawnMap = zrUtil2.createHashMap();
      var selectMode = legendModel.get("selectedMode");
      var excludeSeriesId = [];
      ecModel.eachRawSeries(function(seriesModel) {
        !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
      });
      each2(legendModel.getData(), function(itemModel, dataIndex) {
        var name2 = itemModel.get("name");
        if (!this.newlineDisabled && (name2 === "" || name2 === "\n")) {
          contentGroup.add(new Group2({
            newline: true
          }));
          return;
        }
        var seriesModel = ecModel.getSeriesByName(name2)[0];
        if (legendDrawnMap.get(name2)) {
          return;
        }
        if (seriesModel) {
          var data = seriesModel.getData();
          var color2 = data.getVisual("color");
          var borderColor = data.getVisual("borderColor");
          if (typeof color2 === "function") {
            color2 = color2(seriesModel.getDataParams(0));
          }
          if (typeof borderColor === "function") {
            borderColor = borderColor(seriesModel.getDataParams(0));
          }
          var legendSymbolType = data.getVisual("legendSymbol") || "roundRect";
          var symbolType = data.getVisual("symbol");
          var itemGroup = this._createItem(name2, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color2, borderColor, selectMode);
          itemGroup.on("click", curry2(dispatchSelectAction, name2, null, api, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
          legendDrawnMap.set(name2, true);
        } else {
          ecModel.eachRawSeries(function(seriesModel2) {
            if (legendDrawnMap.get(name2)) {
              return;
            }
            if (seriesModel2.legendVisualProvider) {
              var provider = seriesModel2.legendVisualProvider;
              if (!provider.containName(name2)) {
                return;
              }
              var idx = provider.indexOfName(name2);
              var color3 = provider.getItemVisual(idx, "color");
              var borderColor2 = provider.getItemVisual(idx, "borderColor");
              var legendSymbolType2 = "roundRect";
              var itemGroup2 = this._createItem(name2, dataIndex, itemModel, legendModel, legendSymbolType2, null, itemAlign, color3, borderColor2, selectMode);
              itemGroup2.on("click", curry2(dispatchSelectAction, null, name2, api, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, null, name2, api, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, null, name2, api, excludeSeriesId));
              legendDrawnMap.set(name2, true);
            }
          }, this);
        }
      }, this);
      if (selector) {
        this._createSelector(selector, legendModel, api, orient, selectorPosition);
      }
    },
    _createSelector: function(selector, legendModel, api, orient, selectorPosition) {
      var selectorGroup = this.getSelectorGroup();
      each2(selector, function(selectorItem) {
        createSelectorButton(selectorItem);
      });
      function createSelectorButton(selectorItem) {
        var type = selectorItem.type;
        var labelText = new graphic2.Text({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            api.dispatchAction({
              type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        selectorGroup.add(labelText);
        var labelModel = legendModel.getModel("selectorLabel");
        var emphasisLabelModel = legendModel.getModel("emphasis.selectorLabel");
        graphic2.setLabelStyle(labelText.style, labelText.hoverStyle = {}, labelModel, emphasisLabelModel, {
          defaultText: selectorItem.title,
          isRectText: false
        });
        graphic2.setHoverStyle(labelText);
      }
    },
    _createItem: function(name2, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color2, borderColor, selectMode) {
      var itemWidth = legendModel.get("itemWidth");
      var itemHeight = legendModel.get("itemHeight");
      var inactiveColor = legendModel.get("inactiveColor");
      var inactiveBorderColor = legendModel.get("inactiveBorderColor");
      var symbolKeepAspect = legendModel.get("symbolKeepAspect");
      var legendModelItemStyle = legendModel.getModel("itemStyle");
      var isSelected = legendModel.isSelected(name2);
      var itemGroup = new Group2();
      var textStyleModel = itemModel.getModel("textStyle");
      var itemIcon = itemModel.get("icon");
      var tooltipModel = itemModel.getModel("tooltip");
      var legendGlobalTooltipModel = tooltipModel.parentModel;
      legendSymbolType = itemIcon || legendSymbolType;
      var legendSymbol = createSymbol(
        legendSymbolType,
        0,
        0,
        itemWidth,
        itemHeight,
        isSelected ? color2 : inactiveColor,
        // symbolKeepAspect default true for legend
        symbolKeepAspect == null ? true : symbolKeepAspect
      );
      itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
      if (!itemIcon && symbolType && (symbolType !== legendSymbolType || symbolType === "none")) {
        var size2 = itemHeight * 0.8;
        if (symbolType === "none") {
          symbolType = "circle";
        }
        var legendSymbolCenter = createSymbol(
          symbolType,
          (itemWidth - size2) / 2,
          (itemHeight - size2) / 2,
          size2,
          size2,
          isSelected ? color2 : inactiveColor,
          // symbolKeepAspect default true for legend
          symbolKeepAspect == null ? true : symbolKeepAspect
        );
        itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected));
      }
      var textX = itemAlign === "left" ? itemWidth + 5 : -5;
      var textAlign = itemAlign;
      var formatter = legendModel.get("formatter");
      var content = name2;
      if (typeof formatter === "string" && formatter) {
        content = formatter.replace("{name}", name2 != null ? name2 : "");
      } else if (typeof formatter === "function") {
        content = formatter(name2);
      }
      itemGroup.add(new graphic2.Text({
        style: graphic2.setTextStyle({}, textStyleModel, {
          text: content,
          x: textX,
          y: itemHeight / 2,
          textFill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
          textAlign,
          textVerticalAlign: "middle"
        })
      }));
      var hitRect = new graphic2.Rect({
        shape: itemGroup.getBoundingRect(),
        invisible: true,
        tooltip: tooltipModel.get("show") ? zrUtil2.extend({
          content: name2,
          // Defaul formatter
          formatter: legendGlobalTooltipModel.get("formatter", true) || function() {
            return name2;
          },
          formatterParams: {
            componentType: "legend",
            legendIndex: legendModel.componentIndex,
            name: name2,
            $vars: ["name"]
          }
        }, tooltipModel.option) : null
      });
      itemGroup.add(hitRect);
      itemGroup.eachChild(function(child) {
        child.silent = true;
      });
      hitRect.silent = !selectMode;
      this.getContentGroup().add(itemGroup);
      graphic2.setHoverStyle(itemGroup);
      itemGroup.__legendDataIndex = dataIndex;
      return itemGroup;
    },
    /**
     * @protected
     */
    layoutInner: function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
      var contentGroup = this.getContentGroup();
      var selectorGroup = this.getSelectorGroup();
      layoutUtil.box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
      var contentRect = contentGroup.getBoundingRect();
      var contentPos = [-contentRect.x, -contentRect.y];
      if (selector) {
        layoutUtil.box(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          selectorGroup,
          legendModel.get("selectorItemGap", true)
        );
        var selectorRect = selectorGroup.getBoundingRect();
        var selectorPos = [-selectorRect.x, -selectorRect.y];
        var selectorButtonGap = legendModel.get("selectorButtonGap", true);
        var orientIdx = legendModel.getOrient().index;
        var wh = orientIdx === 0 ? "width" : "height";
        var hw = orientIdx === 0 ? "height" : "width";
        var yx = orientIdx === 0 ? "y" : "x";
        if (selectorPosition === "end") {
          selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
        } else {
          contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
        }
        selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
        selectorGroup.attr("position", selectorPos);
        contentGroup.attr("position", contentPos);
        var mainRect = {
          x: 0,
          y: 0
        };
        mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
        mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
        mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
        return mainRect;
      } else {
        contentGroup.attr("position", contentPos);
        return this.group.getBoundingRect();
      }
    },
    /**
     * @protected
     */
    remove: function() {
      this.getContentGroup().removeAll();
      this._isFirstRender = true;
    }
  });
  function setSymbolStyle(symbol2, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, isSelected) {
    var itemStyle2;
    if (symbolType !== "line" && symbolType.indexOf("empty") < 0) {
      itemStyle2 = legendModelItemStyle.getItemStyle();
      symbol2.style.stroke = borderColor;
      if (!isSelected) {
        itemStyle2.stroke = inactiveBorderColor;
      }
    } else {
      itemStyle2 = legendModelItemStyle.getItemStyle(["borderWidth", "borderColor"]);
    }
    return symbol2.setStyle(itemStyle2);
  }
  function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
    dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
    api.dispatchAction({
      type: "legendToggleSelect",
      name: seriesName != null ? seriesName : dataName
    });
    dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
  }
  function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
    var el = api.getZr().storage.getDisplayList()[0];
    if (!(el && el.useHoverLayer)) {
      api.dispatchAction({
        type: "highlight",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
    var el = api.getZr().storage.getDisplayList()[0];
    if (!(el && el.useHoverLayer)) {
      api.dispatchAction({
        type: "downplay",
        seriesName,
        name: dataName,
        excludeSeriesId
      });
    }
  }
  LegendView = _default2;
  return LegendView;
}
var legendFilter;
var hasRequiredLegendFilter;
function requireLegendFilter() {
  if (hasRequiredLegendFilter)
    return legendFilter;
  hasRequiredLegendFilter = 1;
  function _default2(ecModel) {
    var legendModels = ecModel.findComponents({
      mainType: "legend"
    });
    if (legendModels && legendModels.length) {
      ecModel.filterSeries(function(series) {
        for (var i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(series.name)) {
            return false;
          }
        }
        return true;
      });
    }
  }
  legendFilter = _default2;
  return legendFilter;
}
var hasRequiredLegend;
function requireLegend() {
  if (hasRequiredLegend)
    return legend;
  hasRequiredLegend = 1;
  var echarts$12 = echarts;
  requireLegendModel();
  requireLegendAction();
  requireLegendView();
  var legendFilter2 = requireLegendFilter();
  var Component2 = Component$2;
  echarts$12.registerProcessor(echarts$12.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter2);
  Component2.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  return legend;
}
var ScrollableLegendModel_1;
var hasRequiredScrollableLegendModel;
function requireScrollableLegendModel() {
  if (hasRequiredScrollableLegendModel)
    return ScrollableLegendModel_1;
  hasRequiredScrollableLegendModel = 1;
  var LegendModel = requireLegendModel();
  var _layout2 = layout$1;
  var mergeLayoutParam2 = _layout2.mergeLayoutParam;
  var getLayoutParams2 = _layout2.getLayoutParams;
  var ScrollableLegendModel = LegendModel.extend({
    type: "legend.scroll",
    /**
     * @param {number} scrollDataIndex
     */
    setScrollDataIndex: function(scrollDataIndex) {
      this.option.scrollDataIndex = scrollDataIndex;
    },
    defaultOption: {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      // 'start' or 'end'
      pageFormatter: "{current}/{total}",
      // If null/undefined, do not show page.
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      // Can be [10, 3], which represents [width, height]
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    },
    /**
     * @override
     */
    init: function(option, parentModel, ecModel, extraOpt) {
      var inputPositionParams = getLayoutParams2(option);
      ScrollableLegendModel.superCall(this, "init", option, parentModel, ecModel, extraOpt);
      mergeAndNormalizeLayoutParams(this, option, inputPositionParams);
    },
    /**
     * @override
     */
    mergeOption: function(option, extraOpt) {
      ScrollableLegendModel.superCall(this, "mergeOption", option, extraOpt);
      mergeAndNormalizeLayoutParams(this, this.option, option);
    }
  });
  function mergeAndNormalizeLayoutParams(legendModel, target, raw) {
    var orient = legendModel.getOrient();
    var ignoreSize = [1, 1];
    ignoreSize[orient.index] = 0;
    mergeLayoutParam2(target, raw, {
      type: "box",
      ignoreSize
    });
  }
  var _default2 = ScrollableLegendModel;
  ScrollableLegendModel_1 = _default2;
  return ScrollableLegendModel_1;
}
var ScrollableLegendView_1;
var hasRequiredScrollableLegendView;
function requireScrollableLegendView() {
  if (hasRequiredScrollableLegendView)
    return ScrollableLegendView_1;
  hasRequiredScrollableLegendView = 1;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var layoutUtil = layout$1;
  var LegendView2 = requireLegendView();
  var Group2 = graphic2.Group;
  var WH = ["width", "height"];
  var XY = ["x", "y"];
  var ScrollableLegendView = LegendView2.extend({
    type: "legend.scroll",
    newlineDisabled: true,
    init: function() {
      ScrollableLegendView.superCall(this, "init");
      this._currentIndex = 0;
      this.group.add(this._containerGroup = new Group2());
      this._containerGroup.add(this.getContentGroup());
      this.group.add(this._controllerGroup = new Group2());
      this._showController;
    },
    /**
     * @override
     */
    resetInner: function() {
      ScrollableLegendView.superCall(this, "resetInner");
      this._controllerGroup.removeAll();
      this._containerGroup.removeClipPath();
      this._containerGroup.__rectSize = null;
    },
    /**
     * @override
     */
    renderInner: function(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
      var me = this;
      ScrollableLegendView.superCall(this, "renderInner", itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
      var controllerGroup = this._controllerGroup;
      var pageIconSize = legendModel.get("pageIconSize", true);
      if (!zrUtil2.isArray(pageIconSize)) {
        pageIconSize = [pageIconSize, pageIconSize];
      }
      createPageButton("pagePrev", 0);
      var pageTextStyleModel = legendModel.getModel("pageTextStyle");
      controllerGroup.add(new graphic2.Text({
        name: "pageText",
        style: {
          textFill: pageTextStyleModel.getTextColor(),
          font: pageTextStyleModel.getFont(),
          textVerticalAlign: "middle",
          textAlign: "center"
        },
        silent: true
      }));
      createPageButton("pageNext", 1);
      function createPageButton(name2, iconIdx) {
        var pageDataIndexName = name2 + "DataIndex";
        var icon = graphic2.createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: zrUtil2.bind(me._pageGo, me, pageDataIndexName, legendModel, api)
        }, {
          x: -pageIconSize[0] / 2,
          y: -pageIconSize[1] / 2,
          width: pageIconSize[0],
          height: pageIconSize[1]
        });
        icon.name = name2;
        controllerGroup.add(icon);
      }
    },
    /**
     * @override
     */
    layoutInner: function(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
      var selectorGroup = this.getSelectorGroup();
      var orientIdx = legendModel.getOrient().index;
      var wh = WH[orientIdx];
      var xy = XY[orientIdx];
      var hw = WH[1 - orientIdx];
      var yx = XY[1 - orientIdx];
      selector && layoutUtil.box(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        selectorGroup,
        legendModel.get("selectorItemGap", true)
      );
      var selectorButtonGap = legendModel.get("selectorButtonGap", true);
      var selectorRect = selectorGroup.getBoundingRect();
      var selectorPos = [-selectorRect.x, -selectorRect.y];
      var processMaxSize = zrUtil2.clone(maxSize);
      selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
      var mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx);
      if (selector) {
        if (selectorPosition === "end") {
          selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
        } else {
          var offset = selectorRect[wh] + selectorButtonGap;
          selectorPos[orientIdx] -= offset;
          mainRect[xy] -= offset;
        }
        mainRect[wh] += selectorRect[wh] + selectorButtonGap;
        selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
        mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
        mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
        selectorGroup.attr("position", selectorPos);
      }
      return mainRect;
    },
    _layoutContentAndController: function(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx) {
      var contentGroup = this.getContentGroup();
      var containerGroup = this._containerGroup;
      var controllerGroup = this._controllerGroup;
      layoutUtil.box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
      layoutUtil.box(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        controllerGroup,
        legendModel.get("pageButtonItemGap", true)
      );
      var contentRect = contentGroup.getBoundingRect();
      var controllerRect = controllerGroup.getBoundingRect();
      var showController = this._showController = contentRect[wh] > maxSize[wh];
      var contentPos = [-contentRect.x, -contentRect.y];
      if (!isFirstRender) {
        contentPos[orientIdx] = contentGroup.position[orientIdx];
      }
      var containerPos = [0, 0];
      var controllerPos = [-controllerRect.x, -controllerRect.y];
      var pageButtonGap = zrUtil2.retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
      if (showController) {
        var pageButtonPosition = legendModel.get("pageButtonPosition", true);
        if (pageButtonPosition === "end") {
          controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
        } else {
          containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
        }
      }
      controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
      contentGroup.attr("position", contentPos);
      containerGroup.attr("position", containerPos);
      controllerGroup.attr("position", controllerPos);
      var mainRect = {
        x: 0,
        y: 0
      };
      mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
      mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
      containerGroup.__rectSize = maxSize[wh];
      if (showController) {
        var clipShape = {
          x: 0,
          y: 0
        };
        clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
        clipShape[hw] = mainRect[hw];
        containerGroup.setClipPath(new graphic2.Rect({
          shape: clipShape
        }));
        containerGroup.__rectSize = clipShape[wh];
      } else {
        controllerGroup.eachChild(function(child) {
          child.attr({
            invisible: true,
            silent: true
          });
        });
      }
      var pageInfo = this._getPageInfo(legendModel);
      pageInfo.pageIndex != null && graphic2.updateProps(
        contentGroup,
        {
          position: pageInfo.contentPosition
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        showController ? legendModel : false
      );
      this._updatePageInfoView(legendModel, pageInfo);
      return mainRect;
    },
    _pageGo: function(to, legendModel, api) {
      var scrollDataIndex = this._getPageInfo(legendModel)[to];
      scrollDataIndex != null && api.dispatchAction({
        type: "legendScroll",
        scrollDataIndex,
        legendId: legendModel.id
      });
    },
    _updatePageInfoView: function(legendModel, pageInfo) {
      var controllerGroup = this._controllerGroup;
      zrUtil2.each(["pagePrev", "pageNext"], function(name2) {
        var canJump = pageInfo[name2 + "DataIndex"] != null;
        var icon = controllerGroup.childOfName(name2);
        if (icon) {
          icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
          icon.cursor = canJump ? "pointer" : "default";
        }
      });
      var pageText = controllerGroup.childOfName("pageText");
      var pageFormatter = legendModel.get("pageFormatter");
      var pageIndex = pageInfo.pageIndex;
      var current = pageIndex != null ? pageIndex + 1 : 0;
      var total = pageInfo.pageCount;
      pageText && pageFormatter && pageText.setStyle("text", zrUtil2.isString(pageFormatter) ? pageFormatter.replace("{current}", current).replace("{total}", total) : pageFormatter({
        current,
        total
      }));
    },
    /**
     * @param {module:echarts/model/Model} legendModel
     * @return {Object} {
     *  contentPosition: Array.<number>, null when data item not found.
     *  pageIndex: number, null when data item not found.
     *  pageCount: number, always be a number, can be 0.
     *  pagePrevDataIndex: number, null when no previous page.
     *  pageNextDataIndex: number, null when no next page.
     * }
     */
    _getPageInfo: function(legendModel) {
      var scrollDataIndex = legendModel.get("scrollDataIndex", true);
      var contentGroup = this.getContentGroup();
      var containerRectSize = this._containerGroup.__rectSize;
      var orientIdx = legendModel.getOrient().index;
      var wh = WH[orientIdx];
      var xy = XY[orientIdx];
      var targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
      var children = contentGroup.children();
      var targetItem = children[targetItemIndex];
      var itemCount = children.length;
      var pCount = !itemCount ? 0 : 1;
      var result = {
        contentPosition: contentGroup.position.slice(),
        pageCount: pCount,
        pageIndex: pCount - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!targetItem) {
        return result;
      }
      var targetItemInfo = getItemInfo(targetItem);
      result.contentPosition[orientIdx] = -targetItemInfo.s;
      for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
        currItemInfo = getItemInfo(children[i]);
        if (
          // Half of the last item is out of the window.
          !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page
          // can be started at the current item or the last item.
          currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)
        ) {
          if (winEndItemInfo.i > winStartItemInfo.i) {
            winStartItemInfo = winEndItemInfo;
          } else {
            winStartItemInfo = currItemInfo;
          }
          if (winStartItemInfo) {
            if (result.pageNextDataIndex == null) {
              result.pageNextDataIndex = winStartItemInfo.i;
            }
            ++result.pageCount;
          }
        }
        winEndItemInfo = currItemInfo;
      }
      for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
        currItemInfo = getItemInfo(children[i]);
        if (
          // If the the end item does not intersect with the window started
          // from the current item, a page can be settled.
          (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.
          winStartItemInfo.i < winEndItemInfo.i
        ) {
          winEndItemInfo = winStartItemInfo;
          if (result.pagePrevDataIndex == null) {
            result.pagePrevDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
          ++result.pageIndex;
        }
        winStartItemInfo = currItemInfo;
      }
      return result;
      function getItemInfo(el) {
        if (el) {
          var itemRect = el.getBoundingRect();
          var start = itemRect[xy] + el.position[orientIdx];
          return {
            s: start,
            e: start + itemRect[wh],
            i: el.__legendDataIndex
          };
        }
      }
      function intersect(itemInfo, winStart) {
        return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
      }
    },
    _findTargetItemIndex: function(targetDataIndex) {
      if (!this._showController) {
        return 0;
      }
      var index2;
      var contentGroup = this.getContentGroup();
      var defaultIndex;
      contentGroup.eachChild(function(child, idx) {
        var legendDataIdx = child.__legendDataIndex;
        if (defaultIndex == null && legendDataIdx != null) {
          defaultIndex = idx;
        }
        if (legendDataIdx === targetDataIndex) {
          index2 = idx;
        }
      });
      return index2 != null ? index2 : defaultIndex;
    }
  });
  var _default2 = ScrollableLegendView;
  ScrollableLegendView_1 = _default2;
  return ScrollableLegendView_1;
}
var scrollableLegendAction = {};
var hasRequiredScrollableLegendAction;
function requireScrollableLegendAction() {
  if (hasRequiredScrollableLegendAction)
    return scrollableLegendAction;
  hasRequiredScrollableLegendAction = 1;
  var echarts$12 = echarts;
  echarts$12.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    var scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: payload
    }, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
  return scrollableLegendAction;
}
var hasRequiredLegendScroll;
function requireLegendScroll() {
  if (hasRequiredLegendScroll)
    return legendScroll;
  hasRequiredLegendScroll = 1;
  requireLegend();
  requireScrollableLegendModel();
  requireScrollableLegendView();
  requireScrollableLegendAction();
  return legendScroll;
}
var dataZoom = {};
var dataZoomSlider = {};
var SliderZoomModel_1;
var hasRequiredSliderZoomModel;
function requireSliderZoomModel() {
  if (hasRequiredSliderZoomModel)
    return SliderZoomModel_1;
  hasRequiredSliderZoomModel = 1;
  var DataZoomModel = requireDataZoomModel();
  var SliderZoomModel = DataZoomModel.extend({
    type: "dataZoom.slider",
    layoutMode: "box",
    /**
     * @protected
     */
    defaultOption: {
      show: true,
      // ph => placeholder. Using placehoder here because
      // deault value can only be drived in view stage.
      right: "ph",
      // Default align to grid rect.
      top: "ph",
      // Default align to grid rect.
      width: "ph",
      // Default align to grid rect.
      height: "ph",
      // Default align to grid rect.
      left: null,
      // Default align to grid rect.
      bottom: null,
      // Default align to grid rect.
      backgroundColor: "rgba(47,69,84,0)",
      // Background of slider zoom component.
      // dataBackgroundColor: '#ddd',         // Background coor of data shadow and border of box,
      // highest priority, remain for compatibility of
      // previous version, but not recommended any more.
      dataBackground: {
        lineStyle: {
          color: "#2f4554",
          width: 0.5,
          opacity: 0.3
        },
        areaStyle: {
          color: "rgba(47,69,84,0.3)",
          opacity: 0.3
        }
      },
      borderColor: "#ddd",
      // border color of the box. For compatibility,
      // if dataBackgroundColor is set, borderColor
      // is ignored.
      fillerColor: "rgba(167,183,204,0.4)",
      // Color of selected area.
      // handleColor: 'rgba(89,170,216,0.95)',     // Color of handle.
      // handleIcon: 'path://M4.9,17.8c0-1.4,4.5-10.5,5.5-12.4c0-0.1,0.6-1.1,0.9-1.1c0.4,0,0.9,1,0.9,1.1c1.1,2.2,5.4,11,5.4,12.4v17.8c0,1.5-0.6,2.1-1.3,2.1H6.1c-0.7,0-1.3-0.6-1.3-2.1V17.8z',
      /* eslint-disable */
      handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
      /* eslint-enable */
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#a7b7cc"
      },
      labelPrecision: null,
      labelFormatter: null,
      showDetail: true,
      showDataShadow: "auto",
      // Default auto decision.
      realtime: true,
      zoomLock: false,
      // Whether disable zoom.
      textStyle: {
        color: "#333"
      }
    }
  });
  var _default2 = SliderZoomModel;
  SliderZoomModel_1 = _default2;
  return SliderZoomModel_1;
}
var SliderZoomView_1;
var hasRequiredSliderZoomView;
function requireSliderZoomView() {
  if (hasRequiredSliderZoomView)
    return SliderZoomView_1;
  hasRequiredSliderZoomView = 1;
  var zrUtil2 = util$6;
  var eventTool2 = event;
  var graphic2 = graphic$4;
  var throttle2 = throttle$1;
  var DataZoomView2 = requireDataZoomView();
  var numberUtil = requireNumber();
  var layout2 = layout$1;
  var sliderMove2 = requireSliderMove();
  var Rect2 = graphic2.Rect;
  var linearMap = numberUtil.linearMap;
  var asc = numberUtil.asc;
  var bind2 = zrUtil2.bind;
  var each2 = zrUtil2.each;
  var DEFAULT_LOCATION_EDGE_GAP = 7;
  var DEFAULT_FRAME_BORDER_WIDTH = 1;
  var DEFAULT_FILLER_SIZE = 30;
  var HORIZONTAL = "horizontal";
  var VERTICAL = "vertical";
  var LABEL_GAP = 5;
  var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
  var SliderZoomView = DataZoomView2.extend({
    type: "dataZoom.slider",
    init: function(ecModel, api) {
      this._displayables = {};
      this._orient;
      this._range;
      this._handleEnds;
      this._size;
      this._handleWidth;
      this._handleHeight;
      this._location;
      this._dragging;
      this._dataShadowInfo;
      this.api = api;
    },
    /**
     * @override
     */
    render: function(dataZoomModel, ecModel, api, payload) {
      SliderZoomView.superApply(this, "render", arguments);
      throttle2.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate");
      this._orient = dataZoomModel.get("orient");
      if (this.dataZoomModel.get("show") === false) {
        this.group.removeAll();
        return;
      }
      if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
        this._buildView();
      }
      this._updateView();
    },
    /**
     * @override
     */
    remove: function() {
      SliderZoomView.superApply(this, "remove", arguments);
      throttle2.clear(this, "_dispatchZoomAction");
    },
    /**
     * @override
     */
    dispose: function() {
      SliderZoomView.superApply(this, "dispose", arguments);
      throttle2.clear(this, "_dispatchZoomAction");
    },
    _buildView: function() {
      var thisGroup = this.group;
      thisGroup.removeAll();
      this._resetLocation();
      this._resetInterval();
      var barGroup = this._displayables.barGroup = new graphic2.Group();
      this._renderBackground();
      this._renderHandle();
      this._renderDataShadow();
      thisGroup.add(barGroup);
      this._positionGroup();
    },
    /**
     * @private
     */
    _resetLocation: function() {
      var dataZoomModel = this.dataZoomModel;
      var api = this.api;
      var coordRect = this._findCoordRect();
      var ecSize = {
        width: api.getWidth(),
        height: api.getHeight()
      };
      var positionInfo = this._orient === HORIZONTAL ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: ecSize.width - coordRect.x - coordRect.width,
        top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
        width: coordRect.width,
        height: DEFAULT_FILLER_SIZE
      } : {
        // vertical
        right: DEFAULT_LOCATION_EDGE_GAP,
        top: coordRect.y,
        width: DEFAULT_FILLER_SIZE,
        height: coordRect.height
      };
      var layoutParams = layout2.getLayoutParams(dataZoomModel.option);
      zrUtil2.each(["right", "top", "width", "height"], function(name2) {
        if (layoutParams[name2] === "ph") {
          layoutParams[name2] = positionInfo[name2];
        }
      });
      var layoutRect = layout2.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
      this._location = {
        x: layoutRect.x,
        y: layoutRect.y
      };
      this._size = [layoutRect.width, layoutRect.height];
      this._orient === VERTICAL && this._size.reverse();
    },
    /**
     * @private
     */
    _positionGroup: function() {
      var thisGroup = this.group;
      var location = this._location;
      var orient = this._orient;
      var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
      var inverse = targetAxisModel && targetAxisModel.get("inverse");
      var barGroup = this._displayables.barGroup;
      var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
      barGroup.attr(orient === HORIZONTAL && !inverse ? {
        scale: otherAxisInverse ? [1, 1] : [1, -1]
      } : orient === HORIZONTAL && inverse ? {
        scale: otherAxisInverse ? [-1, 1] : [-1, -1]
      } : orient === VERTICAL && !inverse ? {
        scale: otherAxisInverse ? [1, -1] : [1, 1],
        rotation: Math.PI / 2
        // Dont use Math.PI, considering shadow direction.
      } : {
        scale: otherAxisInverse ? [-1, -1] : [-1, 1],
        rotation: Math.PI / 2
      });
      var rect = thisGroup.getBoundingRect([barGroup]);
      thisGroup.attr("position", [location.x - rect.x, location.y - rect.y]);
    },
    /**
     * @private
     */
    _getViewExtent: function() {
      return [0, this._size[0]];
    },
    _renderBackground: function() {
      var dataZoomModel = this.dataZoomModel;
      var size2 = this._size;
      var barGroup = this._displayables.barGroup;
      barGroup.add(new Rect2({
        silent: true,
        shape: {
          x: 0,
          y: 0,
          width: size2[0],
          height: size2[1]
        },
        style: {
          fill: dataZoomModel.get("backgroundColor")
        },
        z2: -40
      }));
      barGroup.add(new Rect2({
        shape: {
          x: 0,
          y: 0,
          width: size2[0],
          height: size2[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: zrUtil2.bind(this._onClickPanelClick, this)
      }));
    },
    _renderDataShadow: function() {
      var info = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (!info) {
        return;
      }
      var size2 = this._size;
      var seriesModel = info.series;
      var data = seriesModel.getRawData();
      var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
      if (otherDim == null) {
        return;
      }
      var otherDataExtent = data.getDataExtent(otherDim);
      var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
      otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
      var otherShadowExtent = [0, size2[1]];
      var thisShadowExtent = [0, size2[0]];
      var areaPoints = [[size2[0], 0], [0, 0]];
      var linePoints = [];
      var step = thisShadowExtent[1] / (data.count() - 1);
      var thisCoord = 0;
      var stride = Math.round(data.count() / size2[0]);
      var lastIsEmpty;
      data.each([otherDim], function(value, index2) {
        if (stride > 0 && index2 % stride) {
          thisCoord += step;
          return;
        }
        var isEmpty = value == null || isNaN(value) || value === "";
        var otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);
        if (isEmpty && !lastIsEmpty && index2) {
          areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
          linePoints.push([linePoints[linePoints.length - 1][0], 0]);
        } else if (!isEmpty && lastIsEmpty) {
          areaPoints.push([thisCoord, 0]);
          linePoints.push([thisCoord, 0]);
        }
        areaPoints.push([thisCoord, otherCoord]);
        linePoints.push([thisCoord, otherCoord]);
        thisCoord += step;
        lastIsEmpty = isEmpty;
      });
      var dataZoomModel = this.dataZoomModel;
      this._displayables.barGroup.add(new graphic2.Polygon({
        shape: {
          points: areaPoints
        },
        style: zrUtil2.defaults({
          fill: dataZoomModel.get("dataBackgroundColor")
        }, dataZoomModel.getModel("dataBackground.areaStyle").getAreaStyle()),
        silent: true,
        z2: -20
      }));
      this._displayables.barGroup.add(new graphic2.Polyline({
        shape: {
          points: linePoints
        },
        style: dataZoomModel.getModel("dataBackground.lineStyle").getLineStyle(),
        silent: true,
        z2: -19
      }));
    },
    _prepareDataShadowInfo: function() {
      var dataZoomModel = this.dataZoomModel;
      var showDataShadow = dataZoomModel.get("showDataShadow");
      if (showDataShadow === false) {
        return;
      }
      var result;
      var ecModel = this.ecModel;
      dataZoomModel.eachTargetAxis(function(dimNames, axisIndex) {
        var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
        zrUtil2.each(seriesModels, function(seriesModel) {
          if (result) {
            return;
          }
          if (showDataShadow !== true && zrUtil2.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
            return;
          }
          var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
          var otherDim = getOtherDim(dimNames.name);
          var otherAxisInverse;
          var coordSys = seriesModel.coordinateSystem;
          if (otherDim != null && coordSys.getOtherAxis) {
            otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
          }
          otherDim = seriesModel.getData().mapDimension(otherDim);
          result = {
            thisAxis,
            series: seriesModel,
            thisDim: dimNames.name,
            otherDim,
            otherAxisInverse
          };
        }, this);
      }, this);
      return result;
    },
    _renderHandle: function() {
      var displaybles = this._displayables;
      var handles = displaybles.handles = [];
      var handleLabels = displaybles.handleLabels = [];
      var barGroup = this._displayables.barGroup;
      var size2 = this._size;
      var dataZoomModel = this.dataZoomModel;
      barGroup.add(displaybles.filler = new Rect2({
        draggable: true,
        cursor: getCursor(this._orient),
        drift: bind2(this._onDragMove, this, "all"),
        ondragstart: bind2(this._showDataInfo, this, true),
        ondragend: bind2(this._onDragEnd, this),
        onmouseover: bind2(this._showDataInfo, this, true),
        onmouseout: bind2(this._showDataInfo, this, false),
        style: {
          fill: dataZoomModel.get("fillerColor"),
          textPosition: "inside"
        }
      }));
      barGroup.add(new Rect2({
        silent: true,
        subPixelOptimize: true,
        shape: {
          x: 0,
          y: 0,
          width: size2[0],
          height: size2[1]
        },
        style: {
          stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
          lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
          fill: "rgba(0,0,0,0)"
        }
      }));
      each2([0, 1], function(handleIndex) {
        var path2 = graphic2.createIcon(dataZoomModel.get("handleIcon"), {
          cursor: getCursor(this._orient),
          draggable: true,
          drift: bind2(this._onDragMove, this, handleIndex),
          ondragend: bind2(this._onDragEnd, this),
          onmouseover: bind2(this._showDataInfo, this, true),
          onmouseout: bind2(this._showDataInfo, this, false)
        }, {
          x: -1,
          y: 0,
          width: 2,
          height: 2
        });
        var bRect = path2.getBoundingRect();
        this._handleHeight = numberUtil.parsePercent(dataZoomModel.get("handleSize"), this._size[1]);
        this._handleWidth = bRect.width / bRect.height * this._handleHeight;
        path2.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
        var handleColor = dataZoomModel.get("handleColor");
        if (handleColor != null) {
          path2.style.fill = handleColor;
        }
        barGroup.add(handles[handleIndex] = path2);
        var textStyleModel = dataZoomModel.textStyleModel;
        this.group.add(handleLabels[handleIndex] = new graphic2.Text({
          silent: true,
          invisible: true,
          style: {
            x: 0,
            y: 0,
            text: "",
            textVerticalAlign: "middle",
            textAlign: "center",
            textFill: textStyleModel.getTextColor(),
            textFont: textStyleModel.getFont()
          },
          z2: 10
        }));
      }, this);
    },
    /**
     * @private
     */
    _resetInterval: function() {
      var range = this._range = this.dataZoomModel.getPercentRange();
      var viewExtent = this._getViewExtent();
      this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)];
    },
    /**
     * @private
     * @param {(number|string)} handleIndex 0 or 1 or 'all'
     * @param {number} delta
     * @return {boolean} changed
     */
    _updateInterval: function(handleIndex, delta) {
      var dataZoomModel = this.dataZoomModel;
      var handleEnds = this._handleEnds;
      var viewExtend = this._getViewExtent();
      var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      var percentExtent = [0, 100];
      sliderMove2(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
      var lastRange = this._range;
      var range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
      return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
    },
    /**
     * @private
     */
    _updateView: function(nonRealtime) {
      var displaybles = this._displayables;
      var handleEnds = this._handleEnds;
      var handleInterval = asc(handleEnds.slice());
      var size2 = this._size;
      each2([0, 1], function(handleIndex) {
        var handle = displaybles.handles[handleIndex];
        var handleHeight = this._handleHeight;
        handle.attr({
          scale: [handleHeight / 2, handleHeight / 2],
          position: [handleEnds[handleIndex], size2[1] / 2 - handleHeight / 2]
        });
      }, this);
      displaybles.filler.setShape({
        x: handleInterval[0],
        y: 0,
        width: handleInterval[1] - handleInterval[0],
        height: size2[1]
      });
      this._updateDataInfo(nonRealtime);
    },
    /**
     * @private
     */
    _updateDataInfo: function(nonRealtime) {
      var dataZoomModel = this.dataZoomModel;
      var displaybles = this._displayables;
      var handleLabels = displaybles.handleLabels;
      var orient = this._orient;
      var labelTexts = ["", ""];
      if (dataZoomModel.get("showDetail")) {
        var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
        if (axisProxy) {
          var axis2 = axisProxy.getAxisModel().axis;
          var range = this._range;
          var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
            start: range[0],
            end: range[1]
          }).valueWindow : axisProxy.getDataValueWindow();
          labelTexts = [this._formatLabel(dataInterval[0], axis2), this._formatLabel(dataInterval[1], axis2)];
        }
      }
      var orderedHandleEnds = asc(this._handleEnds.slice());
      setLabel.call(this, 0);
      setLabel.call(this, 1);
      function setLabel(handleIndex) {
        var barTransform = graphic2.getTransform(displaybles.handles[handleIndex].parent, this.group);
        var direction = graphic2.transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
        var offset = this._handleWidth / 2 + LABEL_GAP;
        var textPoint = graphic2.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
        handleLabels[handleIndex].setStyle({
          x: textPoint[0],
          y: textPoint[1],
          textVerticalAlign: orient === HORIZONTAL ? "middle" : direction,
          textAlign: orient === HORIZONTAL ? direction : "center",
          text: labelTexts[handleIndex]
        });
      }
    },
    /**
     * @private
     */
    _formatLabel: function(value, axis2) {
      var dataZoomModel = this.dataZoomModel;
      var labelFormatter = dataZoomModel.get("labelFormatter");
      var labelPrecision = dataZoomModel.get("labelPrecision");
      if (labelPrecision == null || labelPrecision === "auto") {
        labelPrecision = axis2.getPixelPrecision();
      }
      var valueStr = value == null || isNaN(value) ? "" : axis2.type === "category" || axis2.type === "time" ? axis2.scale.getLabel(Math.round(value)) : value.toFixed(Math.min(labelPrecision, 20));
      return zrUtil2.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : zrUtil2.isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
    },
    /**
     * @private
     * @param {boolean} showOrHide true: show, false: hide
     */
    _showDataInfo: function(showOrHide) {
      showOrHide = this._dragging || showOrHide;
      var handleLabels = this._displayables.handleLabels;
      handleLabels[0].attr("invisible", !showOrHide);
      handleLabels[1].attr("invisible", !showOrHide);
    },
    _onDragMove: function(handleIndex, dx, dy, event2) {
      this._dragging = true;
      eventTool2.stop(event2.event);
      var barTransform = this._displayables.barGroup.getLocalTransform();
      var vertex = graphic2.applyTransform([dx, dy], barTransform, true);
      var changed = this._updateInterval(handleIndex, vertex[0]);
      var realtime = this.dataZoomModel.get("realtime");
      this._updateView(!realtime);
      changed && realtime && this._dispatchZoomAction();
    },
    _onDragEnd: function() {
      this._dragging = false;
      this._showDataInfo(false);
      var realtime = this.dataZoomModel.get("realtime");
      !realtime && this._dispatchZoomAction();
    },
    _onClickPanelClick: function(e2) {
      var size2 = this._size;
      var localPoint = this._displayables.barGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
      if (localPoint[0] < 0 || localPoint[0] > size2[0] || localPoint[1] < 0 || localPoint[1] > size2[1]) {
        return;
      }
      var handleEnds = this._handleEnds;
      var center2 = (handleEnds[0] + handleEnds[1]) / 2;
      var changed = this._updateInterval("all", localPoint[0] - center2);
      this._updateView();
      changed && this._dispatchZoomAction();
    },
    /**
     * This action will be throttled.
     * @private
     */
    _dispatchZoomAction: function() {
      var range = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        start: range[0],
        end: range[1]
      });
    },
    /**
     * @private
     */
    _findCoordRect: function() {
      var rect;
      each2(this.getTargetCoordInfo(), function(coordInfoList) {
        if (!rect && coordInfoList.length) {
          var coordSys = coordInfoList[0].model.coordinateSystem;
          rect = coordSys.getRect && coordSys.getRect();
        }
      });
      if (!rect) {
        var width = this.api.getWidth();
        var height = this.api.getHeight();
        rect = {
          x: width * 0.2,
          y: height * 0.2,
          width: width * 0.6,
          height: height * 0.6
        };
      }
      return rect;
    }
  });
  function getOtherDim(thisDim) {
    var map2 = {
      x: "y",
      y: "x",
      radius: "angle",
      angle: "radius"
    };
    return map2[thisDim];
  }
  function getCursor(orient) {
    return orient === "vertical" ? "ns-resize" : "ew-resize";
  }
  var _default2 = SliderZoomView;
  SliderZoomView_1 = _default2;
  return SliderZoomView_1;
}
var hasRequiredDataZoomSlider;
function requireDataZoomSlider() {
  if (hasRequiredDataZoomSlider)
    return dataZoomSlider;
  hasRequiredDataZoomSlider = 1;
  requireTypeDefaulter$2();
  requireDataZoomModel();
  requireDataZoomView();
  requireSliderZoomModel();
  requireSliderZoomView();
  requireDataZoomProcessor();
  requireDataZoomAction();
  return dataZoomSlider;
}
var dataZoomInside = {};
var InsideZoomModel;
var hasRequiredInsideZoomModel;
function requireInsideZoomModel() {
  if (hasRequiredInsideZoomModel)
    return InsideZoomModel;
  hasRequiredInsideZoomModel = 1;
  var DataZoomModel = requireDataZoomModel();
  var _default2 = DataZoomModel.extend({
    type: "dataZoom.inside",
    /**
     * @protected
     */
    defaultOption: {
      disabled: false,
      // Whether disable this inside zoom.
      zoomLock: false,
      // Whether disable zoom but only pan.
      zoomOnMouseWheel: true,
      // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
      moveOnMouseMove: true,
      // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
      moveOnMouseWheel: false,
      // Can be: true / false / 'shift' / 'ctrl' / 'alt'.
      preventDefaultMouseMove: true
    }
  });
  InsideZoomModel = _default2;
  return InsideZoomModel;
}
var roams = {};
var hasRequiredRoams;
function requireRoams() {
  if (hasRequiredRoams)
    return roams;
  hasRequiredRoams = 1;
  var zrUtil2 = util$6;
  var RoamController = requireRoamController();
  var throttleUtil = throttle$1;
  var ATTR = "\0_ec_dataZoom_roams";
  function register(api, dataZoomInfo) {
    var store = giveStore(api);
    var theDataZoomId = dataZoomInfo.dataZoomId;
    var theCoordId = dataZoomInfo.coordId;
    zrUtil2.each(store, function(record2, coordId) {
      var dataZoomInfos = record2.dataZoomInfos;
      if (dataZoomInfos[theDataZoomId] && zrUtil2.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
        delete dataZoomInfos[theDataZoomId];
        record2.count--;
      }
    });
    cleanStore(store);
    var record = store[theCoordId];
    if (!record) {
      record = store[theCoordId] = {
        coordId: theCoordId,
        dataZoomInfos: {},
        count: 0
      };
      record.controller = createController(api, record);
      record.dispatchAction = zrUtil2.curry(dispatchAction, api);
    }
    !record.dataZoomInfos[theDataZoomId] && record.count++;
    record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
    var controllerParams = mergeControllerParams(record.dataZoomInfos);
    record.controller.enable(controllerParams.controlType, controllerParams.opt);
    record.controller.setPointerChecker(dataZoomInfo.containsPoint);
    throttleUtil.createOrUpdate(record, "dispatchAction", dataZoomInfo.dataZoomModel.get("throttle", true), "fixRate");
  }
  function unregister(api, dataZoomId) {
    var store = giveStore(api);
    zrUtil2.each(store, function(record) {
      record.controller.dispose();
      var dataZoomInfos = record.dataZoomInfos;
      if (dataZoomInfos[dataZoomId]) {
        delete dataZoomInfos[dataZoomId];
        record.count--;
      }
    });
    cleanStore(store);
  }
  function generateCoordId(coordModel) {
    return coordModel.type + "\0_" + coordModel.id;
  }
  function giveStore(api) {
    var zr = api.getZr();
    return zr[ATTR] || (zr[ATTR] = {});
  }
  function createController(api, newRecord) {
    var controller = new RoamController(api.getZr());
    zrUtil2.each(["pan", "zoom", "scrollMove"], function(eventName) {
      controller.on(eventName, function(event2) {
        var batch = [];
        zrUtil2.each(newRecord.dataZoomInfos, function(info) {
          if (!event2.isAvailableBehavior(info.dataZoomModel.option)) {
            return;
          }
          var method = (info.getRange || {})[eventName];
          var range = method && method(newRecord.controller, event2);
          !info.dataZoomModel.get("disabled", true) && range && batch.push({
            dataZoomId: info.dataZoomId,
            start: range[0],
            end: range[1]
          });
        });
        batch.length && newRecord.dispatchAction(batch);
      });
    });
    return controller;
  }
  function cleanStore(store) {
    zrUtil2.each(store, function(record, coordId) {
      if (!record.count) {
        record.controller.dispose();
        delete store[coordId];
      }
    });
  }
  function dispatchAction(api, batch) {
    api.dispatchAction({
      type: "dataZoom",
      batch
    });
  }
  function mergeControllerParams(dataZoomInfos) {
    var controlType;
    var prefix = "type_";
    var typePriority = {
      "type_true": 2,
      "type_move": 1,
      "type_false": 0,
      "type_undefined": -1
    };
    var preventDefaultMouseMove = true;
    zrUtil2.each(dataZoomInfos, function(dataZoomInfo) {
      var dataZoomModel = dataZoomInfo.dataZoomModel;
      var oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
      if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
        controlType = oneType;
      }
      preventDefaultMouseMove &= dataZoomModel.get("preventDefaultMouseMove", true);
    });
    return {
      controlType,
      opt: {
        // RoamController will enable all of these functionalities,
        // and the final behavior is determined by its event listener
        // provided by each inside zoom.
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!preventDefaultMouseMove
      }
    };
  }
  roams.register = register;
  roams.unregister = unregister;
  roams.generateCoordId = generateCoordId;
  return roams;
}
var InsideZoomView_1;
var hasRequiredInsideZoomView;
function requireInsideZoomView() {
  if (hasRequiredInsideZoomView)
    return InsideZoomView_1;
  hasRequiredInsideZoomView = 1;
  var zrUtil2 = util$6;
  var DataZoomView2 = requireDataZoomView();
  var sliderMove2 = requireSliderMove();
  var roams2 = requireRoams();
  var bind2 = zrUtil2.bind;
  var InsideZoomView = DataZoomView2.extend({
    type: "dataZoom.inside",
    /**
     * @override
     */
    init: function(ecModel, api) {
      this._range;
    },
    /**
     * @override
     */
    render: function(dataZoomModel, ecModel, api, payload) {
      InsideZoomView.superApply(this, "render", arguments);
      this._range = dataZoomModel.getPercentRange();
      zrUtil2.each(this.getTargetCoordInfo(), function(coordInfoList, coordSysName) {
        var allCoordIds = zrUtil2.map(coordInfoList, function(coordInfo) {
          return roams2.generateCoordId(coordInfo.model);
        });
        zrUtil2.each(coordInfoList, function(coordInfo) {
          var coordModel = coordInfo.model;
          var getRange = {};
          zrUtil2.each(["pan", "zoom", "scrollMove"], function(eventName) {
            getRange[eventName] = bind2(roamHandlers[eventName], this, coordInfo, coordSysName);
          }, this);
          roams2.register(api, {
            coordId: roams2.generateCoordId(coordModel),
            allCoordIds,
            containsPoint: function(e2, x, y) {
              return coordModel.coordinateSystem.containPoint([x, y]);
            },
            dataZoomId: dataZoomModel.id,
            dataZoomModel,
            getRange
          });
        }, this);
      }, this);
    },
    /**
     * @override
     */
    dispose: function() {
      roams2.unregister(this.api, this.dataZoomModel.id);
      InsideZoomView.superApply(this, "dispose", arguments);
      this._range = null;
    }
  });
  var roamHandlers = {
    /**
     * @this {module:echarts/component/dataZoom/InsideZoomView}
     */
    zoom: function(coordInfo, coordSysName, controller, e2) {
      var lastRange = this._range;
      var range = lastRange.slice();
      var axisModel = coordInfo.axisModels[0];
      if (!axisModel) {
        return;
      }
      var directionInfo = getDirectionInfo[coordSysName](null, [e2.originX, e2.originY], axisModel, controller, coordInfo);
      var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
      var scale = Math.max(1 / e2.scale, 0);
      range[0] = (range[0] - percentPoint) * scale + percentPoint;
      range[1] = (range[1] - percentPoint) * scale + percentPoint;
      var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      sliderMove2(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
      this._range = range;
      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range;
      }
    },
    /**
     * @this {module:echarts/component/dataZoom/InsideZoomView}
     */
    pan: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e2) {
      var directionInfo = getDirectionInfo[coordSysName]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordInfo);
      return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
    }),
    /**
     * @this {module:echarts/component/dataZoom/InsideZoomView}
     */
    scrollMove: makeMover(function(range, axisModel, coordInfo, coordSysName, controller, e2) {
      var directionInfo = getDirectionInfo[coordSysName]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordInfo);
      return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
    })
  };
  function makeMover(getPercentDelta) {
    return function(coordInfo, coordSysName, controller, e2) {
      var lastRange = this._range;
      var range = lastRange.slice();
      var axisModel = coordInfo.axisModels[0];
      if (!axisModel) {
        return;
      }
      var percentDelta = getPercentDelta(range, axisModel, coordInfo, coordSysName, controller, e2);
      sliderMove2(percentDelta, range, [0, 100], "all");
      this._range = range;
      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range;
      }
    };
  }
  var getDirectionInfo = {
    grid: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
      var axis2 = axisModel.axis;
      var ret = {};
      var rect = coordInfo.model.coordinateSystem.getRect();
      oldPoint = oldPoint || [0, 0];
      if (axis2.dim === "x") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = rect.width;
        ret.pixelStart = rect.x;
        ret.signal = axis2.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = rect.height;
        ret.pixelStart = rect.y;
        ret.signal = axis2.inverse ? -1 : 1;
      }
      return ret;
    },
    polar: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
      var axis2 = axisModel.axis;
      var ret = {};
      var polar2 = coordInfo.model.coordinateSystem;
      var radiusExtent = polar2.getRadiusAxis().getExtent();
      var angleExtent = polar2.getAngleAxis().getExtent();
      oldPoint = oldPoint ? polar2.pointToCoord(oldPoint) : [0, 0];
      newPoint = polar2.pointToCoord(newPoint);
      if (axisModel.mainType === "radiusAxis") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = radiusExtent[1] - radiusExtent[0];
        ret.pixelStart = radiusExtent[0];
        ret.signal = axis2.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = angleExtent[1] - angleExtent[0];
        ret.pixelStart = angleExtent[0];
        ret.signal = axis2.inverse ? -1 : 1;
      }
      return ret;
    },
    singleAxis: function(oldPoint, newPoint, axisModel, controller, coordInfo) {
      var axis2 = axisModel.axis;
      var rect = coordInfo.model.coordinateSystem.getRect();
      var ret = {};
      oldPoint = oldPoint || [0, 0];
      if (axis2.orient === "horizontal") {
        ret.pixel = newPoint[0] - oldPoint[0];
        ret.pixelLength = rect.width;
        ret.pixelStart = rect.x;
        ret.signal = axis2.inverse ? 1 : -1;
      } else {
        ret.pixel = newPoint[1] - oldPoint[1];
        ret.pixelLength = rect.height;
        ret.pixelStart = rect.y;
        ret.signal = axis2.inverse ? -1 : 1;
      }
      return ret;
    }
  };
  var _default2 = InsideZoomView;
  InsideZoomView_1 = _default2;
  return InsideZoomView_1;
}
var hasRequiredDataZoomInside;
function requireDataZoomInside() {
  if (hasRequiredDataZoomInside)
    return dataZoomInside;
  hasRequiredDataZoomInside = 1;
  requireTypeDefaulter$2();
  requireDataZoomModel();
  requireDataZoomView();
  requireInsideZoomModel();
  requireInsideZoomView();
  requireDataZoomProcessor();
  requireDataZoomAction();
  return dataZoomInside;
}
var hasRequiredDataZoom;
function requireDataZoom() {
  if (hasRequiredDataZoom)
    return dataZoom;
  hasRequiredDataZoom = 1;
  requireDataZoomSlider();
  requireDataZoomInside();
  return dataZoom;
}
var visualMap = {};
var visualMapContinuous = {};
var preprocessor;
var hasRequiredPreprocessor;
function requirePreprocessor() {
  if (hasRequiredPreprocessor)
    return preprocessor;
  hasRequiredPreprocessor = 1;
  var zrUtil2 = util$6;
  var each2 = zrUtil2.each;
  function _default2(option) {
    var visualMap2 = option && option.visualMap;
    if (!zrUtil2.isArray(visualMap2)) {
      visualMap2 = visualMap2 ? [visualMap2] : [];
    }
    each2(visualMap2, function(opt) {
      if (!opt) {
        return;
      }
      if (has2(opt, "splitList") && !has2(opt, "pieces")) {
        opt.pieces = opt.splitList;
        delete opt.splitList;
      }
      var pieces = opt.pieces;
      if (pieces && zrUtil2.isArray(pieces)) {
        each2(pieces, function(piece) {
          if (zrUtil2.isObject(piece)) {
            if (has2(piece, "start") && !has2(piece, "min")) {
              piece.min = piece.start;
            }
            if (has2(piece, "end") && !has2(piece, "max")) {
              piece.max = piece.end;
            }
          }
        });
      }
    });
  }
  function has2(obj, name2) {
    return obj && obj.hasOwnProperty && obj.hasOwnProperty(name2);
  }
  preprocessor = _default2;
  return preprocessor;
}
var typeDefaulter = {};
var hasRequiredTypeDefaulter;
function requireTypeDefaulter() {
  if (hasRequiredTypeDefaulter)
    return typeDefaulter;
  hasRequiredTypeDefaulter = 1;
  var Component2 = Component$2;
  Component2.registerSubTypeDefaulter("visualMap", function(option) {
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
  });
  return typeDefaulter;
}
var visualEncoding = {};
var hasRequiredVisualEncoding;
function requireVisualEncoding() {
  if (hasRequiredVisualEncoding)
    return visualEncoding;
  hasRequiredVisualEncoding = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var visualSolution2 = requireVisualSolution();
  var VisualMapping = requireVisualMapping();
  var VISUAL_PRIORITY = echarts$12.PRIORITY.VISUAL.COMPONENT;
  echarts$12.registerVisual(VISUAL_PRIORITY, {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var resetDefines = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        var pipelineContext = seriesModel.pipelineContext;
        if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
          return;
        }
        resetDefines.push(visualSolution2.incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, zrUtil2.bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimension(seriesModel.getData())));
      });
      return resetDefines;
    }
  });
  echarts$12.registerVisual(VISUAL_PRIORITY, {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      var data = seriesModel.getData();
      var visualMetaList = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          var visualMeta = visualMapModel.getVisualMeta(zrUtil2.bind(getColorVisual, null, seriesModel, visualMapModel)) || {
            stops: [],
            outerColors: []
          };
          var concreteDim = visualMapModel.getDataDimension(data);
          var dimInfo = data.getDimensionInfo(concreteDim);
          if (dimInfo != null) {
            visualMeta.dimension = dimInfo.index;
            visualMetaList.push(visualMeta);
          }
        }
      });
      seriesModel.getData().setVisual("visualMeta", visualMetaList);
    }
  });
  function getColorVisual(seriesModel, visualMapModel, value, valueState) {
    var mappings = visualMapModel.targetVisuals[valueState];
    var visualTypes = VisualMapping.prepareVisualTypes(mappings);
    var resultVisual = {
      color: seriesModel.getData().getVisual("color")
      // default color.
    };
    for (var i = 0, len = visualTypes.length; i < len; i++) {
      var type = visualTypes[i];
      var mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
      mapping && mapping.applyVisual(value, getVisual, setVisual);
    }
    return resultVisual.color;
    function getVisual(key) {
      return resultVisual[key];
    }
    function setVisual(key, value2) {
      resultVisual[key] = value2;
    }
  }
  return visualEncoding;
}
var visualDefault_1;
var hasRequiredVisualDefault;
function requireVisualDefault() {
  if (hasRequiredVisualDefault)
    return visualDefault_1;
  hasRequiredVisualDefault = 1;
  var zrUtil2 = util$6;
  var visualDefault = {
    /**
     * @public
     */
    get: function(visualType, key, isCategory) {
      var value = zrUtil2.clone((defaultOption[visualType] || {})[key]);
      return isCategory ? zrUtil2.isArray(value) ? value[value.length - 1] : value : value;
    }
  };
  var defaultOption = {
    color: {
      active: ["#006edd", "#e0ffff"],
      inactive: ["rgba(0,0,0,0)"]
    },
    colorHue: {
      active: [0, 360],
      inactive: [0, 0]
    },
    colorSaturation: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    colorLightness: {
      active: [0.9, 0.5],
      inactive: [0, 0]
    },
    colorAlpha: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    opacity: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    symbol: {
      active: ["circle", "roundRect", "diamond"],
      inactive: ["none"]
    },
    symbolSize: {
      active: [10, 50],
      inactive: [0, 0]
    }
  };
  var _default2 = visualDefault;
  visualDefault_1 = _default2;
  return visualDefault_1;
}
var VisualMapModel_1;
var hasRequiredVisualMapModel;
function requireVisualMapModel() {
  if (hasRequiredVisualMapModel)
    return VisualMapModel_1;
  hasRequiredVisualMapModel = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var env2 = env_1;
  var visualDefault = requireVisualDefault();
  var VisualMapping = requireVisualMapping();
  var visualSolution2 = requireVisualSolution();
  var modelUtil2 = model;
  var numberUtil = requireNumber();
  var mapVisual2 = VisualMapping.mapVisual;
  var eachVisual = VisualMapping.eachVisual;
  var isArray2 = zrUtil2.isArray;
  var each2 = zrUtil2.each;
  var asc = numberUtil.asc;
  var linearMap = numberUtil.linearMap;
  var noop2 = zrUtil2.noop;
  var VisualMapModel = echarts$12.extendComponentModel({
    type: "visualMap",
    dependencies: ["series"],
    /**
     * @readOnly
     * @type {Array.<string>}
     */
    stateList: ["inRange", "outOfRange"],
    /**
     * @readOnly
     * @type {Array.<string>}
     */
    replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
    /**
     * [lowerBound, upperBound]
     *
     * @readOnly
     * @type {Array.<number>}
     */
    dataBound: [-Infinity, Infinity],
    /**
     * @readOnly
     * @type {string|Object}
     */
    layoutMode: {
      type: "box",
      ignoreSize: true
    },
    /**
     * @protected
     */
    defaultOption: {
      show: true,
      zlevel: 0,
      z: 4,
      seriesIndex: "all",
      // 'all' or null/undefined: all series.
      // A number or an array of number: the specified series.
      // set min: 0, max: 200, only for campatible with ec2.
      // In fact min max should not have default value.
      min: 0,
      // min value, must specified if pieces is not specified.
      max: 200,
      // max value, must specified if pieces is not specified.
      dimension: null,
      inRange: null,
      // 'color', 'colorHue', 'colorSaturation', 'colorLightness', 'colorAlpha',
      // 'symbol', 'symbolSize'
      outOfRange: null,
      // 'color', 'colorHue', 'colorSaturation',
      // 'colorLightness', 'colorAlpha',
      // 'symbol', 'symbolSize'
      left: 0,
      // 'center' ¦ 'left' ¦ 'right' ¦ {number} (px)
      right: null,
      // The same as left.
      top: null,
      // 'top' ¦ 'bottom' ¦ 'center' ¦ {number} (px)
      bottom: 0,
      // The same as top.
      itemWidth: null,
      itemHeight: null,
      inverse: false,
      orient: "vertical",
      // 'horizontal' ¦ 'vertical'
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      // 值域边框颜色
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      // 值域边框线宽，单位px，默认为0（无边框）
      padding: 5,
      // 值域内边距，单位px，默认各方向内边距为5，
      // 接受数组分别设定上右下左边距，同css
      textGap: 10,
      //
      precision: 0,
      // 小数精度，默认为0，无小数点
      color: null,
      //颜色（deprecated，兼容ec2，顺序同pieces，不同于inRange/outOfRange）
      formatter: null,
      text: null,
      // 文本，如['高', '低']，兼容ec2，text[0]对应高值，text[1]对应低值
      textStyle: {
        color: "#333"
        // 值域文字颜色
      }
    },
    /**
     * @protected
     */
    init: function(option, parentModel, ecModel) {
      this._dataExtent;
      this.targetVisuals = {};
      this.controllerVisuals = {};
      this.textStyleModel;
      this.itemSize;
      this.mergeDefaultAndTheme(option, ecModel);
    },
    /**
     * @protected
     */
    optionUpdated: function(newOption, isInit) {
      var thisOption = this.option;
      if (!env2.canvasSupported) {
        thisOption.realtime = false;
      }
      !isInit && visualSolution2.replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
      this.textStyleModel = this.getModel("textStyle");
      this.resetItemSize();
      this.completeVisualOption();
    },
    /**
     * @protected
     */
    resetVisual: function(supplementVisualOption) {
      var stateList = this.stateList;
      supplementVisualOption = zrUtil2.bind(supplementVisualOption, this);
      this.controllerVisuals = visualSolution2.createVisualMappings(this.option.controller, stateList, supplementVisualOption);
      this.targetVisuals = visualSolution2.createVisualMappings(this.option.target, stateList, supplementVisualOption);
    },
    /**
     * @protected
     * @return {Array.<number>} An array of series indices.
     */
    getTargetSeriesIndices: function() {
      var optionSeriesIndex = this.option.seriesIndex;
      var seriesIndices = [];
      if (optionSeriesIndex == null || optionSeriesIndex === "all") {
        this.ecModel.eachSeries(function(seriesModel, index2) {
          seriesIndices.push(index2);
        });
      } else {
        seriesIndices = modelUtil2.normalizeToArray(optionSeriesIndex);
      }
      return seriesIndices;
    },
    /**
     * @public
     */
    eachTargetSeries: function(callback, context) {
      zrUtil2.each(this.getTargetSeriesIndices(), function(seriesIndex) {
        callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));
      }, this);
    },
    /**
     * @pubilc
     */
    isTargetSeries: function(seriesModel) {
      var is = false;
      this.eachTargetSeries(function(model2) {
        model2 === seriesModel && (is = true);
      });
      return is;
    },
    /**
     * @example
     * this.formatValueText(someVal); // format single numeric value to text.
     * this.formatValueText(someVal, true); // format single category value to text.
     * this.formatValueText([min, max]); // format numeric min-max to text.
     * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
     * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
     *
     * @param {number|Array.<number>} value Real value, or this.dataBound[0 or 1].
     * @param {boolean} [isCategory=false] Only available when value is number.
     * @param {Array.<string>} edgeSymbols Open-close symbol when value is interval.
     * @return {string}
     * @protected
     */
    formatValueText: function(value, isCategory, edgeSymbols) {
      var option = this.option;
      var precision = option.precision;
      var dataBound = this.dataBound;
      var formatter = option.formatter;
      var isMinMax;
      var textValue;
      edgeSymbols = edgeSymbols || ["<", ">"];
      if (zrUtil2.isArray(value)) {
        value = value.slice();
        isMinMax = true;
      }
      textValue = isCategory ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
      if (zrUtil2.isString(formatter)) {
        return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
      } else if (zrUtil2.isFunction(formatter)) {
        return isMinMax ? formatter(value[0], value[1]) : formatter(value);
      }
      if (isMinMax) {
        if (value[0] === dataBound[0]) {
          return edgeSymbols[0] + " " + textValue[1];
        } else if (value[1] === dataBound[1]) {
          return edgeSymbols[1] + " " + textValue[0];
        } else {
          return textValue[0] + " - " + textValue[1];
        }
      } else {
        return textValue;
      }
      function toFixed(val) {
        return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
      }
    },
    /**
     * @protected
     */
    resetExtent: function() {
      var thisOption = this.option;
      var extent = asc([thisOption.min, thisOption.max]);
      this._dataExtent = extent;
    },
    /**
     * @public
     * @param {module:echarts/data/List} list
     * @return {string} Concrete dimention. If return null/undefined,
     *                  no dimension used.
     */
    getDataDimension: function(list) {
      var optDim = this.option.dimension;
      var listDimensions = list.dimensions;
      if (optDim == null && !listDimensions.length) {
        return;
      }
      if (optDim != null) {
        return list.getDimension(optDim);
      }
      var dimNames = list.dimensions;
      for (var i = dimNames.length - 1; i >= 0; i--) {
        var dimName = dimNames[i];
        var dimInfo = list.getDimensionInfo(dimName);
        if (!dimInfo.isCalculationCoord) {
          return dimName;
        }
      }
    },
    /**
     * @public
     * @override
     */
    getExtent: function() {
      return this._dataExtent.slice();
    },
    /**
     * @protected
     */
    completeVisualOption: function() {
      var ecModel = this.ecModel;
      var thisOption = this.option;
      var base2 = {
        inRange: thisOption.inRange,
        outOfRange: thisOption.outOfRange
      };
      var target = thisOption.target || (thisOption.target = {});
      var controller = thisOption.controller || (thisOption.controller = {});
      zrUtil2.merge(target, base2);
      zrUtil2.merge(controller, base2);
      var isCategory = this.isCategory();
      completeSingle.call(this, target);
      completeSingle.call(this, controller);
      completeInactive.call(this, target, "inRange", "outOfRange");
      completeController.call(this, controller);
      function completeSingle(base3) {
        if (isArray2(thisOption.color) && !base3.inRange) {
          base3.inRange = {
            color: thisOption.color.slice().reverse()
          };
        }
        base3.inRange = base3.inRange || {
          color: ecModel.get("gradientColor")
        };
        each2(this.stateList, function(state) {
          var visualType = base3[state];
          if (zrUtil2.isString(visualType)) {
            var defa = visualDefault.get(visualType, "active", isCategory);
            if (defa) {
              base3[state] = {};
              base3[state][visualType] = defa;
            } else {
              delete base3[state];
            }
          }
        }, this);
      }
      function completeInactive(base3, stateExist, stateAbsent) {
        var optExist = base3[stateExist];
        var optAbsent = base3[stateAbsent];
        if (optExist && !optAbsent) {
          optAbsent = base3[stateAbsent] = {};
          each2(optExist, function(visualData, visualType) {
            if (!VisualMapping.isValidType(visualType)) {
              return;
            }
            var defa = visualDefault.get(visualType, "inactive", isCategory);
            if (defa != null) {
              optAbsent[visualType] = defa;
              if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
                optAbsent.opacity = [0, 0];
              }
            }
          });
        }
      }
      function completeController(controller2) {
        var symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
        var symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
        var inactiveColor = this.get("inactiveColor");
        each2(this.stateList, function(state) {
          var itemSize = this.itemSize;
          var visuals = controller2[state];
          if (!visuals) {
            visuals = controller2[state] = {
              color: isCategory ? inactiveColor : [inactiveColor]
            };
          }
          if (visuals.symbol == null) {
            visuals.symbol = symbolExists && zrUtil2.clone(symbolExists) || (isCategory ? "roundRect" : ["roundRect"]);
          }
          if (visuals.symbolSize == null) {
            visuals.symbolSize = symbolSizeExists && zrUtil2.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);
          }
          visuals.symbol = mapVisual2(visuals.symbol, function(symbol2) {
            return symbol2 === "none" || symbol2 === "square" ? "roundRect" : symbol2;
          });
          var symbolSize = visuals.symbolSize;
          if (symbolSize != null) {
            var max3 = -Infinity;
            eachVisual(symbolSize, function(value) {
              value > max3 && (max3 = value);
            });
            visuals.symbolSize = mapVisual2(symbolSize, function(value) {
              return linearMap(value, [0, max3], [0, itemSize[0]], true);
            });
          }
        }, this);
      }
    },
    /**
     * @protected
     */
    resetItemSize: function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    },
    /**
     * @public
     */
    isCategory: function() {
      return !!this.option.categories;
    },
    /**
     * @public
     * @abstract
     */
    setSelected: noop2,
    /**
     * @public
     * @abstract
     * @param {*|module:echarts/data/List} valueOrData
     * @param {number} dataIndex
     * @return {string} state See this.stateList
     */
    getValueState: noop2,
    /**
     * FIXME
     * Do not publish to thirt-part-dev temporarily
     * util the interface is stable. (Should it return
     * a function but not visual meta?)
     *
     * @pubilc
     * @abstract
     * @param {Function} getColorVisual
     *        params: value, valueState
     *        return: color
     * @return {Object} visualMeta
     *        should includes {stops, outerColors}
     *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
     */
    getVisualMeta: noop2
  });
  var _default2 = VisualMapModel;
  VisualMapModel_1 = _default2;
  return VisualMapModel_1;
}
var ContinuousModel_1;
var hasRequiredContinuousModel;
function requireContinuousModel() {
  if (hasRequiredContinuousModel)
    return ContinuousModel_1;
  hasRequiredContinuousModel = 1;
  var zrUtil2 = util$6;
  var VisualMapModel = requireVisualMapModel();
  var numberUtil = requireNumber();
  var DEFAULT_BAR_BOUND = [20, 140];
  var ContinuousModel = VisualMapModel.extend({
    type: "visualMap.continuous",
    /**
     * @protected
     */
    defaultOption: {
      align: "auto",
      // 'auto', 'left', 'right', 'top', 'bottom'
      calculable: false,
      // This prop effect default component type determine,
      // See echarts/component/visualMap/typeDefaulter.
      range: null,
      // selected range. In default case `range` is [min, max]
      // and can auto change along with modification of min max,
      // util use specifid a range.
      realtime: true,
      // Whether realtime update.
      itemHeight: null,
      // The length of the range control edge.
      itemWidth: null,
      // The length of the other side.
      hoverLink: true,
      // Enable hover highlight.
      hoverLinkDataSize: null,
      // The size of hovered data.
      hoverLinkOnHandle: null
      // Whether trigger hoverLink when hover handle.
      // If not specified, follow the value of `realtime`.
    },
    /**
     * @override
     */
    optionUpdated: function(newOption, isInit) {
      ContinuousModel.superApply(this, "optionUpdated", arguments);
      this.resetExtent();
      this.resetVisual(function(mappingOption) {
        mappingOption.mappingMethod = "linear";
        mappingOption.dataExtent = this.getExtent();
      });
      this._resetRange();
    },
    /**
     * @protected
     * @override
     */
    resetItemSize: function() {
      ContinuousModel.superApply(this, "resetItemSize", arguments);
      var itemSize = this.itemSize;
      this._orient === "horizontal" && itemSize.reverse();
      (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
      (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
    },
    /**
     * @private
     */
    _resetRange: function() {
      var dataExtent = this.getExtent();
      var range = this.option.range;
      if (!range || range.auto) {
        dataExtent.auto = 1;
        this.option.range = dataExtent;
      } else if (zrUtil2.isArray(range)) {
        if (range[0] > range[1]) {
          range.reverse();
        }
        range[0] = Math.max(range[0], dataExtent[0]);
        range[1] = Math.min(range[1], dataExtent[1]);
      }
    },
    /**
     * @protected
     * @override
     */
    completeVisualOption: function() {
      VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
      zrUtil2.each(this.stateList, function(state) {
        var symbolSize = this.option.controller[state].symbolSize;
        if (symbolSize && symbolSize[0] !== symbolSize[1]) {
          symbolSize[0] = 0;
        }
      }, this);
    },
    /**
     * @override
     */
    setSelected: function(selected) {
      this.option.range = selected.slice();
      this._resetRange();
    },
    /**
     * @public
     */
    getSelected: function() {
      var dataExtent = this.getExtent();
      var dataInterval = numberUtil.asc((this.get("range") || []).slice());
      dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
      dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
      dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
      dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
      return dataInterval;
    },
    /**
     * @override
     */
    getValueState: function(value) {
      var range = this.option.range;
      var dataExtent = this.getExtent();
      return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
    },
    /**
     * @params {Array.<number>} range target value: range[0] <= value && value <= range[1]
     * @return {Array.<Object>} [{seriesId, dataIndices: <Array.<number>>}, ...]
     */
    findTargetDataIndices: function(range) {
      var result = [];
      this.eachTargetSeries(function(seriesModel) {
        var dataIndices = [];
        var data = seriesModel.getData();
        data.each(this.getDataDimension(data), function(value, dataIndex) {
          range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
        }, this);
        result.push({
          seriesId: seriesModel.id,
          dataIndex: dataIndices
        });
      }, this);
      return result;
    },
    /**
     * @implement
     */
    getVisualMeta: function(getColorVisual) {
      var oVals = getColorStopValues(this, "outOfRange", this.getExtent());
      var iVals = getColorStopValues(this, "inRange", this.option.range.slice());
      var stops = [];
      function setStop(value, valueState) {
        stops.push({
          value,
          color: getColorVisual(value, valueState)
        });
      }
      var iIdx = 0;
      var oIdx = 0;
      var iLen = iVals.length;
      var oLen = oVals.length;
      for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
        if (oVals[oIdx] < iVals[iIdx]) {
          setStop(oVals[oIdx], "outOfRange");
        }
      }
      for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
        first && stops.length && setStop(iVals[iIdx], "outOfRange");
        setStop(iVals[iIdx], "inRange");
      }
      for (var first = 1; oIdx < oLen; oIdx++) {
        if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
          if (first) {
            stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
            first = 0;
          }
          setStop(oVals[oIdx], "outOfRange");
        }
      }
      var stopsLen = stops.length;
      return {
        stops,
        outerColors: [stopsLen ? stops[0].color : "transparent", stopsLen ? stops[stopsLen - 1].color : "transparent"]
      };
    }
  });
  function getColorStopValues(visualMapModel, valueState, dataExtent) {
    if (dataExtent[0] === dataExtent[1]) {
      return dataExtent.slice();
    }
    var count = 200;
    var step = (dataExtent[1] - dataExtent[0]) / count;
    var value = dataExtent[0];
    var stopValues = [];
    for (var i = 0; i <= count && value < dataExtent[1]; i++) {
      stopValues.push(value);
      value += step;
    }
    stopValues.push(dataExtent[1]);
    return stopValues;
  }
  var _default2 = ContinuousModel;
  ContinuousModel_1 = _default2;
  return ContinuousModel_1;
}
var VisualMapView;
var hasRequiredVisualMapView;
function requireVisualMapView() {
  if (hasRequiredVisualMapView)
    return VisualMapView;
  hasRequiredVisualMapView = 1;
  var echarts$12 = echarts;
  var zrUtil2 = util$6;
  var graphic2 = graphic$4;
  var formatUtil2 = requireFormat();
  var layout2 = layout$1;
  var VisualMapping = requireVisualMapping();
  var _default2 = echarts$12.extendComponentView({
    type: "visualMap",
    /**
     * @readOnly
     * @type {Object}
     */
    autoPositionValues: {
      left: 1,
      right: 1,
      top: 1,
      bottom: 1
    },
    init: function(ecModel, api) {
      this.ecModel = ecModel;
      this.api = api;
      this.visualMapModel;
    },
    /**
     * @protected
     */
    render: function(visualMapModel, ecModel, api, payload) {
      this.visualMapModel = visualMapModel;
      if (visualMapModel.get("show") === false) {
        this.group.removeAll();
        return;
      }
      this.doRender.apply(this, arguments);
    },
    /**
     * @protected
     */
    renderBackground: function(group) {
      var visualMapModel = this.visualMapModel;
      var padding = formatUtil2.normalizeCssArray(visualMapModel.get("padding") || 0);
      var rect = group.getBoundingRect();
      group.add(new graphic2.Rect({
        z2: -1,
        // Lay background rect on the lowest layer.
        silent: true,
        shape: {
          x: rect.x - padding[3],
          y: rect.y - padding[0],
          width: rect.width + padding[3] + padding[1],
          height: rect.height + padding[0] + padding[2]
        },
        style: {
          fill: visualMapModel.get("backgroundColor"),
          stroke: visualMapModel.get("borderColor"),
          lineWidth: visualMapModel.get("borderWidth")
        }
      }));
    },
    /**
     * @protected
     * @param {number} targetValue can be Infinity or -Infinity
     * @param {string=} visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
     * @param {Object} [opts]
     * @param {string=} [opts.forceState] Specify state, instead of using getValueState method.
     * @param {string=} [opts.convertOpacityToAlpha=false] For color gradient in controller widget.
     * @return {*} Visual value.
     */
    getControllerVisual: function(targetValue, visualCluster, opts) {
      opts = opts || {};
      var forceState = opts.forceState;
      var visualMapModel = this.visualMapModel;
      var visualObj = {};
      if (visualCluster === "symbol") {
        visualObj.symbol = visualMapModel.get("itemSymbol");
      }
      if (visualCluster === "color") {
        var defaultColor = visualMapModel.get("contentColor");
        visualObj.color = defaultColor;
      }
      function getter(key) {
        return visualObj[key];
      }
      function setter(key, value) {
        visualObj[key] = value;
      }
      var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
      var visualTypes = VisualMapping.prepareVisualTypes(mappings);
      zrUtil2.each(visualTypes, function(type) {
        var visualMapping = mappings[type];
        if (opts.convertOpacityToAlpha && type === "opacity") {
          type = "colorAlpha";
          visualMapping = mappings.__alphaForOpacity;
        }
        if (VisualMapping.dependsOn(type, visualCluster)) {
          visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
        }
      });
      return visualObj[visualCluster];
    },
    /**
     * @protected
     */
    positionGroup: function(group) {
      var model2 = this.visualMapModel;
      var api = this.api;
      layout2.positionElement(group, model2.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      });
    },
    /**
     * @protected
     * @abstract
     */
    doRender: zrUtil2.noop
  });
  VisualMapView = _default2;
  return VisualMapView;
}
var helper = {};
var hasRequiredHelper;
function requireHelper() {
  if (hasRequiredHelper)
    return helper;
  hasRequiredHelper = 1;
  var zrUtil2 = util$6;
  var _layout2 = layout$1;
  var getLayoutRect2 = _layout2.getLayoutRect;
  function getItemAlign(visualMapModel, api, itemSize) {
    var modelOption = visualMapModel.option;
    var itemAlign = modelOption.align;
    if (itemAlign != null && itemAlign !== "auto") {
      return itemAlign;
    }
    var ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    };
    var realIndex = modelOption.orient === "horizontal" ? 1 : 0;
    var paramsSet = [["left", "right", "width"], ["top", "bottom", "height"]];
    var reals = paramsSet[realIndex];
    var fakeValue = [0, null, 10];
    var layoutInput = {};
    for (var i = 0; i < 3; i++) {
      layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
      layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
    }
    var rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
    var rect = getLayoutRect2(layoutInput, ecSize, modelOption.padding);
    return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
  }
  function makeHighDownBatch(batch, visualMapModel) {
    zrUtil2.each(batch || [], function(batchItem) {
      if (batchItem.dataIndex != null) {
        batchItem.dataIndexInside = batchItem.dataIndex;
        batchItem.dataIndex = null;
      }
      batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
    });
    return batch;
  }
  helper.getItemAlign = getItemAlign;
  helper.makeHighDownBatch = makeHighDownBatch;
  return helper;
}
var ContinuousView_1;
var hasRequiredContinuousView;
function requireContinuousView() {
  if (hasRequiredContinuousView)
    return ContinuousView_1;
  hasRequiredContinuousView = 1;
  var zrUtil2 = util$6;
  var LinearGradient2 = LinearGradient_1;
  var eventTool2 = event;
  var VisualMapView2 = requireVisualMapView();
  var graphic2 = graphic$4;
  var numberUtil = requireNumber();
  var sliderMove2 = requireSliderMove();
  var helper2 = requireHelper();
  var modelUtil2 = model;
  var linearMap = numberUtil.linearMap;
  var each2 = zrUtil2.each;
  var mathMin2 = Math.min;
  var mathMax2 = Math.max;
  var HOVER_LINK_SIZE = 12;
  var HOVER_LINK_OUT = 6;
  var ContinuousView = VisualMapView2.extend({
    type: "visualMap.continuous",
    /**
     * @override
     */
    init: function() {
      ContinuousView.superApply(this, "init", arguments);
      this._shapes = {};
      this._dataInterval = [];
      this._handleEnds = [];
      this._orient;
      this._useHandle;
      this._hoverLinkDataIndices = [];
      this._dragging;
      this._hovering;
    },
    /**
     * @protected
     * @override
     */
    doRender: function(visualMapModel, ecModel, api, payload) {
      if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
        this._buildView();
      }
    },
    /**
     * @private
     */
    _buildView: function() {
      this.group.removeAll();
      var visualMapModel = this.visualMapModel;
      var thisGroup = this.group;
      this._orient = visualMapModel.get("orient");
      this._useHandle = visualMapModel.get("calculable");
      this._resetInterval();
      this._renderBar(thisGroup);
      var dataRangeText = visualMapModel.get("text");
      this._renderEndsText(thisGroup, dataRangeText, 0);
      this._renderEndsText(thisGroup, dataRangeText, 1);
      this._updateView(true);
      this.renderBackground(thisGroup);
      this._updateView();
      this._enableHoverLinkToSeries();
      this._enableHoverLinkFromSeries();
      this.positionGroup(thisGroup);
    },
    /**
     * @private
     */
    _renderEndsText: function(group, dataRangeText, endsIndex) {
      if (!dataRangeText) {
        return;
      }
      var text2 = dataRangeText[1 - endsIndex];
      text2 = text2 != null ? text2 + "" : "";
      var visualMapModel = this.visualMapModel;
      var textGap = visualMapModel.get("textGap");
      var itemSize = visualMapModel.itemSize;
      var barGroup = this._shapes.barGroup;
      var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);
      var align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
      var orient = this._orient;
      var textStyleModel = this.visualMapModel.textStyleModel;
      this.group.add(new graphic2.Text({
        style: {
          x: position[0],
          y: position[1],
          textVerticalAlign: orient === "horizontal" ? "middle" : align,
          textAlign: orient === "horizontal" ? align : "center",
          text: text2,
          textFont: textStyleModel.getFont(),
          textFill: textStyleModel.getTextColor()
        }
      }));
    },
    /**
     * @private
     */
    _renderBar: function(targetGroup) {
      var visualMapModel = this.visualMapModel;
      var shapes = this._shapes;
      var itemSize = visualMapModel.itemSize;
      var orient = this._orient;
      var useHandle = this._useHandle;
      var itemAlign = helper2.getItemAlign(visualMapModel, this.api, itemSize);
      var barGroup = shapes.barGroup = this._createBarGroup(itemAlign);
      barGroup.add(shapes.outOfRange = createPolygon());
      barGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, zrUtil2.bind(this._dragHandle, this, "all", false), zrUtil2.bind(this._dragHandle, this, "all", true)));
      var textRect = visualMapModel.textStyleModel.getTextRect("国");
      var textSize = mathMax2(textRect.width, textRect.height);
      if (useHandle) {
        shapes.handleThumbs = [];
        shapes.handleLabels = [];
        shapes.handleLabelPoints = [];
        this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign);
        this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign);
      }
      this._createIndicator(barGroup, itemSize, textSize, orient);
      targetGroup.add(barGroup);
    },
    /**
     * @private
     */
    _createHandle: function(barGroup, handleIndex, itemSize, textSize, orient) {
      var onDrift = zrUtil2.bind(this._dragHandle, this, handleIndex, false);
      var onDragEnd = zrUtil2.bind(this._dragHandle, this, handleIndex, true);
      var handleThumb = createPolygon(createHandlePoints(handleIndex, textSize), getCursor(this._orient), onDrift, onDragEnd);
      handleThumb.position[0] = itemSize[0];
      barGroup.add(handleThumb);
      var textStyleModel = this.visualMapModel.textStyleModel;
      var handleLabel = new graphic2.Text({
        draggable: true,
        drift: onDrift,
        onmousemove: function(e2) {
          eventTool2.stop(e2.event);
        },
        ondragend: onDragEnd,
        style: {
          x: 0,
          y: 0,
          text: "",
          textFont: textStyleModel.getFont(),
          textFill: textStyleModel.getTextColor()
        }
      });
      this.group.add(handleLabel);
      var handleLabelPoint = [orient === "horizontal" ? textSize / 2 : textSize * 1.5, orient === "horizontal" ? handleIndex === 0 ? -(textSize * 1.5) : textSize * 1.5 : handleIndex === 0 ? -textSize / 2 : textSize / 2];
      var shapes = this._shapes;
      shapes.handleThumbs[handleIndex] = handleThumb;
      shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
      shapes.handleLabels[handleIndex] = handleLabel;
    },
    /**
     * @private
     */
    _createIndicator: function(barGroup, itemSize, textSize, orient) {
      var indicator = createPolygon([[0, 0]], "move");
      indicator.position[0] = itemSize[0];
      indicator.attr({
        invisible: true,
        silent: true
      });
      barGroup.add(indicator);
      var textStyleModel = this.visualMapModel.textStyleModel;
      var indicatorLabel = new graphic2.Text({
        silent: true,
        invisible: true,
        style: {
          x: 0,
          y: 0,
          text: "",
          textFont: textStyleModel.getFont(),
          textFill: textStyleModel.getTextColor()
        }
      });
      this.group.add(indicatorLabel);
      var indicatorLabelPoint = [orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT + 3, 0];
      var shapes = this._shapes;
      shapes.indicator = indicator;
      shapes.indicatorLabel = indicatorLabel;
      shapes.indicatorLabelPoint = indicatorLabelPoint;
    },
    /**
     * @private
     */
    _dragHandle: function(handleIndex, isEnd, dx, dy) {
      if (!this._useHandle) {
        return;
      }
      this._dragging = !isEnd;
      if (!isEnd) {
        var vertex = this._applyTransform([dx, dy], this._shapes.barGroup, true);
        this._updateInterval(handleIndex, vertex[1]);
        this._updateView();
      }
      if (isEnd === !this.visualMapModel.get("realtime")) {
        this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        });
      }
      if (isEnd) {
        !this._hovering && this._clearHoverLinkToSeries();
      } else if (useHoverLinkOnHandle(this.visualMapModel)) {
        this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
      }
    },
    /**
     * @private
     */
    _resetInterval: function() {
      var visualMapModel = this.visualMapModel;
      var dataInterval = this._dataInterval = visualMapModel.getSelected();
      var dataExtent = visualMapModel.getExtent();
      var sizeExtent = [0, visualMapModel.itemSize[1]];
      this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];
    },
    /**
     * @private
     * @param {(number|string)} handleIndex 0 or 1 or 'all'
     * @param {number} dx
     * @param {number} dy
     */
    _updateInterval: function(handleIndex, delta) {
      delta = delta || 0;
      var visualMapModel = this.visualMapModel;
      var handleEnds = this._handleEnds;
      var sizeExtent = [0, visualMapModel.itemSize[1]];
      sliderMove2(
        delta,
        handleEnds,
        sizeExtent,
        handleIndex,
        // cross is forbiden
        0
      );
      var dataExtent = visualMapModel.getExtent();
      this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];
    },
    /**
     * @private
     */
    _updateView: function(forSketch) {
      var visualMapModel = this.visualMapModel;
      var dataExtent = visualMapModel.getExtent();
      var shapes = this._shapes;
      var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
      var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
      var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
      var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
      shapes.inRange.setStyle({
        fill: visualInRange.barColor,
        opacity: visualInRange.opacity
      }).setShape("points", visualInRange.barPoints);
      shapes.outOfRange.setStyle({
        fill: visualOutOfRange.barColor,
        opacity: visualOutOfRange.opacity
      }).setShape("points", visualOutOfRange.barPoints);
      this._updateHandle(inRangeHandleEnds, visualInRange);
    },
    /**
     * @private
     */
    _createBarVisual: function(dataInterval, dataExtent, handleEnds, forceState) {
      var opts = {
        forceState,
        convertOpacityToAlpha: true
      };
      var colorStops = this._makeColorGradient(dataInterval, opts);
      var symbolSizes = [this.getControllerVisual(dataInterval[0], "symbolSize", opts), this.getControllerVisual(dataInterval[1], "symbolSize", opts)];
      var barPoints = this._createBarPoints(handleEnds, symbolSizes);
      return {
        barColor: new LinearGradient2(0, 0, 0, 1, colorStops),
        barPoints,
        handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
      };
    },
    /**
     * @private
     */
    _makeColorGradient: function(dataInterval, opts) {
      var sampleNumber = 100;
      var colorStops = [];
      var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
      colorStops.push({
        color: this.getControllerVisual(dataInterval[0], "color", opts),
        offset: 0
      });
      for (var i = 1; i < sampleNumber; i++) {
        var currValue = dataInterval[0] + step * i;
        if (currValue > dataInterval[1]) {
          break;
        }
        colorStops.push({
          color: this.getControllerVisual(currValue, "color", opts),
          offset: i / sampleNumber
        });
      }
      colorStops.push({
        color: this.getControllerVisual(dataInterval[1], "color", opts),
        offset: 1
      });
      return colorStops;
    },
    /**
     * @private
     */
    _createBarPoints: function(handleEnds, symbolSizes) {
      var itemSize = this.visualMapModel.itemSize;
      return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];
    },
    /**
     * @private
     */
    _createBarGroup: function(itemAlign) {
      var orient = this._orient;
      var inverse = this.visualMapModel.get("inverse");
      return new graphic2.Group(orient === "horizontal" && !inverse ? {
        scale: itemAlign === "bottom" ? [1, 1] : [-1, 1],
        rotation: Math.PI / 2
      } : orient === "horizontal" && inverse ? {
        scale: itemAlign === "bottom" ? [-1, 1] : [1, 1],
        rotation: -Math.PI / 2
      } : orient === "vertical" && !inverse ? {
        scale: itemAlign === "left" ? [1, -1] : [-1, -1]
      } : {
        scale: itemAlign === "left" ? [1, 1] : [-1, 1]
      });
    },
    /**
     * @private
     */
    _updateHandle: function(handleEnds, visualInRange) {
      if (!this._useHandle) {
        return;
      }
      var shapes = this._shapes;
      var visualMapModel = this.visualMapModel;
      var handleThumbs = shapes.handleThumbs;
      var handleLabels = shapes.handleLabels;
      each2([0, 1], function(handleIndex) {
        var handleThumb = handleThumbs[handleIndex];
        handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
        handleThumb.position[1] = handleEnds[handleIndex];
        var textPoint = graphic2.applyTransform(shapes.handleLabelPoints[handleIndex], graphic2.getTransform(handleThumb, this.group));
        handleLabels[handleIndex].setStyle({
          x: textPoint[0],
          y: textPoint[1],
          text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
          textVerticalAlign: "middle",
          textAlign: this._applyTransform(this._orient === "horizontal" ? handleIndex === 0 ? "bottom" : "top" : "left", shapes.barGroup)
        });
      }, this);
    },
    /**
     * @private
     * @param {number} cursorValue
     * @param {number} textValue
     * @param {string} [rangeSymbol]
     * @param {number} [halfHoverLinkSize]
     */
    _showIndicator: function(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
      var visualMapModel = this.visualMapModel;
      var dataExtent = visualMapModel.getExtent();
      var itemSize = visualMapModel.itemSize;
      var sizeExtent = [0, itemSize[1]];
      var pos = linearMap(cursorValue, dataExtent, sizeExtent, true);
      var shapes = this._shapes;
      var indicator = shapes.indicator;
      if (!indicator) {
        return;
      }
      indicator.position[1] = pos;
      indicator.attr("invisible", false);
      indicator.setShape("points", createIndicatorPoints(!!rangeSymbol, halfHoverLinkSize, pos, itemSize[1]));
      var opts = {
        convertOpacityToAlpha: true
      };
      var color2 = this.getControllerVisual(cursorValue, "color", opts);
      indicator.setStyle("fill", color2);
      var textPoint = graphic2.applyTransform(shapes.indicatorLabelPoint, graphic2.getTransform(indicator, this.group));
      var indicatorLabel = shapes.indicatorLabel;
      indicatorLabel.attr("invisible", false);
      var align = this._applyTransform("left", shapes.barGroup);
      var orient = this._orient;
      indicatorLabel.setStyle({
        text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
        textVerticalAlign: orient === "horizontal" ? align : "middle",
        textAlign: orient === "horizontal" ? "center" : align,
        x: textPoint[0],
        y: textPoint[1]
      });
    },
    /**
     * @private
     */
    _enableHoverLinkToSeries: function() {
      var self2 = this;
      this._shapes.barGroup.on("mousemove", function(e2) {
        self2._hovering = true;
        if (!self2._dragging) {
          var itemSize = self2.visualMapModel.itemSize;
          var pos = self2._applyTransform([e2.offsetX, e2.offsetY], self2._shapes.barGroup, true, true);
          pos[1] = mathMin2(mathMax2(0, pos[1]), itemSize[1]);
          self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
        }
      }).on("mouseout", function() {
        self2._hovering = false;
        !self2._dragging && self2._clearHoverLinkToSeries();
      });
    },
    /**
     * @private
     */
    _enableHoverLinkFromSeries: function() {
      var zr = this.api.getZr();
      if (this.visualMapModel.option.hoverLink) {
        zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
        zr.on("mouseout", this._hideIndicator, this);
      } else {
        this._clearHoverLinkFromSeries();
      }
    },
    /**
     * @private
     */
    _doHoverLinkToSeries: function(cursorPos, hoverOnBar) {
      var visualMapModel = this.visualMapModel;
      var itemSize = visualMapModel.itemSize;
      if (!visualMapModel.option.hoverLink) {
        return;
      }
      var sizeExtent = [0, itemSize[1]];
      var dataExtent = visualMapModel.getExtent();
      cursorPos = mathMin2(mathMax2(sizeExtent[0], cursorPos), sizeExtent[1]);
      var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
      var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
      var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);
      var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];
      hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
      hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
      if (hoverOnBar) {
        if (valueRange[0] === -Infinity) {
          this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
        } else if (valueRange[1] === Infinity) {
          this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
        } else {
          this._showIndicator(cursorValue, cursorValue, "≈ ", halfHoverLinkSize);
        }
      }
      var oldBatch = this._hoverLinkDataIndices;
      var newBatch = [];
      if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
        newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
      }
      var resultBatches = modelUtil2.compressBatches(oldBatch, newBatch);
      this._dispatchHighDown("downplay", helper2.makeHighDownBatch(resultBatches[0], visualMapModel));
      this._dispatchHighDown("highlight", helper2.makeHighDownBatch(resultBatches[1], visualMapModel));
    },
    /**
     * @private
     */
    _hoverLinkFromSeriesMouseOver: function(e2) {
      var el = e2.target;
      var visualMapModel = this.visualMapModel;
      if (!el || el.dataIndex == null) {
        return;
      }
      var dataModel = this.ecModel.getSeriesByIndex(el.seriesIndex);
      if (!visualMapModel.isTargetSeries(dataModel)) {
        return;
      }
      var data = dataModel.getData(el.dataType);
      var value = data.get(visualMapModel.getDataDimension(data), el.dataIndex, true);
      if (!isNaN(value)) {
        this._showIndicator(value, value);
      }
    },
    /**
     * @private
     */
    _hideIndicator: function() {
      var shapes = this._shapes;
      shapes.indicator && shapes.indicator.attr("invisible", true);
      shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
    },
    /**
     * @private
     */
    _clearHoverLinkToSeries: function() {
      this._hideIndicator();
      var indices = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", helper2.makeHighDownBatch(indices, this.visualMapModel));
      indices.length = 0;
    },
    /**
     * @private
     */
    _clearHoverLinkFromSeries: function() {
      this._hideIndicator();
      var zr = this.api.getZr();
      zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
      zr.off("mouseout", this._hideIndicator);
    },
    /**
     * @private
     */
    _applyTransform: function(vertex, element, inverse, global2) {
      var transform = graphic2.getTransform(element, global2 ? null : this.group);
      return graphic2[zrUtil2.isArray(vertex) ? "applyTransform" : "transformDirection"](vertex, transform, inverse);
    },
    /**
     * @private
     */
    _dispatchHighDown: function(type, batch) {
      batch && batch.length && this.api.dispatchAction({
        type,
        batch
      });
    },
    /**
     * @override
     */
    dispose: function() {
      this._clearHoverLinkFromSeries();
      this._clearHoverLinkToSeries();
    },
    /**
     * @override
     */
    remove: function() {
      this._clearHoverLinkFromSeries();
      this._clearHoverLinkToSeries();
    }
  });
  function createPolygon(points2, cursor, onDrift, onDragEnd) {
    return new graphic2.Polygon({
      shape: {
        points: points2
      },
      draggable: !!onDrift,
      cursor,
      drift: onDrift,
      onmousemove: function(e2) {
        eventTool2.stop(e2.event);
      },
      ondragend: onDragEnd
    });
  }
  function createHandlePoints(handleIndex, textSize) {
    return handleIndex === 0 ? [[0, 0], [textSize, 0], [textSize, -textSize]] : [[0, 0], [textSize, 0], [textSize, textSize]];
  }
  function createIndicatorPoints(isRange, halfHoverLinkSize, pos, extentMax) {
    return isRange ? [
      // indicate range
      [0, -mathMin2(halfHoverLinkSize, mathMax2(pos, 0))],
      [HOVER_LINK_OUT, 0],
      [0, mathMin2(halfHoverLinkSize, mathMax2(extentMax - pos, 0))]
    ] : [
      // indicate single value
      [0, 0],
      [5, -5],
      [5, 5]
    ];
  }
  function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
    var halfHoverLinkSize = HOVER_LINK_SIZE / 2;
    var hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
    if (hoverLinkDataSize) {
      halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
    }
    return halfHoverLinkSize;
  }
  function useHoverLinkOnHandle(visualMapModel) {
    var hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
    return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
  }
  function getCursor(orient) {
    return orient === "vertical" ? "ns-resize" : "ew-resize";
  }
  var _default2 = ContinuousView;
  ContinuousView_1 = _default2;
  return ContinuousView_1;
}
var visualMapAction = {};
var hasRequiredVisualMapAction;
function requireVisualMapAction() {
  if (hasRequiredVisualMapAction)
    return visualMapAction;
  hasRequiredVisualMapAction = 1;
  var echarts$12 = echarts;
  var actionInfo = {
    type: "selectDataRange",
    event: "dataRangeSelected",
    // FIXME use updateView appears wrong
    update: "update"
  };
  echarts$12.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "visualMap",
      query: payload
    }, function(model2) {
      model2.setSelected(payload.selected);
    });
  });
  return visualMapAction;
}
var hasRequiredVisualMapContinuous;
function requireVisualMapContinuous() {
  if (hasRequiredVisualMapContinuous)
    return visualMapContinuous;
  hasRequiredVisualMapContinuous = 1;
  var echarts$12 = echarts;
  var preprocessor2 = requirePreprocessor();
  requireTypeDefaulter();
  requireVisualEncoding();
  requireContinuousModel();
  requireContinuousView();
  requireVisualMapAction();
  echarts$12.registerPreprocessor(preprocessor2);
  return visualMapContinuous;
}
var visualMapPiecewise = {};
var PiecewiseModel_1;
var hasRequiredPiecewiseModel;
function requirePiecewiseModel() {
  if (hasRequiredPiecewiseModel)
    return PiecewiseModel_1;
  hasRequiredPiecewiseModel = 1;
  var zrUtil2 = util$6;
  var VisualMapModel = requireVisualMapModel();
  var VisualMapping = requireVisualMapping();
  var visualDefault = requireVisualDefault();
  var _number2 = requireNumber();
  var reformIntervals = _number2.reformIntervals;
  var PiecewiseModel = VisualMapModel.extend({
    type: "visualMap.piecewise",
    /**
     * Order Rule:
     *
     * option.categories / option.pieces / option.text / option.selected:
     *     If !option.inverse,
     *     Order when vertical: ['top', ..., 'bottom'].
     *     Order when horizontal: ['left', ..., 'right'].
     *     If option.inverse, the meaning of
     *     the order should be reversed.
     *
     * this._pieceList:
     *     The order is always [low, ..., high].
     *
     * Mapping from location to low-high:
     *     If !option.inverse
     *     When vertical, top is high.
     *     When horizontal, right is high.
     *     If option.inverse, reverse.
     */
    /**
     * @protected
     */
    defaultOption: {
      selected: null,
      // Object. If not specified, means selected.
      // When pieces and splitNumber: {'0': true, '5': true}
      // When categories: {'cate1': false, 'cate3': true}
      // When selected === false, means all unselected.
      minOpen: false,
      // Whether include values that smaller than `min`.
      maxOpen: false,
      // Whether include values that bigger than `max`.
      align: "auto",
      // 'auto', 'left', 'right'
      itemWidth: 20,
      // When put the controller vertically, it is the length of
      // horizontal side of each item. Otherwise, vertical side.
      itemHeight: 14,
      // When put the controller vertically, it is the length of
      // vertical side of each item. Otherwise, horizontal side.
      itemSymbol: "roundRect",
      pieceList: null,
      // Each item is Object, with some of those attrs:
      // {min, max, lt, gt, lte, gte, value,
      // color, colorSaturation, colorAlpha, opacity,
      // symbol, symbolSize}, which customize the range or visual
      // coding of the certain piece. Besides, see "Order Rule".
      categories: null,
      // category names, like: ['some1', 'some2', 'some3'].
      // Attr min/max are ignored when categories set. See "Order Rule"
      splitNumber: 5,
      // If set to 5, auto split five pieces equally.
      // If set to 0 and component type not set, component type will be
      // determined as "continuous". (It is less reasonable but for ec2
      // compatibility, see echarts/component/visualMap/typeDefaulter)
      selectedMode: "multiple",
      // Can be 'multiple' or 'single'.
      itemGap: 10,
      // The gap between two items, in px.
      hoverLink: true,
      // Enable hover highlight.
      showLabel: null
      // By default, when text is used, label will hide (the logic
      // is remained for compatibility reason)
    },
    /**
     * @override
     */
    optionUpdated: function(newOption, isInit) {
      PiecewiseModel.superApply(this, "optionUpdated", arguments);
      this._pieceList = [];
      this.resetExtent();
      var mode = this._mode = this._determineMode();
      resetMethods[this._mode].call(this);
      this._resetSelected(newOption, isInit);
      var categories = this.option.categories;
      this.resetVisual(function(mappingOption, state) {
        if (mode === "categories") {
          mappingOption.mappingMethod = "category";
          mappingOption.categories = zrUtil2.clone(categories);
        } else {
          mappingOption.dataExtent = this.getExtent();
          mappingOption.mappingMethod = "piecewise";
          mappingOption.pieceList = zrUtil2.map(this._pieceList, function(piece) {
            var piece = zrUtil2.clone(piece);
            if (state !== "inRange") {
              piece.visual = null;
            }
            return piece;
          });
        }
      });
    },
    /**
     * @protected
     * @override
     */
    completeVisualOption: function() {
      var option = this.option;
      var visualTypesInPieces = {};
      var visualTypes = VisualMapping.listVisualTypes();
      var isCategory = this.isCategory();
      zrUtil2.each(option.pieces, function(piece) {
        zrUtil2.each(visualTypes, function(visualType) {
          if (piece.hasOwnProperty(visualType)) {
            visualTypesInPieces[visualType] = 1;
          }
        });
      });
      zrUtil2.each(visualTypesInPieces, function(v, visualType) {
        var exists = 0;
        zrUtil2.each(this.stateList, function(state) {
          exists |= has2(option, state, visualType) || has2(option.target, state, visualType);
        }, this);
        !exists && zrUtil2.each(this.stateList, function(state) {
          (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === "inRange" ? "active" : "inactive", isCategory);
        });
      }, this);
      function has2(obj, state, visualType) {
        return obj && obj[state] && (zrUtil2.isObject(obj[state]) ? obj[state].hasOwnProperty(visualType) : obj[state] === visualType);
      }
      VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
    },
    _resetSelected: function(newOption, isInit) {
      var thisOption = this.option;
      var pieceList = this._pieceList;
      var selected = (isInit ? thisOption : newOption).selected || {};
      thisOption.selected = selected;
      zrUtil2.each(pieceList, function(piece, index2) {
        var key = this.getSelectedMapKey(piece);
        if (!selected.hasOwnProperty(key)) {
          selected[key] = true;
        }
      }, this);
      if (thisOption.selectedMode === "single") {
        var hasSel = false;
        zrUtil2.each(pieceList, function(piece, index2) {
          var key = this.getSelectedMapKey(piece);
          if (selected[key]) {
            hasSel ? selected[key] = false : hasSel = true;
          }
        }, this);
      }
    },
    /**
     * @public
     */
    getSelectedMapKey: function(piece) {
      return this._mode === "categories" ? piece.value + "" : piece.index + "";
    },
    /**
     * @public
     */
    getPieceList: function() {
      return this._pieceList;
    },
    /**
     * @private
     * @return {string}
     */
    _determineMode: function() {
      var option = this.option;
      return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    },
    /**
     * @public
     * @override
     */
    setSelected: function(selected) {
      this.option.selected = zrUtil2.clone(selected);
    },
    /**
     * @public
     * @override
     */
    getValueState: function(value) {
      var index2 = VisualMapping.findPieceIndex(value, this._pieceList);
      return index2 != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index2])] ? "inRange" : "outOfRange" : "outOfRange";
    },
    /**
     * @public
     * @params {number} pieceIndex piece index in visualMapModel.getPieceList()
     * @return {Array.<Object>} [{seriesId, dataIndex: <Array.<number>>}, ...]
     */
    findTargetDataIndices: function(pieceIndex) {
      var result = [];
      this.eachTargetSeries(function(seriesModel) {
        var dataIndices = [];
        var data = seriesModel.getData();
        data.each(this.getDataDimension(data), function(value, dataIndex) {
          var pIdx = VisualMapping.findPieceIndex(value, this._pieceList);
          pIdx === pieceIndex && dataIndices.push(dataIndex);
        }, this);
        result.push({
          seriesId: seriesModel.id,
          dataIndex: dataIndices
        });
      }, this);
      return result;
    },
    /**
     * @private
     * @param {Object} piece piece.value or piece.interval is required.
     * @return {number} Can be Infinity or -Infinity
     */
    getRepresentValue: function(piece) {
      var representValue;
      if (this.isCategory()) {
        representValue = piece.value;
      } else {
        if (piece.value != null) {
          representValue = piece.value;
        } else {
          var pieceInterval = piece.interval || [];
          representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
        }
      }
      return representValue;
    },
    getVisualMeta: function(getColorVisual) {
      if (this.isCategory()) {
        return;
      }
      var stops = [];
      var outerColors = [];
      var visualMapModel = this;
      function setStop(interval, valueState) {
        var representValue = visualMapModel.getRepresentValue({
          interval
        });
        if (!valueState) {
          valueState = visualMapModel.getValueState(representValue);
        }
        var color2 = getColorVisual(representValue, valueState);
        if (interval[0] === -Infinity) {
          outerColors[0] = color2;
        } else if (interval[1] === Infinity) {
          outerColors[1] = color2;
        } else {
          stops.push({
            value: interval[0],
            color: color2
          }, {
            value: interval[1],
            color: color2
          });
        }
      }
      var pieceList = this._pieceList.slice();
      if (!pieceList.length) {
        pieceList.push({
          interval: [-Infinity, Infinity]
        });
      } else {
        var edge = pieceList[0].interval[0];
        edge !== -Infinity && pieceList.unshift({
          interval: [-Infinity, edge]
        });
        edge = pieceList[pieceList.length - 1].interval[1];
        edge !== Infinity && pieceList.push({
          interval: [edge, Infinity]
        });
      }
      var curr = -Infinity;
      zrUtil2.each(pieceList, function(piece) {
        var interval = piece.interval;
        if (interval) {
          interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
          setStop(interval.slice());
          curr = interval[1];
        }
      }, this);
      return {
        stops,
        outerColors
      };
    }
  });
  var resetMethods = {
    splitNumber: function() {
      var thisOption = this.option;
      var pieceList = this._pieceList;
      var precision = Math.min(thisOption.precision, 20);
      var dataExtent = this.getExtent();
      var splitNumber = thisOption.splitNumber;
      splitNumber = Math.max(parseInt(splitNumber, 10), 1);
      thisOption.splitNumber = splitNumber;
      var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
      while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
        precision++;
      }
      thisOption.precision = precision;
      splitStep = +splitStep.toFixed(precision);
      if (thisOption.minOpen) {
        pieceList.push({
          interval: [-Infinity, dataExtent[0]],
          close: [0, 0]
        });
      }
      for (var index2 = 0, curr = dataExtent[0]; index2 < splitNumber; curr += splitStep, index2++) {
        var max3 = index2 === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
        pieceList.push({
          interval: [curr, max3],
          close: [1, 1]
        });
      }
      if (thisOption.maxOpen) {
        pieceList.push({
          interval: [dataExtent[1], Infinity],
          close: [0, 0]
        });
      }
      reformIntervals(pieceList);
      zrUtil2.each(pieceList, function(piece, index3) {
        piece.index = index3;
        piece.text = this.formatValueText(piece.interval);
      }, this);
    },
    categories: function() {
      var thisOption = this.option;
      zrUtil2.each(thisOption.categories, function(cate) {
        this._pieceList.push({
          text: this.formatValueText(cate, true),
          value: cate
        });
      }, this);
      normalizeReverse(thisOption, this._pieceList);
    },
    pieces: function() {
      var thisOption = this.option;
      var pieceList = this._pieceList;
      zrUtil2.each(thisOption.pieces, function(pieceListItem, index2) {
        if (!zrUtil2.isObject(pieceListItem)) {
          pieceListItem = {
            value: pieceListItem
          };
        }
        var item = {
          text: "",
          index: index2
        };
        if (pieceListItem.label != null) {
          item.text = pieceListItem.label;
        }
        if (pieceListItem.hasOwnProperty("value")) {
          var value = item.value = pieceListItem.value;
          item.interval = [value, value];
          item.close = [1, 1];
        } else {
          var interval = item.interval = [];
          var close = item.close = [0, 0];
          var closeList = [1, 0, 1];
          var infinityList = [-Infinity, Infinity];
          var useMinMax = [];
          for (var lg = 0; lg < 2; lg++) {
            var names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
            for (var i = 0; i < 3 && interval[lg] == null; i++) {
              interval[lg] = pieceListItem[names[i]];
              close[lg] = closeList[i];
              useMinMax[lg] = i === 2;
            }
            interval[lg] == null && (interval[lg] = infinityList[lg]);
          }
          useMinMax[0] && interval[1] === Infinity && (close[0] = 0);
          useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);
          if (interval[0] === interval[1] && close[0] && close[1]) {
            item.value = interval[0];
          }
        }
        item.visual = VisualMapping.retrieveVisuals(pieceListItem);
        pieceList.push(item);
      }, this);
      normalizeReverse(thisOption, pieceList);
      reformIntervals(pieceList);
      zrUtil2.each(pieceList, function(piece) {
        var close = piece.close;
        var edgeSymbols = [["<", "≤"][close[1]], [">", "≥"][close[0]]];
        piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
      }, this);
    }
  };
  function normalizeReverse(thisOption, pieceList) {
    var inverse = thisOption.inverse;
    if (thisOption.orient === "vertical" ? !inverse : inverse) {
      pieceList.reverse();
    }
  }
  var _default2 = PiecewiseModel;
  PiecewiseModel_1 = _default2;
  return PiecewiseModel_1;
}
var PiecewiseView;
var hasRequiredPiecewiseView;
function requirePiecewiseView() {
  if (hasRequiredPiecewiseView)
    return PiecewiseView;
  hasRequiredPiecewiseView = 1;
  var zrUtil2 = util$6;
  var VisualMapView2 = requireVisualMapView();
  var graphic2 = graphic$4;
  var _symbol = requireSymbol$1();
  var createSymbol = _symbol.createSymbol;
  var layout2 = layout$1;
  var helper2 = requireHelper();
  var PiecewiseVisualMapView = VisualMapView2.extend({
    type: "visualMap.piecewise",
    /**
     * @protected
     * @override
     */
    doRender: function() {
      var thisGroup = this.group;
      thisGroup.removeAll();
      var visualMapModel = this.visualMapModel;
      var textGap = visualMapModel.get("textGap");
      var textStyleModel = visualMapModel.textStyleModel;
      var textFont = textStyleModel.getFont();
      var textFill = textStyleModel.getTextColor();
      var itemAlign = this._getItemAlign();
      var itemSize = visualMapModel.itemSize;
      var viewData = this._getViewData();
      var endsText = viewData.endsText;
      var showLabel = zrUtil2.retrieve(visualMapModel.get("showLabel", true), !endsText);
      endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
      zrUtil2.each(viewData.viewPieceList, renderItem, this);
      endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
      layout2.box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
      this.renderBackground(thisGroup);
      this.positionGroup(thisGroup);
      function renderItem(item) {
        var piece = item.piece;
        var itemGroup = new graphic2.Group();
        itemGroup.onclick = zrUtil2.bind(this._onItemClick, this, piece);
        this._enableHoverLink(itemGroup, item.indexInModelPieceList);
        var representValue = visualMapModel.getRepresentValue(piece);
        this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
        if (showLabel) {
          var visualState = this.visualMapModel.getValueState(representValue);
          itemGroup.add(new graphic2.Text({
            style: {
              x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
              y: itemSize[1] / 2,
              text: piece.text,
              textVerticalAlign: "middle",
              textAlign: itemAlign,
              textFont,
              textFill,
              opacity: visualState === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        thisGroup.add(itemGroup);
      }
    },
    /**
     * @private
     */
    _enableHoverLink: function(itemGroup, pieceIndex) {
      itemGroup.on("mouseover", zrUtil2.bind(onHoverLink, this, "highlight")).on("mouseout", zrUtil2.bind(onHoverLink, this, "downplay"));
      function onHoverLink(method) {
        var visualMapModel = this.visualMapModel;
        visualMapModel.option.hoverLink && this.api.dispatchAction({
          type: method,
          batch: helper2.makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
        });
      }
    },
    /**
     * @private
     */
    _getItemAlign: function() {
      var visualMapModel = this.visualMapModel;
      var modelOption = visualMapModel.option;
      if (modelOption.orient === "vertical") {
        return helper2.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
      } else {
        var align = modelOption.align;
        if (!align || align === "auto") {
          align = "left";
        }
        return align;
      }
    },
    /**
     * @private
     */
    _renderEndsText: function(group, text2, itemSize, showLabel, itemAlign) {
      if (!text2) {
        return;
      }
      var itemGroup = new graphic2.Group();
      var textStyleModel = this.visualMapModel.textStyleModel;
      itemGroup.add(new graphic2.Text({
        style: {
          x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
          y: itemSize[1] / 2,
          textVerticalAlign: "middle",
          textAlign: showLabel ? itemAlign : "center",
          text: text2,
          textFont: textStyleModel.getFont(),
          textFill: textStyleModel.getTextColor()
        }
      }));
      group.add(itemGroup);
    },
    /**
     * @private
     * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
     */
    _getViewData: function() {
      var visualMapModel = this.visualMapModel;
      var viewPieceList = zrUtil2.map(visualMapModel.getPieceList(), function(piece, index2) {
        return {
          piece,
          indexInModelPieceList: index2
        };
      });
      var endsText = visualMapModel.get("text");
      var orient = visualMapModel.get("orient");
      var inverse = visualMapModel.get("inverse");
      if (orient === "horizontal" ? inverse : !inverse) {
        viewPieceList.reverse();
      } else if (endsText) {
        endsText = endsText.slice().reverse();
      }
      return {
        viewPieceList,
        endsText
      };
    },
    /**
     * @private
     */
    _createItemSymbol: function(group, representValue, shapeParam) {
      group.add(createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
    },
    /**
     * @private
     */
    _onItemClick: function(piece) {
      var visualMapModel = this.visualMapModel;
      var option = visualMapModel.option;
      var selected = zrUtil2.clone(option.selected);
      var newKey = visualMapModel.getSelectedMapKey(piece);
      if (option.selectedMode === "single") {
        selected[newKey] = true;
        zrUtil2.each(selected, function(o2, key) {
          selected[key] = key === newKey;
        });
      } else {
        selected[newKey] = !selected[newKey];
      }
      this.api.dispatchAction({
        type: "selectDataRange",
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected
      });
    }
  });
  var _default2 = PiecewiseVisualMapView;
  PiecewiseView = _default2;
  return PiecewiseView;
}
var hasRequiredVisualMapPiecewise;
function requireVisualMapPiecewise() {
  if (hasRequiredVisualMapPiecewise)
    return visualMapPiecewise;
  hasRequiredVisualMapPiecewise = 1;
  var echarts$12 = echarts;
  var preprocessor2 = requirePreprocessor();
  requireTypeDefaulter();
  requireVisualEncoding();
  requirePiecewiseModel();
  requirePiecewiseView();
  requireVisualMapAction();
  echarts$12.registerPreprocessor(preprocessor2);
  return visualMapPiecewise;
}
var hasRequiredVisualMap;
function requireVisualMap() {
  if (hasRequiredVisualMap)
    return visualMap;
  hasRequiredVisualMap = 1;
  requireVisualMapContinuous();
  requireVisualMapPiecewise();
  return visualMap;
}
var vml = {};
var graphic$1 = {};
var core$1 = {};
var hasRequiredCore$1;
function requireCore$1() {
  if (hasRequiredCore$1)
    return core$1;
  hasRequiredCore$1 = 1;
  var env2 = env_1;
  var urn = "urn:schemas-microsoft-com:vml";
  var win = typeof window === "undefined" ? null : window;
  var vmlInited = false;
  var doc = win && win.document;
  function createNode(tagName) {
    return doCreateNode(tagName);
  }
  var doCreateNode;
  if (doc && !env2.canvasSupported) {
    try {
      !doc.namespaces.zrvml && doc.namespaces.add("zrvml", urn);
      doCreateNode = function(tagName) {
        return doc.createElement("<zrvml:" + tagName + ' class="zrvml">');
      };
    } catch (e2) {
      doCreateNode = function(tagName) {
        return doc.createElement("<" + tagName + ' xmlns="' + urn + '" class="zrvml">');
      };
    }
  }
  function initVML() {
    if (vmlInited || !doc) {
      return;
    }
    vmlInited = true;
    var styleSheets = doc.styleSheets;
    if (styleSheets.length < 31) {
      doc.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)");
    } else {
      styleSheets[0].addRule(".zrvml", "behavior:url(#default#VML)");
    }
  }
  core$1.doc = doc;
  core$1.createNode = createNode;
  core$1.initVML = initVML;
  return core$1;
}
var hasRequiredGraphic$1;
function requireGraphic$1() {
  if (hasRequiredGraphic$1)
    return graphic$1;
  hasRequiredGraphic$1 = 1;
  var env2 = env_1;
  var _vector2 = requireVector();
  var applyTransform2 = _vector2.applyTransform;
  var BoundingRect2 = BoundingRect_1;
  var colorTool2 = color$1;
  var textContain2 = text;
  var textHelper2 = text$1;
  var RectText2 = RectText_1;
  var Displayable2 = Displayable_1;
  var ZImage2 = Image$2;
  var Text2 = Text_1;
  var Path2 = Path_1;
  var PathProxy2 = PathProxy_1;
  var Gradient2 = Gradient_1;
  var vmlCore = requireCore$1();
  var CMD2 = PathProxy2.CMD;
  var round2 = Math.round;
  var sqrt = Math.sqrt;
  var abs2 = Math.abs;
  var cos = Math.cos;
  var sin = Math.sin;
  var mathMax2 = Math.max;
  if (!env2.canvasSupported) {
    var comma = ",";
    var imageTransformPrefix = "progid:DXImageTransform.Microsoft";
    var Z = 21600;
    var Z2 = Z / 2;
    var ZLEVEL_BASE = 1e5;
    var Z_BASE = 1e3;
    var initRootElStyle = function(el) {
      el.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;";
      el.coordsize = Z + "," + Z;
      el.coordorigin = "0,0";
    };
    var encodeHtmlAttribute = function(s) {
      return String(s).replace(/&/g, "&amp;").replace(/"/g, "&quot;");
    };
    var rgb2Str = function(r, g, b) {
      return "rgb(" + [r, g, b].join(",") + ")";
    };
    var append = function(parent, child) {
      if (child && parent && child.parentNode !== parent) {
        parent.appendChild(child);
      }
    };
    var remove2 = function(parent, child) {
      if (child && parent && child.parentNode === parent) {
        parent.removeChild(child);
      }
    };
    var getZIndex = function(zlevel, z, z2) {
      return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
    };
    var parsePercent2 = textHelper2.parsePercent;
    var setColorAndOpacity = function(el, color2, opacity) {
      var colorArr = colorTool2.parse(color2);
      opacity = +opacity;
      if (isNaN(opacity)) {
        opacity = 1;
      }
      if (colorArr) {
        el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
        el.opacity = opacity * colorArr[3];
      }
    };
    var getColorAndAlpha = function(color2) {
      var colorArr = colorTool2.parse(color2);
      return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];
    };
    var updateFillNode = function(el, style, zrEl) {
      var fill = style.fill;
      if (fill != null) {
        if (fill instanceof Gradient2) {
          var gradientType;
          var angle = 0;
          var focus = [0, 0];
          var shift = 0;
          var expansion = 1;
          var rect = zrEl.getBoundingRect();
          var rectWidth = rect.width;
          var rectHeight = rect.height;
          if (fill.type === "linear") {
            gradientType = "gradient";
            var transform = zrEl.transform;
            var p0 = [fill.x * rectWidth, fill.y * rectHeight];
            var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];
            if (transform) {
              applyTransform2(p0, p0, transform);
              applyTransform2(p1, p1, transform);
            }
            var dx = p1[0] - p0[0];
            var dy = p1[1] - p0[1];
            angle = Math.atan2(dx, dy) * 180 / Math.PI;
            if (angle < 0) {
              angle += 360;
            }
            if (angle < 1e-6) {
              angle = 0;
            }
          } else {
            gradientType = "gradientradial";
            var p0 = [fill.x * rectWidth, fill.y * rectHeight];
            var transform = zrEl.transform;
            var scale = zrEl.scale;
            var width = rectWidth;
            var height = rectHeight;
            focus = [
              // Percent in bounding rect
              (p0[0] - rect.x) / width,
              (p0[1] - rect.y) / height
            ];
            if (transform) {
              applyTransform2(p0, p0, transform);
            }
            width /= scale[0] * Z;
            height /= scale[1] * Z;
            var dimension = mathMax2(width, height);
            shift = 2 * 0 / dimension;
            expansion = 2 * fill.r / dimension - shift;
          }
          var stops = fill.colorStops.slice();
          stops.sort(function(cs1, cs2) {
            return cs1.offset - cs2.offset;
          });
          var length = stops.length;
          var colorAndAlphaList = [];
          var colors = [];
          for (var i2 = 0; i2 < length; i2++) {
            var stop2 = stops[i2];
            var colorAndAlpha = getColorAndAlpha(stop2.color);
            colors.push(stop2.offset * expansion + shift + " " + colorAndAlpha[0]);
            if (i2 === 0 || i2 === length - 1) {
              colorAndAlphaList.push(colorAndAlpha);
            }
          }
          if (length >= 2) {
            var color1 = colorAndAlphaList[0][0];
            var color2 = colorAndAlphaList[1][0];
            var opacity1 = colorAndAlphaList[0][1] * style.opacity;
            var opacity2 = colorAndAlphaList[1][1] * style.opacity;
            el.type = gradientType;
            el.method = "none";
            el.focus = "100%";
            el.angle = angle;
            el.color = color1;
            el.color2 = color2;
            el.colors = colors.join(",");
            el.opacity = opacity2;
            el.opacity2 = opacity1;
          }
          if (gradientType === "radial") {
            el.focusposition = focus.join(",");
          }
        } else {
          setColorAndOpacity(el, fill, style.opacity);
        }
      }
    };
    var updateStrokeNode = function(el, style) {
      if (style.lineDash) {
        el.dashstyle = style.lineDash.join(" ");
      }
      if (style.stroke != null && !(style.stroke instanceof Gradient2)) {
        setColorAndOpacity(el, style.stroke, style.opacity);
      }
    };
    var updateFillAndStroke = function(vmlEl, type, style, zrEl) {
      var isFill = type === "fill";
      var el = vmlEl.getElementsByTagName(type)[0];
      if (style[type] != null && style[type] !== "none" && (isFill || !isFill && style.lineWidth)) {
        vmlEl[isFill ? "filled" : "stroked"] = "true";
        if (style[type] instanceof Gradient2) {
          remove2(vmlEl, el);
        }
        if (!el) {
          el = vmlCore.createNode(type);
        }
        isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
        append(vmlEl, el);
      } else {
        vmlEl[isFill ? "filled" : "stroked"] = "false";
        remove2(vmlEl, el);
      }
    };
    var points2 = [[], [], []];
    var pathDataToString = function(path2, m2) {
      var M = CMD2.M;
      var C = CMD2.C;
      var L = CMD2.L;
      var A = CMD2.A;
      var Q = CMD2.Q;
      var str = [];
      var nPoint;
      var cmdStr;
      var cmd;
      var i2;
      var xi;
      var yi;
      var data = path2.data;
      var dataLength = path2.len();
      for (i2 = 0; i2 < dataLength; ) {
        cmd = data[i2++];
        cmdStr = "";
        nPoint = 0;
        switch (cmd) {
          case M:
            cmdStr = " m ";
            nPoint = 1;
            xi = data[i2++];
            yi = data[i2++];
            points2[0][0] = xi;
            points2[0][1] = yi;
            break;
          case L:
            cmdStr = " l ";
            nPoint = 1;
            xi = data[i2++];
            yi = data[i2++];
            points2[0][0] = xi;
            points2[0][1] = yi;
            break;
          case Q:
          case C:
            cmdStr = " c ";
            nPoint = 3;
            var x1 = data[i2++];
            var y1 = data[i2++];
            var x2 = data[i2++];
            var y2 = data[i2++];
            var x3;
            var y3;
            if (cmd === Q) {
              x3 = x2;
              y3 = y2;
              x2 = (x2 + 2 * x1) / 3;
              y2 = (y2 + 2 * y1) / 3;
              x1 = (xi + 2 * x1) / 3;
              y1 = (yi + 2 * y1) / 3;
            } else {
              x3 = data[i2++];
              y3 = data[i2++];
            }
            points2[0][0] = x1;
            points2[0][1] = y1;
            points2[1][0] = x2;
            points2[1][1] = y2;
            points2[2][0] = x3;
            points2[2][1] = y3;
            xi = x3;
            yi = y3;
            break;
          case A:
            var x = 0;
            var y = 0;
            var sx = 1;
            var sy = 1;
            var angle = 0;
            if (m2) {
              x = m2[4];
              y = m2[5];
              sx = sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
              sy = sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
              angle = Math.atan2(-m2[1] / sy, m2[0] / sx);
            }
            var cx = data[i2++];
            var cy = data[i2++];
            var rx = data[i2++];
            var ry = data[i2++];
            var startAngle = data[i2++] + angle;
            var endAngle = data[i2++] + startAngle + angle;
            i2++;
            var clockwise = data[i2++];
            var x0 = cx + cos(startAngle) * rx;
            var y0 = cy + sin(startAngle) * ry;
            var x1 = cx + cos(endAngle) * rx;
            var y1 = cy + sin(endAngle) * ry;
            var type = clockwise ? " wa " : " at ";
            if (Math.abs(x0 - x1) < 1e-4) {
              if (Math.abs(endAngle - startAngle) > 0.01) {
                if (clockwise) {
                  x0 += 270 / Z;
                }
              } else {
                if (Math.abs(y0 - cy) < 1e-4) {
                  if (clockwise && x0 < cx || !clockwise && x0 > cx) {
                    y1 -= 270 / Z;
                  } else {
                    y1 += 270 / Z;
                  }
                } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {
                  x1 += 270 / Z;
                } else {
                  x1 -= 270 / Z;
                }
              }
            }
            str.push(type, round2(((cx - rx) * sx + x) * Z - Z2), comma, round2(((cy - ry) * sy + y) * Z - Z2), comma, round2(((cx + rx) * sx + x) * Z - Z2), comma, round2(((cy + ry) * sy + y) * Z - Z2), comma, round2((x0 * sx + x) * Z - Z2), comma, round2((y0 * sy + y) * Z - Z2), comma, round2((x1 * sx + x) * Z - Z2), comma, round2((y1 * sy + y) * Z - Z2));
            xi = x1;
            yi = y1;
            break;
          case CMD2.R:
            var p0 = points2[0];
            var p1 = points2[1];
            p0[0] = data[i2++];
            p0[1] = data[i2++];
            p1[0] = p0[0] + data[i2++];
            p1[1] = p0[1] + data[i2++];
            if (m2) {
              applyTransform2(p0, p0, m2);
              applyTransform2(p1, p1, m2);
            }
            p0[0] = round2(p0[0] * Z - Z2);
            p1[0] = round2(p1[0] * Z - Z2);
            p0[1] = round2(p0[1] * Z - Z2);
            p1[1] = round2(p1[1] * Z - Z2);
            str.push(
              // x0, y0
              " m ",
              p0[0],
              comma,
              p0[1],
              // x1, y0
              " l ",
              p1[0],
              comma,
              p0[1],
              // x1, y1
              " l ",
              p1[0],
              comma,
              p1[1],
              // x0, y1
              " l ",
              p0[0],
              comma,
              p1[1]
            );
            break;
          case CMD2.Z:
            str.push(" x ");
        }
        if (nPoint > 0) {
          str.push(cmdStr);
          for (var k = 0; k < nPoint; k++) {
            var p2 = points2[k];
            m2 && applyTransform2(p2, p2, m2);
            str.push(round2(p2[0] * Z - Z2), comma, round2(p2[1] * Z - Z2), k < nPoint - 1 ? comma : "");
          }
        }
      }
      return str.join("");
    };
    Path2.prototype.brushVML = function(vmlRoot) {
      var style = this.style;
      var vmlEl = this._vmlEl;
      if (!vmlEl) {
        vmlEl = vmlCore.createNode("shape");
        initRootElStyle(vmlEl);
        this._vmlEl = vmlEl;
      }
      updateFillAndStroke(vmlEl, "fill", style, this);
      updateFillAndStroke(vmlEl, "stroke", style, this);
      var m2 = this.transform;
      var needTransform = m2 != null;
      var strokeEl = vmlEl.getElementsByTagName("stroke")[0];
      if (strokeEl) {
        var lineWidth = style.lineWidth;
        if (needTransform && !style.strokeNoScale) {
          var det = m2[0] * m2[3] - m2[1] * m2[2];
          lineWidth *= sqrt(abs2(det));
        }
        strokeEl.weight = lineWidth + "px";
      }
      var path2 = this.path || (this.path = new PathProxy2());
      if (this.__dirtyPath) {
        path2.beginPath();
        path2.subPixelOptimize = false;
        this.buildPath(path2, this.shape);
        path2.toStatic();
        this.__dirtyPath = false;
      }
      vmlEl.path = pathDataToString(path2, this.transform);
      vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
      append(vmlRoot, vmlEl);
      if (style.text != null) {
        this.drawRectText(vmlRoot, this.getBoundingRect());
      } else {
        this.removeRectText(vmlRoot);
      }
    };
    Path2.prototype.onRemove = function(vmlRoot) {
      remove2(vmlRoot, this._vmlEl);
      this.removeRectText(vmlRoot);
    };
    Path2.prototype.onAdd = function(vmlRoot) {
      append(vmlRoot, this._vmlEl);
      this.appendRectText(vmlRoot);
    };
    var isImage = function(img) {
      return typeof img === "object" && img.tagName && img.tagName.toUpperCase() === "IMG";
    };
    ZImage2.prototype.brushVML = function(vmlRoot) {
      var style = this.style;
      var image2 = style.image;
      var ow;
      var oh;
      if (isImage(image2)) {
        var src = image2.src;
        if (src === this._imageSrc) {
          ow = this._imageWidth;
          oh = this._imageHeight;
        } else {
          var imageRuntimeStyle = image2.runtimeStyle;
          var oldRuntimeWidth = imageRuntimeStyle.width;
          var oldRuntimeHeight = imageRuntimeStyle.height;
          imageRuntimeStyle.width = "auto";
          imageRuntimeStyle.height = "auto";
          ow = image2.width;
          oh = image2.height;
          imageRuntimeStyle.width = oldRuntimeWidth;
          imageRuntimeStyle.height = oldRuntimeHeight;
          this._imageSrc = src;
          this._imageWidth = ow;
          this._imageHeight = oh;
        }
        image2 = src;
      } else {
        if (image2 === this._imageSrc) {
          ow = this._imageWidth;
          oh = this._imageHeight;
        }
      }
      if (!image2) {
        return;
      }
      var x = style.x || 0;
      var y = style.y || 0;
      var dw = style.width;
      var dh = style.height;
      var sw = style.sWidth;
      var sh = style.sHeight;
      var sx = style.sx || 0;
      var sy = style.sy || 0;
      var hasCrop = sw && sh;
      var vmlEl = this._vmlEl;
      if (!vmlEl) {
        vmlEl = vmlCore.doc.createElement("div");
        initRootElStyle(vmlEl);
        this._vmlEl = vmlEl;
      }
      var vmlElStyle = vmlEl.style;
      var hasRotation = false;
      var m2;
      var scaleX = 1;
      var scaleY = 1;
      if (this.transform) {
        m2 = this.transform;
        scaleX = sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
        scaleY = sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
        hasRotation = m2[1] || m2[2];
      }
      if (hasRotation) {
        var p0 = [x, y];
        var p1 = [x + dw, y];
        var p2 = [x, y + dh];
        var p3 = [x + dw, y + dh];
        applyTransform2(p0, p0, m2);
        applyTransform2(p1, p1, m2);
        applyTransform2(p2, p2, m2);
        applyTransform2(p3, p3, m2);
        var maxX = mathMax2(p0[0], p1[0], p2[0], p3[0]);
        var maxY = mathMax2(p0[1], p1[1], p2[1], p3[1]);
        var transformFilter = [];
        transformFilter.push("M11=", m2[0] / scaleX, comma, "M12=", m2[2] / scaleY, comma, "M21=", m2[1] / scaleX, comma, "M22=", m2[3] / scaleY, comma, "Dx=", round2(x * scaleX + m2[4]), comma, "Dy=", round2(y * scaleY + m2[5]));
        vmlElStyle.padding = "0 " + round2(maxX) + "px " + round2(maxY) + "px 0";
        vmlElStyle.filter = imageTransformPrefix + ".Matrix(" + transformFilter.join("") + ", SizingMethod=clip)";
      } else {
        if (m2) {
          x = x * scaleX + m2[4];
          y = y * scaleY + m2[5];
        }
        vmlElStyle.filter = "";
        vmlElStyle.left = round2(x) + "px";
        vmlElStyle.top = round2(y) + "px";
      }
      var imageEl = this._imageEl;
      var cropEl = this._cropEl;
      if (!imageEl) {
        imageEl = vmlCore.doc.createElement("div");
        this._imageEl = imageEl;
      }
      var imageELStyle = imageEl.style;
      if (hasCrop) {
        if (!(ow && oh)) {
          var tmpImage = new Image();
          var self2 = this;
          tmpImage.onload = function() {
            tmpImage.onload = null;
            ow = tmpImage.width;
            oh = tmpImage.height;
            imageELStyle.width = round2(scaleX * ow * dw / sw) + "px";
            imageELStyle.height = round2(scaleY * oh * dh / sh) + "px";
            self2._imageWidth = ow;
            self2._imageHeight = oh;
            self2._imageSrc = image2;
          };
          tmpImage.src = image2;
        } else {
          imageELStyle.width = round2(scaleX * ow * dw / sw) + "px";
          imageELStyle.height = round2(scaleY * oh * dh / sh) + "px";
        }
        if (!cropEl) {
          cropEl = vmlCore.doc.createElement("div");
          cropEl.style.overflow = "hidden";
          this._cropEl = cropEl;
        }
        var cropElStyle = cropEl.style;
        cropElStyle.width = round2((dw + sx * dw / sw) * scaleX);
        cropElStyle.height = round2((dh + sy * dh / sh) * scaleY);
        cropElStyle.filter = imageTransformPrefix + ".Matrix(Dx=" + -sx * dw / sw * scaleX + ",Dy=" + -sy * dh / sh * scaleY + ")";
        if (!cropEl.parentNode) {
          vmlEl.appendChild(cropEl);
        }
        if (imageEl.parentNode !== cropEl) {
          cropEl.appendChild(imageEl);
        }
      } else {
        imageELStyle.width = round2(scaleX * dw) + "px";
        imageELStyle.height = round2(scaleY * dh) + "px";
        vmlEl.appendChild(imageEl);
        if (cropEl && cropEl.parentNode) {
          vmlEl.removeChild(cropEl);
          this._cropEl = null;
        }
      }
      var filterStr = "";
      var alpha = style.opacity;
      if (alpha < 1) {
        filterStr += ".Alpha(opacity=" + round2(alpha * 100) + ") ";
      }
      filterStr += imageTransformPrefix + ".AlphaImageLoader(src=" + image2 + ", SizingMethod=scale)";
      imageELStyle.filter = filterStr;
      vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
      append(vmlRoot, vmlEl);
      if (style.text != null) {
        this.drawRectText(vmlRoot, this.getBoundingRect());
      }
    };
    ZImage2.prototype.onRemove = function(vmlRoot) {
      remove2(vmlRoot, this._vmlEl);
      this._vmlEl = null;
      this._cropEl = null;
      this._imageEl = null;
      this.removeRectText(vmlRoot);
    };
    ZImage2.prototype.onAdd = function(vmlRoot) {
      append(vmlRoot, this._vmlEl);
      this.appendRectText(vmlRoot);
    };
    var DEFAULT_STYLE_NORMAL = "normal";
    var fontStyleCache = {};
    var fontStyleCacheCount = 0;
    var MAX_FONT_CACHE_SIZE = 100;
    var fontEl = document.createElement("div");
    var getFontStyle = function(fontString) {
      var fontStyle = fontStyleCache[fontString];
      if (!fontStyle) {
        if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
          fontStyleCacheCount = 0;
          fontStyleCache = {};
        }
        var style = fontEl.style;
        var fontFamily;
        try {
          style.font = fontString;
          fontFamily = style.fontFamily.split(",")[0];
        } catch (e2) {
        }
        fontStyle = {
          style: style.fontStyle || DEFAULT_STYLE_NORMAL,
          variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
          weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
          size: parseFloat(style.fontSize || 12) | 0,
          family: fontFamily || "Microsoft YaHei"
        };
        fontStyleCache[fontString] = fontStyle;
        fontStyleCacheCount++;
      }
      return fontStyle;
    };
    var textMeasureEl;
    textContain2.$override("measureText", function(text2, textFont) {
      var doc = vmlCore.doc;
      if (!textMeasureEl) {
        textMeasureEl = doc.createElement("div");
        textMeasureEl.style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;";
        vmlCore.doc.body.appendChild(textMeasureEl);
      }
      try {
        textMeasureEl.style.font = textFont;
      } catch (ex) {
      }
      textMeasureEl.innerHTML = "";
      textMeasureEl.appendChild(doc.createTextNode(text2));
      return {
        width: textMeasureEl.offsetWidth
      };
    });
    var tmpRect2 = new BoundingRect2();
    var drawRectText = function(vmlRoot, rect, textRect, fromTextEl) {
      var style = this.style;
      this.__dirty && textHelper2.normalizeTextStyle(style, true);
      var text2 = style.text;
      text2 != null && (text2 += "");
      if (!text2) {
        return;
      }
      if (style.rich) {
        var contentBlock = textContain2.parseRichText(text2, style);
        text2 = [];
        for (var i2 = 0; i2 < contentBlock.lines.length; i2++) {
          var tokens = contentBlock.lines[i2].tokens;
          var textLine = [];
          for (var j = 0; j < tokens.length; j++) {
            textLine.push(tokens[j].text);
          }
          text2.push(textLine.join(""));
        }
        text2 = text2.join("\n");
      }
      var x;
      var y;
      var align = style.textAlign;
      var verticalAlign = style.textVerticalAlign;
      var fontStyle = getFontStyle(style.font);
      var font = fontStyle.style + " " + fontStyle.variant + " " + fontStyle.weight + " " + fontStyle.size + 'px "' + fontStyle.family + '"';
      textRect = textRect || textContain2.getBoundingRect(text2, font, align, verticalAlign, style.textPadding, style.textLineHeight);
      var m2 = this.transform;
      if (m2 && !fromTextEl) {
        tmpRect2.copy(rect);
        tmpRect2.applyTransform(m2);
        rect = tmpRect2;
      }
      if (!fromTextEl) {
        var textPosition = style.textPosition;
        if (textPosition instanceof Array) {
          x = rect.x + parsePercent2(textPosition[0], rect.width);
          y = rect.y + parsePercent2(textPosition[1], rect.height);
          align = align || "left";
        } else {
          var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain2.calculateTextPosition({}, style, rect);
          x = res.x;
          y = res.y;
          align = align || res.textAlign;
          verticalAlign = verticalAlign || res.textVerticalAlign;
        }
      } else {
        x = rect.x;
        y = rect.y;
      }
      x = textContain2.adjustTextX(x, textRect.width, align);
      y = textContain2.adjustTextY(y, textRect.height, verticalAlign);
      y += textRect.height / 2;
      var createNode = vmlCore.createNode;
      var textVmlEl = this._textVmlEl;
      var pathEl;
      var textPathEl;
      var skewEl;
      if (!textVmlEl) {
        textVmlEl = createNode("line");
        pathEl = createNode("path");
        textPathEl = createNode("textpath");
        skewEl = createNode("skew");
        textPathEl.style["v-text-align"] = "left";
        initRootElStyle(textVmlEl);
        pathEl.textpathok = true;
        textPathEl.on = true;
        textVmlEl.from = "0 0";
        textVmlEl.to = "1000 0.05";
        append(textVmlEl, skewEl);
        append(textVmlEl, pathEl);
        append(textVmlEl, textPathEl);
        this._textVmlEl = textVmlEl;
      } else {
        skewEl = textVmlEl.firstChild;
        pathEl = skewEl.nextSibling;
        textPathEl = pathEl.nextSibling;
      }
      var coords = [x, y];
      var textVmlElStyle = textVmlEl.style;
      if (m2 && fromTextEl) {
        applyTransform2(coords, coords, m2);
        skewEl.on = true;
        skewEl.matrix = m2[0].toFixed(3) + comma + m2[2].toFixed(3) + comma + m2[1].toFixed(3) + comma + m2[3].toFixed(3) + ",0,0";
        skewEl.offset = (round2(coords[0]) || 0) + "," + (round2(coords[1]) || 0);
        skewEl.origin = "0 0";
        textVmlElStyle.left = "0px";
        textVmlElStyle.top = "0px";
      } else {
        skewEl.on = false;
        textVmlElStyle.left = round2(x) + "px";
        textVmlElStyle.top = round2(y) + "px";
      }
      textPathEl.string = encodeHtmlAttribute(text2);
      try {
        textPathEl.style.font = font;
      } catch (e2) {
      }
      updateFillAndStroke(textVmlEl, "fill", {
        fill: style.textFill,
        opacity: style.opacity
      }, this);
      updateFillAndStroke(textVmlEl, "stroke", {
        stroke: style.textStroke,
        opacity: style.opacity,
        lineDash: style.lineDash || null
        // style.lineDash can be `false`.
      }, this);
      textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
      append(vmlRoot, textVmlEl);
    };
    var removeRectText = function(vmlRoot) {
      remove2(vmlRoot, this._textVmlEl);
      this._textVmlEl = null;
    };
    var appendRectText = function(vmlRoot) {
      append(vmlRoot, this._textVmlEl);
    };
    var list = [RectText2, Displayable2, ZImage2, Path2, Text2];
    for (var i = 0; i < list.length; i++) {
      var proto2 = list[i].prototype;
      proto2.drawRectText = drawRectText;
      proto2.removeRectText = removeRectText;
      proto2.appendRectText = appendRectText;
    }
    Text2.prototype.brushVML = function(vmlRoot) {
      var style = this.style;
      if (style.text != null) {
        this.drawRectText(vmlRoot, {
          x: style.x || 0,
          y: style.y || 0,
          width: 0,
          height: 0
        }, this.getBoundingRect(), true);
      } else {
        this.removeRectText(vmlRoot);
      }
    };
    Text2.prototype.onRemove = function(vmlRoot) {
      this.removeRectText(vmlRoot);
    };
    Text2.prototype.onAdd = function(vmlRoot) {
      this.appendRectText(vmlRoot);
    };
  }
  return graphic$1;
}
var Painter$1;
var hasRequiredPainter$1;
function requirePainter$1() {
  if (hasRequiredPainter$1)
    return Painter$1;
  hasRequiredPainter$1 = 1;
  var logError2 = log;
  var vmlCore = requireCore$1();
  var _util2 = util$6;
  var each2 = _util2.each;
  function parseInt102(val) {
    return parseInt(val, 10);
  }
  function VMLPainter(root, storage2) {
    vmlCore.initVML();
    this.root = root;
    this.storage = storage2;
    var vmlViewport = document.createElement("div");
    var vmlRoot = document.createElement("div");
    vmlViewport.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;";
    vmlRoot.style.cssText = "position:absolute;left:0;top:0;";
    root.appendChild(vmlViewport);
    this._vmlRoot = vmlRoot;
    this._vmlViewport = vmlViewport;
    this.resize();
    var oldDelFromStorage = storage2.delFromStorage;
    var oldAddToStorage = storage2.addToStorage;
    storage2.delFromStorage = function(el) {
      oldDelFromStorage.call(storage2, el);
      if (el) {
        el.onRemove && el.onRemove(vmlRoot);
      }
    };
    storage2.addToStorage = function(el) {
      el.onAdd && el.onAdd(vmlRoot);
      oldAddToStorage.call(storage2, el);
    };
    this._firstPaint = true;
  }
  VMLPainter.prototype = {
    constructor: VMLPainter,
    getType: function() {
      return "vml";
    },
    /**
     * @return {HTMLDivElement}
     */
    getViewportRoot: function() {
      return this._vmlViewport;
    },
    getViewportRootOffset: function() {
      var viewportRoot = this.getViewportRoot();
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        };
      }
    },
    /**
     * 刷新
     */
    refresh: function() {
      var list = this.storage.getDisplayList(true, true);
      this._paintList(list);
    },
    _paintList: function(list) {
      var vmlRoot = this._vmlRoot;
      for (var i = 0; i < list.length; i++) {
        var el = list[i];
        if (el.invisible || el.ignore) {
          if (!el.__alreadyNotVisible) {
            el.onRemove(vmlRoot);
          }
          el.__alreadyNotVisible = true;
        } else {
          if (el.__alreadyNotVisible) {
            el.onAdd(vmlRoot);
          }
          el.__alreadyNotVisible = false;
          if (el.__dirty) {
            el.beforeBrush && el.beforeBrush();
            (el.brushVML || el.brush).call(el, vmlRoot);
            el.afterBrush && el.afterBrush();
          }
        }
        el.__dirty = false;
      }
      if (this._firstPaint) {
        this._vmlViewport.appendChild(vmlRoot);
        this._firstPaint = false;
      }
    },
    resize: function(width, height) {
      var width = width == null ? this._getWidth() : width;
      var height = height == null ? this._getHeight() : height;
      if (this._width !== width || this._height !== height) {
        this._width = width;
        this._height = height;
        var vmlViewportStyle = this._vmlViewport.style;
        vmlViewportStyle.width = width + "px";
        vmlViewportStyle.height = height + "px";
      }
    },
    dispose: function() {
      this.root.innerHTML = "";
      this._vmlRoot = this._vmlViewport = this.storage = null;
    },
    getWidth: function() {
      return this._width;
    },
    getHeight: function() {
      return this._height;
    },
    clear: function() {
      if (this._vmlViewport) {
        this.root.removeChild(this._vmlViewport);
      }
    },
    _getWidth: function() {
      var root = this.root;
      var stl = root.currentStyle;
      return (root.clientWidth || parseInt102(stl.width)) - parseInt102(stl.paddingLeft) - parseInt102(stl.paddingRight) | 0;
    },
    _getHeight: function() {
      var root = this.root;
      var stl = root.currentStyle;
      return (root.clientHeight || parseInt102(stl.height)) - parseInt102(stl.paddingTop) - parseInt102(stl.paddingBottom) | 0;
    }
  };
  function createMethodNotSupport(method) {
    return function() {
      logError2('In IE8.0 VML mode painter not support method "' + method + '"');
    };
  }
  each2(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(name2) {
    VMLPainter.prototype[name2] = createMethodNotSupport(name2);
  });
  var _default2 = VMLPainter;
  Painter$1 = _default2;
  return Painter$1;
}
var hasRequiredVml;
function requireVml() {
  if (hasRequiredVml)
    return vml;
  hasRequiredVml = 1;
  requireGraphic$1();
  var _zrender = zrender;
  var registerPainter2 = _zrender.registerPainter;
  var Painter2 = requirePainter$1();
  registerPainter2("vml", Painter2);
  return vml;
}
var svg = {};
var graphic = {};
var core = {};
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core;
  hasRequiredCore = 1;
  var svgURI = "http://www.w3.org/2000/svg";
  function createElement(name2) {
    return document.createElementNS(svgURI, name2);
  }
  core.createElement = createElement;
  return core;
}
var hasRequiredGraphic;
function requireGraphic() {
  if (hasRequiredGraphic)
    return graphic;
  hasRequiredGraphic = 1;
  var _core = requireCore();
  var createElement = _core.createElement;
  var PathProxy2 = PathProxy_1;
  var BoundingRect2 = BoundingRect_1;
  var matrix2 = requireMatrix();
  var textContain2 = text;
  var textHelper2 = text$1;
  var Text2 = Text_1;
  var CMD2 = PathProxy2.CMD;
  var arrayJoin = Array.prototype.join;
  var NONE = "none";
  var mathRound = Math.round;
  var mathSin2 = Math.sin;
  var mathCos2 = Math.cos;
  var PI3 = Math.PI;
  var PI22 = Math.PI * 2;
  var degree = 180 / PI3;
  var EPSILON2 = 1e-4;
  function round4(val) {
    return mathRound(val * 1e4) / 1e4;
  }
  function isAroundZero2(val) {
    return val < EPSILON2 && val > -EPSILON2;
  }
  function pathHasFill(style, isText) {
    var fill = isText ? style.textFill : style.fill;
    return fill != null && fill !== NONE;
  }
  function pathHasStroke(style, isText) {
    var stroke = isText ? style.textStroke : style.stroke;
    return stroke != null && stroke !== NONE;
  }
  function setTransform(svgEl, m2) {
    if (m2) {
      attr(svgEl, "transform", "matrix(" + arrayJoin.call(m2, ",") + ")");
    }
  }
  function attr(el, key, val) {
    if (!val || val.type !== "linear" && val.type !== "radial") {
      el.setAttribute(key, val);
    }
  }
  function attrXLink(el, key, val) {
    el.setAttributeNS("http://www.w3.org/1999/xlink", key, val);
  }
  function bindStyle(svgEl, style, isText, el) {
    if (pathHasFill(style, isText)) {
      var fill = isText ? style.textFill : style.fill;
      fill = fill === "transparent" ? NONE : fill;
      attr(svgEl, "fill", fill);
      attr(svgEl, "fill-opacity", style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);
    } else {
      attr(svgEl, "fill", NONE);
    }
    if (pathHasStroke(style, isText)) {
      var stroke = isText ? style.textStroke : style.stroke;
      stroke = stroke === "transparent" ? NONE : stroke;
      attr(svgEl, "stroke", stroke);
      var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;
      var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;
      attr(svgEl, "stroke-width", strokeWidth / strokeScale);
      attr(svgEl, "paint-order", isText ? "stroke" : "fill");
      attr(svgEl, "stroke-opacity", style.strokeOpacity != null ? style.strokeOpacity : style.opacity);
      var lineDash = style.lineDash;
      if (lineDash) {
        attr(svgEl, "stroke-dasharray", style.lineDash.join(","));
        attr(svgEl, "stroke-dashoffset", mathRound(style.lineDashOffset || 0));
      } else {
        attr(svgEl, "stroke-dasharray", "");
      }
      style.lineCap && attr(svgEl, "stroke-linecap", style.lineCap);
      style.lineJoin && attr(svgEl, "stroke-linejoin", style.lineJoin);
      style.miterLimit && attr(svgEl, "stroke-miterlimit", style.miterLimit);
    } else {
      attr(svgEl, "stroke", NONE);
    }
  }
  function pathDataToString(path2) {
    var str = [];
    var data = path2.data;
    var dataLength = path2.len();
    for (var i = 0; i < dataLength; ) {
      var cmd = data[i++];
      var cmdStr = "";
      var nData = 0;
      switch (cmd) {
        case CMD2.M:
          cmdStr = "M";
          nData = 2;
          break;
        case CMD2.L:
          cmdStr = "L";
          nData = 2;
          break;
        case CMD2.Q:
          cmdStr = "Q";
          nData = 4;
          break;
        case CMD2.C:
          cmdStr = "C";
          nData = 6;
          break;
        case CMD2.A:
          var cx = data[i++];
          var cy = data[i++];
          var rx = data[i++];
          var ry = data[i++];
          var theta = data[i++];
          var dTheta = data[i++];
          var psi = data[i++];
          var clockwise = data[i++];
          var dThetaPositive = Math.abs(dTheta);
          var isCircle = isAroundZero2(dThetaPositive - PI22) || (clockwise ? dTheta >= PI22 : -dTheta >= PI22);
          var unifiedTheta = dTheta > 0 ? dTheta % PI22 : dTheta % PI22 + PI22;
          var large = false;
          if (isCircle) {
            large = true;
          } else if (isAroundZero2(dThetaPositive)) {
            large = false;
          } else {
            large = unifiedTheta >= PI3 === !!clockwise;
          }
          var x0 = round4(cx + rx * mathCos2(theta));
          var y0 = round4(cy + ry * mathSin2(theta));
          if (isCircle) {
            if (clockwise) {
              dTheta = PI22 - 1e-4;
            } else {
              dTheta = -PI22 + 1e-4;
            }
            large = true;
            if (i === 9) {
              str.push("M", x0, y0);
            }
          }
          var x = round4(cx + rx * mathCos2(theta + dTheta));
          var y = round4(cy + ry * mathSin2(theta + dTheta));
          str.push("A", round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);
          break;
        case CMD2.Z:
          cmdStr = "Z";
          break;
        case CMD2.R:
          var x = round4(data[i++]);
          var y = round4(data[i++]);
          var w = round4(data[i++]);
          var h = round4(data[i++]);
          str.push("M", x, y, "L", x + w, y, "L", x + w, y + h, "L", x, y + h, "L", x, y);
          break;
      }
      cmdStr && str.push(cmdStr);
      for (var j = 0; j < nData; j++) {
        str.push(round4(data[i++]));
      }
    }
    return str.join(" ");
  }
  var svgPath = {};
  svgPath.brush = function(el) {
    var style = el.style;
    var svgEl = el.__svgEl;
    if (!svgEl) {
      svgEl = createElement("path");
      el.__svgEl = svgEl;
    }
    if (!el.path) {
      el.createPathProxy();
    }
    var path2 = el.path;
    if (el.__dirtyPath) {
      path2.beginPath();
      path2.subPixelOptimize = false;
      el.buildPath(path2, el.shape);
      el.__dirtyPath = false;
      var pathStr = pathDataToString(path2);
      if (pathStr.indexOf("NaN") < 0) {
        attr(svgEl, "d", pathStr);
      }
    }
    bindStyle(svgEl, style, false, el);
    setTransform(svgEl, el.transform);
    if (style.text != null) {
      svgTextDrawRectText(el, el.getBoundingRect());
    } else {
      removeOldTextNode(el);
    }
  };
  var svgImage = {};
  svgImage.brush = function(el) {
    var style = el.style;
    var image2 = style.image;
    if (image2 instanceof HTMLImageElement) {
      var src = image2.src;
      image2 = src;
    }
    if (!image2) {
      return;
    }
    var x = style.x || 0;
    var y = style.y || 0;
    var dw = style.width;
    var dh = style.height;
    var svgEl = el.__svgEl;
    if (!svgEl) {
      svgEl = createElement("image");
      el.__svgEl = svgEl;
    }
    if (image2 !== el.__imageSrc) {
      attrXLink(svgEl, "href", image2);
      el.__imageSrc = image2;
    }
    attr(svgEl, "width", dw);
    attr(svgEl, "height", dh);
    attr(svgEl, "x", x);
    attr(svgEl, "y", y);
    setTransform(svgEl, el.transform);
    if (style.text != null) {
      svgTextDrawRectText(el, el.getBoundingRect());
    } else {
      removeOldTextNode(el);
    }
  };
  var svgText = {};
  var _tmpTextHostRect = new BoundingRect2();
  var _tmpTextBoxPos = {};
  var _tmpTextTransform = [];
  var TEXT_ALIGN_TO_ANCHRO = {
    left: "start",
    right: "end",
    center: "middle",
    middle: "middle"
  };
  var svgTextDrawRectText = function(el, hostRect) {
    var style = el.style;
    var elTransform = el.transform;
    var needTransformTextByHostEl = el instanceof Text2 || style.transformText;
    el.__dirty && textHelper2.normalizeTextStyle(style, true);
    var text2 = style.text;
    text2 != null && (text2 += "");
    if (!textHelper2.needDrawText(text2, style)) {
      return;
    }
    text2 == null && (text2 = "");
    if (!needTransformTextByHostEl && elTransform) {
      _tmpTextHostRect.copy(hostRect);
      _tmpTextHostRect.applyTransform(elTransform);
      hostRect = _tmpTextHostRect;
    }
    var textSvgEl = el.__textSvgEl;
    if (!textSvgEl) {
      textSvgEl = createElement("text");
      el.__textSvgEl = textSvgEl;
    }
    var textSvgElStyle = textSvgEl.style;
    var font = style.font || textContain2.DEFAULT_FONT;
    var computedFont = textSvgEl.__computedFont;
    if (font !== textSvgEl.__styleFont) {
      textSvgElStyle.font = textSvgEl.__styleFont = font;
      computedFont = textSvgEl.__computedFont = textSvgElStyle.font;
    }
    var textPadding = style.textPadding;
    var textLineHeight = style.textLineHeight;
    var contentBlock = el.__textCotentBlock;
    if (!contentBlock || el.__dirtyText) {
      contentBlock = el.__textCotentBlock = textContain2.parsePlainText(text2, computedFont, textPadding, textLineHeight, style.truncate);
    }
    var outerHeight = contentBlock.outerHeight;
    var lineHeight = contentBlock.lineHeight;
    textHelper2.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);
    var baseX = _tmpTextBoxPos.baseX;
    var baseY = _tmpTextBoxPos.baseY;
    var textAlign = _tmpTextBoxPos.textAlign || "left";
    var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;
    setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);
    var boxY = textContain2.adjustTextY(baseY, outerHeight, textVerticalAlign);
    var textX = baseX;
    var textY = boxY;
    if (textPadding) {
      textX = getTextXForPadding2(baseX, textAlign, textPadding);
      textY += textPadding[0];
    }
    textY += lineHeight / 2;
    bindStyle(textSvgEl, style, true, el);
    var canCacheByTextString = contentBlock.canCacheByTextString;
    var tspanList = el.__tspanList || (el.__tspanList = []);
    var tspanOriginLen = tspanList.length;
    if (canCacheByTextString && el.__canCacheByTextString && el.__text === text2) {
      if (el.__dirtyText && tspanOriginLen) {
        for (var idx = 0; idx < tspanOriginLen; ++idx) {
          updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);
        }
      }
    } else {
      el.__text = text2;
      el.__canCacheByTextString = canCacheByTextString;
      var textLines = contentBlock.lines;
      var nTextLines = textLines.length;
      var idx = 0;
      for (; idx < nTextLines; idx++) {
        var tspan = tspanList[idx];
        var singleLineText = textLines[idx];
        if (!tspan) {
          tspan = tspanList[idx] = createElement("tspan");
          textSvgEl.appendChild(tspan);
          tspan.appendChild(document.createTextNode(singleLineText));
        } else if (tspan.__zrText !== singleLineText) {
          tspan.innerHTML = "";
          tspan.appendChild(document.createTextNode(singleLineText));
        }
        updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);
      }
      if (tspanOriginLen > nTextLines) {
        for (; idx < tspanOriginLen; idx++) {
          textSvgEl.removeChild(tspanList[idx]);
        }
        tspanList.length = nTextLines;
      }
    }
  };
  function setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {
    matrix2.identity(_tmpTextTransform);
    if (needTransformTextByHostEl && elTransform) {
      matrix2.copy(_tmpTextTransform, elTransform);
    }
    var textRotation = style.textRotation;
    if (hostRect && textRotation) {
      var origin = style.textOrigin;
      if (origin === "center") {
        baseX = hostRect.width / 2 + hostRect.x;
        baseY = hostRect.height / 2 + hostRect.y;
      } else if (origin) {
        baseX = origin[0] + hostRect.x;
        baseY = origin[1] + hostRect.y;
      }
      _tmpTextTransform[4] -= baseX;
      _tmpTextTransform[5] -= baseY;
      matrix2.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);
      _tmpTextTransform[4] += baseX;
      _tmpTextTransform[5] += baseY;
    }
    setTransform(textSvgEl, _tmpTextTransform);
  }
  function getTextXForPadding2(x, textAlign, textPadding) {
    return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
  }
  function updateTextLocation(tspan, textAlign, x, y) {
    attr(tspan, "dominant-baseline", "middle");
    attr(tspan, "text-anchor", TEXT_ALIGN_TO_ANCHRO[textAlign]);
    attr(tspan, "x", x);
    attr(tspan, "y", y);
  }
  function removeOldTextNode(el) {
    if (el && el.__textSvgEl) {
      if (el.__textSvgEl.parentNode) {
        el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);
      }
      el.__textSvgEl = null;
      el.__tspanList = [];
      el.__text = null;
    }
  }
  svgText.drawRectText = svgTextDrawRectText;
  svgText.brush = function(el) {
    var style = el.style;
    if (style.text != null) {
      svgTextDrawRectText(el, false);
    } else {
      removeOldTextNode(el);
    }
  };
  graphic.path = svgPath;
  graphic.image = svgImage;
  graphic.text = svgText;
  return graphic;
}
var arrayDiff2;
var hasRequiredArrayDiff2;
function requireArrayDiff2() {
  if (hasRequiredArrayDiff2)
    return arrayDiff2;
  hasRequiredArrayDiff2 = 1;
  function Diff() {
  }
  Diff.prototype = {
    diff: function(oldArr, newArr, equals) {
      if (!equals) {
        equals = function(a, b) {
          return a === b;
        };
      }
      this.equals = equals;
      var self2 = this;
      oldArr = oldArr.slice();
      newArr = newArr.slice();
      var newLen = newArr.length;
      var oldLen = oldArr.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      var bestPath = [{
        newPos: -1,
        components: []
      }];
      var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);
      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        var indices = [];
        for (var i = 0; i < newArr.length; i++) {
          indices.push(i);
        }
        return [{
          indices,
          count: newArr.length
        }];
      }
      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath;
          var addPath = bestPath[diagonalPath - 1];
          var removePath = bestPath[diagonalPath + 1];
          var oldPos2 = (removePath ? removePath.newPos : 0) - diagonalPath;
          if (addPath) {
            bestPath[diagonalPath - 1] = void 0;
          }
          var canAdd = addPath && addPath.newPos + 1 < newLen;
          var canRemove = removePath && 0 <= oldPos2 && oldPos2 < oldLen;
          if (!canAdd && !canRemove) {
            bestPath[diagonalPath] = void 0;
            continue;
          }
          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self2.pushComponent(basePath.components, void 0, true);
          } else {
            basePath = addPath;
            basePath.newPos++;
            self2.pushComponent(basePath.components, true, void 0);
          }
          oldPos2 = self2.extractCommon(basePath, newArr, oldArr, diagonalPath);
          if (basePath.newPos + 1 >= newLen && oldPos2 + 1 >= oldLen) {
            return buildValues(self2, basePath.components);
          } else {
            bestPath[diagonalPath] = basePath;
          }
        }
        editLength++;
      }
      while (editLength <= maxEditLength) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    },
    pushComponent: function(components, added, removed) {
      var last = components[components.length - 1];
      if (last && last.added === added && last.removed === removed) {
        components[components.length - 1] = {
          count: last.count + 1,
          added,
          removed
        };
      } else {
        components.push({
          count: 1,
          added,
          removed
        });
      }
    },
    extractCommon: function(basePath, newArr, oldArr, diagonalPath) {
      var newLen = newArr.length;
      var oldLen = oldArr.length;
      var newPos = basePath.newPos;
      var oldPos = newPos - diagonalPath;
      var commonCount = 0;
      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }
      if (commonCount) {
        basePath.components.push({
          count: commonCount
        });
      }
      basePath.newPos = newPos;
      return oldPos;
    },
    tokenize: function(value) {
      return value.slice();
    },
    join: function(value) {
      return value.slice();
    }
  };
  function buildValues(diff2, components, newArr, oldArr) {
    var componentPos = 0;
    var componentLen = components.length;
    var newPos = 0;
    var oldPos = 0;
    for (; componentPos < componentLen; componentPos++) {
      var component2 = components[componentPos];
      if (!component2.removed) {
        var indices = [];
        for (var i = newPos; i < newPos + component2.count; i++) {
          indices.push(i);
        }
        component2.indices = indices;
        newPos += component2.count;
        if (!component2.added) {
          oldPos += component2.count;
        }
      } else {
        var indices = [];
        for (var i = oldPos; i < oldPos + component2.count; i++) {
          indices.push(i);
        }
        component2.indices = indices;
        oldPos += component2.count;
      }
    }
    return components;
  }
  function clonePath(path2) {
    return {
      newPos: path2.newPos,
      components: path2.components.slice(0)
    };
  }
  var arrayDiff = new Diff();
  function _default2(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
  }
  arrayDiff2 = _default2;
  return arrayDiff2;
}
var Definable_1;
var hasRequiredDefinable;
function requireDefinable() {
  if (hasRequiredDefinable)
    return Definable_1;
  hasRequiredDefinable = 1;
  var _core = requireCore();
  var createElement = _core.createElement;
  var zrUtil2 = util$6;
  var Path2 = Path_1;
  var ZImage2 = Image$2;
  var ZText = Text_1;
  var _graphic = requireGraphic();
  var svgPath = _graphic.path;
  var svgImage = _graphic.image;
  var svgText = _graphic.text;
  var MARK_UNUSED = "0";
  var MARK_USED = "1";
  function Definable(zrId, svgRoot, tagNames, markLabel, domName) {
    this._zrId = zrId;
    this._svgRoot = svgRoot;
    this._tagNames = typeof tagNames === "string" ? [tagNames] : tagNames;
    this._markLabel = markLabel;
    this._domName = domName || "_dom";
    this.nextId = 0;
  }
  Definable.prototype.createElement = createElement;
  Definable.prototype.getDefs = function(isForceCreating) {
    var svgRoot = this._svgRoot;
    var defs = this._svgRoot.getElementsByTagName("defs");
    if (defs.length === 0) {
      if (isForceCreating) {
        defs = svgRoot.insertBefore(
          this.createElement("defs"),
          // Create new tag
          svgRoot.firstChild
          // Insert in the front of svg
        );
        if (!defs.contains) {
          defs.contains = function(el) {
            var children = defs.children;
            if (!children) {
              return false;
            }
            for (var i = children.length - 1; i >= 0; --i) {
              if (children[i] === el) {
                return true;
              }
            }
            return false;
          };
        }
        return defs;
      } else {
        return null;
      }
    } else {
      return defs[0];
    }
  };
  Definable.prototype.update = function(element, onUpdate) {
    if (!element) {
      return;
    }
    var defs = this.getDefs(false);
    if (element[this._domName] && defs.contains(element[this._domName])) {
      if (typeof onUpdate === "function") {
        onUpdate(element);
      }
    } else {
      var dom2 = this.add(element);
      if (dom2) {
        element[this._domName] = dom2;
      }
    }
  };
  Definable.prototype.addDom = function(dom2) {
    var defs = this.getDefs(true);
    defs.appendChild(dom2);
  };
  Definable.prototype.removeDom = function(element) {
    var defs = this.getDefs(false);
    if (defs && element[this._domName]) {
      defs.removeChild(element[this._domName]);
      element[this._domName] = null;
    }
  };
  Definable.prototype.getDoms = function() {
    var defs = this.getDefs(false);
    if (!defs) {
      return [];
    }
    var doms = [];
    zrUtil2.each(this._tagNames, function(tagName) {
      var tags = defs.getElementsByTagName(tagName);
      doms = doms.concat([].slice.call(tags));
    });
    return doms;
  };
  Definable.prototype.markAllUnused = function() {
    var doms = this.getDoms();
    var that = this;
    zrUtil2.each(doms, function(dom2) {
      dom2[that._markLabel] = MARK_UNUSED;
    });
  };
  Definable.prototype.markUsed = function(dom2) {
    if (dom2) {
      dom2[this._markLabel] = MARK_USED;
    }
  };
  Definable.prototype.removeUnused = function() {
    var defs = this.getDefs(false);
    if (!defs) {
      return;
    }
    var doms = this.getDoms();
    var that = this;
    zrUtil2.each(doms, function(dom2) {
      if (dom2[that._markLabel] !== MARK_USED) {
        defs.removeChild(dom2);
      }
    });
  };
  Definable.prototype.getSvgProxy = function(displayable) {
    if (displayable instanceof Path2) {
      return svgPath;
    } else if (displayable instanceof ZImage2) {
      return svgImage;
    } else if (displayable instanceof ZText) {
      return svgText;
    } else {
      return svgPath;
    }
  };
  Definable.prototype.getTextSvgElement = function(displayable) {
    return displayable.__textSvgEl;
  };
  Definable.prototype.getSvgElement = function(displayable) {
    return displayable.__svgEl;
  };
  var _default2 = Definable;
  Definable_1 = _default2;
  return Definable_1;
}
var GradientManager_1;
var hasRequiredGradientManager;
function requireGradientManager() {
  if (hasRequiredGradientManager)
    return GradientManager_1;
  hasRequiredGradientManager = 1;
  var Definable = requireDefinable();
  var zrUtil2 = util$6;
  var logError2 = log;
  var colorTool2 = color$1;
  function GradientManager(zrId, svgRoot) {
    Definable.call(this, zrId, svgRoot, ["linearGradient", "radialGradient"], "__gradient_in_use__");
  }
  zrUtil2.inherits(GradientManager, Definable);
  GradientManager.prototype.addWithoutUpdate = function(svgElement, displayable) {
    if (displayable && displayable.style) {
      var that = this;
      zrUtil2.each(["fill", "stroke"], function(fillOrStroke) {
        if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === "linear" || displayable.style[fillOrStroke].type === "radial")) {
          var gradient = displayable.style[fillOrStroke];
          var defs = that.getDefs(true);
          var dom2;
          if (gradient._dom) {
            dom2 = gradient._dom;
            if (!defs.contains(gradient._dom)) {
              that.addDom(dom2);
            }
          } else {
            dom2 = that.add(gradient);
          }
          that.markUsed(displayable);
          var id = dom2.getAttribute("id");
          svgElement.setAttribute(fillOrStroke, "url(#" + id + ")");
        }
      });
    }
  };
  GradientManager.prototype.add = function(gradient) {
    var dom2;
    if (gradient.type === "linear") {
      dom2 = this.createElement("linearGradient");
    } else if (gradient.type === "radial") {
      dom2 = this.createElement("radialGradient");
    } else {
      logError2("Illegal gradient type.");
      return null;
    }
    gradient.id = gradient.id || this.nextId++;
    dom2.setAttribute("id", "zr" + this._zrId + "-gradient-" + gradient.id);
    this.updateDom(gradient, dom2);
    this.addDom(dom2);
    return dom2;
  };
  GradientManager.prototype.update = function(gradient) {
    var that = this;
    Definable.prototype.update.call(this, gradient, function() {
      var type = gradient.type;
      var tagName = gradient._dom.tagName;
      if (type === "linear" && tagName === "linearGradient" || type === "radial" && tagName === "radialGradient") {
        that.updateDom(gradient, gradient._dom);
      } else {
        that.removeDom(gradient);
        that.add(gradient);
      }
    });
  };
  GradientManager.prototype.updateDom = function(gradient, dom2) {
    if (gradient.type === "linear") {
      dom2.setAttribute("x1", gradient.x);
      dom2.setAttribute("y1", gradient.y);
      dom2.setAttribute("x2", gradient.x2);
      dom2.setAttribute("y2", gradient.y2);
    } else if (gradient.type === "radial") {
      dom2.setAttribute("cx", gradient.x);
      dom2.setAttribute("cy", gradient.y);
      dom2.setAttribute("r", gradient.r);
    } else {
      logError2("Illegal gradient type.");
      return;
    }
    if (gradient.global) {
      dom2.setAttribute("gradientUnits", "userSpaceOnUse");
    } else {
      dom2.setAttribute("gradientUnits", "objectBoundingBox");
    }
    dom2.innerHTML = "";
    var colors = gradient.colorStops;
    for (var i = 0, len = colors.length; i < len; ++i) {
      var stop2 = this.createElement("stop");
      stop2.setAttribute("offset", colors[i].offset * 100 + "%");
      var color2 = colors[i].color;
      if (color2.indexOf("rgba") > -1) {
        var opacity = colorTool2.parse(color2)[3];
        var hex = colorTool2.toHex(color2);
        stop2.setAttribute("stop-color", "#" + hex);
        stop2.setAttribute("stop-opacity", opacity);
      } else {
        stop2.setAttribute("stop-color", colors[i].color);
      }
      dom2.appendChild(stop2);
    }
    gradient._dom = dom2;
  };
  GradientManager.prototype.markUsed = function(displayable) {
    if (displayable.style) {
      var gradient = displayable.style.fill;
      if (gradient && gradient._dom) {
        Definable.prototype.markUsed.call(this, gradient._dom);
      }
      gradient = displayable.style.stroke;
      if (gradient && gradient._dom) {
        Definable.prototype.markUsed.call(this, gradient._dom);
      }
    }
  };
  var _default2 = GradientManager;
  GradientManager_1 = _default2;
  return GradientManager_1;
}
var ClippathManager_1;
var hasRequiredClippathManager;
function requireClippathManager() {
  if (hasRequiredClippathManager)
    return ClippathManager_1;
  hasRequiredClippathManager = 1;
  var Definable = requireDefinable();
  var zrUtil2 = util$6;
  var matrix2 = requireMatrix();
  function ClippathManager(zrId, svgRoot) {
    Definable.call(this, zrId, svgRoot, "clipPath", "__clippath_in_use__");
  }
  zrUtil2.inherits(ClippathManager, Definable);
  ClippathManager.prototype.update = function(displayable) {
    var svgEl = this.getSvgElement(displayable);
    if (svgEl) {
      this.updateDom(svgEl, displayable.__clipPaths, false);
    }
    var textEl = this.getTextSvgElement(displayable);
    if (textEl) {
      this.updateDom(textEl, displayable.__clipPaths, true);
    }
    this.markUsed(displayable);
  };
  ClippathManager.prototype.updateDom = function(parentEl, clipPaths, isText) {
    if (clipPaths && clipPaths.length > 0) {
      var defs = this.getDefs(true);
      var clipPath = clipPaths[0];
      var clipPathEl;
      var id;
      var dom2 = isText ? "_textDom" : "_dom";
      if (clipPath[dom2]) {
        id = clipPath[dom2].getAttribute("id");
        clipPathEl = clipPath[dom2];
        if (!defs.contains(clipPathEl)) {
          defs.appendChild(clipPathEl);
        }
      } else {
        id = "zr" + this._zrId + "-clip-" + this.nextId;
        ++this.nextId;
        clipPathEl = this.createElement("clipPath");
        clipPathEl.setAttribute("id", id);
        defs.appendChild(clipPathEl);
        clipPath[dom2] = clipPathEl;
      }
      var svgProxy = this.getSvgProxy(clipPath);
      if (clipPath.transform && clipPath.parent.invTransform && !isText) {
        var transform = Array.prototype.slice.call(clipPath.transform);
        matrix2.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);
        svgProxy.brush(clipPath);
        clipPath.transform = transform;
      } else {
        svgProxy.brush(clipPath);
      }
      var pathEl = this.getSvgElement(clipPath);
      clipPathEl.innerHTML = "";
      clipPathEl.appendChild(pathEl.cloneNode());
      parentEl.setAttribute("clip-path", "url(#" + id + ")");
      if (clipPaths.length > 1) {
        this.updateDom(clipPathEl, clipPaths.slice(1), isText);
      }
    } else {
      if (parentEl) {
        parentEl.setAttribute("clip-path", "none");
      }
    }
  };
  ClippathManager.prototype.markUsed = function(displayable) {
    var that = this;
    if (displayable.__clipPaths) {
      zrUtil2.each(displayable.__clipPaths, function(clipPath) {
        if (clipPath._dom) {
          Definable.prototype.markUsed.call(that, clipPath._dom);
        }
        if (clipPath._textDom) {
          Definable.prototype.markUsed.call(that, clipPath._textDom);
        }
      });
    }
  };
  var _default2 = ClippathManager;
  ClippathManager_1 = _default2;
  return ClippathManager_1;
}
var ShadowManager_1;
var hasRequiredShadowManager;
function requireShadowManager() {
  if (hasRequiredShadowManager)
    return ShadowManager_1;
  hasRequiredShadowManager = 1;
  var Definable = requireDefinable();
  var zrUtil2 = util$6;
  function ShadowManager(zrId, svgRoot) {
    Definable.call(this, zrId, svgRoot, ["filter"], "__filter_in_use__", "_shadowDom");
  }
  zrUtil2.inherits(ShadowManager, Definable);
  ShadowManager.prototype.addWithoutUpdate = function(svgElement, displayable) {
    if (displayable && hasShadow(displayable.style)) {
      var dom2;
      if (displayable._shadowDom) {
        dom2 = displayable._shadowDom;
        var defs = this.getDefs(true);
        if (!defs.contains(displayable._shadowDom)) {
          this.addDom(dom2);
        }
      } else {
        dom2 = this.add(displayable);
      }
      this.markUsed(displayable);
      var id = dom2.getAttribute("id");
      svgElement.style.filter = "url(#" + id + ")";
    }
  };
  ShadowManager.prototype.add = function(displayable) {
    var dom2 = this.createElement("filter");
    displayable._shadowDomId = displayable._shadowDomId || this.nextId++;
    dom2.setAttribute("id", "zr" + this._zrId + "-shadow-" + displayable._shadowDomId);
    this.updateDom(displayable, dom2);
    this.addDom(dom2);
    return dom2;
  };
  ShadowManager.prototype.update = function(svgElement, displayable) {
    var style = displayable.style;
    if (hasShadow(style)) {
      var that = this;
      Definable.prototype.update.call(this, displayable, function() {
        that.updateDom(displayable, displayable._shadowDom);
      });
    } else {
      this.remove(svgElement, displayable);
    }
  };
  ShadowManager.prototype.remove = function(svgElement, displayable) {
    if (displayable._shadowDomId != null) {
      this.removeDom(svgElement);
      svgElement.style.filter = "";
    }
  };
  ShadowManager.prototype.updateDom = function(displayable, dom2) {
    var domChild = dom2.getElementsByTagName("feDropShadow");
    if (domChild.length === 0) {
      domChild = this.createElement("feDropShadow");
    } else {
      domChild = domChild[0];
    }
    var style = displayable.style;
    var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;
    var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1;
    var offsetX;
    var offsetY;
    var blur;
    var color2;
    if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {
      offsetX = style.shadowOffsetX || 0;
      offsetY = style.shadowOffsetY || 0;
      blur = style.shadowBlur;
      color2 = style.shadowColor;
    } else if (style.textShadowBlur) {
      offsetX = style.textShadowOffsetX || 0;
      offsetY = style.textShadowOffsetY || 0;
      blur = style.textShadowBlur;
      color2 = style.textShadowColor;
    } else {
      this.removeDom(dom2, style);
      return;
    }
    domChild.setAttribute("dx", offsetX / scaleX);
    domChild.setAttribute("dy", offsetY / scaleY);
    domChild.setAttribute("flood-color", color2);
    var stdDx = blur / 2 / scaleX;
    var stdDy = blur / 2 / scaleY;
    var stdDeviation = stdDx + " " + stdDy;
    domChild.setAttribute("stdDeviation", stdDeviation);
    dom2.setAttribute("x", "-100%");
    dom2.setAttribute("y", "-100%");
    dom2.setAttribute("width", Math.ceil(blur / 2 * 200) + "%");
    dom2.setAttribute("height", Math.ceil(blur / 2 * 200) + "%");
    dom2.appendChild(domChild);
    displayable._shadowDom = dom2;
  };
  ShadowManager.prototype.markUsed = function(displayable) {
    if (displayable._shadowDom) {
      Definable.prototype.markUsed.call(this, displayable._shadowDom);
    }
  };
  function hasShadow(style) {
    return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);
  }
  var _default2 = ShadowManager;
  ShadowManager_1 = _default2;
  return ShadowManager_1;
}
var Painter;
var hasRequiredPainter;
function requirePainter() {
  if (hasRequiredPainter)
    return Painter;
  hasRequiredPainter = 1;
  var _core = requireCore();
  var createElement = _core.createElement;
  var util2 = util$6;
  var logError2 = log;
  var Path2 = Path_1;
  var ZImage2 = Image$2;
  var ZText = Text_1;
  var arrayDiff = requireArrayDiff2();
  var GradientManager = requireGradientManager();
  var ClippathManager = requireClippathManager();
  var ShadowManager = requireShadowManager();
  var _graphic = requireGraphic();
  var svgPath = _graphic.path;
  var svgImage = _graphic.image;
  var svgText = _graphic.text;
  function parseInt102(val) {
    return parseInt(val, 10);
  }
  function getSvgProxy(el) {
    if (el instanceof Path2) {
      return svgPath;
    } else if (el instanceof ZImage2) {
      return svgImage;
    } else if (el instanceof ZText) {
      return svgText;
    } else {
      return svgPath;
    }
  }
  function checkParentAvailable(parent, child) {
    return child && parent && child.parentNode !== parent;
  }
  function insertAfter(parent, child, prevSibling) {
    if (checkParentAvailable(parent, child) && prevSibling) {
      var nextSibling = prevSibling.nextSibling;
      nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);
    }
  }
  function prepend(parent, child) {
    if (checkParentAvailable(parent, child)) {
      var firstChild = parent.firstChild;
      firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);
    }
  }
  function remove2(parent, child) {
    if (child && parent && child.parentNode === parent) {
      parent.removeChild(child);
    }
  }
  function getTextSvgElement(displayable) {
    return displayable.__textSvgEl;
  }
  function getSvgElement(displayable) {
    return displayable.__svgEl;
  }
  var SVGPainter = function(root, storage2, opts, zrId) {
    this.root = root;
    this.storage = storage2;
    this._opts = opts = util2.extend({}, opts || {});
    var svgDom = createElement("svg");
    svgDom.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svgDom.setAttribute("version", "1.1");
    svgDom.setAttribute("baseProfile", "full");
    svgDom.style.cssText = "user-select:none;position:absolute;left:0;top:0;";
    var bgRoot = createElement("g");
    svgDom.appendChild(bgRoot);
    var svgRoot = createElement("g");
    svgDom.appendChild(svgRoot);
    this.gradientManager = new GradientManager(zrId, svgRoot);
    this.clipPathManager = new ClippathManager(zrId, svgRoot);
    this.shadowManager = new ShadowManager(zrId, svgRoot);
    var viewport = document.createElement("div");
    viewport.style.cssText = "overflow:hidden;position:relative";
    this._svgDom = svgDom;
    this._svgRoot = svgRoot;
    this._backgroundRoot = bgRoot;
    this._viewport = viewport;
    root.appendChild(viewport);
    viewport.appendChild(svgDom);
    this.resize(opts.width, opts.height);
    this._visibleList = [];
  };
  SVGPainter.prototype = {
    constructor: SVGPainter,
    getType: function() {
      return "svg";
    },
    getViewportRoot: function() {
      return this._viewport;
    },
    getSvgDom: function() {
      return this._svgDom;
    },
    getSvgRoot: function() {
      return this._svgRoot;
    },
    getViewportRootOffset: function() {
      var viewportRoot = this.getViewportRoot();
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        };
      }
    },
    refresh: function() {
      var list = this.storage.getDisplayList(true);
      this._paintList(list);
    },
    setBackgroundColor: function(backgroundColor) {
      if (this._backgroundRoot && this._backgroundNode) {
        this._backgroundRoot.removeChild(this._backgroundNode);
      }
      var bgNode = createElement("rect");
      bgNode.setAttribute("width", this.getWidth());
      bgNode.setAttribute("height", this.getHeight());
      bgNode.setAttribute("x", 0);
      bgNode.setAttribute("y", 0);
      bgNode.setAttribute("id", 0);
      bgNode.style.fill = backgroundColor;
      this._backgroundRoot.appendChild(bgNode);
      this._backgroundNode = bgNode;
    },
    _paintList: function(list) {
      this.gradientManager.markAllUnused();
      this.clipPathManager.markAllUnused();
      this.shadowManager.markAllUnused();
      var svgRoot = this._svgRoot;
      var visibleList = this._visibleList;
      var listLen = list.length;
      var newVisibleList = [];
      var i;
      for (i = 0; i < listLen; i++) {
        var displayable = list[i];
        var svgProxy = getSvgProxy(displayable);
        var svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);
        if (!displayable.invisible) {
          if (displayable.__dirty) {
            svgProxy && svgProxy.brush(displayable);
            this.clipPathManager.update(displayable);
            if (displayable.style) {
              this.gradientManager.update(displayable.style.fill);
              this.gradientManager.update(displayable.style.stroke);
              this.shadowManager.update(svgElement, displayable);
            }
            displayable.__dirty = false;
          }
          newVisibleList.push(displayable);
        }
      }
      var diff2 = arrayDiff(visibleList, newVisibleList);
      var prevSvgElement;
      for (i = 0; i < diff2.length; i++) {
        var item = diff2[i];
        if (item.removed) {
          for (var k = 0; k < item.count; k++) {
            var displayable = visibleList[item.indices[k]];
            var svgElement = getSvgElement(displayable);
            var textSvgElement = getTextSvgElement(displayable);
            remove2(svgRoot, svgElement);
            remove2(svgRoot, textSvgElement);
          }
        }
      }
      for (i = 0; i < diff2.length; i++) {
        var item = diff2[i];
        if (item.added) {
          for (var k = 0; k < item.count; k++) {
            var displayable = newVisibleList[item.indices[k]];
            var svgElement = getSvgElement(displayable);
            var textSvgElement = getTextSvgElement(displayable);
            prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);
            if (svgElement) {
              insertAfter(svgRoot, textSvgElement, svgElement);
            } else if (prevSvgElement) {
              insertAfter(svgRoot, textSvgElement, prevSvgElement);
            } else {
              prepend(svgRoot, textSvgElement);
            }
            insertAfter(svgRoot, textSvgElement, svgElement);
            prevSvgElement = textSvgElement || svgElement || prevSvgElement;
            this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
            this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
            this.clipPathManager.markUsed(displayable);
          }
        } else if (!item.removed) {
          for (var k = 0; k < item.count; k++) {
            var displayable = newVisibleList[item.indices[k]];
            var svgElement = getSvgElement(displayable);
            var textSvgElement = getTextSvgElement(displayable);
            var svgElement = getSvgElement(displayable);
            var textSvgElement = getTextSvgElement(displayable);
            this.gradientManager.markUsed(displayable);
            this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
            this.shadowManager.markUsed(displayable);
            this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);
            this.clipPathManager.markUsed(displayable);
            if (textSvgElement) {
              insertAfter(svgRoot, textSvgElement, svgElement);
            }
            prevSvgElement = svgElement || textSvgElement || prevSvgElement;
          }
        }
      }
      this.gradientManager.removeUnused();
      this.clipPathManager.removeUnused();
      this.shadowManager.removeUnused();
      this._visibleList = newVisibleList;
    },
    _getDefs: function(isForceCreating) {
      var svgRoot = this._svgDom;
      var defs = svgRoot.getElementsByTagName("defs");
      if (defs.length === 0) {
        if (isForceCreating) {
          var defs = svgRoot.insertBefore(
            createElement("defs"),
            // Create new tag
            svgRoot.firstChild
            // Insert in the front of svg
          );
          if (!defs.contains) {
            defs.contains = function(el) {
              var children = defs.children;
              if (!children) {
                return false;
              }
              for (var i = children.length - 1; i >= 0; --i) {
                if (children[i] === el) {
                  return true;
                }
              }
              return false;
            };
          }
          return defs;
        } else {
          return null;
        }
      } else {
        return defs[0];
      }
    },
    resize: function(width, height) {
      var viewport = this._viewport;
      viewport.style.display = "none";
      var opts = this._opts;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = this._getSize(0);
      height = this._getSize(1);
      viewport.style.display = "";
      if (this._width !== width || this._height !== height) {
        this._width = width;
        this._height = height;
        var viewportStyle = viewport.style;
        viewportStyle.width = width + "px";
        viewportStyle.height = height + "px";
        var svgRoot = this._svgDom;
        svgRoot.setAttribute("width", width);
        svgRoot.setAttribute("height", height);
      }
      if (this._backgroundNode) {
        this._backgroundNode.setAttribute("width", width);
        this._backgroundNode.setAttribute("height", height);
      }
    },
    /**
     * 获取绘图区域宽度
     */
    getWidth: function() {
      return this._width;
    },
    /**
     * 获取绘图区域高度
     */
    getHeight: function() {
      return this._height;
    },
    _getSize: function(whIdx) {
      var opts = this._opts;
      var wh = ["width", "height"][whIdx];
      var cwh = ["clientWidth", "clientHeight"][whIdx];
      var plt = ["paddingLeft", "paddingTop"][whIdx];
      var prb = ["paddingRight", "paddingBottom"][whIdx];
      if (opts[wh] != null && opts[wh] !== "auto") {
        return parseFloat(opts[wh]);
      }
      var root = this.root;
      var stl = document.defaultView.getComputedStyle(root);
      return (root[cwh] || parseInt102(stl[wh]) || parseInt102(root.style[wh])) - (parseInt102(stl[plt]) || 0) - (parseInt102(stl[prb]) || 0) | 0;
    },
    dispose: function() {
      this.root.innerHTML = "";
      this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;
    },
    clear: function() {
      if (this._viewport) {
        this.root.removeChild(this._viewport);
      }
    },
    toDataURL: function() {
      this.refresh();
      var html = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, ">\n\r<"));
      return "data:image/svg+xml;charset=UTF-8," + html;
    }
  };
  function createMethodNotSupport(method) {
    return function() {
      logError2('In SVG mode painter not support method "' + method + '"');
    };
  }
  util2.each(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "pathToImage"], function(name2) {
    SVGPainter.prototype[name2] = createMethodNotSupport(name2);
  });
  var _default2 = SVGPainter;
  Painter = _default2;
  return Painter;
}
var hasRequiredSvg;
function requireSvg() {
  if (hasRequiredSvg)
    return svg;
  hasRequiredSvg = 1;
  requireGraphic();
  var _zrender = zrender;
  var registerPainter2 = _zrender.registerPainter;
  var Painter2 = requirePainter();
  registerPainter2("svg", Painter2);
  return svg;
}
(function(exports2) {
  var _echarts = echarts;
  (function() {
    for (var key in _echarts) {
      if (_echarts == null || !_echarts.hasOwnProperty(key) || key === "default" || key === "__esModule")
        return;
      exports2[key] = _echarts[key];
    }
  })();
  var _export2 = require_export();
  (function() {
    for (var key in _export2) {
      if (_export2 == null || !_export2.hasOwnProperty(key) || key === "default" || key === "__esModule")
        return;
      exports2[key] = _export2[key];
    }
  })();
  requireDataset();
  requireLine$1();
  requireBar();
  requirePie();
  requireScatter();
  requireRadar();
  requireMap();
  requireTree();
  requireTreemap();
  requireGraph();
  requireGauge();
  requireFunnel();
  requireParallel();
  requireSankey();
  requireBoxplot();
  requireCandlestick();
  requireEffectScatter();
  requireLines();
  requireHeatmap();
  requirePictorialBar();
  requireThemeRiver();
  requireSunburst();
  requireCustom();
  requireGrid();
  requirePolar();
  requireGeo();
  requireSingleAxis();
  requireParallel$1();
  requireCalendar();
  requireGraphic$2();
  requireToolbox();
  requireTooltip();
  requireAxisPointer();
  requireBrush();
  requireTitle();
  requireTimeline();
  requireMarkPoint();
  requireMarkLine();
  requireMarkArea();
  requireLegendScroll();
  requireLegend();
  requireDataZoom();
  requireDataZoomInside();
  requireDataZoomSlider();
  requireVisualMap();
  requireVisualMapContinuous();
  requireVisualMapPiecewise();
  requireVml();
  requireSvg();
})(echarts$1);
exports._export_sfc = _export_sfc;
exports.createSSRApp = createSSRApp;
exports.e = e;
exports.echarts = echarts$1;
exports.f = f;
exports.index = index;
exports.o = o;
exports.p = p;
exports.resolveComponent = resolveComponent;
exports.t = t;
